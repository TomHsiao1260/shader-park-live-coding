// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/three/build/three.module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AxisHelper = AxisHelper;
exports.BinaryTextureLoader = BinaryTextureLoader;
exports.BoundingBoxHelper = BoundingBoxHelper;
exports.CanvasRenderer = CanvasRenderer;
exports.DynamicBufferAttribute = DynamicBufferAttribute;
exports.EdgesHelper = EdgesHelper;
exports.Float32Attribute = Float32Attribute;
exports.Float64Attribute = Float64Attribute;
exports.Int16Attribute = Int16Attribute;
exports.Int32Attribute = Int32Attribute;
exports.Int8Attribute = Int8Attribute;
exports.JSONLoader = JSONLoader;
exports.LensFlare = LensFlare;
exports.MeshFaceMaterial = MeshFaceMaterial;
exports.MultiMaterial = MultiMaterial;
exports.Particle = Particle;
exports.ParticleBasicMaterial = ParticleBasicMaterial;
exports.ParticleSystem = ParticleSystem;
exports.ParticleSystemMaterial = ParticleSystemMaterial;
exports.PointCloud = PointCloud;
exports.PointCloudMaterial = PointCloudMaterial;
exports.Uint16Attribute = Uint16Attribute;
exports.Uint32Attribute = Uint32Attribute;
exports.Uint8Attribute = Uint8Attribute;
exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
exports.Vertex = Vertex;
exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
exports.WebGLRenderer = WebGLRenderer;
exports.WebGLUtils = WebGLUtils;
exports.WireframeHelper = WireframeHelper;
exports.XHRLoader = XHRLoader;
exports.EllipseCurve = exports.EdgesGeometry = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = exports.DstAlphaFactor = exports.DoubleSide = exports.DodecahedronGeometry = exports.DodecahedronBufferGeometry = exports.DiscreteInterpolant = exports.DirectionalLightHelper = exports.DirectionalLight = exports.DepthTexture = exports.DepthStencilFormat = exports.DepthFormat = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.DataUtils = exports.DataTextureLoader = exports.DataTexture3D = exports.DataTexture2DArray = exports.DataTexture = exports.Cylindrical = exports.CylinderGeometry = exports.CylinderBufferGeometry = exports.CustomToneMapping = exports.CustomBlending = exports.CurvePath = exports.Curve = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubicInterpolant = exports.CubicBezierCurve3 = exports.CubicBezierCurve = exports.CubeUVRefractionMapping = exports.CubeUVReflectionMapping = exports.CubeTextureLoader = exports.CubeTexture = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.CubeCamera = exports.ConeGeometry = exports.ConeBufferGeometry = exports.CompressedTextureLoader = exports.CompressedTexture = exports.ColorKeyframeTrack = exports.Color = exports.Clock = exports.ClampToEdgeWrapping = exports.CircleGeometry = exports.CircleBufferGeometry = exports.CineonToneMapping = exports.CatmullRomCurve3 = exports.CanvasTexture = exports.CameraHelper = exports.Camera = exports.Cache = exports.ByteType = exports.BufferGeometryLoader = exports.BufferGeometry = exports.BufferAttribute = exports.BoxHelper = exports.BoxGeometry = exports.BoxBufferGeometry = exports.Box3Helper = exports.Box3 = exports.Box2 = exports.BooleanKeyframeTrack = exports.Bone = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AxesHelper = exports.AudioLoader = exports.AudioListener = exports.AudioContext = exports.AudioAnalyser = exports.Audio = exports.ArrowHelper = exports.ArrayCamera = exports.ArcCurve = exports.AnimationUtils = exports.AnimationObjectGroup = exports.AnimationMixer = exports.AnimationLoader = exports.AnimationClip = exports.AmbientLightProbe = exports.AmbientLight = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
exports.MaterialLoader = exports.Material = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LogLuvEncoding = exports.LoadingManager = exports.LoaderUtils = exports.Loader = exports.LinearToneMapping = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearInterpolant = exports.LinearFilter = exports.LinearEncoding = exports.LineStrip = exports.LineSegments = exports.LinePieces = exports.LineLoop = exports.LineDashedMaterial = exports.LineCurve3 = exports.LineCurve = exports.LineBasicMaterial = exports.Line3 = exports.Line = exports.LightProbe = exports.Light = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessDepth = exports.Layers = exports.LatheGeometry = exports.LatheBufferGeometry = exports.LOD = exports.KeyframeTrack = exports.KeepStencilOp = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.Interpolant = exports.InterleavedBufferAttribute = exports.InterleavedBuffer = exports.IntType = exports.Int8BufferAttribute = exports.Int32BufferAttribute = exports.Int16BufferAttribute = exports.InstancedMesh = exports.InstancedInterleavedBuffer = exports.InstancedBufferGeometry = exports.InstancedBufferAttribute = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.ImmediateRenderObject = exports.ImageUtils = exports.ImageLoader = exports.ImageBitmapLoader = exports.IcosahedronGeometry = exports.IcosahedronBufferGeometry = exports.HemisphereLightProbe = exports.HemisphereLightHelper = exports.HemisphereLight = exports.HalfFloatType = exports.Group = exports.GridHelper = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterDepth = exports.GammaEncoding = exports.GLSL3 = exports.GLSL1 = exports.GLBufferAttribute = exports.Frustum = exports.FrontSide = exports.FontLoader = exports.Font = exports.FogExp2 = exports.Fog = exports.FloatType = exports.Float64BufferAttribute = exports.Float32BufferAttribute = exports.Float16BufferAttribute = exports.FlatShading = exports.FileLoader = exports.FaceColors = exports.ExtrudeGeometry = exports.ExtrudeBufferGeometry = exports.EventDispatcher = exports.Euler = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = void 0;
exports.RGBEEncoding = exports.RGBDEncoding = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.QuaternionLinearInterpolant = exports.QuaternionKeyframeTrack = exports.Quaternion = exports.QuadraticBezierCurve3 = exports.QuadraticBezierCurve = exports.PropertyMixer = exports.PropertyBinding = exports.PositionalAudio = exports.PolyhedronGeometry = exports.PolyhedronBufferGeometry = exports.PolarGridHelper = exports.PointsMaterial = exports.Points = exports.PointLightHelper = exports.PointLight = exports.PlaneHelper = exports.PlaneGeometry = exports.PlaneBufferGeometry = exports.Plane = exports.PerspectiveCamera = exports.Path = exports.ParametricGeometry = exports.ParametricBufferGeometry = exports.PMREMGenerator = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OrthographicCamera = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.OctahedronGeometry = exports.OctahedronBufferGeometry = exports.ObjectSpaceNormalMap = exports.ObjectLoader = exports.Object3D = exports.NumberKeyframeTrack = exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColors = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MeshToonMaterial = exports.MeshStandardMaterial = exports.MeshPhysicalMaterial = exports.MeshPhongMaterial = exports.MeshNormalMaterial = exports.MeshMatcapMaterial = exports.MeshLambertMaterial = exports.MeshDistanceMaterial = exports.MeshDepthMaterial = exports.MeshBasicMaterial = exports.Mesh = exports.MaxEquation = exports.Matrix4 = exports.Matrix3 = exports.MathUtils = exports.Math = void 0;
exports.Uint8ClampedBufferAttribute = exports.Uint8BufferAttribute = exports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.UVMapping = exports.TubeGeometry = exports.TubeBufferGeometry = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.Triangle = exports.TorusKnotGeometry = exports.TorusKnotBufferGeometry = exports.TorusGeometry = exports.TorusBufferGeometry = exports.TextureLoader = exports.Texture = exports.TextGeometry = exports.TextBufferGeometry = exports.TetrahedronGeometry = exports.TetrahedronBufferGeometry = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StringKeyframeTrack = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StereoCamera = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.SpriteMaterial = exports.Sprite = exports.SpotLightHelper = exports.SpotLight = exports.SplineCurve = exports.SphericalHarmonics3 = exports.Spherical = exports.SphereGeometry = exports.SphereBufferGeometry = exports.Sphere = exports.SmoothShading = exports.SkinnedMesh = exports.SkeletonHelper = exports.Skeleton = exports.ShortType = exports.ShapeUtils = exports.ShapePath = exports.ShapeGeometry = exports.ShapeBufferGeometry = exports.Shape = exports.ShadowMaterial = exports.ShaderMaterial = exports.ShaderLib = exports.ShaderChunk = exports.SceneUtils = exports.Scene = exports.SRGB8_ALPHA8_ASTC_8x8_Format = exports.SRGB8_ALPHA8_ASTC_8x6_Format = exports.SRGB8_ALPHA8_ASTC_8x5_Format = exports.SRGB8_ALPHA8_ASTC_6x6_Format = exports.SRGB8_ALPHA8_ASTC_6x5_Format = exports.SRGB8_ALPHA8_ASTC_5x5_Format = exports.SRGB8_ALPHA8_ASTC_5x4_Format = exports.SRGB8_ALPHA8_ASTC_4x4_Format = exports.SRGB8_ALPHA8_ASTC_12x12_Format = exports.SRGB8_ALPHA8_ASTC_12x10_Format = exports.SRGB8_ALPHA8_ASTC_10x8_Format = exports.SRGB8_ALPHA8_ASTC_10x6_Format = exports.SRGB8_ALPHA8_ASTC_10x5_Format = exports.SRGB8_ALPHA8_ASTC_10x10_Format = exports.RingGeometry = exports.RingBufferGeometry = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.RectAreaLight = exports.Raycaster = exports.Ray = exports.RawShaderMaterial = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGBM7Encoding = exports.RGBM16Encoding = exports.RGBIntegerFormat = exports.RGBFormat = exports.RGBEFormat = void 0;
exports.sRGBEncoding = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.WireframeGeometry = exports.WebGLRenderTarget = exports.WebGLMultisampleRenderTarget = exports.WebGLMultipleRenderTargets = exports.WebGLCubeRenderTarget = exports.WebGL1Renderer = exports.VideoTexture = exports.VertexColors = exports.VectorKeyframeTrack = exports.Vector4 = exports.Vector3 = exports.Vector2 = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort565Type = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = exports.UniformsLib = exports.Uniform = void 0;

/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '129';
exports.REVISION = REVISION;
const MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2
};
exports.MOUSE = MOUSE;
const TOUCH = {
  ROTATE: 0,
  PAN: 1,
  DOLLY_PAN: 2,
  DOLLY_ROTATE: 3
};
exports.TOUCH = TOUCH;
const CullFaceNone = 0;
exports.CullFaceNone = CullFaceNone;
const CullFaceBack = 1;
exports.CullFaceBack = CullFaceBack;
const CullFaceFront = 2;
exports.CullFaceFront = CullFaceFront;
const CullFaceFrontBack = 3;
exports.CullFaceFrontBack = CullFaceFrontBack;
const BasicShadowMap = 0;
exports.BasicShadowMap = BasicShadowMap;
const PCFShadowMap = 1;
exports.PCFShadowMap = PCFShadowMap;
const PCFSoftShadowMap = 2;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
const VSMShadowMap = 3;
exports.VSMShadowMap = VSMShadowMap;
const FrontSide = 0;
exports.FrontSide = FrontSide;
const BackSide = 1;
exports.BackSide = BackSide;
const DoubleSide = 2;
exports.DoubleSide = DoubleSide;
const FlatShading = 1;
exports.FlatShading = FlatShading;
const SmoothShading = 2;
exports.SmoothShading = SmoothShading;
const NoBlending = 0;
exports.NoBlending = NoBlending;
const NormalBlending = 1;
exports.NormalBlending = NormalBlending;
const AdditiveBlending = 2;
exports.AdditiveBlending = AdditiveBlending;
const SubtractiveBlending = 3;
exports.SubtractiveBlending = SubtractiveBlending;
const MultiplyBlending = 4;
exports.MultiplyBlending = MultiplyBlending;
const CustomBlending = 5;
exports.CustomBlending = CustomBlending;
const AddEquation = 100;
exports.AddEquation = AddEquation;
const SubtractEquation = 101;
exports.SubtractEquation = SubtractEquation;
const ReverseSubtractEquation = 102;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
const MinEquation = 103;
exports.MinEquation = MinEquation;
const MaxEquation = 104;
exports.MaxEquation = MaxEquation;
const ZeroFactor = 200;
exports.ZeroFactor = ZeroFactor;
const OneFactor = 201;
exports.OneFactor = OneFactor;
const SrcColorFactor = 202;
exports.SrcColorFactor = SrcColorFactor;
const OneMinusSrcColorFactor = 203;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
const SrcAlphaFactor = 204;
exports.SrcAlphaFactor = SrcAlphaFactor;
const OneMinusSrcAlphaFactor = 205;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
const DstAlphaFactor = 206;
exports.DstAlphaFactor = DstAlphaFactor;
const OneMinusDstAlphaFactor = 207;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
const DstColorFactor = 208;
exports.DstColorFactor = DstColorFactor;
const OneMinusDstColorFactor = 209;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
const SrcAlphaSaturateFactor = 210;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
const NeverDepth = 0;
exports.NeverDepth = NeverDepth;
const AlwaysDepth = 1;
exports.AlwaysDepth = AlwaysDepth;
const LessDepth = 2;
exports.LessDepth = LessDepth;
const LessEqualDepth = 3;
exports.LessEqualDepth = LessEqualDepth;
const EqualDepth = 4;
exports.EqualDepth = EqualDepth;
const GreaterEqualDepth = 5;
exports.GreaterEqualDepth = GreaterEqualDepth;
const GreaterDepth = 6;
exports.GreaterDepth = GreaterDepth;
const NotEqualDepth = 7;
exports.NotEqualDepth = NotEqualDepth;
const MultiplyOperation = 0;
exports.MultiplyOperation = MultiplyOperation;
const MixOperation = 1;
exports.MixOperation = MixOperation;
const AddOperation = 2;
exports.AddOperation = AddOperation;
const NoToneMapping = 0;
exports.NoToneMapping = NoToneMapping;
const LinearToneMapping = 1;
exports.LinearToneMapping = LinearToneMapping;
const ReinhardToneMapping = 2;
exports.ReinhardToneMapping = ReinhardToneMapping;
const CineonToneMapping = 3;
exports.CineonToneMapping = CineonToneMapping;
const ACESFilmicToneMapping = 4;
exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
const CustomToneMapping = 5;
exports.CustomToneMapping = CustomToneMapping;
const UVMapping = 300;
exports.UVMapping = UVMapping;
const CubeReflectionMapping = 301;
exports.CubeReflectionMapping = CubeReflectionMapping;
const CubeRefractionMapping = 302;
exports.CubeRefractionMapping = CubeRefractionMapping;
const EquirectangularReflectionMapping = 303;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
const EquirectangularRefractionMapping = 304;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
const CubeUVReflectionMapping = 306;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
const CubeUVRefractionMapping = 307;
exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
const RepeatWrapping = 1000;
exports.RepeatWrapping = RepeatWrapping;
const ClampToEdgeWrapping = 1001;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
const MirroredRepeatWrapping = 1002;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
const NearestFilter = 1003;
exports.NearestFilter = NearestFilter;
const NearestMipmapNearestFilter = 1004;
exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
const NearestMipMapNearestFilter = 1004;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
const NearestMipmapLinearFilter = 1005;
exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
const NearestMipMapLinearFilter = 1005;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
const LinearFilter = 1006;
exports.LinearFilter = LinearFilter;
const LinearMipmapNearestFilter = 1007;
exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
const LinearMipMapNearestFilter = 1007;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
const LinearMipmapLinearFilter = 1008;
exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
const LinearMipMapLinearFilter = 1008;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
const UnsignedByteType = 1009;
exports.UnsignedByteType = UnsignedByteType;
const ByteType = 1010;
exports.ByteType = ByteType;
const ShortType = 1011;
exports.ShortType = ShortType;
const UnsignedShortType = 1012;
exports.UnsignedShortType = UnsignedShortType;
const IntType = 1013;
exports.IntType = IntType;
const UnsignedIntType = 1014;
exports.UnsignedIntType = UnsignedIntType;
const FloatType = 1015;
exports.FloatType = FloatType;
const HalfFloatType = 1016;
exports.HalfFloatType = HalfFloatType;
const UnsignedShort4444Type = 1017;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
const UnsignedShort5551Type = 1018;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
const UnsignedShort565Type = 1019;
exports.UnsignedShort565Type = UnsignedShort565Type;
const UnsignedInt248Type = 1020;
exports.UnsignedInt248Type = UnsignedInt248Type;
const AlphaFormat = 1021;
exports.AlphaFormat = AlphaFormat;
const RGBFormat = 1022;
exports.RGBFormat = RGBFormat;
const RGBAFormat = 1023;
exports.RGBAFormat = RGBAFormat;
const LuminanceFormat = 1024;
exports.LuminanceFormat = LuminanceFormat;
const LuminanceAlphaFormat = 1025;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
const RGBEFormat = RGBAFormat;
exports.RGBEFormat = RGBEFormat;
const DepthFormat = 1026;
exports.DepthFormat = DepthFormat;
const DepthStencilFormat = 1027;
exports.DepthStencilFormat = DepthStencilFormat;
const RedFormat = 1028;
exports.RedFormat = RedFormat;
const RedIntegerFormat = 1029;
exports.RedIntegerFormat = RedIntegerFormat;
const RGFormat = 1030;
exports.RGFormat = RGFormat;
const RGIntegerFormat = 1031;
exports.RGIntegerFormat = RGIntegerFormat;
const RGBIntegerFormat = 1032;
exports.RGBIntegerFormat = RGBIntegerFormat;
const RGBAIntegerFormat = 1033;
exports.RGBAIntegerFormat = RGBAIntegerFormat;
const RGB_S3TC_DXT1_Format = 33776;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
const RGBA_S3TC_DXT1_Format = 33777;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
const RGBA_S3TC_DXT3_Format = 33778;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
const RGBA_S3TC_DXT5_Format = 33779;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
const RGB_PVRTC_4BPPV1_Format = 35840;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
const RGB_PVRTC_2BPPV1_Format = 35841;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
const RGBA_PVRTC_4BPPV1_Format = 35842;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
const RGBA_PVRTC_2BPPV1_Format = 35843;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
const RGB_ETC1_Format = 36196;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
const RGB_ETC2_Format = 37492;
exports.RGB_ETC2_Format = RGB_ETC2_Format;
const RGBA_ETC2_EAC_Format = 37496;
exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
const RGBA_ASTC_4x4_Format = 37808;
exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
const RGBA_ASTC_5x4_Format = 37809;
exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
const RGBA_ASTC_5x5_Format = 37810;
exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
const RGBA_ASTC_6x5_Format = 37811;
exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
const RGBA_ASTC_6x6_Format = 37812;
exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
const RGBA_ASTC_8x5_Format = 37813;
exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
const RGBA_ASTC_8x6_Format = 37814;
exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
const RGBA_ASTC_8x8_Format = 37815;
exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
const RGBA_ASTC_10x5_Format = 37816;
exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
const RGBA_ASTC_10x6_Format = 37817;
exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
const RGBA_ASTC_10x8_Format = 37818;
exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
const RGBA_ASTC_10x10_Format = 37819;
exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
const RGBA_ASTC_12x10_Format = 37820;
exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
const RGBA_ASTC_12x12_Format = 37821;
exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
const RGBA_BPTC_Format = 36492;
exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
const LoopOnce = 2200;
exports.LoopOnce = LoopOnce;
const LoopRepeat = 2201;
exports.LoopRepeat = LoopRepeat;
const LoopPingPong = 2202;
exports.LoopPingPong = LoopPingPong;
const InterpolateDiscrete = 2300;
exports.InterpolateDiscrete = InterpolateDiscrete;
const InterpolateLinear = 2301;
exports.InterpolateLinear = InterpolateLinear;
const InterpolateSmooth = 2302;
exports.InterpolateSmooth = InterpolateSmooth;
const ZeroCurvatureEnding = 2400;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
const ZeroSlopeEnding = 2401;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
const WrapAroundEnding = 2402;
exports.WrapAroundEnding = WrapAroundEnding;
const NormalAnimationBlendMode = 2500;
exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
const AdditiveAnimationBlendMode = 2501;
exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
const TrianglesDrawMode = 0;
exports.TrianglesDrawMode = TrianglesDrawMode;
const TriangleStripDrawMode = 1;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
const TriangleFanDrawMode = 2;
exports.TriangleFanDrawMode = TriangleFanDrawMode;
const LinearEncoding = 3000;
exports.LinearEncoding = LinearEncoding;
const sRGBEncoding = 3001;
exports.sRGBEncoding = sRGBEncoding;
const GammaEncoding = 3007;
exports.GammaEncoding = GammaEncoding;
const RGBEEncoding = 3002;
exports.RGBEEncoding = RGBEEncoding;
const LogLuvEncoding = 3003;
exports.LogLuvEncoding = LogLuvEncoding;
const RGBM7Encoding = 3004;
exports.RGBM7Encoding = RGBM7Encoding;
const RGBM16Encoding = 3005;
exports.RGBM16Encoding = RGBM16Encoding;
const RGBDEncoding = 3006;
exports.RGBDEncoding = RGBDEncoding;
const BasicDepthPacking = 3200;
exports.BasicDepthPacking = BasicDepthPacking;
const RGBADepthPacking = 3201;
exports.RGBADepthPacking = RGBADepthPacking;
const TangentSpaceNormalMap = 0;
exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
const ObjectSpaceNormalMap = 1;
exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
const ZeroStencilOp = 0;
exports.ZeroStencilOp = ZeroStencilOp;
const KeepStencilOp = 7680;
exports.KeepStencilOp = KeepStencilOp;
const ReplaceStencilOp = 7681;
exports.ReplaceStencilOp = ReplaceStencilOp;
const IncrementStencilOp = 7682;
exports.IncrementStencilOp = IncrementStencilOp;
const DecrementStencilOp = 7683;
exports.DecrementStencilOp = DecrementStencilOp;
const IncrementWrapStencilOp = 34055;
exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
const DecrementWrapStencilOp = 34056;
exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
const InvertStencilOp = 5386;
exports.InvertStencilOp = InvertStencilOp;
const NeverStencilFunc = 512;
exports.NeverStencilFunc = NeverStencilFunc;
const LessStencilFunc = 513;
exports.LessStencilFunc = LessStencilFunc;
const EqualStencilFunc = 514;
exports.EqualStencilFunc = EqualStencilFunc;
const LessEqualStencilFunc = 515;
exports.LessEqualStencilFunc = LessEqualStencilFunc;
const GreaterStencilFunc = 516;
exports.GreaterStencilFunc = GreaterStencilFunc;
const NotEqualStencilFunc = 517;
exports.NotEqualStencilFunc = NotEqualStencilFunc;
const GreaterEqualStencilFunc = 518;
exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
const AlwaysStencilFunc = 519;
exports.AlwaysStencilFunc = AlwaysStencilFunc;
const StaticDrawUsage = 35044;
exports.StaticDrawUsage = StaticDrawUsage;
const DynamicDrawUsage = 35048;
exports.DynamicDrawUsage = DynamicDrawUsage;
const StreamDrawUsage = 35040;
exports.StreamDrawUsage = StreamDrawUsage;
const StaticReadUsage = 35045;
exports.StaticReadUsage = StaticReadUsage;
const DynamicReadUsage = 35049;
exports.DynamicReadUsage = DynamicReadUsage;
const StreamReadUsage = 35041;
exports.StreamReadUsage = StreamReadUsage;
const StaticCopyUsage = 35046;
exports.StaticCopyUsage = StaticCopyUsage;
const DynamicCopyUsage = 35050;
exports.DynamicCopyUsage = DynamicCopyUsage;
const StreamCopyUsage = 35042;
exports.StreamCopyUsage = StreamCopyUsage;
const GLSL1 = '100';
exports.GLSL1 = GLSL1;
const GLSL3 = '300 es';
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

exports.GLSL3 = GLSL3;

class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === undefined) this._listeners = {};
    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }

  hasEventListener(type, listener) {
    if (this._listeners === undefined) return false;
    const listeners = this._listeners;
    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  }

  removeEventListener(type, listener) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];

    if (listenerArray !== undefined) {
      const index = listenerArray.indexOf(listener);

      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }

  dispatchEvent(event) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this; // Make a copy, in case listeners are removed while iterating.

      const array = listenerArray.slice(0);

      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }

      event.target = null;
    }
  }

}

exports.EventDispatcher = EventDispatcher;
const _lut = [];

for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);
}

let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

function generateUUID() {
  const d0 = Math.random() * 0xffffffff | 0;
  const d1 = Math.random() * 0xffffffff | 0;
  const d2 = Math.random() * 0xffffffff | 0;
  const d3 = Math.random() * 0xffffffff | 0;
  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

  return uuid.toUpperCase();
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
} // compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation


function euclideanModulo(n, m) {
  return (n % m + m) % m;
} // Linear mapping from range <a1, a2> to range <b1, b2>


function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/


function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
} // https://en.wikipedia.org/wiki/Linear_interpolation


function lerp(x, y, t) {
  return (1 - t) * x + t * y;
} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/


function damp(x, y, lambda, dt) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt));
} // https://www.desmos.com/calculator/vcsjnyz7x4


function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
} // http://en.wikipedia.org/wiki/Smoothstep


function smoothstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}

function smootherstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
} // Random integer from <low, high> interval


function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
} // Random float from <low, high> interval


function randFloat(low, high) {
  return low + Math.random() * (high - low);
} // Random float from <-range/2, range/2> interval


function randFloatSpread(range) {
  return range * (0.5 - Math.random());
} // Deterministic pseudo-random float in the interval [ 0, 1 ]


function seededRandom(s) {
  if (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm

  _seed = _seed * 16807 % 2147483647;
  return (_seed - 1) / 2147483646;
}

function degToRad(degrees) {
  return degrees * DEG2RAD;
}

function radToDeg(radians) {
  return radians * RAD2DEG;
}

function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}

function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}

function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}

function setQuaternionFromProperEuler(q, a, b, c, order) {
  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
  // rotations are applied to the axes in the order specified by 'order'
  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
  // angles are in radians
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);

  switch (order) {
    case 'XYX':
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;

    case 'YZY':
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;

    case 'ZXZ':
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;

    case 'XZX':
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;

    case 'YXY':
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;

    case 'ZYZ':
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;

    default:
      console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
  }
}

var MathUtils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DEG2RAD: DEG2RAD,
  RAD2DEG: RAD2DEG,
  generateUUID: generateUUID,
  clamp: clamp,
  euclideanModulo: euclideanModulo,
  mapLinear: mapLinear,
  inverseLerp: inverseLerp,
  lerp: lerp,
  damp: damp,
  pingpong: pingpong,
  smoothstep: smoothstep,
  smootherstep: smootherstep,
  randInt: randInt,
  randFloat: randFloat,
  randFloatSpread: randFloatSpread,
  seededRandom: seededRandom,
  degToRad: degToRad,
  radToDeg: radToDeg,
  isPowerOfTwo: isPowerOfTwo,
  ceilPowerOfTwo: ceilPowerOfTwo,
  floorPowerOfTwo: floorPowerOfTwo,
  setQuaternionFromProperEuler: setQuaternionFromProperEuler
});
exports.MathUtils = exports.Math = MathUtils;

class Vector2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }

  get width() {
    return this.x;
  }

  set width(value) {
    this.x = value;
  }

  get height() {
    return this.y;
  }

  set height(value) {
    this.y = value;
  }

  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }

  add(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }

  sub(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }

  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }

  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  applyMatrix3(m) {
    const x = this.x,
          y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }

  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y;
  }

  cross(v) {
    return this.x * v.y - this.y * v.x;
  }

  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  angle() {
    // computes the angle in radians with respect to the positive x-axis
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }

  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }

  distanceToSquared(v) {
    const dx = this.x - v.x,
          dy = this.y - v.y;
    return dx * dx + dy * dy;
  }

  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }

  equals(v) {
    return v.x === this.x && v.y === this.y;
  }

  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }

  fromBufferAttribute(attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }

  rotateAround(center, angle) {
    const c = Math.cos(angle),
          s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }

}

exports.Vector2 = Vector2;
Vector2.prototype.isVector2 = true;

class Matrix3 {
  constructor() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (arguments.length > 0) {
      console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
  }

  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }

  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }

  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }

  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }

  setFromMatrix4(m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }

  multiply(m) {
    return this.multiplyMatrices(this, m);
  }

  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }

  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[3],
          a13 = ae[6];
    const a21 = ae[1],
          a22 = ae[4],
          a23 = ae[7];
    const a31 = ae[2],
          a32 = ae[5],
          a33 = ae[8];
    const b11 = be[0],
          b12 = be[3],
          b13 = be[6];
    const b21 = be[1],
          b22 = be[4],
          b23 = be[7];
    const b31 = be[2],
          b32 = be[5],
          b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }

  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }

  determinant() {
    const te = this.elements;
    const a = te[0],
          b = te[1],
          c = te[2],
          d = te[3],
          e = te[4],
          f = te[5],
          g = te[6],
          h = te[7],
          i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }

  invert() {
    const te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n12 = te[3],
          n22 = te[4],
          n32 = te[5],
          n13 = te[6],
          n23 = te[7],
          n33 = te[8],
          t11 = n33 * n22 - n32 * n23,
          t12 = n32 * n13 - n33 * n12,
          t13 = n23 * n12 - n22 * n13,
          det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }

  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }

  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }

  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }

  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    return this;
  }

  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }

  rotate(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0],
          a12 = te[3],
          a13 = te[6];
    const a21 = te[1],
          a22 = te[4],
          a23 = te[7];
    te[0] = c * a11 + s * a21;
    te[3] = c * a12 + s * a22;
    te[6] = c * a13 + s * a23;
    te[1] = -s * a11 + c * a21;
    te[4] = -s * a12 + c * a22;
    te[7] = -s * a13 + c * a23;
    return this;
  }

  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }

  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  }

  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }

  clone() {
    return new this.constructor().fromArray(this.elements);
  }

}

exports.Matrix3 = Matrix3;
Matrix3.prototype.isMatrix3 = true;

let _canvas;

class ImageUtils {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }

    if (typeof HTMLCanvasElement == 'undefined') {
      return image.src;
    }

    let canvas;

    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
      _canvas.width = image.width;
      _canvas.height = image.height;

      const context = _canvas.getContext('2d');

      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }

      canvas = _canvas;
    }

    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
      return canvas.toDataURL('image/jpeg', 0.6);
    } else {
      return canvas.toDataURL('image/png');
    }
  }

}

exports.ImageUtils = ImageUtils;
let textureId = 0;

class Texture extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, 'id', {
      value: textureId++
    });
    this.uuid = generateUUID();
    this.name = '';
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
    //
    // Also changing the encoding after already used by a Material will not automatically make the Material
    // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

    this.encoding = encoding;
    this.version = 0;
    this.onUpdate = null;
  }

  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  }

  toJSON(meta) {
    const isRootObject = meta === undefined || typeof meta === 'string';

    if (!isRootObject && meta.textures[this.uuid] !== undefined) {
      return meta.textures[this.uuid];
    }

    const output = {
      metadata: {
        version: 4.5,
        type: 'Texture',
        generator: 'Texture.toJSON'
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };

    if (this.image !== undefined) {
      // TODO: Move to THREE.Image
      const image = this.image;

      if (image.uuid === undefined) {
        image.uuid = generateUUID(); // UGH
      }

      if (!isRootObject && meta.images[image.uuid] === undefined) {
        let url;

        if (Array.isArray(image)) {
          // process array of images e.g. CubeTexture
          url = [];

          for (let i = 0, l = image.length; i < l; i++) {
            // check cube texture with data textures
            if (image[i].isDataTexture) {
              url.push(serializeImage(image[i].image));
            } else {
              url.push(serializeImage(image[i]));
            }
          }
        } else {
          // process single image
          url = serializeImage(image);
        }

        meta.images[image.uuid] = {
          uuid: image.uuid,
          url: url
        };
      }

      output.image = image.uuid;
    }

    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }

    return output;
  }

  dispose() {
    this.dispatchEvent({
      type: 'dispose'
    });
  }

  transformUv(uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);

    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;

        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;

        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }

          break;
      }
    }

    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;

        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;

        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }

          break;
      }
    }

    if (this.flipY) {
      uv.y = 1 - uv.y;
    }

    return uv;
  }

  set needsUpdate(value) {
    if (value === true) this.version++;
  }

}

exports.Texture = Texture;
Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;

function serializeImage(image) {
  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    // default images
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      // images of DataTexture
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn('THREE.Texture: Unable to serialize Texture.');
      return {};
    }
  }
}

class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }

  get width() {
    return this.z;
  }

  set width(value) {
    this.z = value;
  }

  get height() {
    return this.w;
  }

  set height(value) {
    this.w = value;
  }

  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setZ(z) {
    this.z = z;
    return this;
  }

  setW(w) {
    this.w = w;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      case 3:
        this.w = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      case 3:
        return this.w;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== undefined ? v.w : 1;
    return this;
  }

  add(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }

  sub(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }

  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }

  applyMatrix4(m) {
    const x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  setAxisAngleFromQuaternion(q) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
    // q is assumed to be normalized
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);

    if (s < 0.0001) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }

    return this;
  }

  setAxisAngleFromRotationMatrix(m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    let angle, x, y, z; // variables for result

    const epsilon = 0.01,
          // margin to allow for rounding errors
    epsilon2 = 0.1,
          // margin to distinguish between 0 and 180 degrees
    te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10];

    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        // this singularity is identity matrix so angle = 0
        this.set(1, 0, 0, 0);
        return this; // zero angle, arbitrary axis
      } // otherwise this singularity is angle = 180


      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;

      if (xx > yy && xx > zz) {
        // m11 is the largest diagonal term
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        // m22 is the largest diagonal term
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        // m33 is the largest diagonal term so base result on this
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }

      this.set(x, y, z, angle);
      return this; // return 180 deg rotation
    } // as we have reached here there are no singularities so we can handle normally


    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

    if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }

  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }

  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }

  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }

  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }

  fromBufferAttribute(attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }

}

exports.Vector4 = Vector4;
Vector4.prototype.isVector4 = true;
/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/

class WebGLRenderTarget extends EventDispatcher {
  constructor(width, height, options) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options = options || {};
    this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.image = {};
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.image.depth = 1;
    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
  }

  setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  }

  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }

    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.texture.image = { ...this.texture.image
    }; // See #20328.

    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  }

  dispose() {
    this.dispatchEvent({
      type: 'dispose'
    });
  }

}

exports.WebGLRenderTarget = WebGLRenderTarget;
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

class WebGLMultipleRenderTargets extends WebGLRenderTarget {
  constructor(width, height, count) {
    super(width, height);
    const texture = this.texture;
    this.texture = [];

    for (let i = 0; i < count; i++) {
      this.texture[i] = texture.clone();
    }
  }

  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;

      for (let i = 0, il = this.texture.length; i < il; i++) {
        this.texture[i].image.width = width;
        this.texture[i].image.height = height;
        this.texture[i].image.depth = depth;
      }

      this.dispose();
    }

    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
    return this;
  }

  copy(source) {
    this.dispose();
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.set(0, 0, this.width, this.height);
    this.scissor.set(0, 0, this.width, this.height);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    this.texture.length = 0;

    for (let i = 0, il = source.texture.length; i < il; i++) {
      this.texture[i] = source.texture[i].clone();
    }

    return this;
  }

}

exports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;

class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
  constructor(width, height, options) {
    super(width, height, options);
    this.samples = 4;
  }

  copy(source) {
    super.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }

}

exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;

class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }

  static slerp(qa, qb, qm, t) {
    console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');
    return qm.slerpQuaternions(qa, qb, t);
  }

  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    // fuzz-free, array-based Quaternion SLERP operation
    let x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0],
          y1 = src1[srcOffset1 + 1],
          z1 = src1[srcOffset1 + 2],
          w1 = src1[srcOffset1 + 3];

    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }

    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }

    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
            dir = cos >= 0 ? 1 : -1,
            sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin),
              len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }

      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }

    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }

  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }

  get x() {
    return this._x;
  }

  set x(value) {
    this._x = value;

    this._onChangeCallback();
  }

  get y() {
    return this._y;
  }

  set y(value) {
    this._y = value;

    this._onChangeCallback();
  }

  get z() {
    return this._z;
  }

  set z(value) {
    this._z = value;

    this._onChangeCallback();
  }

  get w() {
    return this._w;
  }

  set w(value) {
    this._w = value;

    this._onChangeCallback();
  }

  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this._onChangeCallback();

    return this;
  }

  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }

  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this._onChangeCallback();

    return this;
  }

  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }

    const x = euler._x,
          y = euler._y,
          z = euler._z,
          order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);

    switch (order) {
      case 'XYZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'YXZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'ZXY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'ZYX':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'YZX':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'XZY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      default:
        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
    }

    if (update !== false) this._onChangeCallback();
    return this;
  }

  setFromAxisAngle(axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized
    const halfAngle = angle / 2,
          s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);

    this._onChangeCallback();

    return this;
  }

  setFromRotationMatrix(m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33;

    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1.0);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }

    this._onChangeCallback();

    return this;
  }

  setFromUnitVectors(vFrom, vTo) {
    // assumes direction vectors vFrom and vTo are normalized
    let r = vFrom.dot(vTo) + 1;

    if (r < Number.EPSILON) {
      // vFrom and vTo point in opposite directions
      r = 0;

      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }

    return this.normalize();
  }

  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
  }

  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }

  identity() {
    return this.set(0, 0, 0, 1);
  }

  invert() {
    // quaternion is assumed to have unit length
    return this.conjugate();
  }

  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;

    this._onChangeCallback();

    return this;
  }

  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }

  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }

  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }

  normalize() {
    let l = this.length();

    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }

    this._onChangeCallback();

    return this;
  }

  multiply(q, p) {
    if (p !== undefined) {
      console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
      return this.multiplyQuaternions(q, p);
    }

    return this.multiplyQuaternions(this, q);
  }

  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }

  multiplyQuaternions(a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    const qax = a._x,
          qay = a._y,
          qaz = a._z,
          qaw = a._w;
    const qbx = b._x,
          qby = b._y,
          qbz = b._z,
          qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this._onChangeCallback();

    return this;
  }

  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x,
          y = this._y,
          z = this._z,
          w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }

    if (cosHalfTheta >= 1.0) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }

    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();

      this._onChangeCallback();

      return this;
    }

    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;

    this._onChangeCallback();

    return this;
  }

  slerpQuaternions(qa, qb, t) {
    this.copy(qa).slerp(qb, t);
  }

  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }

  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];

    this._onChangeCallback();

    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }

  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }

  _onChangeCallback() {}

}

exports.Quaternion = Quaternion;
Quaternion.prototype.isQuaternion = true;

class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }

  set(x, y, z) {
    if (z === undefined) z = this.z; // sprite.scale.set(x,y)

    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setZ(z) {
    this.z = z;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }

  add(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }

  sub(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }

  multiply(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
      return this.multiplyVectors(v, w);
    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }

  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }

  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }

    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }

  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }

  applyMatrix3(m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }

  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }

  applyMatrix4(m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }

  applyQuaternion(q) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const qx = q.x,
          qy = q.y,
          qz = q.z,
          qw = q.w; // calculate quat * vector

    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }

  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }

  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }

  transformDirection(m) {
    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }

  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }

  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  } // TODO lengthSquared?


  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }

  cross(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
      return this.crossVectors(v, w);
    }

    return this.crossVectors(this, v);
  }

  crossVectors(a, b) {
    const ax = a.x,
          ay = a.y,
          az = a.z;
    const bx = b.x,
          by = b.y,
          bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }

  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }

  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);

    return this.sub(_vector$c);
  }

  reflect(normal) {
    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }

  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

    return Math.acos(clamp(theta, -1, 1));
  }

  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }

  distanceToSquared(v) {
    const dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }

  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }

  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }

  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }

  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }

  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }

  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }

  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }

  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }

  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }

  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }

  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }

  fromBufferAttribute(attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }

}

exports.Vector3 = Vector3;
Vector3.prototype.isVector3 = true;

const _vector$c = /*@__PURE__*/new Vector3();

const _quaternion$4 = /*@__PURE__*/new Quaternion();

class Box3 {
  constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }

  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }

  setFromArray(array) {
    let minX = +Infinity;
    let minY = +Infinity;
    let minZ = +Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;

    for (let i = 0, l = array.length; i < l; i += 3) {
      const x = array[i];
      const y = array[i + 1];
      const z = array[i + 2];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }

  setFromBufferAttribute(attribute) {
    let minX = +Infinity;
    let minY = +Infinity;
    let minZ = +Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;

    for (let i = 0, l = attribute.count; i < l; i++) {
      const x = attribute.getX(i);
      const y = attribute.getY(i);
      const z = attribute.getZ(i);
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }

  setFromPoints(points) {
    this.makeEmpty();

    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  }

  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);

    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }

  setFromObject(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }

  makeEmpty() {
    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }

  isEmpty() {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }

  getCenter(target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getCenter() target is now required');
      target = new Vector3();
    }

    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }

  getSize(target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getSize() target is now required');
      target = new Vector3();
    }

    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }

  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }

  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }

  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }

  expandByObject(object) {
    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;

    if (geometry !== undefined) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }

      _box$3.copy(geometry.boundingBox);

      _box$3.applyMatrix4(object.matrixWorld);

      this.union(_box$3);
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i]);
    }

    return this;
  }

  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }

  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }

  getParameter(point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    if (target === undefined) {
      console.warn('THREE.Box3: .getParameter() target is now required');
      target = new Vector3();
    }

    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }

  intersectsBox(box) {
    // using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }

  intersectsSphere(sphere) {
    // Find the point on the AABB closest to the sphere center.
    this.clampPoint(sphere.center, _vector$b); // If that point is inside the sphere, the AABB and sphere intersect.

    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }

  intersectsPlane(plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.
    let min, max;

    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }

    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }

    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }

    return min <= -plane.constant && max >= -plane.constant;
  }

  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    } // compute box center and extents


    this.getCenter(_center);

    _extents.subVectors(this.max, _center); // translate triangle to aabb origin


    _v0$2.subVectors(triangle.a, _center);

    _v1$7.subVectors(triangle.b, _center);

    _v2$3.subVectors(triangle.c, _center); // compute edge vectors for triangle


    _f0.subVectors(_v1$7, _v0$2);

    _f1.subVectors(_v2$3, _v1$7);

    _f2.subVectors(_v0$2, _v2$3); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    } // test 3 face normals from the aabb


    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    } // finally testing the face normal of the triangle
    // use already existing triangle edge vectors here


    _triangleNormal.crossVectors(_f0, _f1);

    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
  }

  clampPoint(point, target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .clampPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(point).clamp(this.min, this.max);
  }

  distanceToPoint(point) {
    const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);

    return clampedPoint.sub(point).length();
  }

  getBoundingSphere(target) {
    if (target === undefined) {
      console.error('THREE.Box3: .getBoundingSphere() target is now required'); //target = new Sphere(); // removed to avoid cyclic dependency
    }

    this.getCenter(target.center);
    target.radius = this.getSize(_vector$b).length() * 0.5;
    return target;
  }

  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

    if (this.isEmpty()) this.makeEmpty();
    return this;
  }

  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }

  applyMatrix4(matrix) {
    // transform of empty box is an empty box.
    if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


    this.setFromPoints(_points);
    return this;
  }

  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }

  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }

}

exports.Box3 = Box3;
Box3.prototype.isBox3 = true;
const _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];

const _vector$b = /*@__PURE__*/new Vector3();

const _box$3 = /*@__PURE__*/new Box3(); // triangle centered vertices


const _v0$2 = /*@__PURE__*/new Vector3();

const _v1$7 = /*@__PURE__*/new Vector3();

const _v2$3 = /*@__PURE__*/new Vector3(); // triangle edge vectors


const _f0 = /*@__PURE__*/new Vector3();

const _f1 = /*@__PURE__*/new Vector3();

const _f2 = /*@__PURE__*/new Vector3();

const _center = /*@__PURE__*/new Vector3();

const _extents = /*@__PURE__*/new Vector3();

const _triangleNormal = /*@__PURE__*/new Vector3();

const _testAxis = /*@__PURE__*/new Vector3();

function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i); // project the aabb onto the seperating axis


    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      // points of the projected triangle are outside the projected half-length of the aabb
      // the axis is seperating and we can exit
      return false;
    }
  }

  return true;
}

const _box$2 = /*@__PURE__*/new Box3();

const _v1$6 = /*@__PURE__*/new Vector3();

const _toFarthestPoint = /*@__PURE__*/new Vector3();

const _toPoint = /*@__PURE__*/new Vector3();

class Sphere {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }

  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }

  setFromPoints(points, optionalCenter) {
    const center = this.center;

    if (optionalCenter !== undefined) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }

    let maxRadiusSq = 0;

    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }

    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }

  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }

  isEmpty() {
    return this.radius < 0;
  }

  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }

  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }

  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }

  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }

  intersectsBox(box) {
    return box.intersectsSphere(this);
  }

  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }

  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);

    if (target === undefined) {
      console.warn('THREE.Sphere: .clampPoint() target is now required');
      target = new Vector3();
    }

    target.copy(point);

    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }

    return target;
  }

  getBoundingBox(target) {
    if (target === undefined) {
      console.warn('THREE.Sphere: .getBoundingBox() target is now required');
      target = new Box3();
    }

    if (this.isEmpty()) {
      // Empty sphere produces empty bounding box
      target.makeEmpty();
      return target;
    }

    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }

  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }

  translate(offset) {
    this.center.add(offset);
    return this;
  }

  expandByPoint(point) {
    // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
    _toPoint.subVectors(point, this.center);

    const lengthSq = _toPoint.lengthSq();

    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,
      // and the other half to position. This gives a tighter enclosure, instead of if
      // the whole missing distance were just added to radius.

      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
      this.radius += missingRadiusHalf;
    }

    return this;
  }

  union(sphere) {
    // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
    // To enclose another sphere into this sphere, we only need to enclose two points:
    // 1) Enclose the farthest point on the other sphere into this sphere.
    // 2) Enclose the opposite point of the farthest point into this sphere.
    _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);

    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
    return this;
  }

  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }

  clone() {
    return new this.constructor().copy(this);
  }

}

exports.Sphere = Sphere;

const _vector$a = /*@__PURE__*/new Vector3();

const _segCenter = /*@__PURE__*/new Vector3();

const _segDir = /*@__PURE__*/new Vector3();

const _diff = /*@__PURE__*/new Vector3();

const _edge1 = /*@__PURE__*/new Vector3();

const _edge2 = /*@__PURE__*/new Vector3();

const _normal$1 = /*@__PURE__*/new Vector3();

class Ray {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }

  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }

  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }

  at(t, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .at() target is now required');
      target = new Vector3();
    }

    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  }

  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }

  recast(t) {
    this.origin.copy(this.at(t, _vector$a));
    return this;
  }

  closestPointToPoint(point, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);

    if (directionDistance < 0) {
      return target.copy(this.origin);
    }

    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }

  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }

  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction); // point behind the ray


    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }

    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

    return _vector$a.distanceToSquared(point);
  }

  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
    // It returns the min distance between the ray and the segment
    // defined by v0 and v1
    // It can also set two optional targets :
    // - The closest point on the ray
    // - The closest point on the segment
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);

    _segDir.copy(v1).sub(v0).normalize();

    _diff.copy(this.origin).sub(_segCenter);

    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);

    const b0 = _diff.dot(this.direction);

    const b1 = -_diff.dot(_segDir);

    const c = _diff.lengthSq();

    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;

    if (det > 0) {
      // The ray and segment are not parallel.
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;

      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            // region 0
            // Minimum at interior points of ray and segment.
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            // region 1
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          // region 5
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          // region 4
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          // region 3
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          // region 2
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      // Ray and segment are parallel.
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }

    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }

    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }

    return sqrDist;
  }

  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);

    const tca = _vector$a.dot(this.direction);

    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

    const t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

    const t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

    if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
    // in order to always return an intersect point that is in front of the ray.

    if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

    return this.at(t0, target);
  }

  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }

  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);

    if (denominator === 0) {
      // line is coplanar, return origin
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      } // Null is preferable to undefined since undefined means.... it is undefined


      return null;
    }

    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

    return t >= 0 ? t : null;
  }

  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);

    if (t === null) {
      return null;
    }

    return this.at(t, target);
  }

  intersectsPlane(plane) {
    // check if the ray lies on the plane first
    const distToPoint = plane.distanceToPoint(this.origin);

    if (distToPoint === 0) {
      return true;
    }

    const denominator = plane.normal.dot(this.direction);

    if (denominator * distToPoint < 0) {
      return true;
    } // ray origin is behind the plane (and is pointing behind it)


    return false;
  }

  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x,
          invdiry = 1 / this.direction.y,
          invdirz = 1 / this.direction.z;
    const origin = this.origin;

    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }

    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }

    if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if (tymin > tmin || tmin !== tmin) tmin = tymin;
    if (tymax < tmax || tmax !== tmax) tmax = tymax;

    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }

    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }

  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }

  intersectTriangle(a, b, c, backfaceCulling, target) {
    // Compute the offset origin, edges, and normal.
    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
    _edge1.subVectors(b, a);

    _edge2.subVectors(c, a);

    _normal$1.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)


    let DdN = this.direction.dot(_normal$1);
    let sign;

    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign = 1;
    } else if (DdN < 0) {
      sign = -1;
      DdN = -DdN;
    } else {
      return null;
    }

    _diff.subVectors(this.origin, a);

    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection

    if (DdQxE2 < 0) {
      return null;
    }

    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection

    if (DdE1xQ < 0) {
      return null;
    } // b1+b2 > 1, no intersection


    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    } // Line intersects triangle, check if ray does.


    const QdN = -sign * _diff.dot(_normal$1); // t < 0, no intersection


    if (QdN < 0) {
      return null;
    } // Ray intersects triangle.


    return this.at(QdN / DdN, target);
  }

  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }

  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }

  clone() {
    return new this.constructor().copy(this);
  }

}

exports.Ray = Ray;

class Matrix4 {
  constructor() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

    if (arguments.length > 0) {
      console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
  }

  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }

  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  clone() {
    return new Matrix4().fromArray(this.elements);
  }

  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }

  copyPosition(m) {
    const te = this.elements,
          me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }

  setFromMatrix3(m) {
    const me = m.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }

  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }

  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }

  extractRotation(m) {
    // this method does not support reflection matrices
    const te = this.elements;
    const me = m.elements;

    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();

    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();

    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();

    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }

  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
    }

    const te = this.elements;
    const x = euler.x,
          y = euler.y,
          z = euler.z;
    const a = Math.cos(x),
          b = Math.sin(x);
    const c = Math.cos(y),
          d = Math.sin(y);
    const e = Math.cos(z),
          f = Math.sin(z);

    if (euler.order === 'XYZ') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    } // bottom row


    te[3] = 0;
    te[7] = 0;
    te[11] = 0; // last column

    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }

  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }

  lookAt(eye, target, up) {
    const te = this.elements;

    _z.subVectors(eye, target);

    if (_z.lengthSq() === 0) {
      // eye and target are in the same position
      _z.z = 1;
    }

    _z.normalize();

    _x.crossVectors(up, _z);

    if (_x.lengthSq() === 0) {
      // up and z are parallel
      if (Math.abs(up.z) === 1) {
        _z.x += 0.0001;
      } else {
        _z.z += 0.0001;
      }

      _z.normalize();

      _x.crossVectors(up, _z);
    }

    _x.normalize();

    _y.crossVectors(_z, _x);

    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }

  multiply(m, n) {
    if (n !== undefined) {
      console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
      return this.multiplyMatrices(m, n);
    }

    return this.multiplyMatrices(this, m);
  }

  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }

  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
    const a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
    const a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
    const a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
    const b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
    const b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
    const b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
    const b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }

  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }

  determinant() {
    const te = this.elements;
    const n11 = te[0],
          n12 = te[4],
          n13 = te[8],
          n14 = te[12];
    const n21 = te[1],
          n22 = te[5],
          n23 = te[9],
          n24 = te[13];
    const n31 = te[2],
          n32 = te[6],
          n33 = te[10],
          n34 = te[14];
    const n41 = te[3],
          n42 = te[7],
          n43 = te[11],
          n44 = te[15]; //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }

  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }

  setPosition(x, y, z) {
    const te = this.elements;

    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }

    return this;
  }

  invert() {
    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    const te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n41 = te[3],
          n12 = te[4],
          n22 = te[5],
          n32 = te[6],
          n42 = te[7],
          n13 = te[8],
          n23 = te[9],
          n33 = te[10],
          n43 = te[11],
          n14 = te[12],
          n24 = te[13],
          n34 = te[14],
          n44 = te[15],
          t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
          t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
          t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
          t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }

  scale(v) {
    const te = this.elements;
    const x = v.x,
          y = v.y,
          z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }

  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }

  makeTranslation(x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  }

  makeRotationX(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationY(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationZ(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationAxis(axis, angle) {
    // Based on http://www.gamedev.net/reference/articles/article1199.asp
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x,
          y = axis.y,
          z = axis.z;
    const tx = t * x,
          ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  }

  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }

  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }

  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x,
          y = quaternion._y,
          z = quaternion._z,
          w = quaternion._w;
    const x2 = x + x,
          y2 = y + y,
          z2 = z + z;
    const xx = x * x2,
          xy = x * y2,
          xz = x * z2;
    const yy = y * y2,
          yz = y * z2,
          zz = z * z2;
    const wx = w * x2,
          wy = w * y2,
          wz = w * z2;
    const sx = scale.x,
          sy = scale.y,
          sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }

  decompose(position, quaternion, scale) {
    const te = this.elements;

    let sx = _v1$5.set(te[0], te[1], te[2]).length();

    const sy = _v1$5.set(te[4], te[5], te[6]).length();

    const sz = _v1$5.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14]; // scale the rotation part

    _m1$2.copy(this);

    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }

  makePerspective(left, right, top, bottom, near, far) {
    if (far === undefined) {
      console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
    }

    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    const c = -(far + near) / (far - near);
    const d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }

  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w = 1.0 / (right - left);
    const h = 1.0 / (top - bottom);
    const p = 1.0 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    const z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }

  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  }

  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }

}

exports.Matrix4 = Matrix4;
Matrix4.prototype.isMatrix4 = true;

const _v1$5 = /*@__PURE__*/new Vector3();

const _m1$2 = /*@__PURE__*/new Matrix4();

const _zero = /*@__PURE__*/new Vector3(0, 0, 0);

const _one = /*@__PURE__*/new Vector3(1, 1, 1);

const _x = /*@__PURE__*/new Vector3();

const _y = /*@__PURE__*/new Vector3();

const _z = /*@__PURE__*/new Vector3();

const _matrix$1 = /*@__PURE__*/new Matrix4();

const _quaternion$3 = /*@__PURE__*/new Quaternion();

class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }

  get x() {
    return this._x;
  }

  set x(value) {
    this._x = value;

    this._onChangeCallback();
  }

  get y() {
    return this._y;
  }

  set y(value) {
    this._y = value;

    this._onChangeCallback();
  }

  get z() {
    return this._z;
  }

  set z(value) {
    this._z = value;

    this._onChangeCallback();
  }

  get order() {
    return this._order;
  }

  set order(value) {
    this._order = value;

    this._onChangeCallback();
  }

  set(x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;

    this._onChangeCallback();

    return this;
  }

  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }

  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this._onChangeCallback();

    return this;
  }

  setFromRotationMatrix(m, order, update) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.elements;
    const m11 = te[0],
          m12 = te[4],
          m13 = te[8];
    const m21 = te[1],
          m22 = te[5],
          m23 = te[9];
    const m31 = te[2],
          m32 = te[6],
          m33 = te[10];
    order = order || this._order;

    switch (order) {
      case 'XYZ':
        this._y = Math.asin(clamp(m13, -1, 1));

        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }

        break;

      case 'YXZ':
        this._x = Math.asin(-clamp(m23, -1, 1));

        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }

        break;

      case 'ZXY':
        this._x = Math.asin(clamp(m32, -1, 1));

        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }

        break;

      case 'ZYX':
        this._y = Math.asin(-clamp(m31, -1, 1));

        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }

        break;

      case 'YZX':
        this._z = Math.asin(clamp(m21, -1, 1));

        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }

        break;

      case 'XZY':
        this._z = Math.asin(-clamp(m12, -1, 1));

        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }

        break;

      default:
        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
    }

    this._order = order;
    if (update !== false) this._onChangeCallback();
    return this;
  }

  setFromQuaternion(q, order, update) {
    _matrix$1.makeRotationFromQuaternion(q);

    return this.setFromRotationMatrix(_matrix$1, order, update);
  }

  setFromVector3(v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  }

  reorder(newOrder) {
    // WARNING: this discards revolution information -bhouston
    _quaternion$3.setFromEuler(this);

    return this.setFromQuaternion(_quaternion$3, newOrder);
  }

  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }

  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined) this._order = array[3];

    this._onChangeCallback();

    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }

  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }

  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }

  _onChangeCallback() {}

}

exports.Euler = Euler;
Euler.prototype.isEuler = true;
Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

class Layers {
  constructor() {
    this.mask = 1 | 0;
  }

  set(channel) {
    this.mask = 1 << channel | 0;
  }

  enable(channel) {
    this.mask |= 1 << channel | 0;
  }

  enableAll() {
    this.mask = 0xffffffff | 0;
  }

  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }

  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }

  disableAll() {
    this.mask = 0;
  }

  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }

}

exports.Layers = Layers;
let _object3DId = 0;

const _v1$4 = /*@__PURE__*/new Vector3();

const _q1 = /*@__PURE__*/new Quaternion();

const _m1$1 = /*@__PURE__*/new Matrix4();

const _target = /*@__PURE__*/new Vector3();

const _position$3 = /*@__PURE__*/new Vector3();

const _scale$2 = /*@__PURE__*/new Vector3();

const _quaternion$2 = /*@__PURE__*/new Quaternion();

const _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);

const _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);

const _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);

const _addedEvent = {
  type: 'added'
};
const _removedEvent = {
  type: 'removed'
};

class Object3D extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, 'id', {
      value: _object3DId++
    });
    this.uuid = generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);

    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }

    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, undefined, false);
    }

    rotation._onChange(onRotationChange);

    quaternion._onChange(onQuaternionChange);

    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }

  onBeforeRender() {}

  onAfterRender() {}

  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }

  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }

  setRotationFromAxisAngle(axis, angle) {
    // assumes axis is normalized
    this.quaternion.setFromAxisAngle(axis, angle);
  }

  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }

  setRotationFromMatrix(m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    this.quaternion.setFromRotationMatrix(m);
  }

  setRotationFromQuaternion(q) {
    // assumes q is normalized
    this.quaternion.copy(q);
  }

  rotateOnAxis(axis, angle) {
    // rotate object on axis in object space
    // axis is assumed to be normalized
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.multiply(_q1);
    return this;
  }

  rotateOnWorldAxis(axis, angle) {
    // rotate object on axis in world space
    // axis is assumed to be normalized
    // method assumes no rotated parent
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.premultiply(_q1);
    return this;
  }

  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }

  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }

  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }

  translateOnAxis(axis, distance) {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized
    _v1$4.copy(axis).applyQuaternion(this.quaternion);

    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }

  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }

  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }

  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }

  localToWorld(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  }

  worldToLocal(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }

  lookAt(x, y, z) {
    // This method does not support objects having non-uniformly-scaled parent(s)
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }

    const parent = this.parent;
    this.updateWorldMatrix(true, false);

    _position$3.setFromMatrixPosition(this.matrixWorld);

    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }

    this.quaternion.setFromRotationMatrix(_m1$1);

    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);

      _q1.setFromRotationMatrix(_m1$1);

      this.quaternion.premultiply(_q1.invert());
    }
  }

  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }

      return this;
    }

    if (object === this) {
      console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
      return this;
    }

    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }

      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
    }

    return this;
  }

  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }

      return this;
    }

    const index = this.children.indexOf(object);

    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }

    return this;
  }

  removeFromParent() {
    const parent = this.parent;

    if (parent !== null) {
      parent.remove(this);
    }

    return this;
  }

  clear() {
    for (let i = 0; i < this.children.length; i++) {
      const object = this.children[i];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }

    this.children.length = 0;
    return this;
  }

  attach(object) {
    // adds object as a child of this, while maintaining the object's world transform
    this.updateWorldMatrix(true, false);

    _m1$1.copy(this.matrixWorld).invert();

    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);

      _m1$1.multiply(object.parent.matrixWorld);
    }

    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }

  getObjectById(id) {
    return this.getObjectByProperty('id', id);
  }

  getObjectByName(name) {
    return this.getObjectByProperty('name', name);
  }

  getObjectByProperty(name, value) {
    if (this[name] === value) return this;

    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);

      if (object !== undefined) {
        return object;
      }
    }

    return undefined;
  }

  getWorldPosition(target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldPosition() target is now required');
      target = new Vector3();
    }

    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }

  getWorldQuaternion(target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
      target = new Quaternion();
    }

    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }

  getWorldScale(target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldScale() target is now required');
      target = new Vector3();
    }

    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }

  getWorldDirection(target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldDirection() target is now required');
      target = new Vector3();
    }

    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }

  raycast() {}

  traverse(callback) {
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  }

  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  }

  traverseAncestors(callback) {
    const parent = this.parent;

    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }

  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }

  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      this.matrixWorldNeedsUpdate = false;
      force = true;
    } // update children


    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  }

  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;

    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }

    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    } // update children


    if (updateChildren === true) {
      const children = this.children;

      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  }

  toJSON(meta) {
    // meta is a string when called from JSON.stringify
    const isRootObject = meta === undefined || typeof meta === 'string';
    const output = {}; // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.

    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    } // standard Object3D serialization


    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '') object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

    if (this.isInstancedMesh) {
      object.type = 'InstancedMesh';
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    } //


    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta);
      }

      return element.uuid;
    }

    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;

      if (parameters !== undefined && parameters.shapes !== undefined) {
        const shapes = parameters.shapes;

        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }

    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();

      if (this.skeleton !== undefined) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }

    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        const uuids = [];

        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }

        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    } //


    if (this.children.length > 0) {
      object.children = [];

      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    } //


    if (this.animations.length > 0) {
      object.animations = [];

      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }

    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
    }

    output.object = object;
    return output; // extract data from the cache hash
    // remove metadata on each item
    // and return as array

    function extractFromCache(cache) {
      const values = [];

      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }
  }

  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }

  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));

    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }

    return this;
  }

}

exports.Object3D = Object3D;
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype.isObject3D = true;

const _vector1 = /*@__PURE__*/new Vector3();

const _vector2$1 = /*@__PURE__*/new Vector3();

const _normalMatrix = /*@__PURE__*/new Matrix3();

class Plane {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    // normal is assumed to be normalized
    this.normal = normal;
    this.constant = constant;
  }

  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }

  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }

  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }

  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2$1.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }

  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }

  normalize() {
    // Note: will lead to a divide by zero if the plane is invalid.
    const inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }

  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }

  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }

  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }

  projectPoint(point, target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .projectPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }

  intersectLine(line, target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .intersectLine() target is now required');
      target = new Vector3();
    }

    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);

    if (denominator === 0) {
      // line is coplanar, return origin
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      } // Unsure if this is the correct method to handle this case.


      return null;
    }

    const t = -(line.start.dot(this.normal) + this.constant) / denominator;

    if (t < 0 || t > 1) {
      return null;
    }

    return target.copy(direction).multiplyScalar(t).add(line.start);
  }

  intersectsLine(line) {
    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }

  intersectsBox(box) {
    return box.intersectsPlane(this);
  }

  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }

  coplanarPoint(target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .coplanarPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(this.normal).multiplyScalar(-this.constant);
  }

  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }

  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }

  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }

  clone() {
    return new this.constructor().copy(this);
  }

}

exports.Plane = Plane;
Plane.prototype.isPlane = true;

const _v0$1 = /*@__PURE__*/new Vector3();

const _v1$3 = /*@__PURE__*/new Vector3();

const _v2$2 = /*@__PURE__*/new Vector3();

const _v3$1 = /*@__PURE__*/new Vector3();

const _vab = /*@__PURE__*/new Vector3();

const _vac = /*@__PURE__*/new Vector3();

const _vbc = /*@__PURE__*/new Vector3();

const _vap = /*@__PURE__*/new Vector3();

const _vbp = /*@__PURE__*/new Vector3();

const _vcp = /*@__PURE__*/new Vector3();

class Triangle {
  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }

  static getNormal(a, b, c, target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getNormal() target is now required');
      target = new Vector3();
    }

    target.subVectors(c, b);

    _v0$1.subVectors(a, b);

    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();

    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }

    return target.set(0, 0, 0);
  } // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html


  static getBarycoord(point, a, b, c, target) {
    _v0$1.subVectors(c, a);

    _v1$3.subVectors(b, a);

    _v2$2.subVectors(point, a);

    const dot00 = _v0$1.dot(_v0$1);

    const dot01 = _v0$1.dot(_v1$3);

    const dot02 = _v0$1.dot(_v2$2);

    const dot11 = _v1$3.dot(_v1$3);

    const dot12 = _v1$3.dot(_v2$2);

    const denom = dot00 * dot11 - dot01 * dot01;

    if (target === undefined) {
      console.warn('THREE.Triangle: .getBarycoord() target is now required');
      target = new Vector3();
    } // collinear or singular triangle


    if (denom === 0) {
      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return target.set(-2, -1, -1);
    }

    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

    return target.set(1 - u - v, v, u);
  }

  static containsPoint(point, a, b, c) {
    this.getBarycoord(point, a, b, c, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }

  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3$1);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3$1.x);
    target.addScaledVector(uv2, _v3$1.y);
    target.addScaledVector(uv3, _v3$1.z);
    return target;
  }

  static isFrontFacing(a, b, c, direction) {
    _v0$1.subVectors(c, b);

    _v1$3.subVectors(a, b); // strictly front facing


    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }

  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }

  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }

  getArea() {
    _v0$1.subVectors(this.c, this.b);

    _v1$3.subVectors(this.a, this.b);

    return _v0$1.cross(_v1$3).length() * 0.5;
  }

  getMidpoint(target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getMidpoint() target is now required');
      target = new Vector3();
    }

    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }

  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }

  getPlane(target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getPlane() target is now required');
      target = new Plane();
    }

    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }

  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }

  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }

  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }

  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }

  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }

  closestPointToPoint(p, target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    const a = this.a,
          b = this.b,
          c = this.c;
    let v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
    // under the accompanying license; see chapter 5.1.5 for detailed explanation.
    // basically, we're distinguishing which of the voronoi regions of the triangle
    // the point lies in with the minimum amount of redundant computation.

    _vab.subVectors(b, a);

    _vac.subVectors(c, a);

    _vap.subVectors(p, a);

    const d1 = _vab.dot(_vap);

    const d2 = _vac.dot(_vap);

    if (d1 <= 0 && d2 <= 0) {
      // vertex region of A; barycentric coords (1, 0, 0)
      return target.copy(a);
    }

    _vbp.subVectors(p, b);

    const d3 = _vab.dot(_vbp);

    const d4 = _vac.dot(_vbp);

    if (d3 >= 0 && d4 <= d3) {
      // vertex region of B; barycentric coords (0, 1, 0)
      return target.copy(b);
    }

    const vc = d1 * d4 - d3 * d2;

    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

      return target.copy(a).addScaledVector(_vab, v);
    }

    _vcp.subVectors(p, c);

    const d5 = _vab.dot(_vcp);

    const d6 = _vac.dot(_vcp);

    if (d6 >= 0 && d5 <= d6) {
      // vertex region of C; barycentric coords (0, 0, 1)
      return target.copy(c);
    }

    const vb = d5 * d2 - d1 * d6;

    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

      return target.copy(a).addScaledVector(_vac, w);
    }

    const va = d3 * d6 - d5 * d4;

    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);

      w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

      return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
    } // face region


    const denom = 1 / (va + vb + vc); // u = va * denom

    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }

  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }

}

exports.Triangle = Triangle;
let materialId = 0;

class Material extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, 'id', {
      value: materialId++
    });
    this.uuid = generateUUID();
    this.name = '';
    this.type = 'Material';
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 0xff;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 0xff;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null; // override the renderer's default precision for this material

    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
  }

  onBuild()
  /* shaderobject, renderer */
  {}

  onBeforeCompile()
  /* shaderobject, renderer */
  {}

  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }

  setValues(values) {
    if (values === undefined) return;

    for (const key in values) {
      const newValue = values[key];

      if (newValue === undefined) {
        console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
        continue;
      } // for backward compatability if shading is set in the constructor


      if (key === 'shading') {
        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }

      const currentValue = this[key];

      if (currentValue === undefined) {
        console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
        continue;
      }

      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }

  toJSON(meta) {
    const isRoot = meta === undefined || typeof meta === 'string';

    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }

    const data = {
      metadata: {
        version: 4.5,
        type: 'Material',
        generator: 'Material.toJSON'
      }
    }; // standard Material serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== undefined) data.roughness = this.roughness;
    if (this.metalness !== undefined) data.metalness = this.metalness;
    if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.shininess !== undefined) data.shininess = this.shininess;
    if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }

    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }

    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }

    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;

    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }

    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }

    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }

    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }

    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }

    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== undefined) data.combine = this.combine;
    }

    if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;

    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }

    if (this.transmission !== undefined) data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== undefined) data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== undefined) data.size = this.size;
    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)

    if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== undefined) data.dashSize = this.dashSize;
    if (this.gapSize !== undefined) data.gapSize = this.gapSize;
    if (this.scale !== undefined) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true) data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true) data.morphTargets = true;
    if (this.morphNormals === true) data.morphNormals = true;
    if (this.flatShading === true) data.flatShading = this.flatShading;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

    function extractFromCache(cache) {
      const values = [];

      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }

    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }

    return data;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;

    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);

      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }

    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }

  dispose() {
    this.dispatchEvent({
      type: 'dispose'
    });
  }

  set needsUpdate(value) {
    if (value === true) this.version++;
  }

}

exports.Material = Material;
Material.prototype.isMaterial = true;
const _colorKeywords = {
  'aliceblue': 0xF0F8FF,
  'antiquewhite': 0xFAEBD7,
  'aqua': 0x00FFFF,
  'aquamarine': 0x7FFFD4,
  'azure': 0xF0FFFF,
  'beige': 0xF5F5DC,
  'bisque': 0xFFE4C4,
  'black': 0x000000,
  'blanchedalmond': 0xFFEBCD,
  'blue': 0x0000FF,
  'blueviolet': 0x8A2BE2,
  'brown': 0xA52A2A,
  'burlywood': 0xDEB887,
  'cadetblue': 0x5F9EA0,
  'chartreuse': 0x7FFF00,
  'chocolate': 0xD2691E,
  'coral': 0xFF7F50,
  'cornflowerblue': 0x6495ED,
  'cornsilk': 0xFFF8DC,
  'crimson': 0xDC143C,
  'cyan': 0x00FFFF,
  'darkblue': 0x00008B,
  'darkcyan': 0x008B8B,
  'darkgoldenrod': 0xB8860B,
  'darkgray': 0xA9A9A9,
  'darkgreen': 0x006400,
  'darkgrey': 0xA9A9A9,
  'darkkhaki': 0xBDB76B,
  'darkmagenta': 0x8B008B,
  'darkolivegreen': 0x556B2F,
  'darkorange': 0xFF8C00,
  'darkorchid': 0x9932CC,
  'darkred': 0x8B0000,
  'darksalmon': 0xE9967A,
  'darkseagreen': 0x8FBC8F,
  'darkslateblue': 0x483D8B,
  'darkslategray': 0x2F4F4F,
  'darkslategrey': 0x2F4F4F,
  'darkturquoise': 0x00CED1,
  'darkviolet': 0x9400D3,
  'deeppink': 0xFF1493,
  'deepskyblue': 0x00BFFF,
  'dimgray': 0x696969,
  'dimgrey': 0x696969,
  'dodgerblue': 0x1E90FF,
  'firebrick': 0xB22222,
  'floralwhite': 0xFFFAF0,
  'forestgreen': 0x228B22,
  'fuchsia': 0xFF00FF,
  'gainsboro': 0xDCDCDC,
  'ghostwhite': 0xF8F8FF,
  'gold': 0xFFD700,
  'goldenrod': 0xDAA520,
  'gray': 0x808080,
  'green': 0x008000,
  'greenyellow': 0xADFF2F,
  'grey': 0x808080,
  'honeydew': 0xF0FFF0,
  'hotpink': 0xFF69B4,
  'indianred': 0xCD5C5C,
  'indigo': 0x4B0082,
  'ivory': 0xFFFFF0,
  'khaki': 0xF0E68C,
  'lavender': 0xE6E6FA,
  'lavenderblush': 0xFFF0F5,
  'lawngreen': 0x7CFC00,
  'lemonchiffon': 0xFFFACD,
  'lightblue': 0xADD8E6,
  'lightcoral': 0xF08080,
  'lightcyan': 0xE0FFFF,
  'lightgoldenrodyellow': 0xFAFAD2,
  'lightgray': 0xD3D3D3,
  'lightgreen': 0x90EE90,
  'lightgrey': 0xD3D3D3,
  'lightpink': 0xFFB6C1,
  'lightsalmon': 0xFFA07A,
  'lightseagreen': 0x20B2AA,
  'lightskyblue': 0x87CEFA,
  'lightslategray': 0x778899,
  'lightslategrey': 0x778899,
  'lightsteelblue': 0xB0C4DE,
  'lightyellow': 0xFFFFE0,
  'lime': 0x00FF00,
  'limegreen': 0x32CD32,
  'linen': 0xFAF0E6,
  'magenta': 0xFF00FF,
  'maroon': 0x800000,
  'mediumaquamarine': 0x66CDAA,
  'mediumblue': 0x0000CD,
  'mediumorchid': 0xBA55D3,
  'mediumpurple': 0x9370DB,
  'mediumseagreen': 0x3CB371,
  'mediumslateblue': 0x7B68EE,
  'mediumspringgreen': 0x00FA9A,
  'mediumturquoise': 0x48D1CC,
  'mediumvioletred': 0xC71585,
  'midnightblue': 0x191970,
  'mintcream': 0xF5FFFA,
  'mistyrose': 0xFFE4E1,
  'moccasin': 0xFFE4B5,
  'navajowhite': 0xFFDEAD,
  'navy': 0x000080,
  'oldlace': 0xFDF5E6,
  'olive': 0x808000,
  'olivedrab': 0x6B8E23,
  'orange': 0xFFA500,
  'orangered': 0xFF4500,
  'orchid': 0xDA70D6,
  'palegoldenrod': 0xEEE8AA,
  'palegreen': 0x98FB98,
  'paleturquoise': 0xAFEEEE,
  'palevioletred': 0xDB7093,
  'papayawhip': 0xFFEFD5,
  'peachpuff': 0xFFDAB9,
  'peru': 0xCD853F,
  'pink': 0xFFC0CB,
  'plum': 0xDDA0DD,
  'powderblue': 0xB0E0E6,
  'purple': 0x800080,
  'rebeccapurple': 0x663399,
  'red': 0xFF0000,
  'rosybrown': 0xBC8F8F,
  'royalblue': 0x4169E1,
  'saddlebrown': 0x8B4513,
  'salmon': 0xFA8072,
  'sandybrown': 0xF4A460,
  'seagreen': 0x2E8B57,
  'seashell': 0xFFF5EE,
  'sienna': 0xA0522D,
  'silver': 0xC0C0C0,
  'skyblue': 0x87CEEB,
  'slateblue': 0x6A5ACD,
  'slategray': 0x708090,
  'slategrey': 0x708090,
  'snow': 0xFFFAFA,
  'springgreen': 0x00FF7F,
  'steelblue': 0x4682B4,
  'tan': 0xD2B48C,
  'teal': 0x008080,
  'thistle': 0xD8BFD8,
  'tomato': 0xFF6347,
  'turquoise': 0x40E0D0,
  'violet': 0xEE82EE,
  'wheat': 0xF5DEB3,
  'white': 0xFFFFFF,
  'whitesmoke': 0xF5F5F5,
  'yellow': 0xFFFF00,
  'yellowgreen': 0x9ACD32
};
const _hslA = {
  h: 0,
  s: 0,
  l: 0
};
const _hslB = {
  h: 0,
  s: 0,
  l: 0
};

function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}

function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}

function LinearToSRGB(c) {
  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}

class Color {
  constructor(r, g, b) {
    if (g === undefined && b === undefined) {
      // r is THREE.Color, hex or string
      return this.set(r);
    }

    return this.setRGB(r, g, b);
  }

  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === 'number') {
      this.setHex(value);
    } else if (typeof value === 'string') {
      this.setStyle(value);
    }

    return this;
  }

  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }

  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }

  setRGB(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  }

  setHSL(h, s, l) {
    // h,s,l ranges are in 0.0 - 1.0
    h = euclideanModulo(h, 1);
    s = clamp(s, 0, 1);
    l = clamp(l, 0, 1);

    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }

    return this;
  }

  setStyle(style) {
    function handleAlpha(string) {
      if (string === undefined) return;

      if (parseFloat(string) < 1) {
        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
      }
    }

    let m;

    if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      // rgb / hsl
      let color;
      const name = m[1];
      const components = m[2];

      switch (name) {
        case 'rgb':
        case 'rgba':
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            // rgb(255,0,0) rgba(255,0,0,0.5)
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[4]);
            return this;
          }

          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[4]);
            return this;
          }

          break;

        case 'hsl':
        case 'hsla':
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
            const h = parseFloat(color[1]) / 360;
            const s = parseInt(color[2], 10) / 100;
            const l = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h, s, l);
          }

          break;
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      // hex color
      const hex = m[1];
      const size = hex.length;

      if (size === 3) {
        // #ff0
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        // #ff0000
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }

    if (style && style.length > 0) {
      return this.setColorName(style);
    }

    return this;
  }

  setColorName(style) {
    // color keywords
    const hex = _colorKeywords[style.toLowerCase()];

    if (hex !== undefined) {
      // red
      this.setHex(hex);
    } else {
      // unknown color
      console.warn('THREE.Color: Unknown color ' + style);
    }

    return this;
  }

  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }

  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }

  copyGammaToLinear(color, gammaFactor = 2.0) {
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  }

  copyLinearToGamma(color, gammaFactor = 2.0) {
    const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  }

  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }

  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }

  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }

  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }

  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }

  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }

  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }

  getHexString() {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  }

  getHSL(target) {
    // h,s,l ranges are in 0.0 - 1.0
    if (target === undefined) {
      console.warn('THREE.Color: .getHSL() target is now required');
      target = {
        h: 0,
        s: 0,
        l: 0
      };
    }

    const r = this.r,
          g = this.g,
          b = this.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2.0;

    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;

        case g:
          hue = (b - r) / delta + 2;
          break;

        case b:
          hue = (r - g) / delta + 4;
          break;
      }

      hue /= 6;
    }

    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }

  getStyle() {
    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
  }

  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    _hslA.h += h;
    _hslA.s += s;
    _hslA.l += l;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }

  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }

  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }

  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }

  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }

  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }

  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }

  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }

  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }

  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = lerp(_hslA.h, _hslB.h, alpha);
    const s = lerp(_hslA.s, _hslB.s, alpha);
    const l = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }

  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }

  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);

    if (attribute.normalized === true) {
      // assuming Uint8Array
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }

    return this;
  }

  toJSON() {
    return this.getHex();
  }

}

exports.Color = Color;
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  morphTargets: <bool>
 * }
 */

class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'MeshBasicMaterial';
    this.color = new Color(0xffffff); // emissive

    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.morphTargets = false;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.morphTargets = source.morphTargets;
    return this;
  }

}

exports.MeshBasicMaterial = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

const _vector$9 = /*@__PURE__*/new Vector3();

const _vector2 = /*@__PURE__*/new Vector2();

class BufferAttribute {
  constructor(array, itemSize, normalized) {
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }

    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = {
      offset: 0,
      count: -1
    };
    this.version = 0;
  }

  onUploadCallback() {}

  set needsUpdate(value) {
    if (value === true) this.version++;
  }

  setUsage(value) {
    this.usage = value;
    return this;
  }

  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  }

  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  }

  copyArray(array) {
    this.array.set(array);
    return this;
  }

  copyColorsArray(colors) {
    const array = this.array;
    let offset = 0;

    for (let i = 0, l = colors.length; i < l; i++) {
      let color = colors[i];

      if (color === undefined) {
        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
        color = new Color();
      }

      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }

    return this;
  }

  copyVector2sArray(vectors) {
    const array = this.array;
    let offset = 0;

    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
        vector = new Vector2();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }

    return this;
  }

  copyVector3sArray(vectors) {
    const array = this.array;
    let offset = 0;

    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
        vector = new Vector3();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }

    return this;
  }

  copyVector4sArray(vectors) {
    const array = this.array;
    let offset = 0;

    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
        vector = new Vector4();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }

    return this;
  }

  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2.fromBufferAttribute(this, i);

        _vector2.applyMatrix3(m);

        this.setXY(i, _vector2.x, _vector2.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);

        _vector$9.applyMatrix3(m);

        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }

    return this;
  }

  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.x = this.getX(i);
      _vector$9.y = this.getY(i);
      _vector$9.z = this.getZ(i);

      _vector$9.applyMatrix4(m);

      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }

    return this;
  }

  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.x = this.getX(i);
      _vector$9.y = this.getY(i);
      _vector$9.z = this.getZ(i);

      _vector$9.applyNormalMatrix(m);

      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }

    return this;
  }

  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.x = this.getX(i);
      _vector$9.y = this.getY(i);
      _vector$9.z = this.getZ(i);

      _vector$9.transformDirection(m);

      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }

    return this;
  }

  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }

  getX(index) {
    return this.array[index * this.itemSize];
  }

  setX(index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  }

  getY(index) {
    return this.array[index * this.itemSize + 1];
  }

  setY(index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  }

  getZ(index) {
    return this.array[index * this.itemSize + 2];
  }

  setZ(index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  }

  getW(index) {
    return this.array[index * this.itemSize + 3];
  }

  setW(index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  }

  setXY(index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }

  setXYZ(index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }

  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }

  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }

  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }

  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
    if (this.name !== '') data.name = this.name;
    if (this.usage !== StaticDrawUsage) data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
    return data;
  }

}

exports.BufferAttribute = BufferAttribute;
BufferAttribute.prototype.isBufferAttribute = true; //

class Int8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int8Array(array), itemSize, normalized);
  }

}

exports.Int8BufferAttribute = Int8BufferAttribute;

class Uint8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8Array(array), itemSize, normalized);
  }

}

exports.Uint8BufferAttribute = Uint8BufferAttribute;

class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8ClampedArray(array), itemSize, normalized);
  }

}

exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;

class Int16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int16Array(array), itemSize, normalized);
  }

}

exports.Int16BufferAttribute = Int16BufferAttribute;

class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }

}

exports.Uint16BufferAttribute = Uint16BufferAttribute;

class Int32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int32Array(array), itemSize, normalized);
  }

}

exports.Int32BufferAttribute = Int32BufferAttribute;

class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }

}

exports.Uint32BufferAttribute = Uint32BufferAttribute;

class Float16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }

}

exports.Float16BufferAttribute = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }

}

exports.Float32BufferAttribute = Float32BufferAttribute;

class Float64BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float64Array(array), itemSize, normalized);
  }

}

exports.Float64BufferAttribute = Float64BufferAttribute;

function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  let max = array[0];

  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max) max = array[i];
  }

  return max;
}

const TYPED_ARRAYS = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  Uint8ClampedArray: Uint8ClampedArray,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};

function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}

let _id = 0;

const _m1 = /*@__PURE__*/new Matrix4();

const _obj = /*@__PURE__*/new Object3D();

const _offset = /*@__PURE__*/new Vector3();

const _box$1 = /*@__PURE__*/new Box3();

const _boxMorphTargets = /*@__PURE__*/new Box3();

const _vector$8 = /*@__PURE__*/new Vector3();

class BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, 'id', {
      value: _id++
    });
    this.uuid = generateUUID();
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
      start: 0,
      count: Infinity
    };
    this.userData = {};
  }

  getIndex() {
    return this.index;
  }

  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }

    return this;
  }

  getAttribute(name) {
    return this.attributes[name];
  }

  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }

  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }

  hasAttribute(name) {
    return this.attributes[name] !== undefined;
  }

  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex
    });
  }

  clearGroups() {
    this.groups = [];
  }

  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }

  applyMatrix4(matrix) {
    const position = this.attributes.position;

    if (position !== undefined) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }

    const normal = this.attributes.normal;

    if (normal !== undefined) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }

    const tangent = this.attributes.tangent;

    if (tangent !== undefined) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  }

  applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateX(angle) {
    // rotate geometry around world x-axis
    _m1.makeRotationX(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateY(angle) {
    // rotate geometry around world y-axis
    _m1.makeRotationY(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateZ(angle) {
    // rotate geometry around world z-axis
    _m1.makeRotationZ(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  translate(x, y, z) {
    // translate geometry
    _m1.makeTranslation(x, y, z);

    this.applyMatrix4(_m1);
    return this;
  }

  scale(x, y, z) {
    // scale geometry
    _m1.makeScale(x, y, z);

    this.applyMatrix4(_m1);
    return this;
  }

  lookAt(vector) {
    _obj.lookAt(vector);

    _obj.updateMatrix();

    this.applyMatrix4(_obj.matrix);
    return this;
  }

  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }

  setFromPoints(points) {
    const position = [];

    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }

    this.setAttribute('position', new Float32BufferAttribute(position, 3));
    return this;
  }

  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
      return;
    }

    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _box$1.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$1.min);

            this.boundingBox.expandByPoint(_vector$8);

            _vector$8.addVectors(this.boundingBox.max, _box$1.max);

            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }

    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }

  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }

    if (position) {
      // first, find the center of the bounding sphere
      const center = this.boundingSphere.center;

      _box$1.setFromBufferAttribute(position); // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _boxMorphTargets.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);

            _box$1.expandByPoint(_vector$8);

            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);

            _box$1.expandByPoint(_vector$8);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);

            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }

      _box$1.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case


      let maxRadiusSq = 0;

      for (let i = 0, il = position.count; i < il; i++) {
        _vector$8.fromBufferAttribute(position, i);

        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      } // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;

          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$8.fromBufferAttribute(morphAttribute, j);

            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);

              _vector$8.add(_offset);
            }

            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }

      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }

  computeFaceNormals() {// backwards compatibility
  }

  computeTangents() {
    const index = this.index;
    const attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
    // (per vertex tangents)

    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
      return;
    }

    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;

    if (attributes.tangent === undefined) {
      this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }

    const tangents = attributes.tangent.array;
    const tan1 = [],
          tan2 = [];

    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new Vector3();
      tan2[i] = new Vector3();
    }

    const vA = new Vector3(),
          vB = new Vector3(),
          vC = new Vector3(),
          uvA = new Vector2(),
          uvB = new Vector2(),
          uvC = new Vector2(),
          sdir = new Vector3(),
          tdir = new Vector3();

    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

      if (!isFinite(r)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }

    let groups = this.groups;

    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }

    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;

      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
      }
    }

    const tmp = new Vector3(),
          tmp2 = new Vector3();
    const n = new Vector3(),
          n2 = new Vector3();

    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v]; // Gram-Schmidt orthogonalize

      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

      tmp2.crossVectors(n2, t);
      const test = tmp2.dot(tan2[v]);
      const w = test < 0.0 ? -1.0 : 1.0;
      tangents[v * 4] = tmp.x;
      tangents[v * 4 + 1] = tmp.y;
      tangents[v * 4 + 2] = tmp.z;
      tangents[v * 4 + 3] = w;
    }

    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;

      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  }

  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute('position');

    if (positionAttribute !== undefined) {
      let normalAttribute = this.getAttribute('normal');

      if (normalAttribute === undefined) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute('normal', normalAttribute);
      } else {
        // reset existing normals to zero
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }

      const pA = new Vector3(),
            pB = new Vector3(),
            pC = new Vector3();
      const nA = new Vector3(),
            nB = new Vector3(),
            nC = new Vector3();
      const cb = new Vector3(),
            ab = new Vector3(); // indexed elements

      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        // non-indexed elements (unconnected triangle soup)
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }

      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }

  merge(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
      return;
    }

    if (offset === undefined) {
      offset = 0;
      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
    }

    const attributes = this.attributes;

    for (const key in attributes) {
      if (geometry.attributes[key] === undefined) continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

      for (let i = 0, j = attributeOffset; i < length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }

    return this;
  }

  normalizeNormals() {
    const normals = this.attributes.normal;

    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$8.fromBufferAttribute(normals, i);

      _vector$8.normalize();

      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }

  toNonIndexed() {
    function convertBufferAttribute(attribute, indices) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices.length * itemSize);
      let index = 0,
          index2 = 0;

      for (let i = 0, l = indices.length; i < l; i++) {
        index = indices[i] * itemSize;

        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }

      return new BufferAttribute(array2, itemSize, normalized);
    } //


    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
      return this;
    }

    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes; // attributes

    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    } // morph attributes


    const morphAttributes = this.morphAttributes;

    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }

      geometry2.morphAttributes[name] = morphArray;
    }

    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

    const groups = this.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }

    return geometry2;
  }

  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    }; // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;

    if (this.parameters !== undefined) {
      const parameters = this.parameters;

      for (const key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    } // for simplicity the code assumes attributes are not shared across geometries, see #15811


    data.data = {
      attributes: {}
    };
    const index = this.index;

    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }

    const attributes = this.attributes;

    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }

    const morphAttributes = {};
    let hasMorphAttributes = false;

    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];

      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }

      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }

    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }

    const groups = this.groups;

    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }

    const boundingSphere = this.boundingSphere;

    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }

    return data;
  }

  clone() {
    /*
     // Handle primitives
    	 const parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 const values = [];
    	 for ( const key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 const geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */
    return new BufferGeometry().copy(this);
  }

  copy(source) {
    // reset
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null; // used for storing cloned, shared data

    const data = {}; // name

    this.name = source.name; // index

    const index = source.index;

    if (index !== null) {
      this.setIndex(index.clone(data));
    } // attributes


    const attributes = source.attributes;

    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    } // morph attributes


    const morphAttributes = source.morphAttributes;

    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }

      this.morphAttributes[name] = array;
    }

    this.morphTargetsRelative = source.morphTargetsRelative; // groups

    const groups = source.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    } // bounding box


    const boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    const boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // draw range


    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count; // user data

    this.userData = source.userData;
    return this;
  }

  dispose() {
    this.dispatchEvent({
      type: 'dispose'
    });
  }

}

exports.BufferGeometry = BufferGeometry;
BufferGeometry.prototype.isBufferGeometry = true;

const _inverseMatrix$2 = /*@__PURE__*/new Matrix4();

const _ray$2 = /*@__PURE__*/new Ray();

const _sphere$3 = /*@__PURE__*/new Sphere();

const _vA$1 = /*@__PURE__*/new Vector3();

const _vB$1 = /*@__PURE__*/new Vector3();

const _vC$1 = /*@__PURE__*/new Vector3();

const _tempA = /*@__PURE__*/new Vector3();

const _tempB = /*@__PURE__*/new Vector3();

const _tempC = /*@__PURE__*/new Vector3();

const _morphA = /*@__PURE__*/new Vector3();

const _morphB = /*@__PURE__*/new Vector3();

const _morphC = /*@__PURE__*/new Vector3();

const _uvA$1 = /*@__PURE__*/new Vector2();

const _uvB$1 = /*@__PURE__*/new Vector2();

const _uvC$1 = /*@__PURE__*/new Vector2();

const _intersectionPoint = /*@__PURE__*/new Vector3();

const _intersectionPointWorld = /*@__PURE__*/new Vector3();

class Mesh extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.type = 'Mesh';
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }

  copy(source) {
    super.copy(source);

    if (source.morphTargetInfluences !== undefined) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }

    if (source.morphTargetDictionary !== undefined) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }

    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }

  updateMorphTargets() {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  }

  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === undefined) return; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere$3.copy(geometry.boundingSphere);

    _sphere$3.applyMatrix4(matrixWorld);

    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //

    _inverseMatrix$2.copy(matrixWorld).invert();

    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2); // Check boundingBox before continuing


    if (geometry.boundingBox !== null) {
      if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;
    }

    let intersection;

    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;

      if (index !== null) {
        // indexed buffer geometry
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

            for (let j = start, jl = end; j < jl; j += 3) {
              const a = index.getX(j);
              const b = index.getX(j + 1);
              const c = index.getX(j + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);

          for (let i = start, il = end; i < il; i += 3) {
            const a = index.getX(i);
            const b = index.getX(i + 1);
            const c = index.getX(i + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics

              intersects.push(intersection);
            }
          }
        }
      } else if (position !== undefined) {
        // non-indexed buffer geometry
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

            for (let j = start, jl = end; j < jl; j += 3) {
              const a = j;
              const b = j + 1;
              const c = j + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics

                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);

          for (let i = start, il = end; i < il; i += 3) {
            const a = i;
            const b = i + 1;
            const c = i + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics

              intersects.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
  }

}

exports.Mesh = Mesh;
Mesh.prototype.isMesh = true;

function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;

  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }

  if (intersect === null) return null;

  _intersectionPointWorld.copy(point);

  _intersectionPointWorld.applyMatrix4(object.matrixWorld);

  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance: distance,
    point: _intersectionPointWorld.clone(),
    object: object
  };
}

function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
  _vA$1.fromBufferAttribute(position, a);

  _vB$1.fromBufferAttribute(position, b);

  _vC$1.fromBufferAttribute(position, c);

  const morphInfluences = object.morphTargetInfluences;

  if (material.morphTargets && morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);

    _morphB.set(0, 0, 0);

    _morphC.set(0, 0, 0);

    for (let i = 0, il = morphPosition.length; i < il; i++) {
      const influence = morphInfluences[i];
      const morphAttribute = morphPosition[i];
      if (influence === 0) continue;

      _tempA.fromBufferAttribute(morphAttribute, a);

      _tempB.fromBufferAttribute(morphAttribute, b);

      _tempC.fromBufferAttribute(morphAttribute, c);

      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);

        _morphB.addScaledVector(_tempB, influence);

        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);

        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);

        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }

    _vA$1.add(_morphA);

    _vB$1.add(_morphB);

    _vC$1.add(_morphC);
  }

  if (object.isSkinnedMesh) {
    object.boneTransform(a, _vA$1);
    object.boneTransform(b, _vB$1);
    object.boneTransform(c, _vC$1);
  }

  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);

  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a);

      _uvB$1.fromBufferAttribute(uv, b);

      _uvC$1.fromBufferAttribute(uv, c);

      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }

    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a);

      _uvB$1.fromBufferAttribute(uv2, b);

      _uvC$1.fromBufferAttribute(uv2, c);

      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }

    const face = {
      a: a,
      b: b,
      c: c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }

  return intersection;
}

class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = 'BoxGeometry';
    this.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };
    const scope = this; // segments

    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let numberOfVertices = 0;
    let groupStart = 0; // build each side of the box geometry

    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
      const segmentWidth = width / gridX;
      const segmentHeight = height / gridY;
      const widthHalf = width / 2;
      const heightHalf = height / 2;
      const depthHalf = depth / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3(); // generate vertices, normals and uvs

      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;

        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf; // set values to correct vector component

          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf; // now apply vector to vertex buffer

          vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

          normals.push(vector.x, vector.y, vector.z); // uvs

          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY); // counters

          vertexCounter += 1;
        }
      } // indices
      // 1. you need three indices to draw a single face
      // 2. a single segment consists of two faces
      // 3. so we need to generate six (2*3) indices per segment


      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

          indices.push(a, b, d);
          indices.push(b, c, d); // increase counter

          groupCount += 6;
        }
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

      groupStart += groupCount; // update total number of vertices

      numberOfVertices += vertexCounter;
    }
  }

}
/**
 * Uniform Utilities
 */


exports.BoxGeometry = exports.BoxBufferGeometry = BoxGeometry;

function cloneUniforms(src) {
  const dst = {};

  for (const u in src) {
    dst[u] = {};

    for (const p in src[u]) {
      const property = src[u][p];

      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }

  return dst;
}

function mergeUniforms(uniforms) {
  const merged = {};

  for (let u = 0; u < uniforms.length; u++) {
    const tmp = cloneUniforms(uniforms[u]);

    for (const p in tmp) {
      merged[p] = tmp[p];
    }
  }

  return merged;
} // Legacy


const UniformsUtils = {
  clone: cloneUniforms,
  merge: mergeUniforms
};
exports.UniformsUtils = UniformsUtils;
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

class ShaderMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'ShaderMaterial';
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false; // set to use scene fog

    this.lights = false; // set to use scene lights

    this.clipping = false; // set to use user-defined clipping planes

    this.morphTargets = false; // set to use morph targets

    this.morphNormals = false; // set to use morph normals

    this.extensions = {
      derivatives: false,
      // set to use derivatives
      fragDepth: false,
      // set to use fragment depth values
      drawBuffers: false,
      // set to use draw buffers
      shaderTextureLOD: false // set to use shader texture LOD

    }; // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.

    this.defaultAttributeValues = {
      'color': [1, 1, 1],
      'uv': [0, 0],
      'uv2': [0, 0]
    };
    this.index0AttributeName = undefined;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;

    if (parameters !== undefined) {
      if (parameters.attributes !== undefined) {
        console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
      }

      this.setValues(parameters);
    }
  }

  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }

  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};

    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;

      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: 't',
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: 'c',
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: 'v2',
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: 'v3',
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: 'v4',
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: 'm3',
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: 'm4',
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value: value
        }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
      }
    }

    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {};

    for (const key in this.extensions) {
      if (this.extensions[key] === true) extensions[key] = true;
    }

    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
  }

}

exports.ShaderMaterial = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;

class Camera extends Object3D {
  constructor() {
    super();
    this.type = 'Camera';
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }

  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  }

  getWorldDirection(target) {
    if (target === undefined) {
      console.warn('THREE.Camera: .getWorldDirection() target is now required');
      target = new Vector3();
    }

    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  }

  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }

  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }

  clone() {
    return new this.constructor().copy(this);
  }

}

exports.Camera = Camera;
Camera.prototype.isCamera = true;

class PerspectiveCamera extends Camera {
  constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
    super();
    this.type = 'PerspectiveCamera';
    this.fov = fov;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect;
    this.view = null;
    this.filmGauge = 35; // width of the film (default in millimeters)

    this.filmOffset = 0; // horizontal film offset (same unit as gauge)

    this.updateProjectionMatrix();
  }

  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */


  setFocalLength(focalLength) {
    /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */


  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }

  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
  }

  getFilmWidth() {
    // film not completely covered in portrait format (aspect < 1)
    return this.filmGauge * Math.min(this.aspect, 1);
  }

  getFilmHeight() {
    // film not completely covered in landscape format (aspect > 1)
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */


  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;

    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }

  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }

    this.updateProjectionMatrix();
  }

  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;

    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth,
            fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }

    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }

  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }

}

exports.PerspectiveCamera = PerspectiveCamera;
PerspectiveCamera.prototype.isPerspectiveCamera = true;
const fov = 90,
      aspect = 1;

class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = 'CubeCamera';

    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
      return;
    }

    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }

  update(renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  }

}

exports.CubeCamera = CubeCamera;

class CubeTexture extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
    format = format !== undefined ? format : RGBFormat;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding); // Why CubeTexture._needsFlipEnvMap is necessary:
    //
    // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
    // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
    // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
    // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
    // and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
    // when using WebGLCubeRenderTarget.texture as a cube texture.

    this._needsFlipEnvMap = true;
    this.flipY = false;
  }

  get images() {
    return this.image;
  }

  set images(value) {
    this.image = value;
  }

}

exports.CubeTexture = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;

class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size, options, dummy) {
    if (Number.isInteger(options)) {
      console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
      options = dummy;
    }

    super(size, size, options);
    options = options || {};
    this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    this.texture._needsFlipEnvMap = false;
  }

  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat; // see #18859

    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader:
      /* glsl */
      `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader:
      /* glsl */
      `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: 'CubemapFromEquirect',
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter; // Avoid blurred poles

    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }

  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();

    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color, depth, stencil);
    }

    renderer.setRenderTarget(currentRenderTarget);
  }

}

exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

const _sphere$2 = /*@__PURE__*/new Sphere();

const _vector$7 = /*@__PURE__*/new Vector3();

class Frustum {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }

  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }

  copy(frustum) {
    const planes = this.planes;

    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }

    return this;
  }

  setFromProjectionMatrix(m) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0],
          me1 = me[1],
          me2 = me[2],
          me3 = me[3];
    const me4 = me[4],
          me5 = me[5],
          me6 = me[6],
          me7 = me[7];
    const me8 = me[8],
          me9 = me[9],
          me10 = me[10],
          me11 = me[11];
    const me12 = me[12],
          me13 = me[13],
          me14 = me[14],
          me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }

  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

    return this.intersectsSphere(_sphere$2);
  }

  intersectsSprite(sprite) {
    _sphere$2.center.set(0, 0, 0);

    _sphere$2.radius = 0.7071067811865476;

    _sphere$2.applyMatrix4(sprite.matrixWorld);

    return this.intersectsSphere(_sphere$2);
  }

  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;

    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);

      if (distance < negRadius) {
        return false;
      }
    }

    return true;
  }

  intersectsBox(box) {
    const planes = this.planes;

    for (let i = 0; i < 6; i++) {
      const plane = planes[i]; // corner at max distance

      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }

    return true;
  }

  containsPoint(point) {
    const planes = this.planes;

    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }

    return true;
  }

  clone() {
    return new this.constructor().copy(this);
  }

}

exports.Frustum = Frustum;

function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;

  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }

  return {
    start: function () {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function () {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function (callback) {
      animationLoop = callback;
    },
    setContext: function (value) {
      context = value;
    }
  };
}

function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();

  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;

    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    } else if (array instanceof Uint8ClampedArray) {
      type = 5121;
    }

    return {
      buffer: buffer,
      type: type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }

  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);

    if (updateRange.count === -1) {
      // Not using update ranges
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }

      updateRange.count = -1; // reset range
    }
  } //


  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }

  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);

    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }

  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);

      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }

      return;
    }

    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);

    if (data === undefined) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }

  return {
    get: get,
    remove: remove,
    update: update
  };
}

class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = 'PlaneGeometry';
    this.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY; //

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];

    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;

      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }

    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

}

exports.PlaneGeometry = exports.PlaneBufferGeometry = PlaneGeometry;
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );\n\tvec3 f90 = vec3( 1.0 );\n\tvec3 f_transmission = totalTransmission * getIBLVolumeRefraction(\n\t\tnormal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance);\n\tdiffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\tfloat NdotV = saturate(dot(n, viewDir));\n\t\tvec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);\n\t\tvec3 specularColor = f0 * brdf.x + f90 * brdf.y;\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef USE_TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t\tfloat thicknessFactor = thickness;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\tvec3 rawDiffuseColor = diffuseColor.rgb;\n\t#include <transmission_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
const ShaderChunk = {
  alphamap_fragment: alphamap_fragment,
  alphamap_pars_fragment: alphamap_pars_fragment,
  alphatest_fragment: alphatest_fragment,
  aomap_fragment: aomap_fragment,
  aomap_pars_fragment: aomap_pars_fragment,
  begin_vertex: begin_vertex,
  beginnormal_vertex: beginnormal_vertex,
  bsdfs: bsdfs,
  bumpmap_pars_fragment: bumpmap_pars_fragment,
  clipping_planes_fragment: clipping_planes_fragment,
  clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  clipping_planes_vertex: clipping_planes_vertex,
  color_fragment: color_fragment,
  color_pars_fragment: color_pars_fragment,
  color_pars_vertex: color_pars_vertex,
  color_vertex: color_vertex,
  common: common,
  cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  defaultnormal_vertex: defaultnormal_vertex,
  displacementmap_pars_vertex: displacementmap_pars_vertex,
  displacementmap_vertex: displacementmap_vertex,
  emissivemap_fragment: emissivemap_fragment,
  emissivemap_pars_fragment: emissivemap_pars_fragment,
  encodings_fragment: encodings_fragment,
  encodings_pars_fragment: encodings_pars_fragment,
  envmap_fragment: envmap_fragment,
  envmap_common_pars_fragment: envmap_common_pars_fragment,
  envmap_pars_fragment: envmap_pars_fragment,
  envmap_pars_vertex: envmap_pars_vertex,
  envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  envmap_vertex: envmap_vertex,
  fog_vertex: fog_vertex,
  fog_pars_vertex: fog_pars_vertex,
  fog_fragment: fog_fragment,
  fog_pars_fragment: fog_pars_fragment,
  gradientmap_pars_fragment: gradientmap_pars_fragment,
  lightmap_fragment: lightmap_fragment,
  lightmap_pars_fragment: lightmap_pars_fragment,
  lights_lambert_vertex: lights_lambert_vertex,
  lights_pars_begin: lights_pars_begin,
  lights_toon_fragment: lights_toon_fragment,
  lights_toon_pars_fragment: lights_toon_pars_fragment,
  lights_phong_fragment: lights_phong_fragment,
  lights_phong_pars_fragment: lights_phong_pars_fragment,
  lights_physical_fragment: lights_physical_fragment,
  lights_physical_pars_fragment: lights_physical_pars_fragment,
  lights_fragment_begin: lights_fragment_begin,
  lights_fragment_maps: lights_fragment_maps,
  lights_fragment_end: lights_fragment_end,
  logdepthbuf_fragment: logdepthbuf_fragment,
  logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  logdepthbuf_vertex: logdepthbuf_vertex,
  map_fragment: map_fragment,
  map_pars_fragment: map_pars_fragment,
  map_particle_fragment: map_particle_fragment,
  map_particle_pars_fragment: map_particle_pars_fragment,
  metalnessmap_fragment: metalnessmap_fragment,
  metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  morphnormal_vertex: morphnormal_vertex,
  morphtarget_pars_vertex: morphtarget_pars_vertex,
  morphtarget_vertex: morphtarget_vertex,
  normal_fragment_begin: normal_fragment_begin,
  normal_fragment_maps: normal_fragment_maps,
  normalmap_pars_fragment: normalmap_pars_fragment,
  clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment: clearcoat_pars_fragment,
  packing: packing,
  premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  project_vertex: project_vertex,
  dithering_fragment: dithering_fragment,
  dithering_pars_fragment: dithering_pars_fragment,
  roughnessmap_fragment: roughnessmap_fragment,
  roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  shadowmap_pars_fragment: shadowmap_pars_fragment,
  shadowmap_pars_vertex: shadowmap_pars_vertex,
  shadowmap_vertex: shadowmap_vertex,
  shadowmask_pars_fragment: shadowmask_pars_fragment,
  skinbase_vertex: skinbase_vertex,
  skinning_pars_vertex: skinning_pars_vertex,
  skinning_vertex: skinning_vertex,
  skinnormal_vertex: skinnormal_vertex,
  specularmap_fragment: specularmap_fragment,
  specularmap_pars_fragment: specularmap_pars_fragment,
  tonemapping_fragment: tonemapping_fragment,
  tonemapping_pars_fragment: tonemapping_pars_fragment,
  transmission_fragment: transmission_fragment,
  transmission_pars_fragment: transmission_pars_fragment,
  uv_pars_fragment: uv_pars_fragment,
  uv_pars_vertex: uv_pars_vertex,
  uv_vertex: uv_vertex,
  uv2_pars_fragment: uv2_pars_fragment,
  uv2_pars_vertex: uv2_pars_vertex,
  uv2_vertex: uv2_vertex,
  worldpos_vertex: worldpos_vertex,
  background_frag: background_frag,
  background_vert: background_vert,
  cube_frag: cube_frag,
  cube_vert: cube_vert,
  depth_frag: depth_frag,
  depth_vert: depth_vert,
  distanceRGBA_frag: distanceRGBA_frag,
  distanceRGBA_vert: distanceRGBA_vert,
  equirect_frag: equirect_frag,
  equirect_vert: equirect_vert,
  linedashed_frag: linedashed_frag,
  linedashed_vert: linedashed_vert,
  meshbasic_frag: meshbasic_frag,
  meshbasic_vert: meshbasic_vert,
  meshlambert_frag: meshlambert_frag,
  meshlambert_vert: meshlambert_vert,
  meshmatcap_frag: meshmatcap_frag,
  meshmatcap_vert: meshmatcap_vert,
  meshtoon_frag: meshtoon_frag,
  meshtoon_vert: meshtoon_vert,
  meshphong_frag: meshphong_frag,
  meshphong_vert: meshphong_vert,
  meshphysical_frag: meshphysical_frag,
  meshphysical_vert: meshphysical_vert,
  normal_frag: normal_frag,
  normal_vert: normal_vert,
  points_frag: points_frag,
  points_vert: points_vert,
  shadow_frag: shadow_frag,
  shadow_vert: shadow_vert,
  sprite_frag: sprite_frag,
  sprite_vert: sprite_vert
};
/**
 * Uniforms library for shared webgl shaders
 */

exports.ShaderChunk = ShaderChunk;
const UniformsLib = {
  common: {
    diffuse: {
      value: new Color(0xffffff)
    },
    opacity: {
      value: 1.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    },
    uv2Transform: {
      value: new Matrix3()
    },
    alphaMap: {
      value: null
    }
  },
  specularmap: {
    specularMap: {
      value: null
    }
  },
  envmap: {
    envMap: {
      value: null
    },
    flipEnvMap: {
      value: -1
    },
    reflectivity: {
      value: 1.0
    },
    refractionRatio: {
      value: 0.98
    },
    maxMipLevel: {
      value: 0
    }
  },
  aomap: {
    aoMap: {
      value: null
    },
    aoMapIntensity: {
      value: 1
    }
  },
  lightmap: {
    lightMap: {
      value: null
    },
    lightMapIntensity: {
      value: 1
    }
  },
  emissivemap: {
    emissiveMap: {
      value: null
    }
  },
  bumpmap: {
    bumpMap: {
      value: null
    },
    bumpScale: {
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      value: null
    },
    normalScale: {
      value: new Vector2(1, 1)
    }
  },
  displacementmap: {
    displacementMap: {
      value: null
    },
    displacementScale: {
      value: 1
    },
    displacementBias: {
      value: 0
    }
  },
  roughnessmap: {
    roughnessMap: {
      value: null
    }
  },
  metalnessmap: {
    metalnessMap: {
      value: null
    }
  },
  gradientmap: {
    gradientMap: {
      value: null
    }
  },
  fog: {
    fogDensity: {
      value: 0.00025
    },
    fogNear: {
      value: 1
    },
    fogFar: {
      value: 2000
    },
    fogColor: {
      value: new Color(0xffffff)
    }
  },
  lights: {
    ambientLightColor: {
      value: []
    },
    lightProbe: {
      value: []
    },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {}
      }
    },
    directionalLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    directionalShadowMap: {
      value: []
    },
    directionalShadowMatrix: {
      value: []
    },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      }
    },
    spotLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    spotShadowMap: {
      value: []
    },
    spotShadowMatrix: {
      value: []
    },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      }
    },
    pointLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      }
    },
    pointShadowMap: {
      value: []
    },
    pointShadowMatrix: {
      value: []
    },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      }
    },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      }
    },
    ltc_1: {
      value: null
    },
    ltc_2: {
      value: null
    }
  },
  points: {
    diffuse: {
      value: new Color(0xffffff)
    },
    opacity: {
      value: 1.0
    },
    size: {
      value: 1.0
    },
    scale: {
      value: 1.0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    }
  },
  sprite: {
    diffuse: {
      value: new Color(0xffffff)
    },
    opacity: {
      value: 1.0
    },
    center: {
      value: new Vector2(0.5, 0.5)
    },
    rotation: {
      value: 0.0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    }
  }
};
exports.UniformsLib = UniformsLib;
const ShaderLib = {
  basic: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      specular: {
        value: new Color(0x111111)
      },
      shininess: {
        value: 30
      }
    }]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      roughness: {
        value: 1.0
      },
      metalness: {
        value: 0.0
      },
      envMapIntensity: {
        value: 1
      } // temporary

    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
      matcap: {
        value: null
      }
    }]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
      scale: {
        value: 1
      },
      dashSize: {
        value: 1
      },
      totalSize: {
        value: 2
      }
    }]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {
        value: new Matrix3()
      },
      t2D: {
        value: null
      }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },

  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: mergeUniforms([UniformsLib.envmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
      referencePosition: {
        value: new Vector3()
      },
      nearDistance: {
        value: 1
      },
      farDistance: {
        value: 1000
      }
    }]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
      color: {
        value: new Color(0x00000)
      },
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
exports.ShaderLib = ShaderLib;
ShaderLib.physical = {
  uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
    clearcoat: {
      value: 0
    },
    clearcoatMap: {
      value: null
    },
    clearcoatRoughness: {
      value: 0
    },
    clearcoatRoughnessMap: {
      value: null
    },
    clearcoatNormalScale: {
      value: new Vector2(1, 1)
    },
    clearcoatNormalMap: {
      value: null
    },
    sheen: {
      value: new Color(0x000000)
    },
    transmission: {
      value: 0
    },
    transmissionMap: {
      value: null
    },
    transmissionSamplerSize: {
      value: new Vector2()
    },
    transmissionSamplerMap: {
      value: null
    },
    thickness: {
      value: 0
    },
    thicknessMap: {
      value: null
    },
    attenuationDistance: {
      value: 0
    },
    attenuationColor: {
      value: new Color(0x000000)
    }
  }]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};

function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0x000000);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;

  function render(renderList, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;

    if (background && background.isTexture) {
      background = cubemaps.get(background);
    } // Ignore background in AR
    // TODO: Reconsider this.


    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();

    if (session && session.environmentBlendMode === 'additive') {
      background = null;
    }

    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }

    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }

    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === undefined) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: 'BackgroundCubeMaterial',
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute('normal');
        boxMesh.geometry.deleteAttribute('uv');

        boxMesh.onBeforeRender = function (renderer, scene, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        }; // enable code injection for non-built-in material


        Object.defineProperty(boxMesh.material, 'envMap', {
          get: function () {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }

      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;

      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      } // push to the pre-sorted opaque render list


      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === undefined) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: 'BackgroundMaterial',
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material

        Object.defineProperty(planeMesh.material, 'map', {
          get: function () {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }

      planeMesh.material.uniforms.t2D.value = background;

      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }

      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      } // push to the pre-sorted opaque render list


      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }

  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }

  return {
    getClearColor: function () {
      return clearColor;
    },
    setClearColor: function (color, alpha = 1) {
      clearColor.set(color);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function () {
      return clearAlpha;
    },
    setClearAlpha: function (alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render
  };
}

function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;

  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;

    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);

      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }

      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers) saveCache(geometry, index);
    } else {
      const wireframe = material.wireframe === true;

      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }

    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }

    if (index !== null) {
      attributes.update(index, 34963);
    }

    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);

      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }

  function createVertexArrayObject() {
    if (capabilities.isWebGL2) return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }

  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }

  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }

  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];

    if (programMap === undefined) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }

    let stateMap = programMap[program.id];

    if (stateMap === undefined) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }

    let state = stateMap[wireframe];

    if (state === undefined) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }

    return state;
  }

  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];

    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }

    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes: newAttributes,
      enabledAttributes: enabledAttributes,
      attributeDivisors: attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }

  function needsUpdate(geometry, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;

    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === undefined) return true;
      if (cachedAttribute.attribute !== geometryAttribute) return true;
      if (cachedAttribute.data !== geometryAttribute.data) return true;
      attributesNum++;
    }

    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index) return true;
    return false;
  }

  function saveCache(geometry, index) {
    const cache = {};
    const attributes = geometry.attributes;
    let attributesNum = 0;

    for (const key in attributes) {
      const attribute = attributes[key];
      const data = {};
      data.attribute = attribute;

      if (attribute.data) {
        data.data = attribute.data;
      }

      cache[key] = data;
      attributesNum++;
    }

    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }

  function initAttributes() {
    const newAttributes = currentState.newAttributes;

    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }

  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }

  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;

    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }

    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
      extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }

  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;

    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }

  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }

  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get('ANGLE_instanced_arrays') === null) return;
    }

    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;

    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];

      if (programAttribute >= 0) {
        const geometryAttribute = geometryAttributes[name];

        if (geometryAttribute !== undefined) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;

          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;

            if (data && data.isInstancedInterleavedBuffer) {
              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

              if (geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              enableAttribute(programAttribute);
            }

            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

              if (geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              enableAttribute(programAttribute);
            }

            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (name === 'instanceMatrix') {
          const attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute + 0, 1);
          enableAttributeAndDivisor(programAttribute + 1, 1);
          enableAttributeAndDivisor(programAttribute + 2, 1);
          enableAttributeAndDivisor(programAttribute + 3, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
        } else if (name === 'instanceColor') {
          const attribute = attributes.get(object.instanceColor); // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
        } else if (materialDefaultAttributeValues !== undefined) {
          const value = materialDefaultAttributeValues[name];

          if (value !== undefined) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute, value);
                break;

              case 3:
                gl.vertexAttrib3fv(programAttribute, value);
                break;

              case 4:
                gl.vertexAttrib4fv(programAttribute, value);
                break;

              default:
                gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }

    disableUnusedAttributes();
  }

  function dispose() {
    reset();

    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];

      for (const programId in programMap) {
        const stateMap = programMap[programId];

        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }

        delete programMap[programId];
      }

      delete bindingStates[geometryId];
    }
  }

  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === undefined) return;
    const programMap = bindingStates[geometry.id];

    for (const programId in programMap) {
      const stateMap = programMap[programId];

      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }

      delete programMap[programId];
    }

    delete bindingStates[geometry.id];
  }

  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === undefined) continue;
      const stateMap = programMap[program.id];

      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }

      delete programMap[program.id];
    }
  }

  function reset() {
    resetDefaultState();
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  } // for backward-compatilibity


  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }

  return {
    setup: setup,
    reset: reset,
    resetDefaultState: resetDefaultState,
    dispose: dispose,
    releaseStatesOfGeometry: releaseStatesOfGeometry,
    releaseStatesOfProgram: releaseStatesOfProgram,
    initAttributes: initAttributes,
    enableAttribute: enableAttribute,
    disableUnusedAttributes: disableUnusedAttributes
  };
}

function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;

  function setMode(value) {
    mode = value;
  }

  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }

  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;

    if (isWebGL2) {
      extension = gl;
      methodName = 'drawArraysInstanced';
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');
      methodName = 'drawArraysInstancedANGLE';

      if (extension === null) {
        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  } //


  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}

function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;

  function getMaxAnisotropy() {
    if (maxAnisotropy !== undefined) return maxAnisotropy;

    if (extensions.has('EXT_texture_filter_anisotropic') === true) {
      const extension = extensions.get('EXT_texture_filter_anisotropic');
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }

    return maxAnisotropy;
  }

  function getMaxPrecision(precision) {
    if (precision === 'highp') {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return 'highp';
      }

      precision = 'mediump';
    }

    if (precision === 'mediump') {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return 'mediump';
      }
    }

    return 'lowp';
  }
  /* eslint-disable no-undef */


  const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
  /* eslint-enable no-undef */

  let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  const maxPrecision = getMaxPrecision(precision);

  if (maxPrecision !== precision) {
    console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
    precision = maxPrecision;
  }

  const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2: isWebGL2,
    drawBuffers: drawBuffers,
    getMaxAnisotropy: getMaxAnisotropy,
    getMaxPrecision: getMaxPrecision,
    precision: precision,
    logarithmicDepthBuffer: logarithmicDepthBuffer,
    maxTextures: maxTextures,
    maxVertexTextures: maxVertexTextures,
    maxTextureSize: maxTextureSize,
    maxCubemapSize: maxCubemapSize,
    maxAttributes: maxAttributes,
    maxVertexUniforms: maxVertexUniforms,
    maxVaryings: maxVaryings,
    maxFragmentUniforms: maxFragmentUniforms,
    vertexTextures: vertexTextures,
    floatFragmentTextures: floatFragmentTextures,
    floatVertexTextures: floatVertexTextures,
    maxSamples: maxSamples
  };
}

function WebGLClipping(properties) {
  const scope = this;
  let globalState = null,
      numGlobalPlanes = 0,
      localClippingEnabled = false,
      renderingShadows = false;
  const plane = new Plane(),
        viewNormalMatrix = new Matrix3(),
        uniform = {
    value: null,
    needsUpdate: false
  };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;

  this.init = function (planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };

  this.beginShadows = function () {
    renderingShadows = true;
    projectPlanes(null);
  };

  this.endShadows = function () {
    renderingShadows = false;
    resetGlobalState();
  };

  this.setState = function (material, camera, useCache) {
    const planes = material.clippingPlanes,
          clipIntersection = material.clipIntersection,
          clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);

    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      // there's no local clipping
      if (renderingShadows) {
        // there's no global clipping
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
            lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray; // ensure unique state

      dstArray = projectPlanes(planes, camera, lGlobal, useCache);

      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }

      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };

  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }

    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }

  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;

    if (nPlanes !== 0) {
      dstArray = uniform.value;

      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4,
              viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);

        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }

        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }

      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }

    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}

function WebGLCubeMaps(renderer) {
  let cubemaps = new WeakMap();

  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }

    return texture;
  }

  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;

      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;

          if (image && image.height > 0) {
            const currentRenderTarget = renderer.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            texture.addEventListener('dispose', onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            // image not yet ready. try the conversion next frame
            return null;
          }
        }
      }
    }

    return texture;
  }

  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    const cubemap = cubemaps.get(texture);

    if (cubemap !== undefined) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }

  function dispose() {
    cubemaps = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}

function WebGLExtensions(gl) {
  const extensions = {};

  function getExtension(name) {
    if (extensions[name] !== undefined) {
      return extensions[name];
    }

    let extension;

    switch (name) {
      case 'WEBGL_depth_texture':
        extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
        break;

      case 'EXT_texture_filter_anisotropic':
        extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        break;

      case 'WEBGL_compressed_texture_s3tc':
        extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
        break;

      case 'WEBGL_compressed_texture_pvrtc':
        extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
        break;

      default:
        extension = gl.getExtension(name);
    }

    extensions[name] = extension;
    return extension;
  }

  return {
    has: function (name) {
      return getExtension(name) !== null;
    },
    init: function (capabilities) {
      if (capabilities.isWebGL2) {
        getExtension('EXT_color_buffer_float');
      } else {
        getExtension('WEBGL_depth_texture');
        getExtension('OES_texture_float');
        getExtension('OES_texture_half_float');
        getExtension('OES_texture_half_float_linear');
        getExtension('OES_standard_derivatives');
        getExtension('OES_element_index_uint');
        getExtension('OES_vertex_array_object');
        getExtension('ANGLE_instanced_arrays');
      }

      getExtension('OES_texture_float_linear');
      getExtension('EXT_color_buffer_half_float');
    },
    get: function (name) {
      const extension = getExtension(name);

      if (extension === null) {
        console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
      }

      return extension;
    }
  };
}

function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = new WeakMap();

  function onGeometryDispose(event) {
    const geometry = event.target;

    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }

    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }

    geometry.removeEventListener('dispose', onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);

    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }

    bindingStates.releaseStatesOfGeometry(geometry);

    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    } //


    info.memory.geometries--;
  }

  function get(object, geometry) {
    if (geometries[geometry.id] === true) return geometry;
    geometry.addEventListener('dispose', onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }

  function update(geometry) {
    const geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.

    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    } // morph targets


    const morphAttributes = geometry.morphAttributes;

    for (const name in morphAttributes) {
      const array = morphAttributes[name];

      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], 34962);
      }
    }
  }

  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;

    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;

      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;

      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    }

    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
    //

    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute); //

    wireframeAttributes.set(geometry, attribute);
  }

  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);

    if (currentAttribute) {
      const geometryIndex = geometry.index;

      if (geometryIndex !== null) {
        // if the attribute is obsolete, create a new one
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }

    return wireframeAttributes.get(geometry);
  }

  return {
    get: get,
    update: update,
    getWireframeAttribute: getWireframeAttribute
  };
}

function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;

  function setMode(value) {
    mode = value;
  }

  let type, bytesPerElement;

  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }

  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }

  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;

    if (isWebGL2) {
      extension = gl;
      methodName = 'drawElementsInstanced';
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');
      methodName = 'drawElementsInstancedANGLE';

      if (extension === null) {
        console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  } //


  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}

function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };

  function update(count, mode, instanceCount) {
    render.calls++;

    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;

      case 1:
        render.lines += instanceCount * (count / 2);
        break;

      case 3:
        render.lines += instanceCount * (count - 1);
        break;

      case 2:
        render.lines += instanceCount * count;
        break;

      case 0:
        render.points += instanceCount * count;
        break;

      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
        break;
    }
  }

  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }

  return {
    memory: memory,
    render: render,
    programs: null,
    autoReset: true,
    reset: reset,
    update: update
  };
}

function numericalSort(a, b) {
  return a[0] - b[0];
}

function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}

function WebGLMorphtargets(gl) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const workInfluences = [];

  for (let i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }

  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array
    // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

    const length = objectInfluences === undefined ? 0 : objectInfluences.length;
    let influences = influencesList[geometry.id];

    if (influences === undefined) {
      // initialise list
      influences = [];

      for (let i = 0; i < length; i++) {
        influences[i] = [i, 0];
      }

      influencesList[geometry.id] = influences;
    } // Collect influences


    for (let i = 0; i < length; i++) {
      const influence = influences[i];
      influence[0] = i;
      influence[1] = objectInfluences[i];
    }

    influences.sort(absNumericalSort);

    for (let i = 0; i < 8; i++) {
      if (i < length && influences[i][1]) {
        workInfluences[i][0] = influences[i][0];
        workInfluences[i][1] = influences[i][1];
      } else {
        workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[i][1] = 0;
      }
    }

    workInfluences.sort(numericalSort);
    const morphTargets = material.morphTargets && geometry.morphAttributes.position;
    const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    let morphInfluencesSum = 0;

    for (let i = 0; i < 8; i++) {
      const influence = workInfluences[i];
      const index = influence[0];
      const value = influence[1];

      if (index !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
          geometry.setAttribute('morphTarget' + i, morphTargets[index]);
        }

        if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {
          geometry.setAttribute('morphNormal' + i, morphNormals[index]);
        }

        morphInfluences[i] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {
          geometry.deleteAttribute('morphTarget' + i);
        }

        if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {
          geometry.deleteAttribute('morphNormal' + i);
        }

        morphInfluences[i] = 0;
      }
    } // GLSL shader uses formula baseinfluence * base + sum(target * influence)
    // This allows us to switch between absolute morphs and relative morphs without changing shader code
    // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
    program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
  }

  return {
    update: update
  };
}

function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = new WeakMap();

  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry); // Update once per frame

    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }

    if (object.isInstancedMesh) {
      if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
        object.addEventListener('dispose', onInstancedMeshDispose);
      }

      attributes.update(object.instanceMatrix, 34962);

      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }

    return buffergeometry;
  }

  function dispose() {
    updateMap = new WeakMap();
  }

  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
  }

  return {
    update: update,
    dispose: dispose
  };
}

class DataTexture2DArray extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {
      data,
      width,
      height,
      depth
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }

}

exports.DataTexture2DArray = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;

class DataTexture3D extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    // We're going to add .setXXX() methods for setting properties later.
    // Users can still set in DataTexture3D directly.
    //
    //	const texture = new THREE.DataTexture3D( data, width, height, depth );
    // 	texture.anisotropy = 16;
    //
    // See #14839
    super(null);
    this.image = {
      data,
      width,
      height,
      depth
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }

}

exports.DataTexture3D = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;
/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture(); // --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983

  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];

  if (r === undefined) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }

  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);

    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }

  return r;
}

function arraysEqual(a, b) {
  if (a.length !== b.length) return false;

  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false;
  }

  return true;
}

function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
} // Texture unit allocation


function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];

  if (r === undefined) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }

  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }

  return r;
} // --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar


function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
} // Single float vector (from flat array or THREE.VectorN)


function setValueV2f(gl, v) {
  const cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValueV3f(gl, v) {
  const cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== undefined) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValueV4f(gl, v) {
  const cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
} // Single matrix (from flat array or THREE.MatrixN)


function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}

function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}

function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
} // Single integer / boolean


function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
} // Single integer / boolean vector (from flat array)


function setValueV2i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}

function setValueV3i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}

function setValueV4i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
} // Single unsigned integer


function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
} // Single unsigned integer vector (from flat array)


function setValueV2ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform2uiv(this.addr, v);
  copyArray(cache, v);
}

function setValueV3ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform3uiv(this.addr, v);
  copyArray(cache, v);
}

function setValueV4ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform4uiv(this.addr, v);
  copyArray(cache, v);
} // Single texture (2D / Cube)


function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.safeSetTexture2D(v || emptyTexture, unit);
}

function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.setTexture3D(v || emptyTexture3d, unit);
}

function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}

function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.setTexture2DArray(v || emptyTexture2dArray, unit);
} // Helper to pick the right setter for the singular case


function getSingularSetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1f;
    // FLOAT

    case 0x8b50:
      return setValueV2f;
    // _VEC2

    case 0x8b51:
      return setValueV3f;
    // _VEC3

    case 0x8b52:
      return setValueV4f;
    // _VEC4

    case 0x8b5a:
      return setValueM2;
    // _MAT2

    case 0x8b5b:
      return setValueM3;
    // _MAT3

    case 0x8b5c:
      return setValueM4;
    // _MAT4

    case 0x1404:
    case 0x8b56:
      return setValueV1i;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValueV2i;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValueV3i;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValueV4i;
    // _VEC4

    case 0x1405:
      return setValueV1ui;
    // UINT

    case 0x8dc6:
      return setValueV2ui;
    // _VEC2

    case 0x8dc7:
      return setValueV3ui;
    // _VEC3

    case 0x8dc8:
      return setValueV4ui;
    // _VEC4

    case 0x8b5e: // SAMPLER_2D

    case 0x8d66: // SAMPLER_EXTERNAL_OES

    case 0x8dca: // INT_SAMPLER_2D

    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

    case 0x8b62:
      // SAMPLER_2D_SHADOW
      return setValueT1;

    case 0x8b5f: // SAMPLER_3D

    case 0x8dcb: // INT_SAMPLER_3D

    case 0x8dd3:
      // UNSIGNED_INT_SAMPLER_3D
      return setValueT3D1;

    case 0x8b60: // SAMPLER_CUBE

    case 0x8dcc: // INT_SAMPLER_CUBE

    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

    case 0x8dc5:
      // SAMPLER_CUBE_SHADOW
      return setValueT6;

    case 0x8dc1: // SAMPLER_2D_ARRAY

    case 0x8dcf: // INT_SAMPLER_2D_ARRAY

    case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

    case 0x8dc4:
      // SAMPLER_2D_ARRAY_SHADOW
      return setValueT2DArray1;
  }
} // Array of scalars


function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
} // Array of vectors (from flat array or array of THREE.VectorN)


function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}

function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}

function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
} // Array of matrices (from flat array or array of THREE.MatrixN)


function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}

function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}

function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
} // Array of integer / boolean


function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
} // Array of integer / boolean vectors (from flat array)


function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}

function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}

function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
} // Array of unsigned integer


function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
} // Array of unsigned integer vectors (from flat array)


function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}

function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}

function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
} // Array of textures (2D / Cube)


function setValueT1Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);

  for (let i = 0; i !== n; ++i) {
    textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
  }
}

function setValueT6Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);

  for (let i = 0; i !== n; ++i) {
    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
} // Helper to pick the right setter for a pure (bottom-level) array


function getPureArraySetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1fArray;
    // FLOAT

    case 0x8b50:
      return setValueV2fArray;
    // _VEC2

    case 0x8b51:
      return setValueV3fArray;
    // _VEC3

    case 0x8b52:
      return setValueV4fArray;
    // _VEC4

    case 0x8b5a:
      return setValueM2Array;
    // _MAT2

    case 0x8b5b:
      return setValueM3Array;
    // _MAT3

    case 0x8b5c:
      return setValueM4Array;
    // _MAT4

    case 0x1404:
    case 0x8b56:
      return setValueV1iArray;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValueV2iArray;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValueV3iArray;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValueV4iArray;
    // _VEC4

    case 0x1405:
      return setValueV1uiArray;
    // UINT

    case 0x8dc6:
      return setValueV2uiArray;
    // _VEC2

    case 0x8dc7:
      return setValueV3uiArray;
    // _VEC3

    case 0x8dc8:
      return setValueV4uiArray;
    // _VEC4

    case 0x8b5e: // SAMPLER_2D

    case 0x8d66: // SAMPLER_EXTERNAL_OES

    case 0x8dca: // INT_SAMPLER_2D

    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

    case 0x8b62:
      // SAMPLER_2D_SHADOW
      return setValueT1Array;

    case 0x8b60: // SAMPLER_CUBE

    case 0x8dcc: // INT_SAMPLER_CUBE

    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

    case 0x8dc5:
      // SAMPLER_CUBE_SHADOW
      return setValueT6Array;
  }
} // --- Uniform Classes ---


function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

PureArrayUniform.prototype.updateCache = function (data) {
  const cache = this.cache;

  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }

  copyArray(cache, data);
};

function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}

StructuredUniform.prototype.setValue = function (gl, value, textures) {
  const seq = this.seq;

  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    u.setValue(gl, value[u.id], textures);
  }
}; // --- Top-level ---
// Parser - builds up the property tree from the path strings


const RePathPart = /(\w+)(\])?(\[|\.)?/g; // extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}

function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name,
        pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

  RePathPart.lastIndex = 0;

  while (true) {
    const match = RePathPart.exec(path),
          matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === ']',
          subscript = match[3];
    if (idIsIndex) id = id | 0; // convert to integer

    if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
      // bare name or "pure" bottom-level array "[0]" suffix
      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      // step into inner node / create it in case it doesn't exist
      const map = container.map;
      let next = map[id];

      if (next === undefined) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }

      container = next;
    }
  }
} // Root Container


function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n = gl.getProgramParameter(program, 35718);

  for (let i = 0; i < n; ++i) {
    const info = gl.getActiveUniform(program, i),
          addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}

WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
  const u = this.map[name];
  if (u !== undefined) u.setValue(gl, value, textures);
};

WebGLUniforms.prototype.setOptional = function (gl, object, name) {
  const v = object[name];
  if (v !== undefined) this.setValue(gl, name, v);
}; // Static interface


WebGLUniforms.upload = function (gl, seq, values, textures) {
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i],
          v = values[u.id];

    if (v.needsUpdate !== false) {
      // note: always updating when .needsUpdate is undefined
      u.setValue(gl, v.value, textures);
    }
  }
};

WebGLUniforms.seqWithValue = function (seq, values) {
  const r = [];

  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    if (u.id in values) r.push(u);
  }

  return r;
};

function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}

let programIdCount = 0;

function addLineNumbers(string) {
  const lines = string.split('\n');

  for (let i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ': ' + lines[i];
  }

  return lines.join('\n');
}

function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ['Linear', '( value )'];

    case sRGBEncoding:
      return ['sRGB', '( value )'];

    case RGBEEncoding:
      return ['RGBE', '( value )'];

    case RGBM7Encoding:
      return ['RGBM', '( value, 7.0 )'];

    case RGBM16Encoding:
      return ['RGBM', '( value, 16.0 )'];

    case RGBDEncoding:
      return ['RGBD', '( value, 256.0 )'];

    case GammaEncoding:
      return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

    case LogLuvEncoding:
      return ['LogLuv', '( value )'];

    default:
      console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
      return ['Linear', '( value )'];
  }
}

function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const log = gl.getShaderInfoLog(shader).trim();
  if (status && log === '') return ''; // --enable-privileged-webgl-extension
  // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  const source = gl.getShaderSource(shader);
  return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
}

function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}

function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}

function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;

  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = 'Linear';
      break;

    case ReinhardToneMapping:
      toneMappingName = 'Reinhard';
      break;

    case CineonToneMapping:
      toneMappingName = 'OptimizedCineon';
      break;

    case ACESFilmicToneMapping:
      toneMappingName = 'ACESFilmic';
      break;

    case CustomToneMapping:
      toneMappingName = 'Custom';
      break;

    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
      toneMappingName = 'Linear';
  }

  return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}

function generateExtensions(parameters) {
  const chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
  return chunks.filter(filterEmptyLine).join('\n');
}

function generateDefines(defines) {
  const chunks = [];

  for (const name in defines) {
    const value = defines[name];
    if (value === false) continue;
    chunks.push('#define ' + name + ' ' + value);
  }

  return chunks.join('\n');
}

function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, 35721);

  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

    attributes[name] = gl.getAttribLocation(program, name);
  }

  return attributes;
}

function filterEmptyLine(string) {
  return string !== '';
}

function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}

function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
} // Resolve Includes


const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}

function includeReplacer(match, include) {
  const string = ShaderChunk[include];

  if (string === undefined) {
    throw new Error('Can not resolve #include <' + include + '>');
  }

  return resolveIncludes(string);
} // Unroll Loops


const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}

function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
  return loopReplacer(match, start, end, snippet);
}

function loopReplacer(match, start, end, snippet) {
  let string = '';

  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
  }

  return string;
} //


function generatePrecision(parameters) {
  let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

  if (parameters.precision === 'highp') {
    precisionstring += '\n#define HIGH_PRECISION';
  } else if (parameters.precision === 'mediump') {
    precisionstring += '\n#define MEDIUM_PRECISION';
  } else if (parameters.precision === 'lowp') {
    precisionstring += '\n#define LOW_PRECISION';
  }

  return precisionstring;
}

function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
  }

  return shadowMapTypeDefine;
}

function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        break;

      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
        break;
    }
  }

  return envMapTypeDefine;
}

function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
        break;
    }
  }

  return envMapModeDefine;
}

function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        break;

      case MixOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
        break;

      case AddOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
        break;
    }
  }

  return envMapBlendingDefine;
}

function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
  const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

  if (parameters.isRawShaderMaterial) {
    prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

    if (prefixVertex.length > 0) {
      prefixVertex += '\n';
    }

    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

    if (prefixFragment.length > 0) {
      prefixFragment += '\n';
    }
  } else {
    prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
    prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer
    '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
    parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
    parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
  }

  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);

  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    // GLSL 3.0 conversion for built-in materials and ShaderMaterial
    versionString = '#version 300 es\n';
    prefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
    prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
  }

  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );

  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

  if (parameters.index0AttributeName !== undefined) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
  }

  gl.linkProgram(program); // check for link errors

  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;

    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
      console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== '') {
      console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
    } else if (vertexLog === '' || fragmentLog === '') {
      haveDiagnostics = false;
    }

    if (haveDiagnostics) {
      this.diagnostics = {
        runnable: runnable,
        programLog: programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  } // Clean up
  // Crashes in iOS9 and iOS10. #18402
  // gl.detachShader( program, glVertexShader );
  // gl.detachShader( program, glFragmentShader );


  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader); // set up caching for uniform locations

  let cachedUniforms;

  this.getUniforms = function () {
    if (cachedUniforms === undefined) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }

    return cachedUniforms;
  }; // set up caching for attribute locations


  let cachedAttributes;

  this.getAttributes = function () {
    if (cachedAttributes === undefined) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }

    return cachedAttributes;
  }; // free resource


  this.destroy = function () {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = undefined;
  }; //


  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}

function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  };
  const parameterNames = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'sheen', 'transmission', 'transmissionMap', 'thicknessMap'];

  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;

    if (floatVertexTextures) {
      return 1024;
    } else {
      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);

      if (maxBones < bones.length) {
        console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
        return 0;
      }

      return maxBones;
    }
  }

  function getTextureEncodingFromMap(map) {
    let encoding;

    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }

    return encoding;
  }

  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = cubemaps.get(material.envMap || environment);
    const shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;

    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);

      if (precision !== material.precision) {
        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
      }
    }

    let vertexShader, fragmentShader;

    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }

    const currentRenderTarget = renderer.getRenderTarget();
    const parameters = {
      isWebGL2: isWebGL2,
      shaderID: shaderID,
      shaderName: material.type,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision: precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material.clearcoatMap,
      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      transmission: !!material.transmission,
      transmissionMap: !!material.transmissionMap,
      thicknessMap: !!material.thicknessMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true && maxBones > 0,
      maxBones: maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }

  function getProgramCacheKey(parameters) {
    const array = [];

    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.fragmentShader);
      array.push(parameters.vertexShader);
    }

    if (parameters.defines !== undefined) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }

    if (parameters.isRawShaderMaterial === false) {
      for (let i = 0; i < parameterNames.length; i++) {
        array.push(parameters[parameterNames[i]]);
      }

      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }

    array.push(parameters.customProgramCacheKey);
    return array.join();
  }

  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;

    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }

    return uniforms;
  }

  function acquireProgram(parameters, cacheKey) {
    let program; // Check if code has been already compiled

    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];

      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }

    if (program === undefined) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }

    return program;
  }

  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      // Remove from unordered set
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop(); // Free WebGL resources

      program.destroy();
    }
  }

  return {
    getParameters: getParameters,
    getProgramCacheKey: getProgramCacheKey,
    getUniforms: getUniforms,
    acquireProgram: acquireProgram,
    releaseProgram: releaseProgram,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: programs
  };
}

function WebGLProperties() {
  let properties = new WeakMap();

  function get(object) {
    let map = properties.get(object);

    if (map === undefined) {
      map = {};
      properties.set(object, map);
    }

    return map;
  }

  function remove(object) {
    properties.delete(object);
  }

  function update(object, key, value) {
    properties.get(object)[key] = value;
  }

  function dispose() {
    properties = new WeakMap();
  }

  return {
    get: get,
    remove: remove,
    update: update,
    dispose: dispose
  };
}

function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}

function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}

function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  const defaultProgram = {
    id: -1
  };

  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }

  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);

    if (renderItem === undefined) {
      renderItem = {
        id: object.id,
        object: object,
        geometry: geometry,
        material: material,
        program: materialProperties.program || defaultProgram,
        groupOrder: groupOrder,
        renderOrder: object.renderOrder,
        z: z,
        group: group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }

    renderItemsIndex++;
    return renderItem;
  }

  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

    if (material.transmission > 0.0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }

  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

    if (material.transmission > 0.0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }

  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }

  function finish() {
    // Clear references from inactive renderItems in the list
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }

  return {
    opaque: opaque,
    transmissive: transmissive,
    transparent: transparent,
    init: init,
    push: push,
    unshift: unshift,
    finish: finish,
    sort: sort
  };
}

function WebGLRenderLists(properties) {
  let lists = new WeakMap();

  function get(scene, renderCallDepth) {
    let list;

    if (lists.has(scene) === false) {
      list = new WebGLRenderList(properties);
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList(properties);
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }

    return list;
  }

  function dispose() {
    lists = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}

function UniformsCache() {
  const lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      let uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;

        case 'SpotLight':
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;

        case 'PointLight':
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;

        case 'HemisphereLight':
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;

        case 'RectAreaLight':
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      let uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;

        case 'SpotLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;

        case 'PointLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1000
          };
          break;
        // TODO (abelnation): set RectAreaLight shadow uniforms
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

let nextVersion = 0;

function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}

function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };

  for (let i = 0; i < 9; i++) state.probe.push(new Vector3());

  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();

  function setup(lights) {
    let r = 0,
        g = 0,
        b = 0;

    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);

    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);

    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);

        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }

        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;

        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }

        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light); // (a) intensity is the total visible light emitted
        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
        // (b) intensity is the brightness of the light

        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;

        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }

        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }

    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        // WebGL 2
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        // WebGL 1
        if (extensions.has('OES_texture_float_linear') === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has('OES_texture_half_float_linear') === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
        }
      }
    }

    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash = state.hash;

    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }

  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;

    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];

      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors

        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }

  return {
    setup: setup,
    setupView: setupView,
    state: state
  };
}

function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];

  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }

  function pushLight(light) {
    lightsArray.push(light);
  }

  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }

  function setupLights() {
    lights.setup(lightsArray);
  }

  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }

  const state = {
    lightsArray: lightsArray,
    shadowsArray: shadowsArray,
    lights: lights
  };
  return {
    init: init,
    state: state,
    setupLights: setupLights,
    setupLightsView: setupLightsView,
    pushLight: pushLight,
    pushShadow: pushShadow
  };
}

function WebGLRenderStates(extensions, capabilities) {
  let renderStates = new WeakMap();

  function get(scene, renderCallDepth = 0) {
    let renderState;

    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }

    return renderState;
  }

  function dispose() {
    renderStates = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}
/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */


class MeshDepthMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'MeshDepthMaterial';
    this.depthPacking = BasicDepthPacking;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }

}

exports.MeshDepthMaterial = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

class MeshDistanceMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'MeshDistanceMaterial';
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1000;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }

}

exports.MeshDistanceMaterial = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();

  const _shadowMapSize = new Vector2(),
        _viewportSize = new Vector2(),
        _viewport = new Vector4(),
        _depthMaterials = [],
        _distanceMaterials = [],
        _materialCache = {},
        _maxTextureSize = _capabilities.maxTextureSize;

  const shadowSide = {
    0: BackSide,
    1: FrontSide,
    2: DoubleSide
  };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2.0 / 8.0,
      HALF_SAMPLE_RATE: 1.0 / 8.0
    },
    uniforms: {
      shadow_pass: {
        value: null
      },
      resolution: {
        value: new Vector2()
      },
      radius: {
        value: 4.0
      }
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;

  this.render = function (lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;

    const currentRenderTarget = _renderer.getRenderTarget();

    const activeCubeFace = _renderer.getActiveCubeFace();

    const activeMipmapLevel = _renderer.getActiveMipmapLevel();

    const _state = _renderer.state; // Set GL state for depth map.

    _state.setBlending(NoBlending);

    _state.buffers.color.setClear(1, 1, 1, 1);

    _state.buffers.depth.setTest(true);

    _state.setScissorTest(false); // render depth map


    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;

      if (shadow === undefined) {
        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
        continue;
      }

      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

      _shadowMapSize.copy(shadow.mapSize);

      const shadowFrameExtents = shadow.getFrameExtents();

      _shadowMapSize.multiply(shadowFrameExtents);

      _viewportSize.copy(shadow.mapSize);

      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }

        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }

      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          format: RGBAFormat
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + '.shadowMap';
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }

      if (shadow.map === null) {
        const pars = {
          minFilter: NearestFilter,
          magFilter: NearestFilter,
          format: RGBAFormat
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + '.shadowMap';
        shadow.camera.updateProjectionMatrix();
      }

      _renderer.setRenderTarget(shadow.map);

      _renderer.clear();

      const viewportCount = shadow.getViewportCount();

      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);

        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

        _state.viewport(_viewport);

        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      } // do blur pass for VSM


      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }

      shadow.needsUpdate = false;
    }

    scope.needsUpdate = false;

    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };

  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh); // vertical pass


    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;

    _renderer.setRenderTarget(shadow.mapPass);

    _renderer.clear();

    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass


    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;

    _renderer.setRenderTarget(shadow.map);

    _renderer.clear();

    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }

  function getDepthMaterialVariant(useMorphing) {
    const index = useMorphing << 0;
    let material = _depthMaterials[index];

    if (material === undefined) {
      material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing
      });
      _depthMaterials[index] = material;
    }

    return material;
  }

  function getDistanceMaterialVariant(useMorphing) {
    const index = useMorphing << 0;
    let material = _distanceMaterials[index];

    if (material === undefined) {
      material = new MeshDistanceMaterial({
        morphTargets: useMorphing
      });
      _distanceMaterials[index] = material;
    }

    return material;
  }

  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    let getMaterialVariant = getDepthMaterialVariant;
    let customMaterial = object.customDepthMaterial;

    if (light.isPointLight === true) {
      getMaterialVariant = getDistanceMaterialVariant;
      customMaterial = object.customDistanceMaterial;
    }

    if (customMaterial === undefined) {
      let useMorphing = false;

      if (material.morphTargets === true) {
        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
      }

      result = getMaterialVariant(useMorphing);
    } else {
      result = customMaterial;
    }

    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      // in this case we need a unique material instance reflecting the
      // appropriate state
      const keyA = result.uuid,
            keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];

      if (materialsForVariant === undefined) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }

      let cachedMaterial = materialsForVariant[keyB];

      if (cachedMaterial === undefined) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }

      result = cachedMaterial;
    }

    result.visible = material.visible;
    result.wireframe = material.wireframe;

    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }

    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;

    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }

    return result;
  }

  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);

    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

        const geometry = _objects.update(object);

        const material = object.material;

        if (Array.isArray(material)) {
          const groups = geometry.groups;

          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];

            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);

          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
}

function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;

  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function (colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }

        color.set(r, g, b, a);

        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function () {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0); // set to invalid state
      }
    };
  }

  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function (depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function (depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function (depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;

              case AlwaysDepth:
                gl.depthFunc(519);
                break;

              case LessDepth:
                gl.depthFunc(513);
                break;

              case LessEqualDepth:
                gl.depthFunc(515);
                break;

              case EqualDepth:
                gl.depthFunc(514);
                break;

              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;

              case GreaterDepth:
                gl.depthFunc(516);
                break;

              case NotEqualDepth:
                gl.depthFunc(517);
                break;

              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }

          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function () {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }

  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function (stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function (stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function (stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function (stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function () {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  } //


  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let xrFramebuffer = null;
  let currentBoundFramebuffers = {};
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);

  if (glVersion.indexOf('WebGL') !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1.0;
  } else if (glVersion.indexOf('OpenGL ES') !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2.0;
  }

  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(3088);
  const viewportParam = gl.getParameter(2978);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);

  function createTexture(type, target, count) {
    const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);

    for (let i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }

    return texture;
  }

  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6); // init

  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending); //

  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }

  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }

  function bindXRFramebuffer(framebuffer) {
    if (framebuffer !== xrFramebuffer) {
      gl.bindFramebuffer(36160, framebuffer);
      xrFramebuffer = framebuffer;
    }
  }

  function bindFramebuffer(target, framebuffer) {
    if (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer; // use active XR framebuffer if available

    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;

      if (isWebGL2) {
        // 36009 is equivalent to 36160
        if (target === 36009) {
          currentBoundFramebuffers[36160] = framebuffer;
        }

        if (target === 36160) {
          currentBoundFramebuffers[36009] = framebuffer;
        }
      }

      return true;
    }

    return false;
  }

  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }

    return false;
  }

  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };

  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get('EXT_blend_minmax');

    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }

  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };

  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }

      return;
    }

    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }

    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }

        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;

            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;

            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;

            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;

            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;

            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;

            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        }

        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }

      return;
    } // custom blending


    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;

    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }

    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }

    currentBlending = blending;
    currentPremultipledAlpha = null;
  }

  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);

    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }

    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(32926) : disable(32926);
  } //


  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }

      currentFlipSided = flipSided;
    }
  }

  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);

      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }

    currentCullFace = cullFace;
  }

  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }

  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);

      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }

  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  } // texture


  function activeTexture(webglSlot) {
    if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;

    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }

  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }

    let boundTexture = currentBoundTextures[currentTextureSlot];

    if (boundTexture === undefined) {
      boundTexture = {
        type: undefined,
        texture: undefined
      };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }

    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }

  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];

    if (boundTexture !== undefined && boundTexture.type !== undefined) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = undefined;
      boundTexture.texture = undefined;
    }
  }

  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  } //


  function scissor(scissor) {
    if (currentScissor.equals(scissor) === false) {
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      currentScissor.copy(scissor);
    }
  }

  function viewport(viewport) {
    if (currentViewport.equals(viewport) === false) {
      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
      currentViewport.copy(viewport);
    }
  } //


  function reset() {
    // reset state
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.disable(32926);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(0xffffffff);
    gl.stencilFunc(519, 0, 0xffffffff);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.bindFramebuffer(36160, null);

    if (isWebGL2 === true) {
      gl.bindFramebuffer(36009, null);
      gl.bindFramebuffer(36008, null);
    }

    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // reset internals

    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    xrFramebuffer = null;
    currentBoundFramebuffers = {};
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }

  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable: enable,
    disable: disable,
    bindFramebuffer: bindFramebuffer,
    bindXRFramebuffer: bindXRFramebuffer,
    useProgram: useProgram,
    setBlending: setBlending,
    setMaterial: setMaterial,
    setFlipSided: setFlipSided,
    setCullFace: setCullFace,
    setLineWidth: setLineWidth,
    setPolygonOffset: setPolygonOffset,
    setScissorTest: setScissorTest,
    activeTexture: activeTexture,
    bindTexture: bindTexture,
    unbindTexture: unbindTexture,
    compressedTexImage2D: compressedTexImage2D,
    texImage2D: texImage2D,
    texImage3D: texImage3D,
    scissor: scissor,
    viewport: viewport,
    reset: reset
  };
}

function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;

  const _videoTextures = new WeakMap();

  let _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
  // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).


  let useOffscreenCanvas = false;

  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
  } catch (err) {// Ignore any errors
  }

  function createCanvas(width, height) {
    // Use OffscreenCanvas when available. Specially needed in web workers
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
  }

  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1; // handle case if texture exceeds max size

    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    } // only perform resize if necessary


    if (scale < 1 || needsPowerOfTwo === true) {
      // only perform resize for certain image types
      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, width, height);
        console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
        return canvas;
      } else {
        if ('data' in image) {
          console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
        }

        return image;
      }
    }

    return image;
  }

  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }

  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2) return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }

  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }

  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);

    const textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height));
  }

  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false) return glFormat;

    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
      console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
    }

    let internalFormat = glFormat;

    if (glFormat === 6403) {
      if (glType === 5126) internalFormat = 33326;
      if (glType === 5131) internalFormat = 33325;
      if (glType === 5121) internalFormat = 33321;
    }

    if (glFormat === 6407) {
      if (glType === 5126) internalFormat = 34837;
      if (glType === 5131) internalFormat = 34843;
      if (glType === 5121) internalFormat = 32849;
    }

    if (glFormat === 6408) {
      if (glType === 5126) internalFormat = 34836;
      if (glType === 5131) internalFormat = 34842;
      if (glType === 5121) internalFormat = 32856;
    }

    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get('EXT_color_buffer_float');
    }

    return internalFormat;
  } // Fallback filters for non-power-of-2 textures


  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }

    return 9729;
  } //


  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);

    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }

    info.memory.textures--;
  }

  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  } //


  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === undefined) return;

    _gl.deleteTexture(textureProperties.__webglTexture);

    properties.remove(texture);
  }

  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (!renderTarget) return;

    if (textureProperties.__webglTexture !== undefined) {
      _gl.deleteTexture(textureProperties.__webglTexture);

      info.memory.textures--;
    }

    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }

    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }

    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i = 0, il = texture.length; i < il; i++) {
        const attachmentProperties = properties.get(texture[i]);

        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);

          info.memory.textures--;
        }

        properties.remove(texture[i]);
      }
    }

    properties.remove(texture);
    properties.remove(renderTarget);
  } //


  let textureUnits = 0;

  function resetTextureUnits() {
    textureUnits = 0;
  }

  function allocateTextureUnit() {
    const textureUnit = textureUnits;

    if (textureUnit >= maxTextures) {
      console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
    }

    textureUnits += 1;
    return textureUnit;
  } //


  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;

      if (image === undefined) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
      } else if (image.complete === false) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }

  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }

  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }

  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }

  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };

  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);

      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);

      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }

      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);

      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);

      _gl.texParameteri(textureType, 10243, 33071);

      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }

      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
      }

      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));

      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));

      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
      }
    }

    if (extensions.has('EXT_texture_filter_anisotropic') === true) {
      const extension = extensions.get('EXT_texture_filter_anisotropic');
      if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2

      if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only

      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }

  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === undefined) {
      textureProperties.__webglInit = true;
      texture.addEventListener('dispose', onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }

  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray) textureType = 35866;
    if (texture.isDataTexture3D) textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);

    _gl.pixelStorei(37440, texture.flipY);

    _gl.pixelStorei(37441, texture.premultiplyAlpha);

    _gl.pixelStorei(3317, texture.unpackAlignment);

    _gl.pixelStorei(37443, 0);

    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo$1(image) || isWebGL2,
          glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type),
        glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;

    if (texture.isDepthTexture) {
      // populate depth texture with dummy data
      glInternalFormat = 6402;

      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
        }
      } else {
        if (texture.type === FloatType) {
          console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
        }
      } // validation checks for WebGL 1


      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }

      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        // Depth stencil textures need the DEPTH_STENCIL internal format
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

        if (texture.type !== UnsignedInt248Type) {
          console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      } //


      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }

        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];

        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
          }
        } else {
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }

      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      // regular Texture (image, video, canvas)
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
        }

        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }

    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }

    textureProperties.__version = texture.version;
    if (texture.onUpdate) texture.onUpdate(texture);
  }

  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);

    _gl.pixelStorei(37440, texture.flipY);

    _gl.pixelStorei(37441, texture.premultiplyAlpha);

    _gl.pixelStorei(3317, texture.unpackAlignment);

    _gl.pixelStorei(37443, 0);

    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];

    for (let i = 0; i < 6; i++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
      } else {
        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
      }
    }

    const image = cubeImage[0],
          supportsMips = isPowerOfTwo$1(image) || isWebGL2,
          glFormat = utils.convert(texture.format),
          glType = utils.convert(texture.type),
          glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;

    if (isCompressed) {
      for (let i = 0; i < 6; i++) {
        mipmaps = cubeImage[i].mipmaps;

        for (let j = 0; j < mipmaps.length; j++) {
          const mipmap = mipmaps[j];

          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
            }
          } else {
            state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }

      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else {
      mipmaps = texture.mipmaps;

      for (let i = 0; i < 6; i++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            const mipmapImage = mipmap.image[i].image;
            state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);

          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
          }
        }
      }

      textureProperties.__maxMipLevel = mipmaps.length;
    }

    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      // We assume images for cube map have the same size.
      generateMipmap(34067, texture, image.width, image.height);
    }

    textureProperties.__version = texture.version;
    if (texture.onUpdate) texture.onUpdate(texture);
  } // Render targets
  // Setup storage for target texture and bind it to correct framebuffer


  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
    const glFormat = utils.convert(texture.format);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);

    if (textureTarget === 32879 || textureTarget === 35866) {
      state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
    } else {
      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    }

    state.bindFramebuffer(36160, framebuffer);

    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);

    state.bindFramebuffer(36160, null);
  } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);

    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;

      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;

        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }

        const samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }

      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }

      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      // Use the first texture for MRT so far
      const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
      const glFormat = utils.convert(texture.format);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);

      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }

    _gl.bindRenderbuffer(36161, null);
  } // Setup resources for a Depth Texture for a FBO (needs an extension)


  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
    state.bindFramebuffer(36160, framebuffer);

    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
    } // upload an empty depth texture with framebuffer size


    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }

    setTexture2D(renderTarget.depthTexture, 0);

    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error('Unknown depthTexture format');
    }
  } // Setup GL resources for a non-texture depth buffer


  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;

    if (renderTarget.depthTexture) {
      if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];

        for (let i = 0; i < 6; i++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }

    state.bindFramebuffer(36160, null);
  } // Set up GL resources for the render target


  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener('dispose', onRenderTargetDispose);

    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      textureProperties.__webglTexture = _gl.createTexture();
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }

    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858

    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
      texture.format = RGBAFormat;
      console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
    } // Setup framebuffer


    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];

      for (let i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures = renderTarget.texture;

          for (let i = 0, il = textures.length; i < il; i++) {
            const attachmentProperties = properties.get(textures[i]);

            if (attachmentProperties.__webglTexture === undefined) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');
        }
      } else if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);

          const glFormat = utils.convert(texture.format);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          const samples = getRenderTargetSamples(renderTarget);

          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);

          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);

          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);

          _gl.bindRenderbuffer(36161, null);

          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }

          state.bindFramebuffer(36160, null);
        } else {
          console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
      }
    } // Setup color buffer


    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);

      for (let i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, 36064, 34069 + i);
      }

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
      }

      state.bindTexture(34067, null);
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;

      for (let i = 0, il = textures.length; i < il; i++) {
        const attachment = textures[i];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(3553, attachmentProperties.__webglTexture);
        setTextureParameters(3553, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553);

        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(3553, attachment, renderTarget.width, renderTarget.height);
        }
      }

      state.bindTexture(3553, null);
    } else {
      let glTextureType = 3553;

      if (isRenderTarget3D) {
        // Render targets containing layers, i.e: Texture 3D and 2d arrays
        if (isWebGL2) {
          const isTexture3D = texture.isDataTexture3D;
          glTextureType = isTexture3D ? 32879 : 35866;
        } else {
          console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');
        }
      }

      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(3553, texture, renderTarget.width, renderTarget.height);
      }

      state.bindTexture(3553, null);
    } // Setup depth and stencil buffers


    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }

  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];

    for (let i = 0, il = textures.length; i < il; i++) {
      const texture = textures[i];

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;

        const webglTexture = properties.get(texture).__webglTexture;

        state.bindTexture(target, webglTexture);
        generateMipmap(target, texture, renderTarget.width, renderTarget.height);
        state.bindTexture(target, null);
      }
    }
  }

  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        if (renderTarget.depthBuffer) mask |= 256;
        if (renderTarget.stencilBuffer) mask |= 1024;
        const renderTargetProperties = properties.get(renderTarget);
        state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);

        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);

        state.bindFramebuffer(36008, null);
        state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
      }
    }
  }

  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }

  function updateVideoTexture(texture) {
    const frame = info.render.frame; // Check the last frame we updated the VideoTexture

    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);

      texture.update();
    }
  } // backwards compatibility


  let warnedTexture2D = false;
  let warnedTextureCube = false;

  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
        warnedTexture2D = true;
      }

      texture = texture.texture;
    }

    setTexture2D(texture, slot);
  }

  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
        warnedTextureCube = true;
      }

      texture = texture.texture;
    }

    setTextureCube(texture, slot);
  } //


  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}

function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;

  function convert(p) {
    let extension;
    if (p === UnsignedByteType) return 5121;
    if (p === UnsignedShort4444Type) return 32819;
    if (p === UnsignedShort5551Type) return 32820;
    if (p === UnsignedShort565Type) return 33635;
    if (p === ByteType) return 5120;
    if (p === ShortType) return 5122;
    if (p === UnsignedShortType) return 5123;
    if (p === IntType) return 5124;
    if (p === UnsignedIntType) return 5125;
    if (p === FloatType) return 5126;

    if (p === HalfFloatType) {
      if (isWebGL2) return 5131;
      extension = extensions.get('OES_texture_half_float');

      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }

    if (p === AlphaFormat) return 6406;
    if (p === RGBFormat) return 6407;
    if (p === RGBAFormat) return 6408;
    if (p === LuminanceFormat) return 6409;
    if (p === LuminanceAlphaFormat) return 6410;
    if (p === DepthFormat) return 6402;
    if (p === DepthStencilFormat) return 34041;
    if (p === RedFormat) return 6403; // WebGL2 formats.

    if (p === RedIntegerFormat) return 36244;
    if (p === RGFormat) return 33319;
    if (p === RGIntegerFormat) return 33320;
    if (p === RGBIntegerFormat) return 36248;
    if (p === RGBAIntegerFormat) return 36249;

    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get('WEBGL_compressed_texture_s3tc');

      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }

    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_pvrtc');

      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }

    if (p === RGB_ETC1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc1');

      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }

    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc');

      if (extension !== null) {
        if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }

    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get('WEBGL_compressed_texture_astc');

      if (extension !== null) {
        // TODO Complete?
        return p;
      } else {
        return null;
      }
    }

    if (p === RGBA_BPTC_Format) {
      extension = extensions.get('EXT_texture_compression_bptc');

      if (extension !== null) {
        // TODO Complete?
        return p;
      } else {
        return null;
      }
    }

    if (p === UnsignedInt248Type) {
      if (isWebGL2) return 34042;
      extension = extensions.get('WEBGL_depth_texture');

      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }

  return {
    convert: convert
  };
}

class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.cameras = array;
  }

}

exports.ArrayCamera = ArrayCamera;
ArrayCamera.prototype.isArrayCamera = true;

class Group extends Object3D {
  constructor() {
    super();
    this.type = 'Group';
  }

}

exports.Group = Group;
Group.prototype.isGroup = true;
const _moveEvent = {
  type: 'move'
};

class WebXRController {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }

  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = {
        pinching: false
      };
    }

    return this._hand;
  }

  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }

    return this._targetRay;
  }

  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }

    return this._grip;
  }

  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }

    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }

    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }

    return this;
  }

  disconnect(inputSource) {
    this.dispatchEvent({
      type: 'disconnected',
      data: inputSource
    });

    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }

    if (this._grip !== null) {
      this._grip.visible = false;
    }

    if (this._hand !== null) {
      this._hand.visible = false;
    }

    return this;
  }

  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;

    if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);

          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }

          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }

          this.dispatchEvent(_moveEvent);
        }
      }

      if (hand && inputSource.hand) {
        handPose = true;

        for (const inputjoint of inputSource.hand.values()) {
          // Update the joints groups with the XRJoint poses
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);

          if (hand.joints[inputjoint.jointName] === undefined) {
            // The transform of this joint will be updated with the joint pose on each frame
            const joint = new Group();
            joint.matrixAutoUpdate = false;
            joint.visible = false;
            hand.joints[inputjoint.jointName] = joint; // ??

            hand.add(joint);
          }

          const joint = hand.joints[inputjoint.jointName];

          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }

          joint.visible = jointPose !== null;
        } // Custom events
        // Check pinchz


        const indexTip = hand.joints['index-finger-tip'];
        const thumbTip = hand.joints['thumb-tip'];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 0.005;

        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: 'pinchend',
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: 'pinchstart',
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);

            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }

            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
    }

    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }

    if (grip !== null) {
      grip.visible = gripPose !== null;
    }

    if (hand !== null) {
      hand.visible = handPose !== null;
    }

    return this;
  }

}

class WebXRManager extends EventDispatcher {
  constructor(renderer, gl) {
    super();
    const scope = this;
    const state = renderer.state;
    let session = null;
    let framebufferScaleFactor = 1.0;
    let referenceSpace = null;
    let referenceSpaceType = 'local-floor';
    let pose = null;
    const controllers = [];
    const inputSourcesMap = new Map(); //

    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null; //

    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;

    this.getController = function (index) {
      let controller = controllers[index];

      if (controller === undefined) {
        controller = new WebXRController();
        controllers[index] = controller;
      }

      return controller.getTargetRaySpace();
    };

    this.getControllerGrip = function (index) {
      let controller = controllers[index];

      if (controller === undefined) {
        controller = new WebXRController();
        controllers[index] = controller;
      }

      return controller.getGripSpace();
    };

    this.getHand = function (index) {
      let controller = controllers[index];

      if (controller === undefined) {
        controller = new WebXRController();
        controllers[index] = controller;
      }

      return controller.getHandSpace();
    }; //


    function onSessionEvent(event) {
      const controller = inputSourcesMap.get(event.inputSource);

      if (controller) {
        controller.dispatchEvent({
          type: event.type,
          data: event.inputSource
        });
      }
    }

    function onSessionEnd() {
      inputSourcesMap.forEach(function (controller, inputSource) {
        controller.disconnect(inputSource);
      });
      inputSourcesMap.clear();
      _currentDepthNear = null;
      _currentDepthFar = null; // restore framebuffer/rendering state

      state.bindXRFramebuffer(null);
      renderer.setRenderTarget(renderer.getRenderTarget()); //

      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({
        type: 'sessionend'
      });
    }

    this.setFramebufferScaleFactor = function (value) {
      framebufferScaleFactor = value;

      if (scope.isPresenting === true) {
        console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
      }
    };

    this.setReferenceSpaceType = function (value) {
      referenceSpaceType = value;

      if (scope.isPresenting === true) {
        console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
      }
    };

    this.getReferenceSpace = function () {
      return referenceSpace;
    };

    this.getSession = function () {
      return session;
    };

    this.setSession = async function (value) {
      session = value;

      if (session !== null) {
        session.addEventListener('select', onSessionEvent);
        session.addEventListener('selectstart', onSessionEvent);
        session.addEventListener('selectend', onSessionEvent);
        session.addEventListener('squeeze', onSessionEvent);
        session.addEventListener('squeezestart', onSessionEvent);
        session.addEventListener('squeezeend', onSessionEvent);
        session.addEventListener('end', onSessionEnd);
        session.addEventListener('inputsourceschange', onInputSourcesChange);
        const attributes = gl.getContextAttributes();

        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }

        const layerInit = {
          antialias: attributes.antialias,
          alpha: attributes.alpha,
          depth: attributes.depth,
          stencil: attributes.stencil,
          framebufferScaleFactor: framebufferScaleFactor
        }; // eslint-disable-next-line no-undef

        const baseLayer = new XRWebGLLayer(session, gl, layerInit);
        session.updateRenderState({
          baseLayer: baseLayer
        });
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({
          type: 'sessionstart'
        });
      }
    };

    function onInputSourcesChange(event) {
      const inputSources = session.inputSources; // Assign inputSources to available controllers

      for (let i = 0; i < controllers.length; i++) {
        inputSourcesMap.set(inputSources[i], controllers[i]);
      } // Notify disconnected


      for (let i = 0; i < event.removed.length; i++) {
        const inputSource = event.removed[i];
        const controller = inputSourcesMap.get(inputSource);

        if (controller) {
          controller.dispatchEvent({
            type: 'disconnected',
            data: inputSource
          });
          inputSourcesMap.delete(inputSource);
        }
      } // Notify connected


      for (let i = 0; i < event.added.length; i++) {
        const inputSource = event.added[i];
        const controller = inputSourcesMap.get(inputSource);

        if (controller) {
          controller.dispatchEvent({
            type: 'connected',
            data: inputSource
          });
        }
      }
    } //


    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    /**
     * Assumes 2 cameras that are parallel and share an X-axis, and that
     * the cameras' projection and world matrices have already been set.
     * And that near and far planes are identical for both cameras.
     * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
     */

    function setProjectionFromUnion(camera, cameraL, cameraR) {
      cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL.projectionMatrix.elements;
      const projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
      // most likely identical top and bottom frustum extents.
      // Use the left camera for these values.

      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov; // Calculate the new camera's position offset from the
      // left camera. xOffset should be roughly half `ipd`.

      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

      cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale
      // the values so that the near plane's position does not change in world space,
      // although must now be relative to the new union camera.

      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }

    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }

      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }

    this.updateCamera = function (camera) {
      if (session === null) return;
      cameraVR.near = cameraR.near = cameraL.near = camera.near;
      cameraVR.far = cameraR.far = cameraL.far = camera.far;

      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        // Note that the new renderState won't apply until the next frame. See #18320
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }

      const parent = camera.parent;
      const cameras = cameraVR.cameras;
      updateCamera(cameraVR, parent);

      for (let i = 0; i < cameras.length; i++) {
        updateCamera(cameras[i], parent);
      } // update camera and its children


      camera.matrixWorld.copy(cameraVR.matrixWorld);
      camera.matrix.copy(cameraVR.matrix);
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      const children = camera.children;

      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(true);
      } // update projection matrix for proper view frustum culling


      if (cameras.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        // assume single camera setup (AR)
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
    };

    this.getCamera = function () {
      return cameraVR;
    }; // Animation Loop


    let onAnimationFrameCallback = null;

    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(referenceSpace);

      if (pose !== null) {
        const views = pose.views;
        const baseLayer = session.renderState.baseLayer;
        state.bindXRFramebuffer(baseLayer.framebuffer);
        let cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list

        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }

        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          const viewport = baseLayer.getViewport(view);
          const camera = cameras[i];
          camera.matrix.fromArray(view.transform.matrix);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

          if (i === 0) {
            cameraVR.matrix.copy(camera.matrix);
          }

          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera);
          }
        }
      } //


      const inputSources = session.inputSources;

      for (let i = 0; i < controllers.length; i++) {
        const controller = controllers[i];
        const inputSource = inputSources[i];
        controller.update(inputSource, frame, referenceSpace);
      }

      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
    }

    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);

    this.setAnimationLoop = function (callback) {
      onAnimationFrameCallback = callback;
    };

    this.dispose = function () {};
  }

}

function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);

    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }

  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);

      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);

      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false; // #15581
    }
  }

  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;

    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }

    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }

    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }

    const envMap = properties.get(material).envMap;

    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;

      const maxMipLevel = properties.get(envMap).__maxMipLevel;

      if (maxMipLevel !== undefined) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }

    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }

    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. displacementMap map
    // 4. normal map
    // 5. bump map
    // 6. roughnessMap map
    // 7. metalnessMap map
    // 8. alphaMap map
    // 9. emissiveMap map
    // 10. clearcoat map
    // 11. clearcoat normal map
    // 12. clearcoat roughnessMap map


    let uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    }

    if (uvScaleMap !== undefined) {
      // backwards compatibility
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }

      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    } // uv repeat and offset setting priorities for uv2
    // 1. ao map
    // 2. light map


    let uv2ScaleMap;

    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }

    if (uv2ScaleMap !== undefined) {
      // backwards compatibility
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }

      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }

      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }

  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }

  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }

  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. alpha map


    let uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }

    if (uvScaleMap !== undefined) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. alpha map


    let uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }

    if (uvScaleMap !== undefined) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }

  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;

    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }

    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    const envMap = properties.get(material).envMap;

    if (envMap) {
      //uniforms.envMap.value = material.envMap; // part of uniforms common
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }

  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen) uniforms.sheen.value.copy(material.sheen);

    if (material.clearcoatMap) {
      uniforms.clearcoatMap.value = material.clearcoatMap;
    }

    if (material.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
    }

    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }

    uniforms.transmission.value = material.transmission;

    if (material.transmissionMap) {
      uniforms.transmissionMap.value = material.transmissionMap;
    }

    if (material.transmission > 0.0) {
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
    }

    uniforms.thickness.value = material.thickness;

    if (material.thicknessMap) {
      uniforms.thicknessMap.value = material.thicknessMap;
    }

    uniforms.attenuationDistance.value = material.attenuationDistance;
    uniforms.attenuationColor.value.copy(material.attenuationColor);
  }

  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }

  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  return {
    refreshFogUniforms: refreshFogUniforms,
    refreshMaterialUniforms: refreshMaterialUniforms
  };
}

function createCanvasElement() {
  const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
  canvas.style.display = 'block';
  return canvas;
}

function WebGLRenderer(parameters) {
  parameters = parameters || {};

  const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
        _context = parameters.context !== undefined ? parameters.context : null,
        _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
        _depth = parameters.depth !== undefined ? parameters.depth : true,
        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
        _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
        _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

  let currentRenderList = null;
  let currentRenderState = null; // render() can be called from within a callback triggered by another render.
  // We track this so that the nested render call gets its list and state isolated from the parent render call.

  const renderListStack = [];
  const renderStateStack = []; // public properties

  this.domElement = _canvas; // Debug configuration container

  this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: true
  }; // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true; // scene graph

  this.sortObjects = true; // user-defined clipping

  this.clippingPlanes = [];
  this.localClippingEnabled = false; // physically based shading

  this.gammaFactor = 2.0; // for backwards compatibility

  this.outputEncoding = LinearEncoding; // physical lights

  this.physicallyCorrectLights = false; // tone mapping

  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1.0; // internal properties

  const _this = this;

  let _isContextLost = false; // internal state cache

  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;

  let _currentMaterialId = -1;

  let _currentCamera = null;

  const _currentViewport = new Vector4();

  const _currentScissor = new Vector4();

  let _currentScissorTest = null; //

  let _width = _canvas.width;
  let _height = _canvas.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;

  const _viewport = new Vector4(0, 0, _width, _height);

  const _scissor = new Vector4(0, 0, _width, _height);

  let _scissorTest = false; //

  const _currentDrawBuffers = []; // frustum

  const _frustum = new Frustum(); // clipping


  let _clippingEnabled = false;
  let _localClippingEnabled = false; // transmission

  let _transmissionRenderTarget = null; // camera matrices cache

  const _projScreenMatrix = new Matrix4();

  const _vector3 = new Vector3();

  const _emptyScene = {
    background: null,
    fog: null,
    environment: null,
    overrideMaterial: null,
    isScene: true
  };

  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  } // initialize


  let _gl = _context;

  function getContext(contextNames, contextAttributes) {
    for (let i = 0; i < contextNames.length; i++) {
      const contextName = contextNames[i];

      const context = _canvas.getContext(contextName, contextAttributes);

      if (context !== null) return context;
    }

    return null;
  }

  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    }; // event listeners must be registered before WebGL context is created, see #12753

    _canvas.addEventListener('webglcontextlost', onContextLost, false);

    _canvas.addEventListener('webglcontextrestored', onContextRestore, false);

    if (_gl === null) {
      const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];

      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }

      _gl = getContext(contextNames, contextAttributes);

      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error('Error creating WebGL context with your selected attributes.');
        } else {
          throw new Error('Error creating WebGL context.');
        }
      }
    } // Some experimental-webgl implementations do not have getShaderPrecisionFormat


    if (_gl.getShaderPrecisionFormat === undefined) {
      _gl.getShaderPrecisionFormat = function () {
        return {
          'rangeMin': 1,
          'rangeMax': 1,
          'precision': 1
        };
      };
    }
  } catch (error) {
    console.error('THREE.WebGLRenderer: ' + error.message);
    throw error;
  }

  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping, shadowMap;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;

  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    _currentDrawBuffers[0] = 1029;
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }

  initGLContext(); // xr

  const xr = new WebXRManager(_this, _gl);
  this.xr = xr; // API

  this.getContext = function () {
    return _gl;
  };

  this.getContextAttributes = function () {
    return _gl.getContextAttributes();
  };

  this.forceContextLoss = function () {
    const extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.loseContext();
  };

  this.forceContextRestore = function () {
    const extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.restoreContext();
  };

  this.getPixelRatio = function () {
    return _pixelRatio;
  };

  this.setPixelRatio = function (value) {
    if (value === undefined) return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };

  this.getSize = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
      target = new Vector2();
    }

    return target.set(_width, _height);
  };

  this.setSize = function (width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
      return;
    }

    _width = width;
    _height = height;
    _canvas.width = Math.floor(width * _pixelRatio);
    _canvas.height = Math.floor(height * _pixelRatio);

    if (updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }

    this.setViewport(0, 0, width, height);
  };

  this.getDrawingBufferSize = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
      target = new Vector2();
    }

    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };

  this.setDrawingBufferSize = function (width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas.width = Math.floor(width * pixelRatio);
    _canvas.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };

  this.getCurrentViewport = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
      target = new Vector4();
    }

    return target.copy(_currentViewport);
  };

  this.getViewport = function (target) {
    return target.copy(_viewport);
  };

  this.setViewport = function (x, y, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y, width, height);
    }

    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };

  this.getScissor = function (target) {
    return target.copy(_scissor);
  };

  this.setScissor = function (x, y, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y, width, height);
    }

    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };

  this.getScissorTest = function () {
    return _scissorTest;
  };

  this.setScissorTest = function (boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };

  this.setOpaqueSort = function (method) {
    _opaqueSort = method;
  };

  this.setTransparentSort = function (method) {
    _transparentSort = method;
  }; // Clearing


  this.getClearColor = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getClearColor() now requires a Color as an argument');
      target = new Color();
    }

    return target.copy(background.getClearColor());
  };

  this.setClearColor = function () {
    background.setClearColor.apply(background, arguments);
  };

  this.getClearAlpha = function () {
    return background.getClearAlpha();
  };

  this.setClearAlpha = function () {
    background.setClearAlpha.apply(background, arguments);
  };

  this.clear = function (color, depth, stencil) {
    let bits = 0;
    if (color === undefined || color) bits |= 16384;
    if (depth === undefined || depth) bits |= 256;
    if (stencil === undefined || stencil) bits |= 1024;

    _gl.clear(bits);
  };

  this.clearColor = function () {
    this.clear(true, false, false);
  };

  this.clearDepth = function () {
    this.clear(false, true, false);
  };

  this.clearStencil = function () {
    this.clear(false, false, true);
  }; //


  this.dispose = function () {
    _canvas.removeEventListener('webglcontextlost', onContextLost, false);

    _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    xr.removeEventListener('sessionstart', onXRSessionStart);
    xr.removeEventListener('sessionend', onXRSessionEnd);

    if (_transmissionRenderTarget) {
      _transmissionRenderTarget.dispose();

      _transmissionRenderTarget = null;
    }

    animation.stop();
  }; // Events


  function onContextLost(event) {
    event.preventDefault();
    console.log('THREE.WebGLRenderer: Context Lost.');
    _isContextLost = true;
  }

  function onContextRestore()
  /* event */
  {
    console.log('THREE.WebGLRenderer: Context Restored.');
    _isContextLost = false;
    const infoAutoReset = info.autoReset;
    const shadowMapEnabled = shadowMap.enabled;
    const shadowMapAutoUpdate = shadowMap.autoUpdate;
    const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    const shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }

  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);
    deallocateMaterial(material);
  } // Buffer deallocation


  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material);
    properties.remove(material);
  }

  function releaseMaterialProgramReferences(material) {
    const programs = properties.get(material).programs;

    if (programs !== undefined) {
      programs.forEach(function (program) {
        programCache.releaseProgram(program);
      });
    }
  } // Buffer rendering


  function renderObjectImmediate(object, program) {
    object.render(function (object) {
      _this.renderBufferImmediate(object, program);
    });
  }

  this.renderBufferImmediate = function (object, program) {
    bindingStates.initAttributes();
    const buffers = properties.get(object);
    if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();

    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);

      _gl.bufferData(34962, object.positionArray, 35048);

      bindingStates.enableAttribute(programAttributes.position);

      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }

    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);

      _gl.bufferData(34962, object.normalArray, 35048);

      bindingStates.enableAttribute(programAttributes.normal);

      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }

    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);

      _gl.bufferData(34962, object.uvArray, 35048);

      bindingStates.enableAttribute(programAttributes.uv);

      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }

    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);

      _gl.bufferData(34962, object.colorArray, 35048);

      bindingStates.enableAttribute(programAttributes.color);

      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }

    bindingStates.disableUnusedAttributes();

    _gl.drawArrays(4, 0, object.count);

    object.count = 0;
  };

  this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
    if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, material, object);
    state.setMaterial(material, frontFaceCW); //

    let index = geometry.index;
    const position = geometry.attributes.position; //

    if (index === null) {
      if (position === undefined || position.count === 0) return;
    } else if (index.count === 0) {
      return;
    } //


    let rangeFactor = 1;

    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }

    if (material.morphTargets || material.morphNormals) {
      morphtargets.update(object, geometry, material, program);
    }

    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;

    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    } //


    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0) return; //

    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

      state.setLineWidth(lineWidth * getTargetPixelRatio());

      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }

    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  }; // Compile


  this.compile = function (scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    scene.traverseVisible(function (object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights();
    scene.traverse(function (object) {
      const material = object.material;

      if (material) {
        if (Array.isArray(material)) {
          for (let i = 0; i < material.length; i++) {
            const material2 = material[i];
            getProgram(material2, scene, object);
          }
        } else {
          getProgram(material, scene, object);
        }
      }
    });
  }; // Animation Loop


  let onAnimationFrameCallback = null;

  function onAnimationFrame(time) {
    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
  }

  function onXRSessionStart() {
    animation.stop();
  }

  function onXRSessionEnd() {
    animation.start();
  }

  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== 'undefined') animation.setContext(window);

  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };

  xr.addEventListener('sessionstart', onXRSessionStart);
  xr.addEventListener('sessionend', onXRSessionEnd); // Rendering

  this.render = function (scene, camera) {
    if (camera !== undefined && camera.isCamera !== true) {
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }

    if (_isContextLost === true) return; // update scene graph

    if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

    if (camera.parent === null) camera.updateMatrixWorld();

    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
      camera = xr.getCamera(); // use XR camera for rendering
    } //


    if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);

    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    _frustum.setFromProjectionMatrix(_projScreenMatrix);

    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();

    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    } //


    if (_clippingEnabled === true) clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights();
    currentRenderState.setupLightsView(camera);
    if (_clippingEnabled === true) clipping.endShadows(); //

    if (this.info.autoReset === true) this.info.reset(); //

    background.render(currentRenderList, scene); // render scene

    const opaqueObjects = currentRenderList.opaque;
    const transmissiveObjects = currentRenderList.transmissive;
    const transparentObjects = currentRenderList.transparent;
    if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
    if (transmissiveObjects.length > 0) renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera);
    if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); //

    if (_currentRenderTarget !== null) {
      // Generate mipmap if we're using any kind of mipmap filtering
      textures.updateRenderTargetMipmap(_currentRenderTarget); // resolve multisample renderbuffers to a single-sample texture if necessary

      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    } //


    if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render

    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false); // _gl.finish();

    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();

    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }

    renderListStack.pop();

    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };

  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);

    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true) object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          const geometry = objects.update(object);
          const material = object.material;

          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
        }

        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          // update skeleton only once in a frame
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }

        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          const geometry = objects.update(object);
          const material = object.material;

          if (Array.isArray(material)) {
            const groups = geometry.groups;

            for (let i = 0, l = groups.length; i < l; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];

              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, groupOrder, sortObjects);
    }
  }

  function renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera) {
    if (_transmissionRenderTarget === null) {
      _transmissionRenderTarget = new WebGLRenderTarget(1024, 1024, {
        generateMipmaps: true,
        minFilter: LinearMipmapLinearFilter,
        magFilter: NearestFilter,
        wrapS: ClampToEdgeWrapping,
        wrapT: ClampToEdgeWrapping
      });
    }

    const currentRenderTarget = _this.getRenderTarget();

    _this.setRenderTarget(_transmissionRenderTarget);

    _this.clear();

    renderObjects(opaqueObjects, scene, camera);
    textures.updateRenderTargetMipmap(_transmissionRenderTarget);

    _this.setRenderTarget(currentRenderTarget);

    renderObjects(transmissiveObjects, scene, camera);
  }

  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

    for (let i = 0, l = renderList.length; i < l; i++) {
      const renderItem = renderList[i];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;

      if (camera.isArrayCamera) {
        const cameras = camera.cameras;

        for (let j = 0, jl = cameras.length; j < jl; j++) {
          const camera2 = cameras[j];

          if (object.layers.test(camera2.layers)) {
            state.viewport(_currentViewport.copy(camera2.viewport));
            currentRenderState.setupLightsView(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }

  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

    if (object.isImmediateRenderObject) {
      const program = setProgram(camera, scene, material, object);
      state.setMaterial(material);
      bindingStates.reset();
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }

    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }

  function getProgram(material, scene, object) {
    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters);
    let programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);

    if (programs === undefined) {
      // new material
      material.addEventListener('dispose', onMaterialDispose);
      programs = new Map();
      materialProperties.programs = programs;
    }

    let program = programs.get(programCacheKey);

    if (program !== undefined) {
      // early out if program and light state is identical
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material, parameters);
        return program;
      }
    } else {
      parameters.uniforms = programCache.getUniforms(material);
      material.onBuild(parameters, _this);
      material.onBeforeCompile(parameters, _this);
      program = programCache.acquireProgram(parameters, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters.uniforms;
    }

    const uniforms = materialProperties.uniforms;

    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }

    updateCommonMaterialProperties(material, parameters); // store the light setup it was created for

    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;

    if (materialProperties.needsLights) {
      // wire up the material to this renderer's lighting state
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
    }

    const progUniforms = program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }

  function updateCommonMaterialProperties(material, parameters) {
    const materialProperties = properties.get(material);
    materialProperties.outputEncoding = parameters.outputEncoding;
    materialProperties.instancing = parameters.instancing;
    materialProperties.skinning = parameters.skinning;
    materialProperties.numClippingPlanes = parameters.numClippingPlanes;
    materialProperties.numIntersection = parameters.numClipIntersection;
    materialProperties.vertexAlphas = parameters.vertexAlphas;
  }

  function setProgram(camera, scene, material, object) {
    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = cubemaps.get(material.envMap || environment);
    const vertexAlphas = material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;

    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
        // object instead of the material, once it becomes feasible
        // (#8465, #8379)

        clipping.setState(material, camera, useCache);
      }
    } //


    let needsProgramChange = false;

    if (material.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true;
      } else if (object.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
        needsProgramChange = true;
      } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material.version;
    } //


    let program = materialProperties.currentProgram;

    if (needsProgramChange === true) {
      program = getProgram(material, scene, object);
    }

    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const p_uniforms = program.getUniforms(),
          m_uniforms = materialProperties.uniforms;

    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }

    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }

    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
      }

      if (_currentCamera !== camera) {
        _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
        // now, in case this material supports lights - or later, when
        // the next material that does gets activated:

        refreshMaterial = true; // set to true on material change

        refreshLights = true; // remains set until update done
      } // load material specific uniforms
      // (shader material also gets them for the sake of genericity)


      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;

        if (uCamPos !== undefined) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }

      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
      }

      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
      }
    } // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // otherwise textures used for skinning can take over texture units reserved for other material textures


    if (object.isSkinnedMesh) {
      p_uniforms.setOptional(_gl, object, 'bindMatrix');
      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
      const skeleton = object.skeleton;

      if (skeleton) {
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
        }
      }
    }

    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
    }

    if (refreshMaterial) {
      p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);

      if (materialProperties.needsLights) {
        // the current material requires lighting info
        // note: all lighting uniforms are always set correctly
        // they simply reference the renderer's state for their
        // values
        //
        // use the current material's .needsUpdate flags to set
        // the GL state when required
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      } // refresh uniforms common to several materials


      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }

      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }

    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }

    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, 'center', object.center);
    } // common matrices


    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
    return program;
  } // If uniforms are marked as clean, they don't need to be loaded to the GPU.


  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }

  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }

  this.getActiveCubeFace = function () {
    return _currentActiveCubeFace;
  };

  this.getActiveMipmapLevel = function () {
    return _currentActiveMipmapLevel;
  };

  this.getRenderTarget = function () {
    return _currentRenderTarget;
  };

  this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;

    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
      textures.setupRenderTarget(renderTarget);
    }

    let framebuffer = null;
    let isCube = false;
    let isRenderTarget3D = false;

    if (renderTarget) {
      const texture = renderTarget.texture;

      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
        isRenderTarget3D = true;
      }

      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }

      _currentViewport.copy(renderTarget.viewport);

      _currentScissor.copy(renderTarget.scissor);

      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

      _currentScissorTest = _scissorTest;
    }

    const framebufferBound = state.bindFramebuffer(36160, framebuffer);

    if (framebufferBound && capabilities.drawBuffers) {
      let needsUpdate = false;

      if (renderTarget) {
        if (renderTarget.isWebGLMultipleRenderTargets) {
          const textures = renderTarget.texture;

          if (_currentDrawBuffers.length !== textures.length || _currentDrawBuffers[0] !== 36064) {
            for (let i = 0, il = textures.length; i < il; i++) {
              _currentDrawBuffers[i] = 36064 + i;
            }

            _currentDrawBuffers.length = textures.length;
            needsUpdate = true;
          }
        } else {
          if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 36064) {
            _currentDrawBuffers[0] = 36064;
            _currentDrawBuffers.length = 1;
            needsUpdate = true;
          }
        }
      } else {
        if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 1029) {
          _currentDrawBuffers[0] = 1029;
          _currentDrawBuffers.length = 1;
          needsUpdate = true;
        }
      }

      if (needsUpdate) {
        if (capabilities.isWebGL2) {
          _gl.drawBuffers(_currentDrawBuffers);
        } else {
          extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);
        }
      }
    }

    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);

    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);

      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;

      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
  };

  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
      return;
    }

    let framebuffer = properties.get(renderTarget).__webglFramebuffer;

    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }

    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);

      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;

        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
          return;
        }

        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));

        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)
        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
        !halfFloatSupportedByExt) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
          return;
        }

        if (_gl.checkFramebufferStatus(36160) === 36053) {
          // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
          if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
        }
      } finally {
        // restore framebuffer of current render target if necessary
        const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
        state.bindFramebuffer(36160, framebuffer);
      }
    }
  };

  this.copyFramebufferToTexture = function (position, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    let glFormat = utils.convert(texture.format);

    if (capabilities.isWebGL2) {
      // Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
      if (glFormat === 6407) glFormat = 32849;
      if (glFormat === 6408) glFormat = 32856;
    }

    textures.setTexture2D(texture, 0);

    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);

    state.unbindTexture();
  };

  this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei
    // parameters, make sure they are correct for the dstTexture

    _gl.pixelStorei(37440, dstTexture.flipY);

    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);

    _gl.pixelStorei(3317, dstTexture.unpackAlignment);

    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    } // Generate mipmaps only when copying level 0


    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
    state.unbindTexture();
  };

  this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
      return;
    }

    const {
      width,
      height,
      data
    } = srcTexture.image;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;

    if (dstTexture.isDataTexture3D) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataTexture2DArray) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
      return;
    }

    _gl.pixelStorei(37440, dstTexture.flipY);

    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);

    _gl.pixelStorei(3317, dstTexture.unpackAlignment);

    const unpackRowLen = _gl.getParameter(3314);

    const unpackImageHeight = _gl.getParameter(32878);

    const unpackSkipPixels = _gl.getParameter(3316);

    const unpackSkipRows = _gl.getParameter(3315);

    const unpackSkipImages = _gl.getParameter(32877);

    _gl.pixelStorei(3314, width);

    _gl.pixelStorei(32878, height);

    _gl.pixelStorei(3316, sourceBox.min.x);

    _gl.pixelStorei(3315, sourceBox.min.y);

    _gl.pixelStorei(32877, sourceBox.min.z);

    _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data);

    _gl.pixelStorei(3314, unpackRowLen);

    _gl.pixelStorei(32878, unpackImageHeight);

    _gl.pixelStorei(3316, unpackSkipPixels);

    _gl.pixelStorei(3315, unpackSkipRows);

    _gl.pixelStorei(32877, unpackSkipImages); // Generate mipmaps only when copying level 0


    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };

  this.initTexture = function (texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };

  this.resetState = function () {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };

  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
      detail: this
    })); // eslint-disable-line no-undef

  }
}

class WebGL1Renderer extends WebGLRenderer {}

exports.WebGL1Renderer = WebGL1Renderer;
WebGL1Renderer.prototype.isWebGL1Renderer = true;

class FogExp2 {
  constructor(color, density = 0.00025) {
    this.name = '';
    this.color = new Color(color);
    this.density = density;
  }

  clone() {
    return new FogExp2(this.color, this.density);
  }

  toJSON()
  /* meta */
  {
    return {
      type: 'FogExp2',
      color: this.color.getHex(),
      density: this.density
    };
  }

}

exports.FogExp2 = FogExp2;
FogExp2.prototype.isFogExp2 = true;

class Fog {
  constructor(color, near = 1, far = 1000) {
    this.name = '';
    this.color = new Color(color);
    this.near = near;
    this.far = far;
  }

  clone() {
    return new Fog(this.color, this.near, this.far);
  }

  toJSON()
  /* meta */
  {
    return {
      type: 'Fog',
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }

}

exports.Fog = Fog;
Fog.prototype.isFog = true;

class Scene extends Object3D {
  constructor() {
    super();
    this.type = 'Scene';
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true; // checked by the renderer

    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
      })); // eslint-disable-line no-undef

    }
  }

  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null) this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }

  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.background !== null) data.object.background = this.background.toJSON(meta);
    if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    return data;
  }

}

exports.Scene = Scene;
Scene.prototype.isScene = true;

class InterleavedBuffer {
  constructor(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== undefined ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = {
      offset: 0,
      count: -1
    };
    this.version = 0;
    this.uuid = generateUUID();
  }

  onUploadCallback() {}

  set needsUpdate(value) {
    if (value === true) this.version++;
  }

  setUsage(value) {
    this.usage = value;
    return this;
  }

  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }

  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;

    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  }

  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }

  clone(data) {
    if (data.arrayBuffers === undefined) {
      data.arrayBuffers = {};
    }

    if (this.array.buffer._uuid === undefined) {
      this.array.buffer._uuid = generateUUID();
    }

    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }

    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new this.constructor(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }

  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }

  toJSON(data) {
    if (data.arrayBuffers === undefined) {
      data.arrayBuffers = {};
    } // generate UUID for array buffer if necessary


    if (this.array.buffer._uuid === undefined) {
      this.array.buffer._uuid = generateUUID();
    }

    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    } //


    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }

}

exports.InterleavedBuffer = InterleavedBuffer;
InterleavedBuffer.prototype.isInterleavedBuffer = true;

const _vector$6 = /*@__PURE__*/new Vector3();

class InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset, normalized) {
    this.name = '';
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
  }

  get count() {
    return this.data.count;
  }

  get array() {
    return this.data.array;
  }

  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }

  applyMatrix4(m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);

      _vector$6.applyMatrix4(m);

      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }

    return this;
  }

  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);

      _vector$6.applyNormalMatrix(m);

      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }

    return this;
  }

  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);

      _vector$6.transformDirection(m);

      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }

    return this;
  }

  setX(index, x) {
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  }

  setY(index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  }

  setZ(index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  }

  setW(index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  }

  getX(index) {
    return this.data.array[index * this.data.stride + this.offset];
  }

  getY(index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  }

  getZ(index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  }

  getW(index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  }

  setXY(index, x, y) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  }

  setXYZ(index, x, y, z) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  }

  setXYZW(index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }

  clone(data) {
    if (data === undefined) {
      console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
      const array = [];

      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;

        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }

      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === undefined) {
        data.interleavedBuffers = {};
      }

      if (data.interleavedBuffers[this.data.uuid] === undefined) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }

      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }

  toJSON(data) {
    if (data === undefined) {
      console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
      const array = [];

      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;

        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      } // deinterleave data and save it as an ordinary buffer attribute for now


      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: array,
        normalized: this.normalized
      };
    } else {
      // save as true interlaved attribtue
      if (data.interleavedBuffers === undefined) {
        data.interleavedBuffers = {};
      }

      if (data.interleavedBuffers[this.data.uuid] === undefined) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }

      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }

}

exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

class SpriteMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'SpriteMaterial';
    this.color = new Color(0xffffff);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }

}

exports.SpriteMaterial = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;

let _geometry;

const _intersectPoint = /*@__PURE__*/new Vector3();

const _worldScale = /*@__PURE__*/new Vector3();

const _mvPosition = /*@__PURE__*/new Vector3();

const _alignedPosition = /*@__PURE__*/new Vector2();

const _rotatedPosition = /*@__PURE__*/new Vector2();

const _viewWorldMatrix = /*@__PURE__*/new Matrix4();

const _vA = /*@__PURE__*/new Vector3();

const _vB = /*@__PURE__*/new Vector3();

const _vC = /*@__PURE__*/new Vector3();

const _uvA = /*@__PURE__*/new Vector2();

const _uvB = /*@__PURE__*/new Vector2();

const _uvC = /*@__PURE__*/new Vector2();

class Sprite extends Object3D {
  constructor(material) {
    super();
    this.type = 'Sprite';

    if (_geometry === undefined) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);

      _geometry.setIndex([0, 1, 2, 0, 2, 3]);

      _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

      _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }

    this.geometry = _geometry;
    this.material = material !== undefined ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }

  raycast(raycaster, intersects) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }

    _worldScale.setFromMatrixScale(this.matrixWorld);

    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);

    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);

    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }

    const rotation = this.material.rotation;
    let sin, cos;

    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }

    const center = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

    _uvA.set(0, 0);

    _uvB.set(1, 0);

    _uvC.set(1, 1); // check first triangle


    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);

    if (intersect === null) {
      // check second triangle
      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

      _uvB.set(0, 1);

      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);

      if (intersect === null) {
        return;
      }
    }

    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance: distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
      face: null,
      object: this
    });
  }

  copy(source) {
    super.copy(source);
    if (source.center !== undefined) this.center.copy(source.center);
    this.material = source.material;
    return this;
  }

}

exports.Sprite = Sprite;
Sprite.prototype.isSprite = true;

function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  // compute position in camera space
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero


  if (sin !== undefined) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }

  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y; // transform to world space

  vertexPosition.applyMatrix4(_viewWorldMatrix);
}

const _v1$2 = /*@__PURE__*/new Vector3();

const _v2$1 = /*@__PURE__*/new Vector3();

class LOD extends Object3D {
  constructor() {
    super();
    this._currentLevel = 0;
    this.type = 'LOD';
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      },
      isLOD: {
        value: true
      }
    });
    this.autoUpdate = true;
  }

  copy(source) {
    super.copy(source, false);
    const levels = source.levels;

    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      this.addLevel(level.object.clone(), level.distance);
    }

    this.autoUpdate = source.autoUpdate;
    return this;
  }

  addLevel(object, distance = 0) {
    distance = Math.abs(distance);
    const levels = this.levels;
    let l;

    for (l = 0; l < levels.length; l++) {
      if (distance < levels[l].distance) {
        break;
      }
    }

    levels.splice(l, 0, {
      distance: distance,
      object: object
    });
    this.add(object);
    return this;
  }

  getCurrentLevel() {
    return this._currentLevel;
  }

  getObjectForDistance(distance) {
    const levels = this.levels;

    if (levels.length > 0) {
      let i, l;

      for (i = 1, l = levels.length; i < l; i++) {
        if (distance < levels[i].distance) {
          break;
        }
      }

      return levels[i - 1].object;
    }

    return null;
  }

  raycast(raycaster, intersects) {
    const levels = this.levels;

    if (levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld);

      const distance = raycaster.ray.origin.distanceTo(_v1$2);
      this.getObjectForDistance(distance).raycast(raycaster, intersects);
    }
  }

  update(camera) {
    const levels = this.levels;

    if (levels.length > 1) {
      _v1$2.setFromMatrixPosition(camera.matrixWorld);

      _v2$1.setFromMatrixPosition(this.matrixWorld);

      const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
      levels[0].object.visible = true;
      let i, l;

      for (i = 1, l = levels.length; i < l; i++) {
        if (distance >= levels[i].distance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }

      this._currentLevel = i - 1;

      for (; i < l; i++) {
        levels[i].object.visible = false;
      }
    }
  }

  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.autoUpdate === false) data.object.autoUpdate = false;
    data.object.levels = [];
    const levels = this.levels;

    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }

    return data;
  }

}

exports.LOD = LOD;

const _basePosition = /*@__PURE__*/new Vector3();

const _skinIndex = /*@__PURE__*/new Vector4();

const _skinWeight = /*@__PURE__*/new Vector4();

const _vector$5 = /*@__PURE__*/new Vector3();

const _matrix = /*@__PURE__*/new Matrix4();

class SkinnedMesh extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = 'SkinnedMesh';
    this.bindMode = 'attached';
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
  }

  copy(source) {
    super.copy(source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  }

  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;

    if (bindMatrix === undefined) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }

    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }

  pose() {
    this.skeleton.pose();
  }

  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;

    for (let i = 0, l = skinWeight.count; i < l; i++) {
      vector.x = skinWeight.getX(i);
      vector.y = skinWeight.getY(i);
      vector.z = skinWeight.getZ(i);
      vector.w = skinWeight.getW(i);
      const scale = 1.0 / vector.manhattanLength();

      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0); // do something reasonable
      }

      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  }

  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);

    if (this.bindMode === 'attached') {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === 'detached') {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
    }
  }

  boneTransform(index, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;

    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);

    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);

    _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);

    target.set(0, 0, 0);

    for (let i = 0; i < 4; i++) {
      const weight = _skinWeight.getComponent(i);

      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i);

        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);

        target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
      }
    }

    return target.applyMatrix4(this.bindMatrixInverse);
  }

}

exports.SkinnedMesh = SkinnedMesh;
SkinnedMesh.prototype.isSkinnedMesh = true;

class Bone extends Object3D {
  constructor() {
    super();
    this.type = 'Bone';
  }

}

exports.Bone = Bone;
Bone.prototype.isBone = true;

class DataTexture extends Texture {
  constructor(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
      data: data || null,
      width: width || 1,
      height: height || 1
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }

}

exports.DataTexture = DataTexture;
DataTexture.prototype.isDataTexture = true;

const _offsetMatrix = /*@__PURE__*/new Matrix4();

const _identityMatrix = /*@__PURE__*/new Matrix4();

class Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }

  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary

    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      // handle special case
      if (bones.length !== boneInverses.length) {
        console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
        this.boneInverses = [];

        for (let i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }

  calculateInverses() {
    this.boneInverses.length = 0;

    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse = new Matrix4();

      if (this.bones[i]) {
        inverse.copy(this.bones[i].matrixWorld).invert();
      }

      this.boneInverses.push(inverse);
    }
  }

  pose() {
    // recover the bind-time world matrices
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];

      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i]).invert();
      }
    } // compute the local matrices, positions, rotations and scales


    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];

      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }

        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }

  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture; // flatten bone matrices to array

    for (let i = 0, il = bones.length; i < il; i++) {
      // compute the offset between the current and the original transform
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);

      _offsetMatrix.toArray(boneMatrices, i * 16);
    }

    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }

  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }

  computeBoneTexture() {
    // layout (1 matrix = 4 pixels)
    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
    //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
    //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
    //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
    //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
    let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix

    size = ceilPowerOfTwo(size);
    size = Math.max(size, 4);
    const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

    boneMatrices.set(this.boneMatrices); // copy current values

    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    this.boneTextureSize = size;
    return this;
  }

  getBoneByName(name) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];

      if (bone.name === name) {
        return bone;
      }
    }

    return undefined;
  }

  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }

  fromJSON(json, bones) {
    this.uuid = json.uuid;

    for (let i = 0, l = json.bones.length; i < l; i++) {
      const uuid = json.bones[i];
      let bone = bones[uuid];

      if (bone === undefined) {
        console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
        bone = new Bone();
      }

      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
    }

    this.init();
    return this;
  }

  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: 'Skeleton',
        generator: 'Skeleton.toJSON'
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;

    for (let i = 0, l = bones.length; i < l; i++) {
      const bone = bones[i];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i];
      data.boneInverses.push(boneInverse.toArray());
    }

    return data;
  }

}

exports.Skeleton = Skeleton;

const _instanceLocalMatrix = /*@__PURE__*/new Matrix4();

const _instanceWorldMatrix = /*@__PURE__*/new Matrix4();

const _instanceIntersects = [];

const _mesh = /*@__PURE__*/new Mesh();

class InstancedMesh extends Mesh {
  constructor(geometry, material, count) {
    super(geometry, material);
    this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.frustumCulled = false;
  }

  copy(source) {
    super.copy(source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  }

  getColorAt(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  }

  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  }

  raycast(raycaster, intersects) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === undefined) return;

    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      // calculate the world matrix for each instance
      this.getMatrixAt(instanceId, _instanceLocalMatrix);

      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance


      _mesh.matrixWorld = _instanceWorldMatrix;

      _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast


      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
        const intersect = _instanceIntersects[i];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects.push(intersect);
      }

      _instanceIntersects.length = 0;
    }
  }

  setColorAt(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
    }

    color.toArray(this.instanceColor.array, index * 3);
  }

  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  }

  updateMorphTargets() {}

  dispose() {
    this.dispatchEvent({
      type: 'dispose'
    });
  }

}

exports.InstancedMesh = InstancedMesh;
InstancedMesh.prototype.isInstancedMesh = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

class LineBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'LineBasicMaterial';
    this.color = new Color(0xffffff);
    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';
    this.morphTargets = false;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
  }

}

exports.LineBasicMaterial = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;

const _start$1 = /*@__PURE__*/new Vector3();

const _end$1 = /*@__PURE__*/new Vector3();

const _inverseMatrix$1 = /*@__PURE__*/new Matrix4();

const _ray$1 = /*@__PURE__*/new Ray();

const _sphere$1 = /*@__PURE__*/new Sphere();

class Line extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.type = 'Line';
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }

  copy(source) {
    super.copy(source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }

  computeLineDistances() {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      // we assume non-indexed geometry
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];

        for (let i = 1, l = positionAttribute.count; i < l; i++) {
          _start$1.fromBufferAttribute(positionAttribute, i - 1);

          _end$1.fromBufferAttribute(positionAttribute, i);

          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += _start$1.distanceTo(_end$1);
        }

        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
      }
    } else if (geometry.isGeometry) {
      console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }

    return this;
  }

  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere$1.copy(geometry.boundingSphere);

    _sphere$1.applyMatrix4(matrixWorld);

    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return; //

    _inverseMatrix$1.copy(matrixWorld).invert();

    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;

    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;

      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);

        for (let i = start, l = end - 1; i < l; i += step) {
          const a = index.getX(i);
          const b = index.getX(i + 1);
          vStart.fromBufferAttribute(positionAttribute, a);
          vEnd.fromBufferAttribute(positionAttribute, b);

          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

          if (distSq > localThresholdSq) continue;
          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

        for (let i = start, l = end - 1; i < l; i += step) {
          vStart.fromBufferAttribute(positionAttribute, i);
          vEnd.fromBufferAttribute(positionAttribute, i + 1);

          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

          if (distSq > localThresholdSq) continue;
          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
  }

  updateMorphTargets() {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  }

}

exports.Line = Line;
Line.prototype.isLine = true;

const _start = /*@__PURE__*/new Vector3();

const _end = /*@__PURE__*/new Vector3();

class LineSegments extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = 'LineSegments';
  }

  computeLineDistances() {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      // we assume non-indexed geometry
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];

        for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
          _start.fromBufferAttribute(positionAttribute, i);

          _end.fromBufferAttribute(positionAttribute, i + 1);

          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
        }

        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
      }
    } else if (geometry.isGeometry) {
      console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }

    return this;
  }

}

exports.LineSegments = LineSegments;
LineSegments.prototype.isLineSegments = true;

class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = 'LineLoop';
  }

}

exports.LineLoop = LineLoop;
LineLoop.prototype.isLineLoop = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

class PointsMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'PointsMaterial';
    this.color = new Color(0xffffff);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
  }

}

exports.PointsMaterial = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;

const _inverseMatrix = /*@__PURE__*/new Matrix4();

const _ray = /*@__PURE__*/new Ray();

const _sphere = /*@__PURE__*/new Sphere();

const _position$2 = /*@__PURE__*/new Vector3();

class Points extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    super();
    this.type = 'Points';
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }

  copy(source) {
    super.copy(source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }

  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere.copy(geometry.boundingSphere);

    _sphere.applyMatrix4(matrixWorld);

    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //

    _inverseMatrix.copy(matrixWorld).invert();

    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;

    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;

      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);

        for (let i = start, il = end; i < il; i++) {
          const a = index.getX(i);

          _position$2.fromBufferAttribute(positionAttribute, a);

          testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

        for (let i = start, l = end; i < l; i++) {
          _position$2.fromBufferAttribute(positionAttribute, i);

          testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      }
    } else {
      console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
  }

  updateMorphTargets() {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  }

}

exports.Points = Points;
Points.prototype.isPoints = true;

function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);

  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();

    _ray.closestPointToPoint(point, intersectPoint);

    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance: distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index: index,
      face: null,
      object: object
    });
  }
}

class VideoTexture extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== undefined ? format : RGBFormat;
    this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;

    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }

    if ('requestVideoFrameCallback' in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }

  clone() {
    return new this.constructor(this.image).copy(this);
  }

  update() {
    const video = this.image;
    const hasVideoFrameCallback = ('requestVideoFrameCallback' in video);

    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }

}

exports.VideoTexture = VideoTexture;
VideoTexture.prototype.isVideoTexture = true;

class CompressedTexture extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
      width: width,
      height: height
    };
    this.mipmaps = mipmaps; // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )

    this.flipY = false; // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files

    this.generateMipmaps = false;
  }

}

exports.CompressedTexture = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;

class CanvasTexture extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }

}

exports.CanvasTexture = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;

class DepthTexture extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== undefined ? format : DepthFormat;

    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
    }

    if (type === undefined && format === DepthFormat) type = UnsignedShortType;
    if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {
      width: width,
      height: height
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }

}

exports.DepthTexture = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;

class CircleGeometry extends BufferGeometry {
  constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = 'CircleGeometry';
    this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    segments = Math.max(3, segments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    const vertex = new Vector3();
    const uv = new Vector2(); // center point

    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);

    for (let s = 0, i = 3; s <= segments; s++, i += 3) {
      const segment = thetaStart + s / segments * thetaLength; // vertex

      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, 0, 1); // uvs

      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    } // indices


    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

}

exports.CircleGeometry = exports.CircleBufferGeometry = CircleGeometry;

class CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = 'CylinderGeometry';
    this.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0; // generate geometry

    generateTorso();

    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    function generateTorso() {
      const normal = new Vector3();
      const vertex = new Vector3();
      let groupCount = 0; // this will be used to calculate the normal

      const slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments; // calculate the radius of the current row

        const radius = v * (radiusBottom - radiusTop) + radiusTop;

        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta); // vertex

          vertex.x = radius * sinTheta;
          vertex.y = -v * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z); // normal

          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z); // uv

          uvs.push(u, 1 - v); // save index of vertex in respective row

          indexRow.push(index++);
        } // now save vertices of the row in our index array


        indexArray.push(indexRow);
      } // generate indices


      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          // we use the index array to access the correct indices
          const a = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c = indexArray[y + 1][x + 1];
          const d = indexArray[y][x + 1]; // faces

          indices.push(a, b, d);
          indices.push(b, c, d); // update group counter

          groupCount += 6;
        }
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

      groupStart += groupCount;
    }

    function generateCap(top) {
      // save the index of the first center vertex
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.
      // because the geometry needs one set of uvs per face,
      // we must generate a center vertex per face/segment

      for (let x = 1; x <= radialSegments; x++) {
        // vertex
        vertices.push(0, halfHeight * sign, 0); // normal

        normals.push(0, sign, 0); // uv

        uvs.push(0.5, 0.5); // increase index

        index++;
      } // save the index of the last center vertex


      const centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta); // vertex

        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normals.push(0, sign, 0); // uv

        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign + 0.5;
        uvs.push(uv.x, uv.y); // increase index

        index++;
      } // generate indices


      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;

        if (top === true) {
          // face top
          indices.push(i, i + 1, c);
        } else {
          // face bottom
          indices.push(i + 1, i, c);
        }

        groupCount += 3;
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

      groupStart += groupCount;
    }
  }

}

exports.CylinderGeometry = exports.CylinderBufferGeometry = CylinderGeometry;

class ConeGeometry extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = 'ConeGeometry';
    this.parameters = {
      radius: radius,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
  }

}

exports.ConeGeometry = exports.ConeBufferGeometry = ConeGeometry;

class PolyhedronGeometry extends BufferGeometry {
  constructor(vertices, indices, radius = 1, detail = 0) {
    super();
    this.type = 'PolyhedronGeometry';
    this.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    }; // default buffer data

    const vertexBuffer = [];
    const uvBuffer = []; // the subdivision creates the vertex buffer data

    subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

    applyRadius(radius); // finally, create the uv data

    generateUVs(); // build non-indexed geometry

    this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

    if (detail === 0) {
      this.computeVertexNormals(); // flat normals
    } else {
      this.normalizeNormals(); // smooth normals
    } // helper functions


    function subdivide(detail) {
      const a = new Vector3();
      const b = new Vector3();
      const c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value

      for (let i = 0; i < indices.length; i += 3) {
        // get the vertices of the face
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c); // perform subdivision

        subdivideFace(a, b, c, detail);
      }
    }

    function subdivideFace(a, b, c, detail) {
      const cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision

      const v = []; // construct all of the vertices for this subdivision

      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;

        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      } // construct all of the faces


      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);

          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }

    function applyRadius(radius) {
      const vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex

      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        vertex.normalize().multiplyScalar(radius);
        vertexBuffer[i + 0] = vertex.x;
        vertexBuffer[i + 1] = vertex.y;
        vertexBuffer[i + 2] = vertex.z;
      }
    }

    function generateUVs() {
      const vertex = new Vector3();

      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        const u = azimuth(vertex) / 2 / Math.PI + 0.5;
        const v = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }

      correctUVs();
      correctSeam();
    }

    function correctSeam() {
      // handle case when face straddles the seam, see #3269
      for (let i = 0; i < uvBuffer.length; i += 6) {
        // uv data of a single face
        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i + 0] += 1;
          if (x1 < 0.2) uvBuffer[i + 2] += 1;
          if (x2 < 0.2) uvBuffer[i + 4] += 1;
        }
      }
    }

    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }

    function getVertexByIndex(index, vertex) {
      const stride = index * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }

    function correctUVs() {
      const a = new Vector3();
      const b = new Vector3();
      const c = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();

      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }

    function correctUV(uv, stride, vector, azimuth) {
      if (azimuth < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }

      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
      }
    } // Angle around the Y axis, counter-clockwise when looking from above.


    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    } // Angle above the XZ plane.


    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }

}

exports.PolyhedronGeometry = exports.PolyhedronBufferGeometry = PolyhedronGeometry;

class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [// (±1, ±1, ±1)
    -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)
    0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)
    -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)
    -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
    const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    super(vertices, indices, radius, detail);
    this.type = 'DodecahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

}

exports.DodecahedronGeometry = exports.DodecahedronBufferGeometry = DodecahedronGeometry;

const _v0 = new Vector3();

const _v1$1 = new Vector3();

const _normal = new Vector3();

const _triangle = new Triangle();

class EdgesGeometry extends BufferGeometry {
  constructor(geometry, thresholdAngle) {
    super();
    this.type = 'EdgesGeometry';
    this.parameters = {
      thresholdAngle: thresholdAngle
    };
    thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;

    if (geometry.isGeometry === true) {
      console.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      return;
    }

    const precisionPoints = 4;
    const precision = Math.pow(10, precisionPoints);
    const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
    const indexAttr = geometry.getIndex();
    const positionAttr = geometry.getAttribute('position');
    const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
    const indexArr = [0, 0, 0];
    const vertKeys = ['a', 'b', 'c'];
    const hashes = new Array(3);
    const edgeData = {};
    const vertices = [];

    for (let i = 0; i < indexCount; i += 3) {
      if (indexAttr) {
        indexArr[0] = indexAttr.getX(i);
        indexArr[1] = indexAttr.getX(i + 1);
        indexArr[2] = indexAttr.getX(i + 2);
      } else {
        indexArr[0] = i;
        indexArr[1] = i + 1;
        indexArr[2] = i + 2;
      }

      const {
        a,
        b,
        c
      } = _triangle;
      a.fromBufferAttribute(positionAttr, indexArr[0]);
      b.fromBufferAttribute(positionAttr, indexArr[1]);
      c.fromBufferAttribute(positionAttr, indexArr[2]);

      _triangle.getNormal(_normal); // create hashes for the edge from the vertices


      hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
      hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
      hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`; // skip degenerate triangles

      if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
        continue;
      } // iterate over every edge


      for (let j = 0; j < 3; j++) {
        // get the first and next vertex making up the edge
        const jNext = (j + 1) % 3;
        const vecHash0 = hashes[j];
        const vecHash1 = hashes[jNext];
        const v0 = _triangle[vertKeys[j]];
        const v1 = _triangle[vertKeys[jNext]];
        const hash = `${vecHash0}_${vecHash1}`;
        const reverseHash = `${vecHash1}_${vecHash0}`;

        if (reverseHash in edgeData && edgeData[reverseHash]) {
          // if we found a sibling edge add it into the vertex array if
          // it meets the angle threshold and delete the edge from the map.
          if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
            vertices.push(v0.x, v0.y, v0.z);
            vertices.push(v1.x, v1.y, v1.z);
          }

          edgeData[reverseHash] = null;
        } else if (!(hash in edgeData)) {
          // if we've already got an edge here then skip adding a new one
          edgeData[hash] = {
            index0: indexArr[j],
            index1: indexArr[jNext],
            normal: _normal.clone()
          };
        }
      }
    } // iterate over all remaining, unmatched edges and add them to the vertex array


    for (const key in edgeData) {
      if (edgeData[key]) {
        const {
          index0,
          index1
        } = edgeData[key];

        _v0.fromBufferAttribute(positionAttr, index0);

        _v1$1.fromBufferAttribute(positionAttr, index1);

        vertices.push(_v0.x, _v0.y, _v0.z);
        vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
      }
    }

    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  }

}
/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */


exports.EdgesGeometry = EdgesGeometry;
const Earcut = {
  triangulate: function (data, holeIndices, dim) {
    dim = dim || 2;
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];

      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
}; // create a circular doubly linked list from polygon points in the specified winding order

function linkedList(data, start, end, dim, clockwise) {
  let i, last;

  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }

  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }

  return last;
} // eliminate colinear or duplicate points


function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start,
      again;

  do {
    again = false;

    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);

  return end;
} // main ear slicing loop which triangulates a polygon (given as a linked list)


function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return; // interlink polygon nodes in z-order

  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear,
      prev,
      next; // iterate through ears, slicing them one by one

  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;

    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear); // skipping the next vertex leads to less sliver triangles

      ear = next.next;
      stop = next.next;
      continue;
    }

    ear = next; // if we looped through the whole remaining polygon and can't find any more ears

    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }

      break;
    }
  }
} // check whether a polygon node forms a valid ear with adjacent nodes


function isEar(ear) {
  const a = ear.prev,
        b = ear,
        c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear

  let p = ear.next.next;

  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }

  return true;
}

function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev,
        b = ear,
        c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // triangle bbox; min & max are calculated like this for speed

  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
        minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
        maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
        maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

  const minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ,
      n = ear.nextZ; // look for points inside the triangle in both directions

  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  } // look for remaining points in decreasing z-order


  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  } // look for remaining points in increasing z-order


  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  return true;
} // go through all polygon nodes and cure small local self-intersections


function cureLocalIntersections(start, triangles, dim) {
  let p = start;

  do {
    const a = p.prev,
          b = p.next.next;

    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim); // remove two nodes involved

      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }

    p = p.next;
  } while (p !== start);

  return filterPoints(p);
} // try splitting polygon into two and triangulate them independently


function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  let a = start;

  do {
    let b = a.next.next;

    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        let c = splitPolygon(a, b); // filter colinear points around the cuts

        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next); // run earcut on each half

        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }

      b = b.next;
    }

    a = a.next;
  } while (a !== start);
} // link every hole into the outer loop, producing a single-ring polygon without holes


function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list;

  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }

  queue.sort(compareX); // process holes from left to right

  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }

  return outerNode;
}

function compareX(a, b) {
  return a.x - b.x;
} // find a bridge between vertices that connects hole with an outer ring and and link it


function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);

  if (outerNode) {
    const b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
} // David Eberly's algorithm for finding a bridge between hole and outer polygon


function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity,
      m; // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point

  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

      if (x <= hx && x > qx) {
        qx = x;

        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }

        m = p.x < p.next.x ? p : p.next;
      }
    }

    p = p.next;
  } while (p !== outerNode);

  if (!m) return null;
  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  const stop = m,
        mx = m.x,
        my = m.y;
  let tanMin = Infinity,
      tan;
  p = m;

  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }

    p = p.next;
  } while (p !== stop);

  return m;
} // whether sector in vertex m contains sector in vertex p in the same coordinates


function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
} // interlink polygon nodes in z-order


function indexCurve(start, minX, minY, invSize) {
  let p = start;

  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);

  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
} // Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


function sortLinked(list) {
  let i,
      p,
      q,
      e,
      tail,
      numMerges,
      pSize,
      qSize,
      inSize = 1;

  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;

    while (p) {
      numMerges++;
      q = p;
      pSize = 0;

      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }

      qSize = inSize;

      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }

        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }

      p = q;
    }

    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);

  return list;
} // z-order of a point given coords and inverse of the longer side of data bbox


function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
} // find the leftmost node of a polygon ring


function getLeftmost(start) {
  let p = start,
      leftmost = start;

  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);

  return leftmost;
} // check if a point lies within a convex triangle


function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
  area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
} // signed area of a triangle


function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
} // check if two points are equal


function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
} // check if two segments intersect


function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true; // general case

  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  return false;
} // for collinear points p, q, r, check if point q lies on segment pr


function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
} // check if a polygon diagonal intersects any polygon segments


function intersectsPolygon(a, b) {
  let p = a;

  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);

  return false;
} // check if a polygon diagonal is locally inside the polygon


function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
} // check if the middle point of a polygon diagonal is inside the polygon


function middleInside(a, b) {
  let p = a,
      inside = false;
  const px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;

  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);

  return inside;
} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring


function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
} // create a node and optionally link it with previous one (in a circular doubly linked list)


function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);

  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }

  return p;
}

function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
  // vertex index in coordinates array
  this.i = i; // vertex coordinates

  this.x = x;
  this.y = y; // previous and next vertex nodes in a polygon ring

  this.prev = null;
  this.next = null; // z-order curve value

  this.z = null; // previous and next nodes in z-order

  this.prevZ = null;
  this.nextZ = null; // indicates whether this is a steiner point

  this.steiner = false;
}

function signedArea(data, start, end, dim) {
  let sum = 0;

  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }

  return sum;
}

class ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n = contour.length;
    let a = 0.0;

    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }

    return a * 0.5;
  }

  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }

  static triangulateShape(contour, holes) {
    const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

    const holeIndices = []; // array of hole indices

    const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

    removeDupEndPts(contour);
    addContour(vertices, contour); //

    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);

    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    } //


    const triangles = Earcut.triangulate(vertices, holeIndices); //

    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }

    return faces;
  }

}

exports.ShapeUtils = ShapeUtils;

function removeDupEndPts(points) {
  const l = points.length;

  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}

function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */


class ExtrudeGeometry extends BufferGeometry {
  constructor(shapes, options) {
    super();
    this.type = 'ExtrudeGeometry';
    this.parameters = {
      shapes: shapes,
      options: options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];

    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      addShape(shape);
    } // build geometry


    this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals(); // functions

    function addShape(shape) {
      const placeholder = []; // options

      const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      const steps = options.steps !== undefined ? options.steps : 1;
      let depth = options.depth !== undefined ? options.depth : 100;
      let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
      let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
      let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

      if (options.amount !== undefined) {
        console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
        depth = options.amount;
      } //


      let extrudePts,
          extrudeByPath = false;
      let splineTube, binormal, normal, position2;

      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion
        // SETUP TNB variables
        // TODO1 - have a .isClosed in spline?

        splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      } // Safeguards if bevels are not enabled


      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      } // Variables initialization


      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);

      if (reverse) {
        vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];

          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }

      const faces = ShapeUtils.triangulateShape(vertices, holes);
      /* Vertices */

      const contour = vertices; // vertices has all points but contour has only points of circumference

      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }

      function scalePt2(pt, vec, size) {
        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
        return vec.clone().multiplyScalar(size).add(pt);
      }

      const vlen = vertices.length,
            flen = faces.length; // Find directions for point movement

      function getBevelVec(inPt, inPrev, inNext) {
        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.
        let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        const v_prev_x = inPt.x - inPrev.x,
              v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x,
              v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

        if (Math.abs(collinear0) > Number.EPSILON) {
          // not collinear
          // length of vectors for normalizing
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
          //  but prevent crazy spikes

          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          // handle special case of collinear edges
          let direction_eq = false; // assumes: opposite

          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }

          if (direction_eq) {
            // console.log("Warning: lines are a straight sequence");
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            // console.log("Warning: lines are a straight spike");
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }

        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }

      const contourMovements = [];

      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0; //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }

      const holesMovements = [];
      let oneHoleMovements,
          verticesMovements = contourMovements.concat();

      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];

        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il) j = 0;
          if (k === il) k = 0; //  (j)---(i)---(k)

          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }

        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      } // Loop bevelSegments, 1 for the front, 1 for the back


      for (let b = 0; b < bevelSegments; b++) {
        //for ( b = bevelSegments; b > 0; b -- ) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, -z);
        } // expand holes


        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];

          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            v(vert.x, vert.y, -z);
          }
        }
      }

      const bs = bevelSize + bevelOffset; // Back facing vertices

      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      } // Add stepped vertices...
      // Including front facing vertices


      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s);
          } else {
            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      } // Add bevel segments planes
      //for ( b = 1; b <= bevelSegments; b ++ ) {


      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, depth + z);
        } // expand holes


        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];

          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      /* Faces */
      // Top and bottom faces


      buildLidFaces(); // Sides faces

      buildSideFaces(); /////  Internal functions

      function buildLidFaces() {
        const start = verticesArray.length / 3;

        if (bevelEnabled) {
          let layer = 0; // steps + 1

          let offset = vlen * layer; // Bottom faces

          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }

          layer = steps + bevelSegments * 2;
          offset = vlen * layer; // Top faces

          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          // Bottom faces
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          } // Top faces


          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      } // Create faces for the z-sides of the shape


      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;

        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset); //, true

          layeroffset += ahole.length;
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }

      function sidewalls(contour, layeroffset) {
        let i = contour.length;

        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s;
            const slen2 = vlen * (s + 1);
            const a = layeroffset + j + slen1,
                  b = layeroffset + k + slen1,
                  c = layeroffset + k + slen2,
                  d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }

      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }

      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }

      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }

      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }

      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }

  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON$1(shapes, options, data);
  }

}

exports.ExtrudeGeometry = exports.ExtrudeBufferGeometry = ExtrudeGeometry;
const WorldUVGenerator = {
  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
  },
  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];

    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
    } else {
      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
    }
  }
};

function toJSON$1(shapes, options, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}

class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
    const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    super(vertices, indices, radius, detail);
    this.type = 'IcosahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

}

exports.IcosahedronGeometry = exports.IcosahedronBufferGeometry = IcosahedronGeometry;

class LatheGeometry extends BufferGeometry {
  constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = 'LatheGeometry';
    this.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };
    segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]

    phiLength = clamp(phiLength, 0, Math.PI * 2); // buffers

    const indices = [];
    const vertices = [];
    const uvs = []; // helper variables

    const inverseSegments = 1.0 / segments;
    const vertex = new Vector3();
    const uv = new Vector2(); // generate vertices and uvs

    for (let i = 0; i <= segments; i++) {
      const phi = phiStart + i * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);

      for (let j = 0; j <= points.length - 1; j++) {
        // vertex
        vertex.x = points[j].x * sin;
        vertex.y = points[j].y;
        vertex.z = points[j].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z); // uv

        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
      }
    } // indices


    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base = j + i * points.length;
        const a = base;
        const b = base + points.length;
        const c = base + points.length + 1;
        const d = base + 1; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals

    this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
    // because the corresponding vertices are identical (but still have different UVs).

    if (phiLength === Math.PI * 2) {
      const normals = this.attributes.normal.array;
      const n1 = new Vector3();
      const n2 = new Vector3();
      const n = new Vector3(); // this is the buffer offset for the last line of vertices

      const base = segments * points.length * 3;

      for (let i = 0, j = 0; i < points.length; i++, j += 3) {
        // select the normal of the vertex in the first line
        n1.x = normals[j + 0];
        n1.y = normals[j + 1];
        n1.z = normals[j + 2]; // select the normal of the vertex in the last line

        n2.x = normals[base + j + 0];
        n2.y = normals[base + j + 1];
        n2.z = normals[base + j + 2]; // average normals

        n.addVectors(n1, n2).normalize(); // assign the new values to both normals

        normals[j + 0] = normals[base + j + 0] = n.x;
        normals[j + 1] = normals[base + j + 1] = n.y;
        normals[j + 2] = normals[base + j + 2] = n.z;
      }
    }
  }

}

exports.LatheGeometry = exports.LatheBufferGeometry = LatheGeometry;

class OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
    const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    super(vertices, indices, radius, detail);
    this.type = 'OctahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

}
/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */


exports.OctahedronGeometry = exports.OctahedronBufferGeometry = OctahedronGeometry;

class ParametricGeometry extends BufferGeometry {
  constructor(func, slices, stacks) {
    super();
    this.type = 'ParametricGeometry';
    this.parameters = {
      func: func,
      slices: slices,
      stacks: stacks
    }; // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const EPS = 0.00001;
    const normal = new Vector3();
    const p0 = new Vector3(),
          p1 = new Vector3();
    const pu = new Vector3(),
          pv = new Vector3();

    if (func.length < 3) {
      console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
    } // generate vertices, normals and uvs


    const sliceCount = slices + 1;

    for (let i = 0; i <= stacks; i++) {
      const v = i / stacks;

      for (let j = 0; j <= slices; j++) {
        const u = j / slices; // vertex

        func(u, v, p0);
        vertices.push(p0.x, p0.y, p0.z); // normal
        // approximate tangent vectors via finite differences

        if (u - EPS >= 0) {
          func(u - EPS, v, p1);
          pu.subVectors(p0, p1);
        } else {
          func(u + EPS, v, p1);
          pu.subVectors(p1, p0);
        }

        if (v - EPS >= 0) {
          func(u, v - EPS, p1);
          pv.subVectors(p0, p1);
        } else {
          func(u, v + EPS, p1);
          pv.subVectors(p1, p0);
        } // cross product of tangent vectors returns surface normal


        normal.crossVectors(pu, pv).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(u, v);
      }
    } // generate indices


    for (let i = 0; i < stacks; i++) {
      for (let j = 0; j < slices; j++) {
        const a = i * sliceCount + j;
        const b = i * sliceCount + j + 1;
        const c = (i + 1) * sliceCount + j + 1;
        const d = (i + 1) * sliceCount + j; // faces one and two

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

}

exports.ParametricGeometry = exports.ParametricBufferGeometry = ParametricGeometry;

class RingGeometry extends BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = 'RingGeometry';
    this.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // some helper variables

    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex = new Vector3();
    const uv = new Vector2(); // generate vertices, normals and uvs

    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        // values are generate from the inside of the ring to the outside
        const segment = thetaStart + i / thetaSegments * thetaLength; // vertex

        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normals.push(0, 0, 1); // uv

        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      } // increase the radius for next row of vertices


      radius += radiusStep;
    } // indices


    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);

      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel;
        const a = segment;
        const b = segment + thetaSegments + 1;
        const c = segment + thetaSegments + 2;
        const d = segment + 1; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

}

exports.RingGeometry = exports.RingBufferGeometry = RingGeometry;

class ShapeGeometry extends BufferGeometry {
  constructor(shapes, curveSegments = 12) {
    super();
    this.type = 'ShapeGeometry';
    this.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    }; // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let groupStart = 0;
    let groupCount = 0; // allow single and array values for "shapes" parameter

    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

        groupStart += groupCount;
        groupCount = 0;
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions

    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes; // check direction of vertices

      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }

      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];

        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }

      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      } // vertices, normals, uvs


      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex = shapeVertices[i];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y); // world uvs
      } // incides


      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];
        const a = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }

  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }

}

exports.ShapeGeometry = exports.ShapeBufferGeometry = ShapeGeometry;

function toJSON(shapes, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  return data;
}

class SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = 'SphereGeometry';
    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal = new Vector3(); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // generate vertices, normals and uvs

    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments; // special case for the poles

      let uOffset = 0;

      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }

      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments; // vertex

        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }

      grid.push(verticesRow);
    } // indices


    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

}

exports.SphereGeometry = exports.SphereBufferGeometry = SphereGeometry;

class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
    const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(vertices, indices, radius, detail);
    this.type = 'TetrahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

}
/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */


exports.TetrahedronGeometry = exports.TetrahedronBufferGeometry = TetrahedronGeometry;

class TextGeometry extends ExtrudeGeometry {
  constructor(text, parameters = {}) {
    const font = parameters.font;

    if (!(font && font.isFont)) {
      console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
      return new BufferGeometry();
    }

    const shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API

    parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults

    if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
    if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
    if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
    super(shapes, parameters);
    this.type = 'TextGeometry';
  }

}

exports.TextGeometry = exports.TextBufferGeometry = TextGeometry;

class TorusGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
    super();
    this.type = 'TorusGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    const center = new Vector3();
    const vertex = new Vector3();
    const normal = new Vector3(); // generate vertices, normals and uvs

    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2; // vertex

        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    } // generate indices


    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        // indices
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

}

exports.TorusGeometry = exports.TorusBufferGeometry = TorusGeometry;

class TorusKnotGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
    super();
    this.type = 'TorusKnotGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      tubularSegments: tubularSegments,
      radialSegments: radialSegments,
      p: p,
      q: q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    const vertex = new Vector3();
    const normal = new Vector3();
    const P1 = new Vector3();
    const P2 = new Vector3();
    const B = new Vector3();
    const T = new Vector3();
    const N = new Vector3(); // generate vertices, normals and uvs

    for (let i = 0; i <= tubularSegments; ++i) {
      // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
      const u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
      // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

      B.normalize();
      N.normalize();

      for (let j = 0; j <= radialSegments; ++j) {
        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
        const v = j / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v);
        const cy = tube * Math.sin(v); // now calculate the final vertex position.
        // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

        vertex.x = P1.x + (cx * N.x + cy * B.x);
        vertex.y = P1.y + (cx * N.y + cy * B.y);
        vertex.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

        normal.subVectors(vertex, P1).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    } // generate indices


    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        // indices
        const a = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c = (radialSegments + 1) * j + i;
        const d = (radialSegments + 1) * (j - 1) + i; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve

    function calculatePositionOnCurve(u, p, q, radius, position) {
      const cu = Math.cos(u);
      const su = Math.sin(u);
      const quOverP = q / p * u;
      const cs = Math.cos(quOverP);
      position.x = radius * (2 + cs) * 0.5 * cu;
      position.y = radius * (2 + cs) * su * 0.5;
      position.z = radius * Math.sin(quOverP) * 0.5;
    }
  }

}

exports.TorusKnotGeometry = exports.TorusKnotBufferGeometry = TorusKnotGeometry;

class TubeGeometry extends BufferGeometry {
  constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = 'TubeGeometry';
    this.parameters = {
      path: path,
      tubularSegments: tubularSegments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals; // helper variables

    const vertex = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P = new Vector3(); // buffer

    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = []; // create buffer data

    generateBufferData(); // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions

    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      } // if the geometry is not closed, generate the last row of vertices and normals
      // at the regular position on the given path
      //
      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


      generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
      // this makes it easy compute correct values for closed geometries

      generateUVs(); // finally create faces

      generateIndices();
    }

    function generateSegment(i) {
      // we use getPointAt to sample evenly distributed points from the given path
      P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

      const N = frames.normals[i];
      const B = frames.binormals[i]; // generate normals and vertices for the current segment

      for (let j = 0; j <= radialSegments; j++) {
        const v = j / radialSegments * Math.PI * 2;
        const sin = Math.sin(v);
        const cos = -Math.cos(v); // normal

        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z); // vertex

        vertex.x = P.x + radius * normal.x;
        vertex.y = P.y + radius * normal.y;
        vertex.z = P.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }

    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1);
          const b = (radialSegments + 1) * j + (i - 1);
          const c = (radialSegments + 1) * j + i;
          const d = (radialSegments + 1) * (j - 1) + i; // faces

          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }

    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }

  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }

}

exports.TubeGeometry = exports.TubeBufferGeometry = TubeGeometry;

class WireframeGeometry extends BufferGeometry {
  constructor(geometry) {
    super();
    this.type = 'WireframeGeometry';

    if (geometry.isGeometry === true) {
      console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      return;
    } // buffer


    const vertices = []; // helper variables

    const edge = [0, 0],
          edges = {};
    const vertex = new Vector3();

    if (geometry.index !== null) {
      // indexed BufferGeometry
      const position = geometry.attributes.position;
      const indices = geometry.index;
      let groups = geometry.groups;

      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: indices.count,
          materialIndex: 0
        }];
      } // create a data structure that contains all eges without duplicates


      for (let o = 0, ol = groups.length; o < ol; ++o) {
        const group = groups[o];
        const start = group.start;
        const count = group.count;

        for (let i = start, l = start + count; i < l; i += 3) {
          for (let j = 0; j < 3; j++) {
            const edge1 = indices.getX(i + j);
            const edge2 = indices.getX(i + (j + 1) % 3);
            edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates

            edge[1] = Math.max(edge1, edge2);
            const key = edge[0] + ',' + edge[1];

            if (edges[key] === undefined) {
              edges[key] = {
                index1: edge[0],
                index2: edge[1]
              };
            }
          }
        }
      } // generate vertices


      for (const key in edges) {
        const e = edges[key];
        vertex.fromBufferAttribute(position, e.index1);
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex.fromBufferAttribute(position, e.index2);
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else {
      // non-indexed BufferGeometry
      const position = geometry.attributes.position;

      for (let i = 0, l = position.count / 3; i < l; i++) {
        for (let j = 0; j < 3; j++) {
          // three edges per triangle, an edge is represented as (index1, index2)
          // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
          const index1 = 3 * i + j;
          vertex.fromBufferAttribute(position, index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          const index2 = 3 * i + (j + 1) % 3;
          vertex.fromBufferAttribute(position, index2);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
    } // build geometry


    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  }

}

exports.WireframeGeometry = WireframeGeometry;
var Geometries = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BoxGeometry: BoxGeometry,
  BoxBufferGeometry: BoxGeometry,
  CircleGeometry: CircleGeometry,
  CircleBufferGeometry: CircleGeometry,
  ConeGeometry: ConeGeometry,
  ConeBufferGeometry: ConeGeometry,
  CylinderGeometry: CylinderGeometry,
  CylinderBufferGeometry: CylinderGeometry,
  DodecahedronGeometry: DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  EdgesGeometry: EdgesGeometry,
  ExtrudeGeometry: ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  IcosahedronGeometry: IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  LatheGeometry: LatheGeometry,
  LatheBufferGeometry: LatheGeometry,
  OctahedronGeometry: OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronGeometry,
  ParametricGeometry: ParametricGeometry,
  ParametricBufferGeometry: ParametricGeometry,
  PlaneGeometry: PlaneGeometry,
  PlaneBufferGeometry: PlaneGeometry,
  PolyhedronGeometry: PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  RingGeometry: RingGeometry,
  RingBufferGeometry: RingGeometry,
  ShapeGeometry: ShapeGeometry,
  ShapeBufferGeometry: ShapeGeometry,
  SphereGeometry: SphereGeometry,
  SphereBufferGeometry: SphereGeometry,
  TetrahedronGeometry: TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TextGeometry: TextGeometry,
  TextBufferGeometry: TextGeometry,
  TorusGeometry: TorusGeometry,
  TorusBufferGeometry: TorusGeometry,
  TorusKnotGeometry: TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TubeGeometry: TubeGeometry,
  TubeBufferGeometry: TubeGeometry,
  WireframeGeometry: WireframeGeometry
});
/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

class ShadowMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'ShadowMaterial';
    this.color = new Color(0x000000);
    this.transparent = true;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    return this;
  }

}

exports.ShadowMaterial = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;

class RawShaderMaterial extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.type = 'RawShaderMaterial';
  }

}

exports.RawShaderMaterial = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

class MeshStandardMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = {
      'STANDARD': ''
    };
    this.type = 'MeshStandardMaterial';
    this.color = new Color(0xffffff); // diffuse

    this.roughness = 1.0;
    this.metalness = 0.0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1.0;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.vertexTangents = false;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.defines = {
      'STANDARD': ''
    };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    this.vertexTangents = source.vertexTangents;
    return this;
  }

}

exports.MeshStandardMaterial = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *  ior: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> ),
 *
 *  thickness: <float>,
 *  thicknessMap: new THREE.Texture( <Image> ),
 *  attenuationDistance: <float>,
 *  attenuationColor: <Color>
 * }
 */

class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.defines = {
      'STANDARD': '',
      'PHYSICAL': ''
    };
    this.type = 'MeshPhysicalMaterial';
    this.clearcoat = 0.0;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0.0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.reflectivity = 0.5; // maps to F0 = 0.04

    Object.defineProperty(this, 'ior', {
      get: function () {
        return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
      },
      set: function (ior) {
        this.reflectivity = clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
      }
    });
    this.sheen = null; // null will disable sheen bsdf

    this.transmission = 0.0;
    this.transmissionMap = null;
    this.thickness = 0.01;
    this.thicknessMap = null;
    this.attenuationDistance = 0.0;
    this.attenuationColor = new Color(1, 1, 1);
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.defines = {
      'STANDARD': '',
      'PHYSICAL': ''
    };
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.reflectivity = source.reflectivity;

    if (source.sheen) {
      this.sheen = (this.sheen || new Color()).copy(source.sheen);
    } else {
      this.sheen = null;
    }

    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationColor.copy(source.attenuationColor);
    return this;
  }

}

exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

class MeshPhongMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'MeshPhongMaterial';
    this.color = new Color(0xffffff); // diffuse

    this.specular = new Color(0x111111);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }

}

exports.MeshPhongMaterial = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

class MeshToonMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = {
      'TOON': ''
    };
    this.type = 'MeshToonMaterial';
    this.color = new Color(0xffffff);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  }

}

exports.MeshToonMaterial = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;
/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

class MeshNormalMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'MeshNormalMaterial';
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }

}

exports.MeshNormalMaterial = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

class MeshLambertMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = 'MeshLambertMaterial';
    this.color = new Color(0xffffff); // diffuse

    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  }

}

exports.MeshLambertMaterial = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 *
 *  flatShading: <bool>
 * }
 */

class MeshMatcapMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = {
      'MATCAP': ''
    };
    this.type = 'MeshMatcapMaterial';
    this.color = new Color(0xffffff); // diffuse

    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.defines = {
      'MATCAP': ''
    };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }

}

exports.MeshMatcapMaterial = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

class LineDashedMaterial extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.type = 'LineDashedMaterial';
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }

}

exports.LineDashedMaterial = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
var Materials = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ShadowMaterial: ShadowMaterial,
  SpriteMaterial: SpriteMaterial,
  RawShaderMaterial: RawShaderMaterial,
  ShaderMaterial: ShaderMaterial,
  PointsMaterial: PointsMaterial,
  MeshPhysicalMaterial: MeshPhysicalMaterial,
  MeshStandardMaterial: MeshStandardMaterial,
  MeshPhongMaterial: MeshPhongMaterial,
  MeshToonMaterial: MeshToonMaterial,
  MeshNormalMaterial: MeshNormalMaterial,
  MeshLambertMaterial: MeshLambertMaterial,
  MeshDepthMaterial: MeshDepthMaterial,
  MeshDistanceMaterial: MeshDistanceMaterial,
  MeshBasicMaterial: MeshBasicMaterial,
  MeshMatcapMaterial: MeshMatcapMaterial,
  LineDashedMaterial: LineDashedMaterial,
  LineBasicMaterial: LineBasicMaterial,
  Material: Material
});
const AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function (array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      // in ios9 array.subarray(from, undefined) will return empty array
      // but array.subarray(from) or array.subarray(from, len) is correct
      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
    }

    return array.slice(from, to);
  },
  // converts an array to a specific type
  convertArray: function (array, type, forceClone) {
    if (!array || // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type) return array;

    if (typeof type.BYTES_PER_ELEMENT === 'number') {
      return new type(array); // create typed array
    }

    return Array.prototype.slice.call(array); // create Array
  },
  isTypedArray: function (object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function (times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }

    const n = times.length;
    const result = new Array(n);

    for (let i = 0; i !== n; ++i) result[i] = i;

    result.sort(compareTime);
    return result;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function (values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);

    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      const srcOffset = order[i] * stride;

      for (let j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }

    return result;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
    let i = 1,
        key = jsonKeys[0];

    while (key !== undefined && key[valuePropertyName] === undefined) {
      key = jsonKeys[i++];
    }

    if (key === undefined) return; // no data

    let value = key[valuePropertyName];
    if (value === undefined) return; // no data

    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          values.push.apply(values, value); // push all elements
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else if (value.toArray !== undefined) {
      // ...assume THREE.Math-ish
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          value.toArray(values, values.length);
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else {
      // otherwise push as-is
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          values.push(value);
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    }
  },
  subclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name;
    const tracks = [];

    for (let i = 0; i < clip.tracks.length; ++i) {
      const track = clip.tracks[i];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];

      for (let j = 0; j < track.times.length; ++j) {
        const frame = track.times[j] * fps;
        if (frame < startFrame || frame >= endFrame) continue;
        times.push(track.times[j]);

        for (let k = 0; k < valueSize; ++k) {
          values.push(track.values[j * valueSize + k]);
        }
      }

      if (times.length === 0) continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }

    clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip

    let minStartTime = Infinity;

    for (let i = 0; i < clip.tracks.length; ++i) {
      if (minStartTime > clip.tracks[i].times[0]) {
        minStartTime = clip.tracks[i].times[0];
      }
    } // shift all tracks such that clip begins at t=0


    for (let i = 0; i < clip.tracks.length; ++i) {
      clip.tracks[i].shift(-1 * minStartTime);
    }

    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0) fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame

    for (let i = 0; i < numTracks; ++i) {
      const referenceTrack = referenceClip.tracks[i];
      const referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric

      if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track

      const targetTrack = targetClip.tracks.find(function (track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === undefined) continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();

      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }

      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();

      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }

      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue; // Find the value to subtract out of the track

      if (referenceTime <= referenceTrack.times[0]) {
        // Reference frame is earlier than the first keyframe, so just use the first keyframe
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        // Reference frame is after the last keyframe, so just use the last keyframe
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        // Interpolate to the reference value
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      } // Conjugate the quaternion


      if (referenceTrackType === 'quaternion') {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      } // Subtract the reference value from all of the track values


      const numTimes = targetTrack.times.length;

      for (let j = 0; j < numTimes; ++j) {
        const valueStart = j * targetValueSize + targetOffset;

        if (referenceTrackType === 'quaternion') {
          // Multiply the conjugate for quaternion track types
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types

          for (let k = 0; k < valueEnd; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k];
          }
        }
      }
    }

    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

exports.AnimationUtils = AnimationUtils;

class Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }

  evaluate(t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex,
        t1 = pp[i1],
        t0 = pp[i1 - 1];

    validate_interval: {
      seek: {
        let right;

        linear_scan: {
          //- See http://jsperf.com/comparison-to-undefined/3
          //- slower code:
          //-
          //- 				if ( t >= t1 || t1 === undefined ) {
          forward_scan: if (!(t < t1)) {
            for (let giveUpAt = i1 + 2;;) {
              if (t1 === undefined) {
                if (t < t0) break forward_scan; // after end

                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t, t0);
              }

              if (i1 === giveUpAt) break; // this loop

              t0 = t1;
              t1 = pp[++i1];

              if (t < t1) {
                // we have arrived at the sought interval
                break seek;
              }
            } // prepare binary search on the right side of the index


            right = pp.length;
            break linear_scan;
          } //- slower code:
          //-					if ( t < t0 || t0 === undefined ) {


          if (!(t >= t0)) {
            // looping?
            const t1global = pp[1];

            if (t < t1global) {
              i1 = 2; // + 1, using the scan for the details

              t0 = t1global;
            } // linear reverse scan


            for (let giveUpAt = i1 - 2;;) {
              if (t0 === undefined) {
                // before start
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }

              if (i1 === giveUpAt) break; // this loop

              t1 = t0;
              t0 = pp[--i1 - 1];

              if (t >= t0) {
                // we have arrived at the sought interval
                break seek;
              }
            } // prepare binary search on the left side of the index


            right = i1;
            i1 = 0;
            break linear_scan;
          } // the interval is valid


          break validate_interval;
        } // linear scan
        // binary search


        while (i1 < right) {
          const mid = i1 + right >>> 1;

          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }

        t1 = pp[i1];
        t0 = pp[i1 - 1]; // check boundary cases, again

        if (t0 === undefined) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }

        if (t1 === undefined) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      } // seek


      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    } // validate_interval


    return this.interpolate_(i1, t0, t, t1);
  }

  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }

  copySampleValue_(index) {
    // copies a sample value to the result buffer
    const result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset = index * stride;

    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }

    return result;
  } // Template methods for derived classes:


  interpolate_()
  /* i1, t0, t, t1 */
  {
    throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
  }

  intervalChanged_()
  /* i1, t0, t1 */
  {// empty
  }

} // ALIAS DEFINITIONS


exports.Interpolant = Interpolant;
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

class CubicInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }

  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2,
        iNext = i1 + 1,
        tPrev = pp[iPrev],
        tNext = pp[iNext];

    if (tPrev === undefined) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          // f'(t0) = 0
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;

        case WrapAroundEnding:
          // use the other end of the curve
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;

        default:
          // ZeroCurvatureEnding
          // f''(t0) = 0 a.k.a. Natural Spline
          iPrev = i1;
          tPrev = t1;
      }
    }

    if (tNext === undefined) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          // f'(tN) = 0
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;

        case WrapAroundEnding:
          // use the other end of the curve
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;

        default:
          // ZeroCurvatureEnding
          // f''(tN) = 0, a.k.a. Natural Spline
          iNext = i1 - 1;
          tNext = t0;
      }
    }

    const halfDt = (t1 - t0) * 0.5,
          stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }

  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          o1 = i1 * stride,
          o0 = o1 - stride,
          oP = this._offsetPrev,
          oN = this._offsetNext,
          wP = this._weightPrev,
          wN = this._weightNext,
          p = (t - t0) / (t1 - t0),
          pp = p * p,
          ppp = pp * p; // evaluate polynomials

    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp; // combine data linearly

    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }

    return result;
  }

}

exports.CubicInterpolant = CubicInterpolant;

class LinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset1 = i1 * stride,
          offset0 = offset1 - stride,
          weight1 = (t - t0) / (t1 - t0),
          weight0 = 1 - weight1;

    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }

    return result;
  }

}
/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */


exports.LinearInterpolant = LinearInterpolant;

class DiscreteInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  interpolate_(i1
  /*, t0, t, t1 */
  ) {
    return this.copySampleValue_(i1 - 1);
  }

}

exports.DiscreteInterpolant = DiscreteInterpolant;

class KeyframeTrack {
  constructor(name, times, values, interpolation) {
    if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  } // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):


  static toJSON(track) {
    const trackType = track.constructor;
    let json; // derived classes can define a static toJSON method

    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      // by default, we assume the data can be serialized as-is
      json = {
        'name': track.name,
        'times': AnimationUtils.convertArray(track.times, Array),
        'values': AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();

      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }

    json.type = track.ValueTypeName; // mandatory

    return json;
  }

  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }

  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }

  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }

  setInterpolation(interpolation) {
    let factoryMethod;

    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;

      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;

      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }

    if (factoryMethod === undefined) {
      const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;

      if (this.createInterpolant === undefined) {
        // fall back to default, unless the default itself is messed up
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message); // fatal, in this case
        }
      }

      console.warn('THREE.KeyframeTrack:', message);
      return this;
    }

    this.createInterpolant = factoryMethod;
    return this;
  }

  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;

      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;

      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }

  getValueSize() {
    return this.values.length / this.times.length;
  } // move all keyframes either forwards or backwards in time


  shift(timeOffset) {
    if (timeOffset !== 0.0) {
      const times = this.times;

      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }

    return this;
  } // scale all keyframe times by a factor (useful for frame <-> seconds conversions)


  scale(timeScale) {
    if (timeScale !== 1.0) {
      const times = this.times;

      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }

    return this;
  } // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values


  trim(startTime, endTime) {
    const times = this.times,
          nKeys = times.length;
    let from = 0,
        to = nKeys - 1;

    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }

    while (to !== -1 && times[to] > endTime) {
      --to;
    }

    ++to; // inclusive -> exclusive bound

    if (from !== 0 || to !== nKeys) {
      // empty tracks are forbidden, so keep at least one keyframe
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }

      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }

    return this;
  } // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable


  validate() {
    let valid = true;
    const valueSize = this.getValueSize();

    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
      valid = false;
    }

    const times = this.times,
          values = this.values,
          nKeys = times.length;

    if (nKeys === 0) {
      console.error('THREE.KeyframeTrack: Track is empty.', this);
      valid = false;
    }

    let prevTime = null;

    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];

      if (typeof currTime === 'number' && isNaN(currTime)) {
        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
        valid = false;
        break;
      }

      if (prevTime !== null && prevTime > currTime) {
        console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
        valid = false;
        break;
      }

      prevTime = currTime;
    }

    if (values !== undefined) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];

          if (isNaN(value)) {
            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
            valid = false;
            break;
          }
        }
      }
    }

    return valid;
  } // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)


  optimize() {
    // times or values may be shared with other tracks, so overwriting is unsafe
    const times = AnimationUtils.arraySlice(this.times),
          values = AnimationUtils.arraySlice(this.values),
          stride = this.getValueSize(),
          smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
          lastIndex = times.length - 1;
    let writeIndex = 1;

    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time

      if (time !== timeNext && (i !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          // remove unnecessary keyframes same as their neighbors
          const offset = i * stride,
                offsetP = offset - stride,
                offsetN = offset + stride;

          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];

            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      } // in-place compaction


      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride,
                writeOffset = writeIndex * stride;

          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }

        ++writeIndex;
      }
    } // flush last keyframe (compaction looks ahead)


    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];

      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }

      ++writeIndex;
    }

    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }

    return this;
  }

  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.

    track.createInterpolant = this.createInterpolant;
    return track;
  }

}

exports.KeyframeTrack = KeyframeTrack;
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
/**
 * A Track of Boolean keyframe values.
 */

class BooleanKeyframeTrack extends KeyframeTrack {}

exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track of keyframe values that represent color.
 */

class ColorKeyframeTrack extends KeyframeTrack {}

exports.ColorKeyframeTrack = ColorKeyframeTrack;
ColorKeyframeTrack.prototype.ValueTypeName = 'color';
/**
 * A Track of numeric keyframe values.
 */

class NumberKeyframeTrack extends KeyframeTrack {}

exports.NumberKeyframeTrack = NumberKeyframeTrack;
NumberKeyframeTrack.prototype.ValueTypeName = 'number';
/**
 * Spherical linear unit quaternion interpolant.
 */

class QuaternionLinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          alpha = (t - t0) / (t1 - t0);
    let offset = i1 * stride;

    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }

    return result;
  }

}
/**
 * A Track of quaternion keyframe values.
 */


exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;

class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }

}

exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'; // ValueBufferType is inherited

QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track that interpolates Strings
 */

class StringKeyframeTrack extends KeyframeTrack {}

exports.StringKeyframeTrack = StringKeyframeTrack;
StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track of vectored keyframe values.
 */

class VectorKeyframeTrack extends KeyframeTrack {}

exports.VectorKeyframeTrack = VectorKeyframeTrack;
VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

class AnimationClip {
  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID(); // this means it should figure out its duration by scanning the tracks

    if (this.duration < 0) {
      this.resetDuration();
    }
  }

  static parse(json) {
    const tracks = [],
          jsonTracks = json.tracks,
          frameTime = 1.0 / (json.fps || 1.0);

    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }

    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }

  static toJSON(clip) {
    const tracks = [],
          clipTracks = clip.tracks;
    const json = {
      'name': clip.name,
      'duration': clip.duration,
      'tracks': tracks,
      'uuid': clip.uuid,
      'blendMode': clip.blendMode
    };

    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }

    return json;
  }

  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];

    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
      // last frame as well for perfect loop.

      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }

      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
    }

    return new this(name, -1, tracks);
  }

  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;

    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }

    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }

    return null;
  }

  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059

    const pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
    // patterns like Walk_001, Walk_002, Run_001, Run_002

    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);

      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];

        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }

        animationMorphTargets.push(morphTarget);
      }
    }

    const clips = [];

    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }

    return clips;
  } // parse the animation.hierarchy format


  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error('THREE.AnimationClip: No animation in JSONLoader data.');
      return null;
    }

    const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
      // only return track if there are actually keys.
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again

        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };

    const tracks = [];
    const clipName = animation.name || 'default';
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode; // automatic length determination in AnimationClip.

    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];

    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys; // skip empty tracks

      if (!animationKeys || animationKeys.length === 0) continue; // process morph targets

      if (animationKeys[0].morphTargets) {
        // figure out all morph targets used in this track
        const morphTargetNames = {};
        let k;

        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        } // create a track for each morph target with all zero
        // morphTargetInfluences except for the keys in which
        // the morphTarget is named.


        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];

          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            const animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }

          tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
        }

        duration = morphTargetNames.length * (fps || 1.0);
      } else {
        // ...assume skeletal animation
        const boneName = '.bones[' + bones[h].name + ']';
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
      }
    }

    if (tracks.length === 0) {
      return null;
    }

    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }

  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;

    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }

    this.duration = duration;
    return this;
  }

  trim() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }

    return this;
  }

  validate() {
    let valid = true;

    for (let i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }

    return valid;
  }

  optimize() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }

    return this;
  }

  clone() {
    const tracks = [];

    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }

    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }

  toJSON() {
    return this.constructor.toJSON(this);
  }

}

exports.AnimationClip = AnimationClip;

function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return NumberKeyframeTrack;

    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return VectorKeyframeTrack;

    case 'color':
      return ColorKeyframeTrack;

    case 'quaternion':
      return QuaternionKeyframeTrack;

    case 'bool':
    case 'boolean':
      return BooleanKeyframeTrack;

    case 'string':
      return StringKeyframeTrack;
  }

  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}

function parseKeyframeTrack(json) {
  if (json.type === undefined) {
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
  }

  const trackType = getTrackTypeForValueTypeName(json.type);

  if (json.times === undefined) {
    const times = [],
          values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, 'value');
    json.times = times;
    json.values = values;
  } // derived classes can define a static parse method


  if (trackType.parse !== undefined) {
    return trackType.parse(json);
  } else {
    // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}

const Cache = {
  enabled: false,
  files: {},
  add: function (key, file) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[key] = file;
  },
  get: function (key) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[key];
  },
  remove: function (key) {
    delete this.files[key];
  },
  clear: function () {
    this.files = {};
  }
};
exports.Cache = Cache;

class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = undefined;
    const handlers = []; // Refer to #5689 for the reason why we don't set .onStart
    // in the constructor

    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;

    this.itemStart = function (url) {
      itemsTotal++;

      if (isLoading === false) {
        if (scope.onStart !== undefined) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }

      isLoading = true;
    };

    this.itemEnd = function (url) {
      itemsLoaded++;

      if (scope.onProgress !== undefined) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }

      if (itemsLoaded === itemsTotal) {
        isLoading = false;

        if (scope.onLoad !== undefined) {
          scope.onLoad();
        }
      }
    };

    this.itemError = function (url) {
      if (scope.onError !== undefined) {
        scope.onError(url);
      }
    };

    this.resolveURL = function (url) {
      if (urlModifier) {
        return urlModifier(url);
      }

      return url;
    };

    this.setURLModifier = function (transform) {
      urlModifier = transform;
      return this;
    };

    this.addHandler = function (regex, loader) {
      handlers.push(regex, loader);
      return this;
    };

    this.removeHandler = function (regex) {
      const index = handlers.indexOf(regex);

      if (index !== -1) {
        handlers.splice(index, 2);
      }

      return this;
    };

    this.getHandler = function (file) {
      for (let i = 0, l = handlers.length; i < l; i += 2) {
        const regex = handlers[i];
        const loader = handlers[i + 1];
        if (regex.global) regex.lastIndex = 0; // see #17920

        if (regex.test(file)) {
          return loader;
        }
      }

      return null;
    };
  }

}

exports.LoadingManager = LoadingManager;
const DefaultLoadingManager = new LoadingManager();
exports.DefaultLoadingManager = DefaultLoadingManager;

class Loader {
  constructor(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.crossOrigin = 'anonymous';
    this.withCredentials = false;
    this.path = '';
    this.resourcePath = '';
    this.requestHeader = {};
  }

  load()
  /* url, onLoad, onProgress, onError */
  {}

  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function (resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }

  parse()
  /* data */
  {}

  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }

  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }

  setPath(path) {
    this.path = path;
    return this;
  }

  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }

  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }

}

exports.Loader = Loader;
const loading = {};

class FileLoader extends Loader {
  constructor(manager) {
    super(manager);
  }

  load(url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    } // Check if request is duplicate


    if (loading[url] !== undefined) {
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      return;
    } // Check for data: URI


    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    const dataUriRegexResult = url.match(dataUriRegex);
    let request; // Safari can not handle Data URIs through XMLHttpRequest so process manually

    if (dataUriRegexResult) {
      const mimeType = dataUriRegexResult[1];
      const isBase64 = !!dataUriRegexResult[2];
      let data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64) data = atob(data);

      try {
        let response;
        const responseType = (this.responseType || '').toLowerCase();

        switch (responseType) {
          case 'arraybuffer':
          case 'blob':
            const view = new Uint8Array(data.length);

            for (let i = 0; i < data.length; i++) {
              view[i] = data.charCodeAt(i);
            }

            if (responseType === 'blob') {
              response = new Blob([view.buffer], {
                type: mimeType
              });
            } else {
              response = view.buffer;
            }

            break;

          case 'document':
            const parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;

          case 'json':
            response = JSON.parse(data);
            break;

          default:
            // 'text' or other
            response = data;
            break;
        } // Wait for next browser tick like standard XMLHttpRequest event dispatching does


        setTimeout(function () {
          if (onLoad) onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        // Wait for next browser tick like standard XMLHttpRequest event dispatching does
        setTimeout(function () {
          if (onError) onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      // Initialise array for duplicate requests
      loading[url] = [];
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.addEventListener('load', function (event) {
        const response = this.response;
        const callbacks = loading[url];
        delete loading[url];

        if (this.status === 200 || this.status === 0) {
          // Some browsers return HTTP Status 0 when using non-http protocol
          // e.g. 'file://' or 'data://'. Handle as success.
          if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache
          // error response bodies as proper responses to requests.

          Cache.add(url, response);

          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onLoad) callback.onLoad(response);
          }

          scope.manager.itemEnd(url);
        } else {
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onError) callback.onError(event);
          }

          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener('progress', function (event) {
        const callbacks = loading[url];

        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onProgress) callback.onProgress(event);
        }
      }, false);
      request.addEventListener('error', function (event) {
        const callbacks = loading[url];
        delete loading[url];

        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError) callback.onError(event);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener('abort', function (event) {
        const callbacks = loading[url];
        delete loading[url];

        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError) callback.onError(event);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== undefined) request.responseType = this.responseType;
      if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
      if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

      for (const header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }

      request.send(null);
    }

    scope.manager.itemStart(url);
    return request;
  }

  setResponseType(value) {
    this.responseType = value;
    return this;
  }

  setMimeType(value) {
    this.mimeType = value;
    return this;
  }

}

exports.FileLoader = FileLoader;

class AnimationLoader extends Loader {
  constructor(manager) {
    super(manager);
  }

  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function (text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }

  parse(json) {
    const animations = [];

    for (let i = 0; i < json.length; i++) {
      const clip = AnimationClip.parse(json[i]);
      animations.push(clip);
    }

    return animations;
  }

}
/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */


exports.AnimationLoader = AnimationLoader;

class CompressedTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }

  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType('arraybuffer');
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    let loaded = 0;

    function loadTexture(i) {
      loader.load(url[i], function (buffer) {
        const texDatas = scope.parse(buffer, true);
        images[i] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;

        if (loaded === 6) {
          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
          texture.image = images;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, onProgress, onError);
    }

    if (Array.isArray(url)) {
      for (let i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      // compressed cubemap texture stored in a single DDS file
      loader.load(url, function (buffer) {
        const texDatas = scope.parse(buffer, true);

        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

          for (let f = 0; f < faces; f++) {
            images[f] = {
              mipmaps: []
            };

            for (let i = 0; i < texDatas.mipmapCount; i++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }

          texture.image = images;
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }

        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }

        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad) onLoad(texture);
      }, onProgress, onError);
    }

    return texture;
  }

}

exports.CompressedTextureLoader = CompressedTextureLoader;

class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }

  load(url, onLoad, onProgress, onError) {
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }

    const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

    function onImageLoad() {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }

    function onImageError(event) {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }

    image.addEventListener('load', onImageLoad, false);
    image.addEventListener('error', onImageError, false);

    if (url.substr(0, 5) !== 'data:') {
      if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
    }

    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }

}

exports.ImageLoader = ImageLoader;

class CubeTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }

  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;

    function loadTexture(i) {
      loader.load(urls[i], function (image) {
        texture.images[i] = image;
        loaded++;

        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, undefined, onError);
    }

    for (let i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }

    return texture;
  }

}
/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */


exports.CubeTextureLoader = CubeTextureLoader;

class DataTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }

  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType('arraybuffer');
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function (buffer) {
      const texData = scope.parse(buffer);
      if (!texData) return;

      if (texData.image !== undefined) {
        texture.image = texData.image;
      } else if (texData.data !== undefined) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }

      texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

      if (texData.encoding !== undefined) {
        texture.encoding = texData.encoding;
      }

      if (texData.flipY !== undefined) {
        texture.flipY = texData.flipY;
      }

      if (texData.format !== undefined) {
        texture.format = texData.format;
      }

      if (texData.type !== undefined) {
        texture.type = texData.type;
      }

      if (texData.mipmaps !== undefined) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter; // presumably...
      }

      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }

      if (texData.generateMipmaps !== undefined) {
        texture.generateMipmaps = texData.generateMipmaps;
      }

      texture.needsUpdate = true;
      if (onLoad) onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }

}

exports.DataTextureLoader = DataTextureLoader;

class TextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }

  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function (image) {
      texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

      const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;

      if (onLoad !== undefined) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }

}
/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/


exports.TextureLoader = TextureLoader;

class Curve {
  constructor() {
    this.type = 'Curve';
    this.arcLengthDivisions = 200;
  } // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]


  getPoint()
  /* t, optionalTarget */
  {
    console.warn('THREE.Curve: .getPoint() not implemented.');
    return null;
  } // Get point at relative position in curve according to arc length
  // - u [0 .. 1]


  getPointAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  } // Get sequence of points using getPoint( t )


  getPoints(divisions = 5) {
    const points = [];

    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }

    return points;
  } // Get sequence of points using getPointAt( u )


  getSpacedPoints(divisions = 5) {
    const points = [];

    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }

    return points;
  } // Get total curve arc length


  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  } // Get list of cumulative segment lengths


  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }

    this.needsUpdate = false;
    const cache = [];
    let current,
        last = this.getPoint(0);
    let sum = 0;
    cache.push(0);

    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }

    this.cacheArcLengths = cache;
    return cache; // { sums: cache, sum: sum }; Sum is in the last element.
  }

  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  } // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant


  getUtoTmapping(u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength; // The targeted u distance value to get

    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    } // binary search for the index with largest value smaller than target u distance


    let low = 0,
        high = il - 1,
        comparison;

    while (low <= high) {
      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

      comparison = arcLengths[i] - targetArcLength;

      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break; // DONE
      }
    }

    i = high;

    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    } // we could get finer grain at lengths, or use simple interpolation between two points


    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

    const t = (i + segmentFraction) / (il - 1);
    return t;
  } // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation


  getTangent(t, optionalTarget) {
    const delta = 0.0001;
    let t1 = t - delta;
    let t2 = t + delta; // Capping in case of danger

    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }

  getTangentAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  }

  computeFrenetFrames(segments, closed) {
    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4(); // compute the tangent vectors for each segment on the curve

    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3());
      tangents[i].normalize();
    } // select an initial normal vector perpendicular to the first tangent vector,
    // and in the direction of the minimum tangent xyz component


    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);

    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }

    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }

    if (tz <= min) {
      normal.set(0, 0, 1);
    }

    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);

      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }

      binormals[i].crossVectors(tangents[i], normals[i]);
    } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;

      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }

      for (let i = 1; i <= segments; i++) {
        // twist a little...
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }

    return {
      tangents: tangents,
      normals: normals,
      binormals: binormals
    };
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }

  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: 'Curve',
        generator: 'Curve.toJSON'
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }

  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }

}

exports.Curve = Curve;

class EllipseCurve extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.type = 'EllipseCurve';
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }

  getPoint(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

    while (deltaAngle < 0) deltaAngle += twoPi;

    while (deltaAngle > twoPi) deltaAngle -= twoPi;

    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }

    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }

    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);

    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y - this.aY; // Rotate the point about the center of the ellipse.

      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }

    return point.set(x, y);
  }

  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }

}

exports.EllipseCurve = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;

class ArcCurve extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = 'ArcCurve';
  }

}

exports.ArcCurve = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {
  let c0 = 0,
      c1 = 0,
      c2 = 0,
      c3 = 0;
  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */

  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }

  return {
    initCatmullRom: function (x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
      // compute tangents when parameterized in [t1,t2]
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function (t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
} //


const tmp = new Vector3();
const px = new CubicPoly(),
      py = new CubicPoly(),
      pz = new CubicPoly();

class CatmullRomCurve3 extends Curve {
  constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
    super();
    this.type = 'CatmullRomCurve3';
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }

  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;

    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }

    let p0, p3; // 4 points (p1 & p2 defined below)

    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      // extrapolate first point
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }

    const p1 = points[intPoint % l];
    const p2 = points[(intPoint + 1) % l];

    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      // extrapolate last point
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }

    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
      // init Centripetal / Chordal Catmull-Rom
      const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
      let dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

      if (dt1 < 1e-4) dt1 = 1.0;
      if (dt0 < 1e-4) dt0 = dt1;
      if (dt2 < 1e-4) dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === 'catmullrom') {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }

    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.points = [];

    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }

    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.points = [];

    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }

    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];

    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector3().fromArray(point));
    }

    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }

}

exports.CatmullRomCurve3 = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */

function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
} //


function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}

function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}

function QuadraticBezierP2(t, p) {
  return t * t * p;
}

function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
} //


function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}

function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}

function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}

function CubicBezierP3(t, p) {
  return t * t * t * p;
}

function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}

class CubicBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.type = 'CubicBezierCurve';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }

  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2,
          v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }

}

exports.CubicBezierCurve = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;

class CubicBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.type = 'CubicBezierCurve3';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }

  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2,
          v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }

}

exports.CubicBezierCurve3 = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

class LineCurve extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = 'LineCurve';
    this.v1 = v1;
    this.v2 = v2;
  }

  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;

    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }

    return point;
  } // Line curve is linear, so we can overwrite default getPointAt


  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }

  getTangent(t, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  }

  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }

}

exports.LineCurve = LineCurve;
LineCurve.prototype.isLineCurve = true;

class LineCurve3 extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = 'LineCurve3';
    this.isLineCurve3 = true;
    this.v1 = v1;
    this.v2 = v2;
  }

  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;

    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }

    return point;
  } // Line curve is linear, so we can overwrite default getPointAt


  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }

  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }

}

exports.LineCurve3 = LineCurve3;

class QuadraticBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = 'QuadraticBezierCurve';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }

  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }

}

exports.QuadraticBezierCurve = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

class QuadraticBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = 'QuadraticBezierCurve3';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }

  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }

}

exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

class SplineCurve extends Curve {
  constructor(points = []) {
    super();
    this.type = 'SplineCurve';
    this.points = points;
  }

  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.points = [];

    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }

    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.points = [];

    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }

    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];

    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector2().fromArray(point));
    }

    return this;
  }

}

exports.SplineCurve = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;
var Curves = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ArcCurve: ArcCurve,
  CatmullRomCurve3: CatmullRomCurve3,
  CubicBezierCurve: CubicBezierCurve,
  CubicBezierCurve3: CubicBezierCurve3,
  EllipseCurve: EllipseCurve,
  LineCurve: LineCurve,
  LineCurve3: LineCurve3,
  QuadraticBezierCurve: QuadraticBezierCurve,
  QuadraticBezierCurve3: QuadraticBezierCurve3,
  SplineCurve: SplineCurve
});
/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

class CurvePath extends Curve {
  constructor() {
    super();
    this.type = 'CurvePath';
    this.curves = [];
    this.autoClose = false; // Automatically closes the path
  }

  add(curve) {
    this.curves.push(curve);
  }

  closePath() {
    // Add a line curve if start and end of lines are not connected
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);

    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  } // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')


  getPoint(t) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0; // To think about boundaries points.

    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u);
      }

      i++;
    }

    return null; // loop where sum != 0, sum > d , sum+1 <d
  } // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength


  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  } // cacheLengths must be recalculated.


  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  } // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.


  getCurveLengths() {
    // We use cache values if curves and cache array are same length
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    } // Get length of sub-curve
    // Push sums into cached array


    const lengths = [];
    let sums = 0;

    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }

    this.cacheLengths = lengths;
    return lengths;
  }

  getSpacedPoints(divisions = 40) {
    const points = [];

    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }

    if (this.autoClose) {
      points.push(points[0]);
    }

    return points;
  }

  getPoints(divisions = 12) {
    const points = [];
    let last;

    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);

      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

        points.push(point);
        last = point;
      }
    }

    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }

    return points;
  }

  copy(source) {
    super.copy(source);
    this.curves = [];

    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }

    this.autoClose = source.autoClose;
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];

    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }

    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];

    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }

    return this;
  }

}

exports.CurvePath = CurvePath;

class Path extends CurvePath {
  constructor(points) {
    super();
    this.type = 'Path';
    this.currentPoint = new Vector2();

    if (points) {
      this.setFromPoints(points);
    }
  }

  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);

    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }

    return this;
  }

  moveTo(x, y) {
    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

    return this;
  }

  lineTo(x, y) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  }

  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }

  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }

  splineThru(pts
  /*Array of Vector*/
  ) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }

  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }

  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }

  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }

  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

    if (this.curves.length > 0) {
      // if a previous curve is present, attempt to join
      const firstPoint = curve.getPoint(0);

      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }

    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }

  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }

}

exports.Path = Path;

class Shape extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = 'Shape';
    this.holes = [];
  }

  getPointsHoles(divisions) {
    const holesPts = [];

    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }

    return holesPts;
  } // get points of shape and holes (keypoints based on segments parameter)


  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }

  copy(source) {
    super.copy(source);
    this.holes = [];

    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }

    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];

    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }

    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];

    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }

    return this;
  }

}

exports.Shape = Shape;

class Light extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.type = 'Light';
    this.color = new Color(color);
    this.intensity = intensity;
  }

  dispose() {// Empty here in base class; some subclasses override.
  }

  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }

  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== undefined) data.object.distance = this.distance;
    if (this.angle !== undefined) data.object.angle = this.angle;
    if (this.decay !== undefined) data.object.decay = this.decay;
    if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
    if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
    return data;
  }

}

exports.Light = Light;
Light.prototype.isLight = true;

class HemisphereLight extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.type = 'HemisphereLight';
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }

  copy(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }

}

exports.HemisphereLight = HemisphereLight;
HemisphereLight.prototype.isHemisphereLight = true;

const _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();

const _lightPositionWorld$1 = /*@__PURE__*/new Vector3();

const _lookTarget$1 = /*@__PURE__*/new Vector3();

class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [new Vector4(0, 0, 1, 1)];
  }

  getViewportCount() {
    return this._viewportCount;
  }

  getFrustum() {
    return this._frustum;
  }

  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;

    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);

    shadowCamera.position.copy(_lightPositionWorld$1);

    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);

    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();

    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);

    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }

  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }

  getFrameExtents() {
    return this._frameExtents;
  }

  dispose() {
    if (this.map) {
      this.map.dispose();
    }

    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }

  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  toJSON() {
    const object = {};
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }

}

class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }

  updateMatrices(light) {
    const camera = this.camera;
    const fov = RAD2DEG * 2 * light.angle * this.focus;
    const aspect = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;

    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
      camera.fov = fov;
      camera.aspect = aspect;
      camera.far = far;
      camera.updateProjectionMatrix();
    }

    super.updateMatrices(light);
  }

  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }

}

SpotLightShadow.prototype.isSpotLightShadow = true;

class SpotLight extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color, intensity);
    this.type = 'SpotLight';
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay; // for physically correct lights, should be 2.

    this.shadow = new SpotLightShadow();
  }

  get power() {
    // intensity = power per solid angle.
    // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
    return this.intensity * Math.PI;
  }

  set power(power) {
    // intensity = power per solid angle.
    // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
    this.intensity = power / Math.PI;
  }

  dispose() {
    this.shadow.dispose();
  }

  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }

}

exports.SpotLight = SpotLight;
SpotLight.prototype.isSpotLight = true;

const _projScreenMatrix = /*@__PURE__*/new Matrix4();

const _lightPositionWorld = /*@__PURE__*/new Vector3();

const _lookTarget = /*@__PURE__*/new Vector3();

class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [// These viewports map a cube-map onto a 2D texture with the
    // following orientation:
    //
    //  xzXZ
    //   y Y
    //
    // X - Positive x direction
    // x - Negative x direction
    // Y - Positive y direction
    // y - Negative y direction
    // Z - Positive z direction
    // z - Negative z direction
    // positive X
    new Vector4(2, 1, 1, 1), // negative X
    new Vector4(0, 1, 1, 1), // positive Z
    new Vector4(3, 1, 1, 1), // negative Z
    new Vector4(1, 1, 1, 1), // positive Y
    new Vector4(3, 0, 1, 1), // negative Y
    new Vector4(1, 0, 1, 1)];
    this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
    this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
  }

  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;

    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }

    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);

    camera.position.copy(_lightPositionWorld);

    _lookTarget.copy(camera.position);

    _lookTarget.add(this._cubeDirections[viewportIndex]);

    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);

    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }

}

PointLightShadow.prototype.isPointLightShadow = true;

class PointLight extends Light {
  constructor(color, intensity, distance = 0, decay = 1) {
    super(color, intensity);
    this.type = 'PointLight';
    this.distance = distance;
    this.decay = decay; // for physically correct lights, should be 2.

    this.shadow = new PointLightShadow();
  }

  get power() {
    // intensity = power per solid angle.
    // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
    return this.intensity * 4 * Math.PI;
  }

  set power(power) {
    // intensity = power per solid angle.
    // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
    this.intensity = power / (4 * Math.PI);
  }

  dispose() {
    this.shadow.dispose();
  }

  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }

}

exports.PointLight = PointLight;
PointLight.prototype.isPointLight = true;

class OrthographicCamera extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
    super();
    this.type = 'OrthographicCamera';
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }

  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }

  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }

  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }

    this.updateProjectionMatrix();
  }

  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;

    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }

    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }

  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }

}

exports.OrthographicCamera = OrthographicCamera;
OrthographicCamera.prototype.isOrthographicCamera = true;

class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }

}

DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

class DirectionalLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = 'DirectionalLight';
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }

  dispose() {
    this.shadow.dispose();
  }

  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }

}

exports.DirectionalLight = DirectionalLight;
DirectionalLight.prototype.isDirectionalLight = true;

class AmbientLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = 'AmbientLight';
  }

}

exports.AmbientLight = AmbientLight;
AmbientLight.prototype.isAmbientLight = true;

class RectAreaLight extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.type = 'RectAreaLight';
    this.width = width;
    this.height = height;
  }

  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }

  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }

}

exports.RectAreaLight = RectAreaLight;
RectAreaLight.prototype.isRectAreaLight = true;
/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */
// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {
  constructor() {
    this.coefficients = [];

    for (let i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3());
    }
  }

  set(coefficients) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i]);
    }

    return this;
  }

  zero() {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0);
    }

    return this;
  } // get the radiance in the direction of the normal
  // target is a Vector3


  getAt(normal, target) {
    // normal is assumed to be unit length
    const x = normal.x,
          y = normal.y,
          z = normal.z;
    const coeff = this.coefficients; // band 0

    target.copy(coeff[0]).multiplyScalar(0.282095); // band 1

    target.addScaledVector(coeff[1], 0.488603 * y);
    target.addScaledVector(coeff[2], 0.488603 * z);
    target.addScaledVector(coeff[3], 0.488603 * x); // band 2

    target.addScaledVector(coeff[4], 1.092548 * (x * y));
    target.addScaledVector(coeff[5], 1.092548 * (y * z));
    target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
    target.addScaledVector(coeff[7], 1.092548 * (x * z));
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
    return target;
  } // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf


  getIrradianceAt(normal, target) {
    // normal is assumed to be unit length
    const x = normal.x,
          y = normal.y,
          z = normal.z;
    const coeff = this.coefficients; // band 0

    target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095
    // band 1

    target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603

    target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
    target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2

    target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548

    target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3

    target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274

    return target;
  }

  add(sh) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i]);
    }

    return this;
  }

  addScaledSH(sh, s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].addScaledVector(sh.coefficients[i], s);
    }

    return this;
  }

  scale(s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s);
    }

    return this;
  }

  lerp(sh, alpha) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha);
    }

    return this;
  }

  equals(sh) {
    for (let i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false;
      }
    }

    return true;
  }

  copy(sh) {
    return this.set(sh.coefficients);
  }

  clone() {
    return new this.constructor().copy(this);
  }

  fromArray(array, offset = 0) {
    const coefficients = this.coefficients;

    for (let i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset + i * 3);
    }

    return this;
  }

  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients;

    for (let i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset + i * 3);
    }

    return array;
  } // evaluate the basis functions
  // shBasis is an Array[ 9 ]


  static getBasisAt(normal, shBasis) {
    // normal is assumed to be unit length
    const x = normal.x,
          y = normal.y,
          z = normal.z; // band 0

    shBasis[0] = 0.282095; // band 1

    shBasis[1] = 0.488603 * y;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x; // band 2

    shBasis[4] = 1.092548 * x * y;
    shBasis[5] = 1.092548 * y * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x * z;
    shBasis[8] = 0.546274 * (x * x - y * y);
  }

}

exports.SphericalHarmonics3 = SphericalHarmonics3;
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

class LightProbe extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(undefined, intensity);
    this.sh = sh;
  }

  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }

  fromJSON(json) {
    this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();

    this.sh.fromArray(json.sh);
    return this;
  }

  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }

}

exports.LightProbe = LightProbe;
LightProbe.prototype.isLightProbe = true;

class MaterialLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }

  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function (text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }

  parse(json) {
    const textures = this.textures;

    function getTexture(name) {
      if (textures[name] === undefined) {
        console.warn('THREE.MaterialLoader: Undefined texture', name);
      }

      return textures[name];
    }

    const material = new Materials[json.type]();
    if (json.uuid !== undefined) material.uuid = json.uuid;
    if (json.name !== undefined) material.name = json.name;
    if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
    if (json.roughness !== undefined) material.roughness = json.roughness;
    if (json.metalness !== undefined) material.metalness = json.metalness;
    if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
    if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
    if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
    if (json.shininess !== undefined) material.shininess = json.shininess;
    if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
    if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
    if (json.transmission !== undefined) material.transmission = json.transmission;
    if (json.thickness !== undefined) material.thickness = json.thickness;
    if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
    if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);
    if (json.fog !== undefined) material.fog = json.fog;
    if (json.flatShading !== undefined) material.flatShading = json.flatShading;
    if (json.blending !== undefined) material.blending = json.blending;
    if (json.combine !== undefined) material.combine = json.combine;
    if (json.side !== undefined) material.side = json.side;
    if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
    if (json.opacity !== undefined) material.opacity = json.opacity;
    if (json.transparent !== undefined) material.transparent = json.transparent;
    if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
    if (json.depthTest !== undefined) material.depthTest = json.depthTest;
    if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
    if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
    if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
    if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
    if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
    if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
    if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
    if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
    if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
    if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
    if (json.wireframe !== undefined) material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== undefined) material.rotation = json.rotation;
    if (json.linewidth !== 1) material.linewidth = json.linewidth;
    if (json.dashSize !== undefined) material.dashSize = json.dashSize;
    if (json.gapSize !== undefined) material.gapSize = json.gapSize;
    if (json.scale !== undefined) material.scale = json.scale;
    if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
    if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
    if (json.dithering !== undefined) material.dithering = json.dithering;
    if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
    if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
    if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;
    if (json.visible !== undefined) material.visible = json.visible;
    if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
    if (json.userData !== undefined) material.userData = json.userData;

    if (json.vertexColors !== undefined) {
      if (typeof json.vertexColors === 'number') {
        material.vertexColors = json.vertexColors > 0 ? true : false;
      } else {
        material.vertexColors = json.vertexColors;
      }
    } // Shader Material


    if (json.uniforms !== undefined) {
      for (const name in json.uniforms) {
        const uniform = json.uniforms[name];
        material.uniforms[name] = {};

        switch (uniform.type) {
          case 't':
            material.uniforms[name].value = getTexture(uniform.value);
            break;

          case 'c':
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;

          case 'v2':
            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
            break;

          case 'v3':
            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
            break;

          case 'v4':
            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
            break;

          case 'm3':
            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
            break;

          case 'm4':
            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
            break;

          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }

    if (json.defines !== undefined) material.defines = json.defines;
    if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

    if (json.extensions !== undefined) {
      for (const key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    } // Deprecated


    if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
    // for PointsMaterial

    if (json.size !== undefined) material.size = json.size;
    if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps

    if (json.map !== undefined) material.map = getTexture(json.map);
    if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
    if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
    if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
    if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

    if (json.normalScale !== undefined) {
      let normalScale = json.normalScale;

      if (Array.isArray(normalScale) === false) {
        // Blender exporter used to export a scalar. See #7459
        normalScale = [normalScale, normalScale];
      }

      material.normalScale = new Vector2().fromArray(normalScale);
    }

    if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
    if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
    if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
    if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
    if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
    if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
    if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
    if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
    if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
    if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
    if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
    if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
    return material;
  }

  setTextures(value) {
    this.textures = value;
    return this;
  }

}

exports.MaterialLoader = MaterialLoader;

class LoaderUtils {
  static decodeText(array) {
    if (typeof TextDecoder !== 'undefined') {
      return new TextDecoder().decode(array);
    } // Avoid the String.fromCharCode.apply(null, array) shortcut, which
    // throws a "maximum call stack size exceeded" error for large arrays.


    let s = '';

    for (let i = 0, il = array.length; i < il; i++) {
      // Implicitly assumes little-endian.
      s += String.fromCharCode(array[i]);
    }

    try {
      // merges multi-byte utf-8 characters.
      return decodeURIComponent(escape(s));
    } catch (e) {
      // see #16358
      return s;
    }
  }

  static extractUrlBase(url) {
    const index = url.lastIndexOf('/');
    if (index === -1) return './';
    return url.substr(0, index + 1);
  }

}

exports.LoaderUtils = LoaderUtils;

class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super();
    this.type = 'InstancedBufferGeometry';
    this.instanceCount = Infinity;
  }

  copy(source) {
    super.copy(source);
    this.instanceCount = source.instanceCount;
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  toJSON() {
    const data = super.toJSON(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }

}

exports.InstancedBufferGeometry = InstancedBufferGeometry;
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

class InstancedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute) {
    if (typeof normalized === 'number') {
      meshPerAttribute = normalized;
      normalized = false;
      console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
    }

    super(array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute || 1;
  }

  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }

}

exports.InstancedBufferAttribute = InstancedBufferAttribute;
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

class BufferGeometryLoader extends Loader {
  constructor(manager) {
    super(manager);
  }

  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function (text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }

  parse(json) {
    const interleavedBufferMap = {};
    const arrayBufferMap = {};

    function getInterleavedBuffer(json, uuid) {
      if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
      const interleavedBuffers = json.interleavedBuffers;
      const interleavedBuffer = interleavedBuffers[uuid];
      const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
      const array = getTypedArray(interleavedBuffer.type, buffer);
      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
      ib.uuid = interleavedBuffer.uuid;
      interleavedBufferMap[uuid] = ib;
      return ib;
    }

    function getArrayBuffer(json, uuid) {
      if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
      const arrayBuffers = json.arrayBuffers;
      const arrayBuffer = arrayBuffers[uuid];
      const ab = new Uint32Array(arrayBuffer).buffer;
      arrayBufferMap[uuid] = ab;
      return ab;
    }

    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    const index = json.data.index;

    if (index !== undefined) {
      const typedArray = getTypedArray(index.type, index.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }

    const attributes = json.data.attributes;

    for (const key in attributes) {
      const attribute = attributes[key];
      let bufferAttribute;

      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
      } else {
        const typedArray = getTypedArray(attribute.type, attribute.array);
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      }

      if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
      if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);

      if (attribute.updateRange !== undefined) {
        bufferAttribute.updateRange.offset = attribute.updateRange.offset;
        bufferAttribute.updateRange.count = attribute.updateRange.count;
      }

      geometry.setAttribute(key, bufferAttribute);
    }

    const morphAttributes = json.data.morphAttributes;

    if (morphAttributes) {
      for (const key in morphAttributes) {
        const attributeArray = morphAttributes[key];
        const array = [];

        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          let bufferAttribute;

          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array);
            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          }

          if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }

        geometry.morphAttributes[key] = array;
      }
    }

    const morphTargetsRelative = json.data.morphTargetsRelative;

    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true;
    }

    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

    if (groups !== undefined) {
      for (let i = 0, n = groups.length; i !== n; ++i) {
        const group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }

    const boundingSphere = json.data.boundingSphere;

    if (boundingSphere !== undefined) {
      const center = new Vector3();

      if (boundingSphere.center !== undefined) {
        center.fromArray(boundingSphere.center);
      }

      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }

    if (json.name) geometry.name = json.name;
    if (json.userData) geometry.userData = json.userData;
    return geometry;
  }

}

exports.BufferGeometryLoader = BufferGeometryLoader;

class ObjectLoader extends Loader {
  constructor(manager) {
    super(manager);
  }

  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function (text) {
      let json = null;

      try {
        json = JSON.parse(text);
      } catch (error) {
        if (onError !== undefined) onError(error);
        console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
        return;
      }

      const metadata = json.metadata;

      if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
        console.error('THREE.ObjectLoader: Can\'t load ' + url);
        return;
      }

      scope.parse(json, onLoad);
    }, onProgress, onError);
  }

  parse(json, onLoad) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = this.parseImages(json.images, function () {
      if (onLoad !== undefined) onLoad(object);
    });
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons); //

    if (onLoad !== undefined) {
      let hasImages = false;

      for (const uuid in images) {
        if (images[uuid] instanceof HTMLImageElement) {
          hasImages = true;
          break;
        }
      }

      if (hasImages === false) onLoad(object);
    }

    return object;
  }

  parseShapes(json) {
    const shapes = {};

    if (json !== undefined) {
      for (let i = 0, l = json.length; i < l; i++) {
        const shape = new Shape().fromJSON(json[i]);
        shapes[shape.uuid] = shape;
      }
    }

    return shapes;
  }

  parseSkeletons(json, object) {
    const skeletons = {};
    const bones = {}; // generate bone lookup table

    object.traverse(function (child) {
      if (child.isBone) bones[child.uuid] = child;
    }); // create skeletons

    if (json !== undefined) {
      for (let i = 0, l = json.length; i < l; i++) {
        const skeleton = new Skeleton().fromJSON(json[i], bones);
        skeletons[skeleton.uuid] = skeleton;
      }
    }

    return skeletons;
  }

  parseGeometries(json, shapes) {
    const geometries = {};
    let geometryShapes;

    if (json !== undefined) {
      const bufferGeometryLoader = new BufferGeometryLoader();

      for (let i = 0, l = json.length; i < l; i++) {
        let geometry;
        const data = json[i];

        switch (data.type) {
          case 'PlaneGeometry':
          case 'PlaneBufferGeometry':
            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
            break;

          case 'BoxGeometry':
          case 'BoxBufferGeometry':
            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
            break;

          case 'CircleGeometry':
          case 'CircleBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
            break;

          case 'CylinderGeometry':
          case 'CylinderBufferGeometry':
            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;

          case 'ConeGeometry':
          case 'ConeBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;

          case 'SphereGeometry':
          case 'SphereBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
            break;

          case 'DodecahedronGeometry':
          case 'DodecahedronBufferGeometry':
          case 'IcosahedronGeometry':
          case 'IcosahedronBufferGeometry':
          case 'OctahedronGeometry':
          case 'OctahedronBufferGeometry':
          case 'TetrahedronGeometry':
          case 'TetrahedronBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.detail);
            break;

          case 'RingGeometry':
          case 'RingBufferGeometry':
            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
            break;

          case 'TorusGeometry':
          case 'TorusBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
            break;

          case 'TorusKnotGeometry':
          case 'TorusKnotBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
            break;

          case 'TubeGeometry':
          case 'TubeBufferGeometry':
            // This only works for built-in curves (e.g. CatmullRomCurve3).
            // User defined curves or instances of CurvePath will not be deserialized.
            geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
            break;

          case 'LatheGeometry':
          case 'LatheBufferGeometry':
            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
            break;

          case 'PolyhedronGeometry':
          case 'PolyhedronBufferGeometry':
            geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
            break;

          case 'ShapeGeometry':
          case 'ShapeBufferGeometry':
            geometryShapes = [];

            for (let j = 0, jl = data.shapes.length; j < jl; j++) {
              const shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }

            geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
            break;

          case 'ExtrudeGeometry':
          case 'ExtrudeBufferGeometry':
            geometryShapes = [];

            for (let j = 0, jl = data.shapes.length; j < jl; j++) {
              const shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }

            const extrudePath = data.options.extrudePath;

            if (extrudePath !== undefined) {
              data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
            }

            geometry = new Geometries[data.type](geometryShapes, data.options);
            break;

          case 'BufferGeometry':
          case 'InstancedBufferGeometry':
            geometry = bufferGeometryLoader.parse(data);
            break;

          case 'Geometry':
            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
            break;

          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
            continue;
        }

        geometry.uuid = data.uuid;
        if (data.name !== undefined) geometry.name = data.name;
        if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
        geometries[data.uuid] = geometry;
      }
    }

    return geometries;
  }

  parseMaterials(json, textures) {
    const cache = {}; // MultiMaterial

    const materials = {};

    if (json !== undefined) {
      const loader = new MaterialLoader();
      loader.setTextures(textures);

      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];

        if (data.type === 'MultiMaterial') {
          // Deprecated
          const array = [];

          for (let j = 0; j < data.materials.length; j++) {
            const material = data.materials[j];

            if (cache[material.uuid] === undefined) {
              cache[material.uuid] = loader.parse(material);
            }

            array.push(cache[material.uuid]);
          }

          materials[data.uuid] = array;
        } else {
          if (cache[data.uuid] === undefined) {
            cache[data.uuid] = loader.parse(data);
          }

          materials[data.uuid] = cache[data.uuid];
        }
      }
    }

    return materials;
  }

  parseAnimations(json) {
    const animations = {};

    if (json !== undefined) {
      for (let i = 0; i < json.length; i++) {
        const data = json[i];
        const clip = AnimationClip.parse(data);
        animations[clip.uuid] = clip;
      }
    }

    return animations;
  }

  parseImages(json, onLoad) {
    const scope = this;
    const images = {};
    let loader;

    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function () {
        scope.manager.itemEnd(url);
      }, undefined, function () {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }

    function deserializeImage(image) {
      if (typeof image === 'string') {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return loadImage(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height
          };
        } else {
          return null;
        }
      }
    }

    if (json !== undefined && json.length > 0) {
      const manager = new LoadingManager(onLoad);
      loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);

      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i];
        const url = image.url;

        if (Array.isArray(url)) {
          // load array of images e.g CubeTexture
          images[image.uuid] = [];

          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = deserializeImage(currentUrl);

            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                images[image.uuid].push(deserializedImage);
              } else {
                // special case: handle array of data textures for cube textures
                images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
        } else {
          // load single image
          const deserializedImage = deserializeImage(image.url);

          if (deserializedImage !== null) {
            images[image.uuid] = deserializedImage;
          }
        }
      }
    }

    return images;
  }

  parseTextures(json, images) {
    function parseConstant(value, type) {
      if (typeof value === 'number') return value;
      console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
      return type[value];
    }

    const textures = {};

    if (json !== undefined) {
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];

        if (data.image === undefined) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }

        if (images[data.image] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined image', data.image);
        }

        let texture;
        const image = images[data.image];

        if (Array.isArray(image)) {
          texture = new CubeTexture(image);
          if (image.length === 6) texture.needsUpdate = true;
        } else {
          if (image && image.data) {
            texture = new DataTexture(image.data, image.width, image.height);
          } else {
            texture = new Texture(image);
          }

          if (image) texture.needsUpdate = true; // textures can have undefined image data
        }

        texture.uuid = data.uuid;
        if (data.name !== undefined) texture.name = data.name;
        if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.offset !== undefined) texture.offset.fromArray(data.offset);
        if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
        if (data.center !== undefined) texture.center.fromArray(data.center);
        if (data.rotation !== undefined) texture.rotation = data.rotation;

        if (data.wrap !== undefined) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }

        if (data.format !== undefined) texture.format = data.format;
        if (data.type !== undefined) texture.type = data.type;
        if (data.encoding !== undefined) texture.encoding = data.encoding;
        if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
        if (data.flipY !== undefined) texture.flipY = data.flipY;
        if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
        textures[data.uuid] = texture;
      }
    }

    return textures;
  }

  parseObject(data, geometries, materials, animations) {
    let object;

    function getGeometry(name) {
      if (geometries[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined geometry', name);
      }

      return geometries[name];
    }

    function getMaterial(name) {
      if (name === undefined) return undefined;

      if (Array.isArray(name)) {
        const array = [];

        for (let i = 0, l = name.length; i < l; i++) {
          const uuid = name[i];

          if (materials[uuid] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined material', uuid);
          }

          array.push(materials[uuid]);
        }

        return array;
      }

      if (materials[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined material', name);
      }

      return materials[name];
    }

    let geometry, material;

    switch (data.type) {
      case 'Scene':
        object = new Scene();

        if (data.background !== undefined) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          }
        }

        if (data.fog !== undefined) {
          if (data.fog.type === 'Fog') {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === 'FogExp2') {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
        }

        break;

      case 'PerspectiveCamera':
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== undefined) object.focus = data.focus;
        if (data.zoom !== undefined) object.zoom = data.zoom;
        if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
        if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
        if (data.view !== undefined) object.view = Object.assign({}, data.view);
        break;

      case 'OrthographicCamera':
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== undefined) object.zoom = data.zoom;
        if (data.view !== undefined) object.view = Object.assign({}, data.view);
        break;

      case 'AmbientLight':
        object = new AmbientLight(data.color, data.intensity);
        break;

      case 'DirectionalLight':
        object = new DirectionalLight(data.color, data.intensity);
        break;

      case 'PointLight':
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;

      case 'RectAreaLight':
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;

      case 'SpotLight':
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;

      case 'HemisphereLight':
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;

      case 'LightProbe':
        object = new LightProbe().fromJSON(data);
        break;

      case 'SkinnedMesh':
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new SkinnedMesh(geometry, material);
        if (data.bindMode !== undefined) object.bindMode = data.bindMode;
        if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
        if (data.skeleton !== undefined) object.skeleton = data.skeleton;
        break;

      case 'Mesh':
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new Mesh(geometry, material);
        break;

      case 'InstancedMesh':
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        const count = data.count;
        const instanceMatrix = data.instanceMatrix;
        const instanceColor = data.instanceColor;
        object = new InstancedMesh(geometry, material, count);
        object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
        if (instanceColor !== undefined) object.instanceColor = new BufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
        break;

      case 'LOD':
        object = new LOD();
        break;

      case 'Line':
        object = new Line(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'LineLoop':
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'LineSegments':
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'PointCloud':
      case 'Points':
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'Sprite':
        object = new Sprite(getMaterial(data.material));
        break;

      case 'Group':
        object = new Group();
        break;

      case 'Bone':
        object = new Bone();
        break;

      default:
        object = new Object3D();
    }

    object.uuid = data.uuid;
    if (data.name !== undefined) object.name = data.name;

    if (data.matrix !== undefined) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== undefined) object.position.fromArray(data.position);
      if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
      if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
      if (data.scale !== undefined) object.scale.fromArray(data.scale);
    }

    if (data.castShadow !== undefined) object.castShadow = data.castShadow;
    if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

    if (data.shadow) {
      if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
      if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
      if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
    }

    if (data.visible !== undefined) object.visible = data.visible;
    if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
    if (data.userData !== undefined) object.userData = data.userData;
    if (data.layers !== undefined) object.layers.mask = data.layers;

    if (data.children !== undefined) {
      const children = data.children;

      for (let i = 0; i < children.length; i++) {
        object.add(this.parseObject(children[i], geometries, materials, animations));
      }
    }

    if (data.animations !== undefined) {
      const objectAnimations = data.animations;

      for (let i = 0; i < objectAnimations.length; i++) {
        const uuid = objectAnimations[i];
        object.animations.push(animations[uuid]);
      }
    }

    if (data.type === 'LOD') {
      if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
      const levels = data.levels;

      for (let l = 0; l < levels.length; l++) {
        const level = levels[l];
        const child = object.getObjectByProperty('uuid', level.object);

        if (child !== undefined) {
          object.addLevel(child, level.distance);
        }
      }
    }

    return object;
  }

  bindSkeletons(object, skeletons) {
    if (Object.keys(skeletons).length === 0) return;
    object.traverse(function (child) {
      if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
        const skeleton = skeletons[child.skeleton];

        if (skeleton === undefined) {
          console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
        } else {
          child.bind(skeleton, child.bindMatrix);
        }
      }
    });
  }
  /* DEPRECATED */


  setTexturePath(value) {
    console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
    return this.setResourcePath(value);
  }

}

exports.ObjectLoader = ObjectLoader;
const TEXTURE_MAPPING = {
  UVMapping: UVMapping,
  CubeReflectionMapping: CubeReflectionMapping,
  CubeRefractionMapping: CubeRefractionMapping,
  EquirectangularReflectionMapping: EquirectangularReflectionMapping,
  EquirectangularRefractionMapping: EquirectangularRefractionMapping,
  CubeUVReflectionMapping: CubeUVReflectionMapping,
  CubeUVRefractionMapping: CubeUVRefractionMapping
};
const TEXTURE_WRAPPING = {
  RepeatWrapping: RepeatWrapping,
  ClampToEdgeWrapping: ClampToEdgeWrapping,
  MirroredRepeatWrapping: MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
  NearestFilter: NearestFilter,
  NearestMipmapNearestFilter: NearestMipmapNearestFilter,
  NearestMipmapLinearFilter: NearestMipmapLinearFilter,
  LinearFilter: LinearFilter,
  LinearMipmapNearestFilter: LinearMipmapNearestFilter,
  LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

class ImageBitmapLoader extends Loader {
  constructor(manager) {
    super(manager);

    if (typeof createImageBitmap === 'undefined') {
      console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
    }

    if (typeof fetch === 'undefined') {
      console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
    }

    this.options = {
      premultiplyAlpha: 'none'
    };
  }

  setOptions(options) {
    this.options = options;
    return this;
  }

  load(url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }

    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function (res) {
      return res.blob();
    }).then(function (blob) {
      return createImageBitmap(blob, Object.assign(scope.options, {
        colorSpaceConversion: 'none'
      }));
    }).then(function (imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad) onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function (e) {
      if (onError) onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }

}

exports.ImageBitmapLoader = ImageBitmapLoader;
ImageBitmapLoader.prototype.isImageBitmapLoader = true;

class ShapePath {
  constructor() {
    this.type = 'ShapePath';
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }

  moveTo(x, y) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y);
    return this;
  }

  lineTo(x, y) {
    this.currentPath.lineTo(x, y);
    return this;
  }

  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  }

  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  }

  splineThru(pts) {
    this.currentPath.splineThru(pts);
    return this;
  }

  toShapes(isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      const shapes = [];

      for (let i = 0, l = inSubpaths.length; i < l; i++) {
        const tmpPath = inSubpaths[i];
        const tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
      }

      return shapes;
    }

    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length; // inPt on polygon contour => immediate success    or
      // toggling of inside/outside at every single! intersection point of an edge
      //  with the horizontal line through inPt, left of inPt
      //  not counting lowerY endpoints of edges and whole edges on that line

      let inside = false;

      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        let edgeLowPt = inPolygon[p];
        let edgeHighPt = inPolygon[q];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;

        if (Math.abs(edgeDy) > Number.EPSILON) {
          // not parallel
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }

          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
            // continue;				// no intersection or edgeLowPt => doesn't count !!!
          } else {
            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0) return true; // inPt is on contour ?

            if (perpEdge < 0) continue;
            inside = !inside; // true intersection left of inPt
          }
        } else {
          // parallel or collinear
          if (inPt.y !== edgeLowPt.y) continue; // parallel
          // edge lies on the same horizontal line as inPt

          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
          // continue;
        }
      }

      return inside;
    }

    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0) return [];
    if (noHoles === true) return toShapesNoHoles(subPaths);
    let solid, tmpPath, tmpShape;
    const shapes = [];

    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }

    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);

    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = undefined;
    newShapeHoles[mainIdx] = [];

    for (let i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;

      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) mainIdx++;
        newShapes[mainIdx] = {
          s: new Shape(),
          p: tmpPoints
        };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst) mainIdx++;
        newShapeHoles[mainIdx] = []; //console.log('cw', i);
      } else {
        newShapeHoles[mainIdx].push({
          h: tmpPath,
          p: tmpPoints[0]
        }); //console.log('ccw', i);
      }
    } // only Holes? -> probably all Shapes with wrong orientation


    if (!newShapes[0]) return toShapesNoHoles(subPaths);

    if (newShapes.length > 1) {
      let ambiguous = false;
      const toChange = [];

      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }

      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];

        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;

          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) toChange.push({
                froms: sIdx,
                tos: s2Idx,
                hole: hIdx
              });

              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }

          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      } // console.log("ambiguous: ", ambiguous);


      if (toChange.length > 0) {
        // console.log("to change: ", toChange);
        if (!ambiguous) newShapeHoles = betterShapeHoles;
      }
    }

    let tmpHoles;

    for (let i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];

      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    } //console.log("shape", shapes);


    return shapes;
  }

}

exports.ShapePath = ShapePath;

class Font {
  constructor(data) {
    this.type = 'Font';
    this.data = data;
  }

  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);

    for (let p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes());
    }

    return shapes;
  }

}

exports.Font = Font;

function createPaths(text, size, data) {
  const chars = Array.from(text);
  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0,
      offsetY = 0;

  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];

    if (char === '\n') {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }

  return paths;
}

function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs['?'];

  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
    return;
  }

  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

    for (let i = 0, l = outline.length; i < l;) {
      const action = outline[i++];

      switch (action) {
        case 'm':
          // moveTo
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.moveTo(x, y);
          break;

        case 'l':
          // lineTo
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.lineTo(x, y);
          break;

        case 'q':
          // quadraticCurveTo
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;

        case 'b':
          // bezierCurveTo
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }

  return {
    offsetX: glyph.ha * scale,
    path: path
  };
}

Font.prototype.isFont = true;

class FontLoader extends Loader {
  constructor(manager) {
    super(manager);
  }

  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function (text) {
      let json;

      try {
        json = JSON.parse(text);
      } catch (e) {
        console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
        json = JSON.parse(text.substring(65, text.length - 2));
      }

      const font = scope.parse(json);
      if (onLoad) onLoad(font);
    }, onProgress, onError);
  }

  parse(json) {
    return new Font(json);
  }

}

exports.FontLoader = FontLoader;

let _context;

const AudioContext = {
  getContext: function () {
    if (_context === undefined) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }

    return _context;
  },
  setContext: function (value) {
    _context = value;
  }
};
exports.AudioContext = AudioContext;

class AudioLoader extends Loader {
  constructor(manager) {
    super(manager);
  }

  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType('arraybuffer');
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function (buffer) {
      try {
        // Create a copy of the buffer. The `decodeAudioData` method
        // detaches the buffer when complete, preventing reuse.
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function (audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }

}

exports.AudioLoader = AudioLoader;

class HemisphereLightProbe extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(undefined, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );

    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }

}

exports.HemisphereLightProbe = HemisphereLightProbe;
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

class AmbientLightProbe extends LightProbe {
  constructor(color, intensity = 1) {
    super(undefined, intensity);
    const color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );

    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }

}

exports.AmbientLightProbe = AmbientLightProbe;
AmbientLightProbe.prototype.isAmbientLightProbe = true;

const _eyeRight = /*@__PURE__*/new Matrix4();

const _eyeLeft = /*@__PURE__*/new Matrix4();

class StereoCamera {
  constructor() {
    this.type = 'StereoCamera';
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }

  update(camera) {
    const cache = this._cache;
    const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

    if (needsUpdate) {
      cache.focus = camera.focus;
      cache.fov = camera.fov;
      cache.aspect = camera.aspect * this.aspect;
      cache.near = camera.near;
      cache.far = camera.far;
      cache.zoom = camera.zoom;
      cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on
      // http://paulbourke.net/stereographics/stereorender/

      const projectionMatrix = camera.projectionMatrix.clone();
      const eyeSepHalf = cache.eyeSep / 2;
      const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
      const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
      let xmin, xmax; // translate xOffset

      _eyeLeft.elements[12] = -eyeSepHalf;
      _eyeRight.elements[12] = eyeSepHalf; // for left eye

      xmin = -ymax * cache.aspect + eyeSepOnProjection;
      xmax = ymax * cache.aspect + eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye

      xmin = -ymax * cache.aspect - eyeSepOnProjection;
      xmax = ymax * cache.aspect - eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraR.projectionMatrix.copy(projectionMatrix);
    }

    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
  }

}

exports.StereoCamera = StereoCamera;

class Clock {
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }

  start() {
    this.startTime = now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }

  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }

  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }

  getDelta() {
    let diff = 0;

    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }

    if (this.running) {
      const newTime = now();
      diff = (newTime - this.oldTime) / 1000;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }

    return diff;
  }

}

exports.Clock = Clock;

function now() {
  return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
}

const _position$1 = /*@__PURE__*/new Vector3();

const _quaternion$1 = /*@__PURE__*/new Quaternion();

const _scale$1 = /*@__PURE__*/new Vector3();

const _orientation$1 = /*@__PURE__*/new Vector3();

class AudioListener extends Object3D {
  constructor() {
    super();
    this.type = 'AudioListener';
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0; // private

    this._clock = new Clock();
  }

  getInput() {
    return this.gain;
  }

  removeFilter() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }

    return this;
  }

  getFilter() {
    return this.filter;
  }

  setFilter(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }

    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }

  getMasterVolume() {
    return this.gain.gain.value;
  }

  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }

  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);

    _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);

    if (listener.positionX) {
      // code path for Chrome (see #14393)
      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
      listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
    }
  }

}

exports.AudioListener = AudioListener;

class Audio extends Object3D {
  constructor(listener) {
    super();
    this.type = 'Audio';
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = undefined;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = 'empty';
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }

  getOutput() {
    return this.gain;
  }

  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = 'audioNode';
    this.source = audioNode;
    this.connect();
    return this;
  }

  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = 'mediaNode';
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }

  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = 'mediaStreamNode';
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }

  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = 'buffer';
    if (this.autoplay) this.play();
    return this;
  }

  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn('THREE.Audio: Audio is already playing.');
      return;
    }

    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }

  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    if (this.isPlaying === true) {
      // update current progress
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;

      if (this.loop === true) {
        // ensure _progress does not exceed duration with looped audios
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }

      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }

    return this;
  }

  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }

  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);

      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }

      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }

    this._connected = true;
    return this;
  }

  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);

      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }

      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }

    this._connected = false;
    return this;
  }

  getFilters() {
    return this.filters;
  }

  setFilters(value) {
    if (!value) value = [];

    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }

    return this;
  }

  setDetune(value) {
    this.detune = value;
    if (this.source.detune === undefined) return; // only set detune when available

    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }

    return this;
  }

  getDetune() {
    return this.detune;
  }

  getFilter() {
    return this.getFilters()[0];
  }

  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }

  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this.playbackRate = value;

    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }

    return this;
  }

  getPlaybackRate() {
    return this.playbackRate;
  }

  onEnded() {
    this.isPlaying = false;
  }

  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return false;
    }

    return this.loop;
  }

  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this.loop = value;

    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }

    return this;
  }

  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }

  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }

  getVolume() {
    return this.gain.gain.value;
  }

  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }

}

exports.Audio = Audio;

const _position = /*@__PURE__*/new Vector3();

const _quaternion = /*@__PURE__*/new Quaternion();

const _scale = /*@__PURE__*/new Vector3();

const _orientation = /*@__PURE__*/new Vector3();

class PositionalAudio extends Audio {
  constructor(listener) {
    super(listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = 'HRTF';
    this.panner.connect(this.gain);
  }

  getOutput() {
    return this.panner;
  }

  getRefDistance() {
    return this.panner.refDistance;
  }

  setRefDistance(value) {
    this.panner.refDistance = value;
    return this;
  }

  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }

  setRolloffFactor(value) {
    this.panner.rolloffFactor = value;
    return this;
  }

  getDistanceModel() {
    return this.panner.distanceModel;
  }

  setDistanceModel(value) {
    this.panner.distanceModel = value;
    return this;
  }

  getMaxDistance() {
    return this.panner.maxDistance;
  }

  setMaxDistance(value) {
    this.panner.maxDistance = value;
    return this;
  }

  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  }

  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.hasPlaybackControl === true && this.isPlaying === false) return;
    this.matrixWorld.decompose(_position, _quaternion, _scale);

    _orientation.set(0, 0, 1).applyQuaternion(_quaternion);

    const panner = this.panner;

    if (panner.positionX) {
      // code path for Chrome and Firefox (see #14393)
      const endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
    } else {
      panner.setPosition(_position.x, _position.y, _position.z);
      panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
    }
  }

}

exports.PositionalAudio = PositionalAudio;

class AudioAnalyser {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }

  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }

  getAverageFrequency() {
    let value = 0;
    const data = this.getFrequencyData();

    for (let i = 0; i < data.length; i++) {
      value += data[i];
    }

    return value / data.length;
  }

}

exports.AudioAnalyser = AudioAnalyser;

class PropertyMixer {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
    //
    // interpolators can use .buffer as their .result
    // the data then goes to 'incoming'
    //
    // 'accu0' and 'accu1' are used frame-interleaved for
    // the cumulative result and are compared to detect
    // changes
    //
    // 'orig' stores the original state of the property
    //
    // 'add' is used for additive cumulative results
    //
    // 'work' is optional and is only present for quaternion types. It is used
    // to store intermediate quaternion multiplication results

    switch (typeName) {
      case 'quaternion':
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;

      case 'string':
      case 'bool':
        mixFunction = this._select; // Use the regular mix function and for additive on these types,
        // additive is not relevant for non-numeric types

        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;

      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }

    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  } // accumulate data in the 'incoming' region into 'accu<i>'


  accumulate(accuIndex, weight) {
    // note: happily accumulating nothing when weight = 0, the caller knows
    // the weight and shouldn't have made the call in the first place
    const buffer = this.buffer,
          stride = this.valueSize,
          offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;

    if (currentWeight === 0) {
      // accuN := incoming * weight
      for (let i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }

      currentWeight = weight;
    } else {
      // accuN := accuN + incoming * weight
      currentWeight += weight;
      const mix = weight / currentWeight;

      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }

    this.cumulativeWeight = currentWeight;
  } // accumulate data in the 'incoming' region into 'add'


  accumulateAdditive(weight) {
    const buffer = this.buffer,
          stride = this.valueSize,
          offset = stride * this._addIndex;

    if (this.cumulativeWeightAdditive === 0) {
      // add = identity
      this._setIdentity();
    } // add := add + incoming * weight


    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);

    this.cumulativeWeightAdditive += weight;
  } // apply the state of 'accu<i>' to the binding when accus differ


  apply(accuIndex) {
    const stride = this.valueSize,
          buffer = this.buffer,
          offset = accuIndex * stride + stride,
          weight = this.cumulativeWeight,
          weightAdditive = this.cumulativeWeightAdditive,
          binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;

    if (weight < 1) {
      // accuN := accuN + original * ( 1 - cumulativeWeight )
      const originalValueOffset = stride * this._origIndex;

      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }

    if (weightAdditive > 0) {
      // accuN := accuN + additive accuN
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }

    for (let i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        // value has changed -> update scene graph
        binding.setValue(buffer, offset);
        break;
      }
    }
  } // remember the state of the bound property and copy it to both accus


  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer,
          stride = this.valueSize,
          originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original

    for (let i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    } // Add to identity for additive


    this._setIdentity();

    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  } // apply the state previously taken via 'saveOriginalState' to the binding


  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }

  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;

    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0;
    }
  }

  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();

    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }

  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;

    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i];
    }
  } // mix functions


  _select(buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  }

  _slerp(buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  }

  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride; // Store result in intermediate buffer offset

    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result

    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
  }

  _lerp(buffer, dstOffset, srcOffset, t, stride) {
    const s = 1 - t;

    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
    }
  }

  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
    }
  }

} // Characters [].:/ are reserved for track binding syntax.


exports.PropertyMixer = PropertyMixer;
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.


const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';

const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.


const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.


const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.


const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.


const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

const _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');

const _supportedObjectNames = ['material', 'materials', 'bones'];

class Composite {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }

  getValue(array, offset) {
    this.bind(); // bind all binding

    const firstValidIndex = this._targetGroup.nCachedObjects_,
          binding = this._bindings[firstValidIndex]; // and only call .getValue on the first

    if (binding !== undefined) binding.getValue(array, offset);
  }

  setValue(array, offset) {
    const bindings = this._bindings;

    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  }

  bind() {
    const bindings = this._bindings;

    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  }

  unbind() {
    const bindings = this._bindings;

    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }

} // Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.


class PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode; // initial state of these methods that calls 'bind'

    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }

  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */


  static sanitizeNodeName(name) {
    return name.replace(/\s/g, '_').replace(_reservedRe, '');
  }

  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);

    if (!matches) {
      throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
    }

    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

    if (lastDot !== undefined && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there
      // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
      // 'bar' could be the objectName, or part of a nodeName (which can
      // include '.' characters).

      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }

    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
    }

    return results;
  }

  static findNode(root, nodeName) {
    if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    } // search into skeleton bones.


    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);

      if (bone !== undefined) {
        return bone;
      }
    } // search into node subtree.


    if (root.children) {
      const searchNodeSubtree = function (children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i];

          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }

          const result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }

        return null;
      };

      const subTreeNode = searchNodeSubtree(root.children);

      if (subTreeNode) {
        return subTreeNode;
      }
    }

    return null;
  } // these are used to "bind" a nonexistent property


  _getValue_unavailable() {}

  _setValue_unavailable() {} // Getters


  _getValue_direct(buffer, offset) {
    buffer[offset] = this.node[this.propertyName];
  }

  _getValue_array(buffer, offset) {
    const source = this.resolvedProperty;

    for (let i = 0, n = source.length; i !== n; ++i) {
      buffer[offset++] = source[i];
    }
  }

  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }

  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  } // Direct


  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }

  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }

  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  } // EntireArray


  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;

    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
  }

  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;

    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }

    this.targetObject.needsUpdate = true;
  }

  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;

    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }

    this.targetObject.matrixWorldNeedsUpdate = true;
  } // ArrayElement


  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }

  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }

  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  } // HasToFromArray


  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }

  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }

  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }

  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }

  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  } // create getter / setter pair for a property in the scene graph


  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;

    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    } // set fail state so we can just 'return' on error


    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable; // ensure there is a value node

    if (!targetObject) {
      console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
      return;
    }

    if (objectName) {
      let objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....

      switch (objectName) {
        case 'materials':
          if (!targetObject.material) {
            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
            return;
          }

          if (!targetObject.material.materials) {
            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
            return;
          }

          targetObject = targetObject.material.materials;
          break;

        case 'bones':
          if (!targetObject.skeleton) {
            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
            return;
          } // potential future optimization: skip this if propertyIndex is already an integer
          // and convert the integer string to a true integer.


          targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.

          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }

          break;

        default:
          if (targetObject[objectName] === undefined) {
            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
            return;
          }

          targetObject = targetObject[objectName];
      }

      if (objectIndex !== undefined) {
        if (targetObject[objectIndex] === undefined) {
          console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
          return;
        }

        targetObject = targetObject[objectIndex];
      }
    } // resolve property


    const nodeProperty = targetObject[propertyName];

    if (nodeProperty === undefined) {
      const nodeName = parsedPath.nodeName;
      console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
      return;
    } // determine versioning scheme


    let versioning = this.Versioning.None;
    this.targetObject = targetObject;

    if (targetObject.needsUpdate !== undefined) {
      // material
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
      // node transform
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    } // determine how the property gets bound


    let bindingType = this.BindingType.Direct;

    if (propertyIndex !== undefined) {
      // access a sub element of the property array (only primitives are supported right now)
      if (propertyName === 'morphTargetInfluences') {
        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
        // support resolving morphTarget names into indices.
        if (!targetObject.geometry) {
          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
          return;
        }

        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
            return;
          }

          if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
          return;
        }
      }

      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
      // must use copy for Object3D.Euler/Quaternion
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    } // select getter / setter


    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }

  unbind() {
    this.node = null; // back to the prototype version of getValue / setValue
    // note: avoiding to mutate the shape of 'this' via 'delete'

    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }

}

exports.PropertyBinding = PropertyBinding;
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct
PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray
PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement
PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray
PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

class AnimationObjectGroup {
  constructor() {
    this.uuid = generateUUID(); // cached objects followed by the active ones

    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0; // threshold
    // note: read by PropertyBinding.Composite

    const indices = {};
    this._indicesByUUID = indices; // for bookkeeping

    for (let i = 0, n = arguments.length; i !== n; ++i) {
      indices[arguments[i].uuid] = i;
    }

    this._paths = []; // inside: string

    this._parsedPaths = []; // inside: { we don't care, here }

    this._bindings = []; // inside: Array< PropertyBinding >

    this._bindingsIndicesByPath = {}; // inside: indices in these arrays

    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },

        get inUse() {
          return this.total - scope.nCachedObjects_;
        }

      },

      get bindingsPerObject() {
        return scope._bindings.length;
      }

    };
  }

  add() {
    const objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          paths = this._paths,
          parsedPaths = this._parsedPaths,
          bindings = this._bindings,
          nBindings = bindings.length;
    let knownObject = undefined,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_;

    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
            uuid = object.uuid;
      let index = indicesByUUID[uuid];

      if (index === undefined) {
        // unknown object -> add it to the ACTIVE region
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object); // accounting is done, now do the same for all bindings

        for (let j = 0, m = nBindings; j !== m; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index]; // move existing object to the ACTIVE region

        const firstActiveIndex = --nCachedObjects,
              lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings

        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j],
                lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;

          if (binding === undefined) {
            // since we do not bother to create new bindings
            // for objects that are cached, the binding may
            // or may not exist
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }

          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
      } // else the object is already where we want it to be

    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  }

  remove() {
    const objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          bindings = this._bindings,
          nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;

    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
            uuid = object.uuid,
            index = indicesByUUID[uuid];

      if (index !== undefined && index >= nCachedObjects) {
        // move existing object into the CACHED region
        const lastCachedIndex = nCachedObjects++,
              firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings

        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j],
                firstActive = bindingsForPath[lastCachedIndex],
                binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  } // remove & forget


  uncache() {
    const objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          bindings = this._bindings,
          nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_,
        nObjects = objects.length;

    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
            uuid = object.uuid,
            index = indicesByUUID[uuid];

      if (index !== undefined) {
        delete indicesByUUID[uuid];

        if (index < nCachedObjects) {
          // object is cached, shrink the CACHED region
          const firstActiveIndex = --nCachedObjects,
                lastCachedObject = objects[firstActiveIndex],
                lastIndex = --nObjects,
                lastObject = objects[lastIndex]; // last cached object takes this object's place

          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject; // last object goes to the activated slot and pop

          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop(); // accounting is done, now do the same for all bindings

          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j],
                  lastCached = bindingsForPath[firstActiveIndex],
                  last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          // object is active, just swap with the last and pop
          const lastIndex = --nObjects,
                lastObject = objects[lastIndex];

          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index;
          }

          objects[index] = lastObject;
          objects.pop(); // accounting is done, now do the same for all bindings

          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        } // cached or active

      } // if object is known

    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  } // Internal interface used by befriended PropertyBinding.Composite:


  subscribe_(path, parsedPath) {
    // returns an array of bindings for the given path that is changed
    // according to the contained objects in the group
    const indicesByPath = this._bindingsIndicesByPath;
    let index = indicesByPath[path];
    const bindings = this._bindings;
    if (index !== undefined) return bindings[index];
    const paths = this._paths,
          parsedPaths = this._parsedPaths,
          objects = this._objects,
          nObjects = objects.length,
          nCachedObjects = this.nCachedObjects_,
          bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);

    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
      const object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }

    return bindingsForPath;
  }

  unsubscribe_(path) {
    // tells the group to forget about a property path and no longer
    // update the array previously obtained with 'subscribe_'
    const indicesByPath = this._bindingsIndicesByPath,
          index = indicesByPath[path];

    if (index !== undefined) {
      const paths = this._paths,
            parsedPaths = this._parsedPaths,
            bindings = this._bindings,
            lastBindingsIndex = bindings.length - 1,
            lastBindings = bindings[lastBindingsIndex],
            lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }

}

exports.AnimationObjectGroup = AnimationObjectGroup;
AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

class AnimationAction {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks,
          nTracks = tracks.length,
          interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };

    for (let i = 0; i !== nTracks; ++i) {
      const interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }

    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants; // bound by the mixer
    // inside: PropertyMixer (managed by the mixer)

    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null; // for the memory manager

    this._byClipCacheIndex = null; // for the memory manager

    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1; // global mixer time when the action is to be started
    // it's set back to 'null' upon start of the action

    this._startTime = null; // scaled local time of the action
    // gets clamped or wrapped to 0..clip.duration according to loop

    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity; // no. of repetitions when looping

    this.paused = false; // true -> zero effective time scale

    this.enabled = true; // false -> zero effective weight

    this.clampWhenFinished = false; // keep feeding the last frame?

    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate

    this.zeroSlopeAtEnd = true; // clips for start, loop and end
  } // State & Scheduling


  play() {
    this._mixer._activateAction(this);

    return this;
  }

  stop() {
    this._mixer._deactivateAction(this);

    return this.reset();
  }

  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0; // restart clip

    this._loopCount = -1; // forget previous loops

    this._startTime = null; // forget scheduling

    return this.stopFading().stopWarping();
  }

  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  } // return true when play has been called


  isScheduled() {
    return this._mixer._isActiveAction(this);
  }

  startAt(time) {
    this._startTime = time;
    return this;
  }

  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  } // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing


  setEffectiveWeight(weight) {
    this.weight = weight; // note: same logic as when updated at runtime

    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  } // return the weight considering fading and .enabled


  getEffectiveWeight() {
    return this._effectiveWeight;
  }

  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }

  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }

  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);

    if (warp) {
      const fadeInDuration = this._clip.duration,
            fadeOutDuration = fadeOutAction._clip.duration,
            startEndRatio = fadeOutDuration / fadeInDuration,
            endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1.0, startEndRatio, duration);
      this.warp(endStartRatio, 1.0, duration);
    }

    return this;
  }

  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }

  stopFading() {
    const weightInterpolant = this._weightInterpolant;

    if (weightInterpolant !== null) {
      this._weightInterpolant = null;

      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }

    return this;
  } // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing


  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  } // return the time scale considering warping and .paused


  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }

  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }

  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }

  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }

  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer,
          now = mixer.time,
          timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;

    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }

    const times = interpolant.parameterPositions,
          values = interpolant.sampleValues;
    times[0] = now;
    times[1] = now + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }

  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;

    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;

      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }

    return this;
  } // Object Accessors


  getMixer() {
    return this._mixer;
  }

  getClip() {
    return this._clip;
  }

  getRoot() {
    return this._localRoot || this._mixer._root;
  } // Interna


  _update(time, deltaTime, timeDirection, accuIndex) {
    // called by the mixer
    if (!this.enabled) {
      // call ._updateWeight() to update ._effectiveWeight
      this._updateWeight(time);

      return;
    }

    const startTime = this._startTime;

    if (startTime !== null) {
      // check for scheduled start of action
      const timeRunning = (time - startTime) * timeDirection;

      if (timeRunning < 0 || timeDirection === 0) {
        return; // yet to come / don't decide when delta = 0
      } // start


      this._startTime = null; // unschedule

      deltaTime = timeDirection * timeRunning;
    } // apply time scale and advance time


    deltaTime *= this._updateTimeScale(time);

    const clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
    // an effective weight of 0


    const weight = this._updateWeight(time);

    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;

      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }

          break;

        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }

      }
    }
  }

  _updateWeight(time) {
    let weight = 0;

    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;

      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;

        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();

          if (interpolantValue === 0) {
            // faded out, disable
            this.enabled = false;
          }
        }
      }
    }

    this._effectiveWeight = weight;
    return weight;
  }

  _updateTimeScale(time) {
    let timeScale = 0;

    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;

      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;

        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();

          if (timeScale === 0) {
            // motion has halted, pause
            this.paused = true;
          } else {
            // warp done - apply final time scale
            this.timeScale = timeScale;
          }
        }
      }
    }

    this._effectiveTimeScale = timeScale;
    return timeScale;
  }

  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;

    if (deltaTime === 0) {
      if (loopCount === -1) return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }

    if (loop === LoopOnce) {
      if (loopCount === -1) {
        // just started
        this._loopCount = 0;

        this._setEndings(true, true, false);
      }

      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }

        if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
        this.time = time;

        this._mixer.dispatchEvent({
          type: 'finished',
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      // repetitive Repeat or PingPong
      if (loopCount === -1) {
        // just started
        if (deltaTime >= 0) {
          loopCount = 0;

          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          // when looping in reverse direction, the initial
          // transition through zero counts as a repetition,
          // so leave loopCount at -1
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }

      if (time >= duration || time < 0) {
        // wrap around
        const loopDelta = Math.floor(time / duration); // signed

        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;

        if (pending <= 0) {
          // have to stop (switch state, clamp time, fire event)
          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;

          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          // keep running
          if (pending === 1) {
            // entering the last round
            const atStart = deltaTime < 0;

            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }

          this._loopCount = loopCount;
          this.time = time;

          this._mixer.dispatchEvent({
            type: 'loop',
            action: this,
            loopDelta: loopDelta
          });
        }
      } else {
        this.time = time;
      }

      if (pingPong && (loopCount & 1) === 1) {
        // invert time for the "pong round"
        return duration - time;
      }
    }

    return time;
  }

  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;

    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      // assuming for LoopOnce atStart == atEnd == true
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }

      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }

  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer,
          now = mixer.time;
    let interpolant = this._weightInterpolant;

    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }

    const times = interpolant.parameterPositions,
          values = interpolant.sampleValues;
    times[0] = now;
    values[0] = weightNow;
    times[1] = now + duration;
    values[1] = weightThen;
    return this;
  }

}

class AnimationMixer extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;

    this._initMemoryManager();

    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1.0;
  }

  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root,
          tracks = action._clip.tracks,
          nTracks = tracks.length,
          bindings = action._propertyBindings,
          interpolants = action._interpolants,
          rootUuid = root.uuid,
          bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];

    if (bindingsByName === undefined) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }

    for (let i = 0; i !== nTracks; ++i) {
      const track = tracks[i],
            trackName = track.name;
      let binding = bindingsByName[trackName];

      if (binding !== undefined) {
        bindings[i] = binding;
      } else {
        binding = bindings[i];

        if (binding !== undefined) {
          // existing binding, make sure the cache knows
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;

            this._addInactiveBinding(binding, rootUuid, trackName);
          }

          continue;
        }

        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;

        this._addInactiveBinding(binding, rootUuid, trackName);

        bindings[i] = binding;
      }

      interpolants[i].resultBuffer = binding.buffer;
    }
  }

  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        // this action has been forgotten by the cache, but the user
        // appears to be still using it -> rebind
        const rootUuid = (action._localRoot || this._root).uuid,
              clipUuid = action._clip.uuid,
              actionsForClip = this._actionsByClip[clipUuid];

        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

        this._addInactiveAction(action, clipUuid, rootUuid);
      }

      const bindings = action._propertyBindings; // increment reference counts / sort out state

      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];

        if (binding.useCount++ === 0) {
          this._lendBinding(binding);

          binding.saveOriginalState();
        }
      }

      this._lendAction(action);
    }
  }

  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings; // decrement reference counts / sort out state

      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];

        if (--binding.useCount === 0) {
          binding.restoreOriginalState();

          this._takeBackBinding(binding);
        }
      }

      this._takeBackAction(action);
    }
  } // Memory manager


  _initMemoryManager() {
    this._actions = []; // 'nActiveActions' followed by inactive ones

    this._nActiveActions = 0;
    this._actionsByClip = {}; // inside:
    // {
    // 	knownActions: Array< AnimationAction > - used as prototypes
    // 	actionByRoot: AnimationAction - lookup
    // }

    this._bindings = []; // 'nActiveBindings' followed by inactive ones

    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

    this._controlInterpolants = []; // same game as above

    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },

        get inUse() {
          return scope._nActiveActions;
        }

      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },

        get inUse() {
          return scope._nActiveBindings;
        }

      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },

        get inUse() {
          return scope._nActiveControlInterpolants;
        }

      }
    };
  } // Memory management for AnimationAction objects


  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }

  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions,
          actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];

    if (actionsForClip === undefined) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }

    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }

  _removeInactiveAction(action) {
    const actions = this._actions,
          lastInactiveAction = actions[actions.length - 1],
          cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid],
          knownActionsForClip = actionsForClip.knownActions,
          lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
          byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot,
          rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];

    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }

    this._removeInactiveBindingsForAction(action);
  }

  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;

    for (let i = 0, n = bindings.length; i !== n; ++i) {
      const binding = bindings[i];

      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }

  _lendAction(action) {
    // [ active actions |  inactive actions  ]
    // [  active actions >| inactive actions ]
    //                 s        a
    //                  <-swap->
    //                 a        s
    const actions = this._actions,
          prevIndex = action._cacheIndex,
          lastActiveIndex = this._nActiveActions++,
          firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }

  _takeBackAction(action) {
    // [  active actions  | inactive actions ]
    // [ active actions |< inactive actions  ]
    //        a        s
    //         <-swap->
    //        s        a
    const actions = this._actions,
          prevIndex = action._cacheIndex,
          firstInactiveIndex = --this._nActiveActions,
          lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  } // Memory management for PropertyMixer objects


  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName,
          bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];

    if (bindingByName === undefined) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }

    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }

  _removeInactiveBinding(binding) {
    const bindings = this._bindings,
          propBinding = binding.binding,
          rootUuid = propBinding.rootNode.uuid,
          trackName = propBinding.path,
          bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid],
          lastInactiveBinding = bindings[bindings.length - 1],
          cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];

    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }

  _lendBinding(binding) {
    const bindings = this._bindings,
          prevIndex = binding._cacheIndex,
          lastActiveIndex = this._nActiveBindings++,
          firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }

  _takeBackBinding(binding) {
    const bindings = this._bindings,
          prevIndex = binding._cacheIndex,
          firstInactiveIndex = --this._nActiveBindings,
          lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  } // Memory management of Interpolants for weight and time scale


  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants,
          lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];

    if (interpolant === undefined) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }

    return interpolant;
  }

  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants,
          prevIndex = interpolant.__cacheIndex,
          firstInactiveIndex = --this._nActiveControlInterpolants,
          lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  } // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)


  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root,
          rootUuid = root.uuid;
    let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;

    if (blendMode === undefined) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }

    if (actionsForClip !== undefined) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];

      if (existingAction !== undefined && existingAction.blendMode === blendMode) {
        return existingAction;
      } // we know the clip, so we don't have to parse all
      // the bindings again but can just copy


      prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action

      if (clipObject === null) clipObject = prototypeAction._clip;
    } // clip must be known when specified via string


    if (clipObject === null) return null; // allocate all resources required to run it

    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);

    this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager


    this._addInactiveAction(newAction, clipUuid, rootUuid);

    return newAction;
  } // get an existing action


  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root,
          rootUuid = root.uuid,
          clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
          clipUuid = clipObject ? clipObject.uuid : clip,
          actionsForClip = this._actionsByClip[clipUuid];

    if (actionsForClip !== undefined) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }

    return null;
  } // deactivates all previously scheduled actions


  stopAllAction() {
    const actions = this._actions,
          nActions = this._nActiveActions;

    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop();
    }

    return this;
  } // advance the time and update apply the animation


  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions,
          nActions = this._nActiveActions,
          time = this.time += deltaTime,
          timeDirection = Math.sign(deltaTime),
          accuIndex = this._accuIndex ^= 1; // run active actions

    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i];

      action._update(time, deltaTime, timeDirection, accuIndex);
    } // update scene graph


    const bindings = this._bindings,
          nBindings = this._nActiveBindings;

    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }

    return this;
  } // Allows you to seek to a specific time in an animation.


  setTime(timeInSeconds) {
    this.time = 0; // Zero out time attribute for AnimationMixer object;

    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
    }

    return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
  } // return this mixer's root target object


  getRoot() {
    return this._root;
  } // free all resources specific to a particular clip


  uncacheClip(clip) {
    const actions = this._actions,
          clipUuid = clip.uuid,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid];

    if (actionsForClip !== undefined) {
      // note: just calling _removeInactiveAction would mess up the
      // iteration state and also require updating the state we can
      // just throw away
      const actionsToRemove = actionsForClip.knownActions;

      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
        const action = actionsToRemove[i];

        this._deactivateAction(action);

        const cacheIndex = action._cacheIndex,
              lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();

        this._removeInactiveBindingsForAction(action);
      }

      delete actionsByClip[clipUuid];
    }
  } // free all resources specific to a particular root target object


  uncacheRoot(root) {
    const rootUuid = root.uuid,
          actionsByClip = this._actionsByClip;

    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot,
            action = actionByRoot[rootUuid];

      if (action !== undefined) {
        this._deactivateAction(action);

        this._removeInactiveAction(action);
      }
    }

    const bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid];

    if (bindingByName !== undefined) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();

        this._removeInactiveBinding(binding);
      }
    }
  } // remove a targeted clip from the cache


  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);

    if (action !== null) {
      this._deactivateAction(action);

      this._removeInactiveAction(action);
    }
  }

}

exports.AnimationMixer = AnimationMixer;
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);

class Uniform {
  constructor(value) {
    if (typeof value === 'string') {
      console.warn('THREE.Uniform: Type parameter is no longer needed.');
      value = arguments[1];
    }

    this.value = value;
  }

  clone() {
    return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
  }

}

exports.Uniform = Uniform;

class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(array, stride, meshPerAttribute = 1) {
    super(array, stride);
    this.meshPerAttribute = meshPerAttribute || 1;
  }

  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }

  clone(data) {
    const ib = super.clone(data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  }

  toJSON(data) {
    const json = super.toJSON(data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }

}

exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

class GLBufferAttribute {
  constructor(buffer, type, itemSize, elementSize, count) {
    this.buffer = buffer;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.version = 0;
  }

  set needsUpdate(value) {
    if (value === true) this.version++;
  }

  setBuffer(buffer) {
    this.buffer = buffer;
    return this;
  }

  setType(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  }

  setItemSize(itemSize) {
    this.itemSize = itemSize;
    return this;
  }

  setCount(count) {
    this.count = count;
    return this;
  }

}

exports.GLBufferAttribute = GLBufferAttribute;
GLBufferAttribute.prototype.isGLBufferAttribute = true;

class Raycaster {
  constructor(origin, direction, near = 0, far = Infinity) {
    this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: {
        threshold: 1
      },
      LOD: {},
      Points: {
        threshold: 1
      },
      Sprite: {}
    };
  }

  set(origin, direction) {
    // direction is assumed to be normalized (for accurate distance calculations)
    this.ray.set(origin, direction);
  }

  setFromCamera(coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
    }
  }

  intersectObject(object, recursive = false, intersects = []) {
    intersectObject(object, this, intersects, recursive);
    intersects.sort(ascSort);
    return intersects;
  }

  intersectObjects(objects, recursive = false, intersects = []) {
    for (let i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects, recursive);
    }

    intersects.sort(ascSort);
    return intersects;
  }

}

exports.Raycaster = Raycaster;

function ascSort(a, b) {
  return a.distance - b.distance;
}

function intersectObject(object, raycaster, intersects, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects);
  }

  if (recursive === true) {
    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects, true);
    }
  }
}
/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */


class Spherical {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi; // polar angle

    this.theta = theta; // azimuthal angle

    return this;
  }

  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }

  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  } // restrict phi to be betwee EPS and PI-EPS


  makeSafe() {
    const EPS = 0.000001;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }

  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }

  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);

    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(clamp(y / this.radius, -1, 1));
    }

    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

}
/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */


exports.Spherical = Spherical;

class Cylindrical {
  constructor(radius = 1, theta = 0, y = 0) {
    this.radius = radius; // distance from the origin to a point in the x-z plane

    this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis

    this.y = y; // height above the x-z plane

    return this;
  }

  set(radius, theta, y) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  }

  copy(other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  }

  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }

  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + z * z);
    this.theta = Math.atan2(x, z);
    this.y = y;
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

}

exports.Cylindrical = Cylindrical;

const _vector$4 = /*@__PURE__*/new Vector2();

class Box2 {
  constructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }

  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }

  setFromPoints(points) {
    this.makeEmpty();

    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  }

  setFromCenterAndSize(center, size) {
    const halfSize = _vector$4.copy(size).multiplyScalar(0.5);

    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }

  makeEmpty() {
    this.min.x = this.min.y = +Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }

  isEmpty() {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }

  getCenter(target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .getCenter() target is now required');
      target = new Vector2();
    }

    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }

  getSize(target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .getSize() target is now required');
      target = new Vector2();
    }

    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  }

  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }

  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }

  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }

  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  }

  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  }

  getParameter(point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    if (target === undefined) {
      console.warn('THREE.Box2: .getParameter() target is now required');
      target = new Vector2();
    }

    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  }

  intersectsBox(box) {
    // using 4 splitting planes to rule out intersections
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  }

  clampPoint(point, target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .clampPoint() target is now required');
      target = new Vector2();
    }

    return target.copy(point).clamp(this.min, this.max);
  }

  distanceToPoint(point) {
    const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);

    return clampedPoint.sub(point).length();
  }

  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  }

  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }

  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }

  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }

}

exports.Box2 = Box2;
Box2.prototype.isBox2 = true;

const _startP = /*@__PURE__*/new Vector3();

const _startEnd = /*@__PURE__*/new Vector3();

class Line3 {
  constructor(start = new Vector3(), end = new Vector3()) {
    this.start = start;
    this.end = end;
  }

  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }

  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }

  getCenter(target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .getCenter() target is now required');
      target = new Vector3();
    }

    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }

  delta(target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .delta() target is now required');
      target = new Vector3();
    }

    return target.subVectors(this.end, this.start);
  }

  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }

  distance() {
    return this.start.distanceTo(this.end);
  }

  at(t, target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .at() target is now required');
      target = new Vector3();
    }

    return this.delta(target).multiplyScalar(t).add(this.start);
  }

  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);

    _startEnd.subVectors(this.end, this.start);

    const startEnd2 = _startEnd.dot(_startEnd);

    const startEnd_startP = _startEnd.dot(_startP);

    let t = startEnd_startP / startEnd2;

    if (clampToLine) {
      t = clamp(t, 0, 1);
    }

    return t;
  }

  closestPointToPoint(point, clampToLine, target) {
    const t = this.closestPointToPointParameter(point, clampToLine);

    if (target === undefined) {
      console.warn('THREE.Line3: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    return this.delta(target).multiplyScalar(t).add(this.start);
  }

  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }

  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }

  clone() {
    return new this.constructor().copy(this);
  }

}

exports.Line3 = Line3;

class ImmediateRenderObject extends Object3D {
  constructor(material) {
    super();
    this.material = material;

    this.render = function ()
    /* renderCallback */
    {};

    this.hasPositions = false;
    this.hasNormals = false;
    this.hasColors = false;
    this.hasUvs = false;
    this.positionArray = null;
    this.normalArray = null;
    this.colorArray = null;
    this.uvArray = null;
    this.count = 0;
  }

}

exports.ImmediateRenderObject = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;

const _vector$3 = /*@__PURE__*/new Vector3();

class SpotLightHelper extends Object3D {
  constructor(light, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new BufferGeometry();
    const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

    for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
      const p1 = i / l * Math.PI * 2;
      const p2 = j / l * Math.PI * 2;
      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }

    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    const material = new LineBasicMaterial({
      fog: false,
      toneMapped: false
    });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
  }

  dispose() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }

  update() {
    this.light.updateMatrixWorld();
    const coneLength = this.light.distance ? this.light.distance : 1000;
    const coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);

    _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);

    this.cone.lookAt(_vector$3);

    if (this.color !== undefined) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  }

}

exports.SpotLightHelper = SpotLightHelper;

const _vector$2 = /*@__PURE__*/new Vector3();

const _boneMatrix = /*@__PURE__*/new Matrix4();

const _matrixWorldInv = /*@__PURE__*/new Matrix4();

class SkeletonHelper extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);

    for (let i = 0; i < bones.length; i++) {
      const bone = bones[i];

      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }

    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      depthTest: false,
      depthWrite: false,
      toneMapped: false,
      transparent: true
    });
    super(geometry, material);
    this.type = 'SkeletonHelper';
    this.isSkeletonHelper = true;
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }

  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute('position');

    _matrixWorldInv.copy(this.root.matrixWorld).invert();

    for (let i = 0, j = 0; i < bones.length; i++) {
      const bone = bones[i];

      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);

        _vector$2.setFromMatrixPosition(_boneMatrix);

        position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);

        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);

        _vector$2.setFromMatrixPosition(_boneMatrix);

        position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
        j += 2;
      }
    }

    geometry.getAttribute('position').needsUpdate = true;
    super.updateMatrixWorld(force);
  }

}

exports.SkeletonHelper = SkeletonHelper;

function getBoneList(object) {
  const boneList = [];

  if (object && object.isBone) {
    boneList.push(object);
  }

  for (let i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }

  return boneList;
}

class PointLightHelper extends Mesh {
  constructor(light, sphereSize, color) {
    const geometry = new SphereGeometry(sphereSize, 4, 2);
    const material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false
    });
    super(geometry, material);
    this.light = light;
    this.light.updateMatrixWorld();
    this.color = color;
    this.type = 'PointLightHelper';
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
    /*
    // TODO: delete this comment?
    const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
    const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
    this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
    this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
    const d = light.distance;
    if ( d === 0.0 ) {
    	this.lightDistance.visible = false;
    } else {
    	this.lightDistance.scale.set( d, d, d );
    }
    this.add( this.lightDistance );
    */
  }

  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }

  update() {
    if (this.color !== undefined) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }
    /*
    const d = this.light.distance;
    	if ( d === 0.0 ) {
    		this.lightDistance.visible = false;
    	} else {
    		this.lightDistance.visible = true;
    	this.lightDistance.scale.set( d, d, d );
    	}
    */

  }

}

exports.PointLightHelper = PointLightHelper;

const _vector$1 = /*@__PURE__*/new Vector3();

const _color1 = /*@__PURE__*/new Color();

const _color2 = /*@__PURE__*/new Color();

class HemisphereLightHelper extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new OctahedronGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false
    });
    if (this.color === undefined) this.material.vertexColors = true;
    const position = geometry.getAttribute('position');
    const colors = new Float32Array(position.count * 3);
    geometry.setAttribute('color', new BufferAttribute(colors, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
  }

  dispose() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }

  update() {
    const mesh = this.children[0];

    if (this.color !== undefined) {
      this.material.color.set(this.color);
    } else {
      const colors = mesh.geometry.getAttribute('color');

      _color1.copy(this.light.color);

      _color2.copy(this.light.groundColor);

      for (let i = 0, l = colors.count; i < l; i++) {
        const color = i < l / 2 ? _color1 : _color2;
        colors.setXYZ(i, color.r, color.g, color.b);
      }

      colors.needsUpdate = true;
    }

    mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
  }

}

exports.HemisphereLightHelper = HemisphereLightHelper;

class GridHelper extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [],
          colors = [];

    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      const color = i === center ? color1 : color2;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
    }

    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    super(geometry, material);
    this.type = 'GridHelper';
  }

}

exports.GridHelper = GridHelper;

class PolarGridHelper extends LineSegments {
  constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const vertices = [];
    const colors = []; // create the radials

    for (let i = 0; i <= radials; i++) {
      const v = i / radials * (Math.PI * 2);
      const x = Math.sin(v) * radius;
      const z = Math.cos(v) * radius;
      vertices.push(0, 0, 0);
      vertices.push(x, 0, z);
      const color = i & 1 ? color1 : color2;
      colors.push(color.r, color.g, color.b);
      colors.push(color.r, color.g, color.b);
    } // create the circles


    for (let i = 0; i <= circles; i++) {
      const color = i & 1 ? color1 : color2;
      const r = radius - radius / circles * i;

      for (let j = 0; j < divisions; j++) {
        // first vertex
        let v = j / divisions * (Math.PI * 2);
        let x = Math.sin(v) * r;
        let z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color.r, color.g, color.b); // second vertex

        v = (j + 1) / divisions * (Math.PI * 2);
        x = Math.sin(v) * r;
        z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color.r, color.g, color.b);
      }
    }

    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    super(geometry, material);
    this.type = 'PolarGridHelper';
  }

}

exports.PolarGridHelper = PolarGridHelper;

const _v1 = /*@__PURE__*/new Vector3();

const _v2 = /*@__PURE__*/new Vector3();

const _v3 = /*@__PURE__*/new Vector3();

class DirectionalLightHelper extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    if (size === undefined) size = 1;
    let geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
    const material = new LineBasicMaterial({
      fog: false,
      toneMapped: false
    });
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  }

  dispose() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  }

  update() {
    _v1.setFromMatrixPosition(this.light.matrixWorld);

    _v2.setFromMatrixPosition(this.light.target.matrixWorld);

    _v3.subVectors(_v2, _v1);

    this.lightPlane.lookAt(_v2);

    if (this.color !== undefined) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }

    this.targetLine.lookAt(_v2);
    this.targetLine.scale.z = _v3.length();
  }

}

exports.DirectionalLightHelper = DirectionalLightHelper;

const _vector = /*@__PURE__*/new Vector3();

const _camera = /*@__PURE__*/new Camera();
/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */


class CameraHelper extends LineSegments {
  constructor(camera) {
    const geometry = new BufferGeometry();
    const material = new LineBasicMaterial({
      color: 0xffffff,
      vertexColors: true,
      toneMapped: false
    });
    const vertices = [];
    const colors = [];
    const pointMap = {}; // colors

    const colorFrustum = new Color(0xffaa00);
    const colorCone = new Color(0xff0000);
    const colorUp = new Color(0x00aaff);
    const colorTarget = new Color(0xffffff);
    const colorCross = new Color(0x333333); // near

    addLine('n1', 'n2', colorFrustum);
    addLine('n2', 'n4', colorFrustum);
    addLine('n4', 'n3', colorFrustum);
    addLine('n3', 'n1', colorFrustum); // far

    addLine('f1', 'f2', colorFrustum);
    addLine('f2', 'f4', colorFrustum);
    addLine('f4', 'f3', colorFrustum);
    addLine('f3', 'f1', colorFrustum); // sides

    addLine('n1', 'f1', colorFrustum);
    addLine('n2', 'f2', colorFrustum);
    addLine('n3', 'f3', colorFrustum);
    addLine('n4', 'f4', colorFrustum); // cone

    addLine('p', 'n1', colorCone);
    addLine('p', 'n2', colorCone);
    addLine('p', 'n3', colorCone);
    addLine('p', 'n4', colorCone); // up

    addLine('u1', 'u2', colorUp);
    addLine('u2', 'u3', colorUp);
    addLine('u3', 'u1', colorUp); // target

    addLine('c', 't', colorTarget);
    addLine('p', 'c', colorCross); // cross

    addLine('cn1', 'cn2', colorCross);
    addLine('cn3', 'cn4', colorCross);
    addLine('cf1', 'cf2', colorCross);
    addLine('cf3', 'cf4', colorCross);

    function addLine(a, b, color) {
      addPoint(a, color);
      addPoint(b, color);
    }

    function addPoint(id, color) {
      vertices.push(0, 0, 0);
      colors.push(color.r, color.g, color.b);

      if (pointMap[id] === undefined) {
        pointMap[id] = [];
      }

      pointMap[id].push(vertices.length / 3 - 1);
    }

    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    super(geometry, material);
    this.type = 'CameraHelper';
    this.camera = camera;
    if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
  }

  update() {
    const geometry = this.geometry;
    const pointMap = this.pointMap;
    const w = 1,
          h = 1; // we need just camera projection matrix inverse
    // world matrix must be identity

    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target


    setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
    setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near

    setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
    setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
    setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
    setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far

    setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
    setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
    setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
    setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up

    setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
    setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
    setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross

    setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
    setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
    setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
    setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
    setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
    setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
    setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
    setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
    geometry.getAttribute('position').needsUpdate = true;
  }

  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }

}

exports.CameraHelper = CameraHelper;

function setPoint(point, pointMap, geometry, camera, x, y, z) {
  _vector.set(x, y, z).unproject(camera);

  const points = pointMap[point];

  if (points !== undefined) {
    const position = geometry.getAttribute('position');

    for (let i = 0, l = points.length; i < l; i++) {
      position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
    }
  }
}

const _box = /*@__PURE__*/new Box3();

class BoxHelper extends LineSegments {
  constructor(object, color = 0xffff00) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = new Float32Array(8 * 3);
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.object = object;
    this.type = 'BoxHelper';
    this.matrixAutoUpdate = false;
    this.update();
  }

  update(object) {
    if (object !== undefined) {
      console.warn('THREE.BoxHelper: .update() has no longer arguments.');
    }

    if (this.object !== undefined) {
      _box.setFromObject(this.object);
    }

    if (_box.isEmpty()) return;
    const min = _box.min;
    const max = _box.max;
    /*
    	5____4
    1/___0/|
    | 6__|_7
    2/___3/
    	0: max.x, max.y, max.z
    1: min.x, max.y, max.z
    2: min.x, min.y, max.z
    3: max.x, min.y, max.z
    4: max.x, max.y, min.z
    5: min.x, max.y, min.z
    6: min.x, min.y, min.z
    7: max.x, min.y, min.z
    */

    const position = this.geometry.attributes.position;
    const array = position.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  }

  setFromObject(object) {
    this.object = object;
    this.update();
    return this;
  }

  copy(source) {
    LineSegments.prototype.copy.call(this, source);
    this.object = source.object;
    return this;
  }

}

exports.BoxHelper = BoxHelper;

class Box3Helper extends LineSegments {
  constructor(box, color = 0xffff00) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.box = box;
    this.type = 'Box3Helper';
    this.geometry.computeBoundingSphere();
  }

  updateMatrixWorld(force) {
    const box = this.box;
    if (box.isEmpty()) return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    super.updateMatrixWorld(force);
  }

}

exports.Box3Helper = Box3Helper;

class PlaneHelper extends Line {
  constructor(plane, size = 1, hex = 0xffff00) {
    const color = hex;
    const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    super(geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.type = 'PlaneHelper';
    this.plane = plane;
    this.size = size;
    const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({
      color: color,
      opacity: 0.2,
      transparent: true,
      depthWrite: false,
      toneMapped: false
    })));
  }

  updateMatrixWorld(force) {
    let scale = -this.plane.constant;
    if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

    this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
    this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

    this.lookAt(this.plane.normal);
    super.updateMatrixWorld(force);
  }

}

exports.PlaneHelper = PlaneHelper;

const _axis = /*@__PURE__*/new Vector3();

let _lineGeometry, _coneGeometry;

class ArrowHelper extends Object3D {
  // dir is assumed to be normalized
  constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {
    super();
    this.type = 'ArrowHelper';

    if (_lineGeometry === undefined) {
      _lineGeometry = new BufferGeometry();

      _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);

      _coneGeometry.translate(0, -0.5, 0);
    }

    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
  }

  setDirection(dir) {
    // dir is assumed to be normalized
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();

      const radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians);
    }
  }

  setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
    this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458

    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
  }

  setColor(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
  }

  copy(source) {
    super.copy(source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  }

}

exports.ArrowHelper = ArrowHelper;

class AxesHelper extends LineSegments {
  constructor(size = 1) {
    const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
    const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    super(geometry, material);
    this.type = 'AxesHelper';
  }

  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }

}

exports.AxesHelper = AxesHelper;

const _floatView = new Float32Array(1);

const _int32View = new Int32Array(_floatView.buffer);

class DataUtils {
  // Converts float32 to float16 (stored as uint16 value).
  static toHalfFloat(val) {
    // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

    /* This method is faster than the OpenEXR implementation (very often
    * used, eg. in Ogre), with the additional benefit of rounding, inspired
    * by James Tursa?s half-precision code. */
    _floatView[0] = val;
    const x = _int32View[0];
    let bits = x >> 16 & 0x8000;
    /* Get the sign */

    let m = x >> 12 & 0x07ff;
    /* Keep one extra bit for rounding */

    const e = x >> 23 & 0xff;
    /* Using int is faster here */

    /* If zero, or denormal, or exponent underflows too much for a denormal
    	* half, return signed zero. */

    if (e < 103) return bits;
    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */

    if (e > 142) {
      bits |= 0x7c00;
      /* If exponent was 0xff and one mantissa bit was set, it means NaN,
      			* not Inf, so make sure we set one mantissa bit too. */

      bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
      return bits;
    }
    /* If exponent underflows but not too much, return a denormal */


    if (e < 113) {
      m |= 0x0800;
      /* Extra rounding may overflow and set mantissa to 0 and exponent
      	* to 1, which is OK. */

      bits |= (m >> 114 - e) + (m >> 113 - e & 1);
      return bits;
    }

    bits |= e - 112 << 10 | m >> 1;
    /* Extra rounding. An overflow will set mantissa to 0 and increment
    	* the exponent, which is OK. */

    bits += m & 1;
    return bits;
  }

}

exports.DataUtils = DataUtils;
const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.

const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.

const MAX_SAMPLES = 20;
const ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};
const backgroundMaterial = new MeshBasicMaterial({
  side: BackSide,
  depthWrite: false,
  depthTest: false
});
const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);

const _flatCamera = /*@__PURE__*/new OrthographicCamera();

const {
  _lodPlanes,
  _sizeLods,
  _sigmas
} = /*@__PURE__*/_createPlanes();

const _clearColor = /*@__PURE__*/new Color();

let _oldTarget = null; // Golden Ratio

const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.

const _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];
/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

function convertLinearToRGBE(color) {
  const maxComponent = Math.max(color.r, color.g, color.b);
  const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);
  color.multiplyScalar(Math.pow(2.0, -fExp));
  const alpha = (fExp + 128.0) / 255.0;
  return alpha;
}

class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._blurMaterial = _getBlurShader(MAX_SAMPLES);
    this._equirectShader = null;
    this._cubemapShader = null;

    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */


  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();

    const cubeUVRenderTarget = this._allocateTargets();

    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);

    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }

    this._applyPMREM(cubeUVRenderTarget);

    this._cleanup(cubeUVRenderTarget);

    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */


  fromEquirectangular(equirectangular) {
    return this._fromTexture(equirectangular);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */


  fromCubemap(cubemap) {
    return this._fromTexture(cubemap);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */


  compileCubemapShader() {
    if (this._cubemapShader === null) {
      this._cubemapShader = _getCubemapShader();

      this._compileMaterial(this._cubemapShader);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */


  compileEquirectangularShader() {
    if (this._equirectShader === null) {
      this._equirectShader = _getEquirectShader();

      this._compileMaterial(this._equirectShader);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */


  dispose() {
    this._blurMaterial.dispose();

    if (this._cubemapShader !== null) this._cubemapShader.dispose();
    if (this._equirectShader !== null) this._equirectShader.dispose();

    for (let i = 0; i < _lodPlanes.length; i++) {
      _lodPlanes[i].dispose();
    }
  } // private interface


  _cleanup(outputTarget) {
    this._pingPongRenderTarget.dispose();

    this._renderer.setRenderTarget(_oldTarget);

    outputTarget.scissorTest = false;

    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }

  _fromTexture(texture) {
    _oldTarget = this._renderer.getRenderTarget();

    const cubeUVRenderTarget = this._allocateTargets(texture);

    this._textureToCubeUV(texture, cubeUVRenderTarget);

    this._applyPMREM(cubeUVRenderTarget);

    this._cleanup(cubeUVRenderTarget);

    return cubeUVRenderTarget;
  }

  _allocateTargets(texture) {
    // warning: null texture is valid
    const params = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: false,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
      depthBuffer: false
    };

    const cubeUVRenderTarget = _createRenderTarget(params);

    cubeUVRenderTarget.depthBuffer = texture ? false : true;
    this._pingPongRenderTarget = _createRenderTarget(params);
    return cubeUVRenderTarget;
  }

  _compileMaterial(material) {
    const tmpMesh = new Mesh(_lodPlanes[0], material);

    this._renderer.compile(tmpMesh, _flatCamera);
  }

  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov = 90;
    const aspect = 1;
    const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const outputEncoding = renderer.outputEncoding;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.outputEncoding = LinearEncoding;
    renderer.autoClear = false;
    let useSolidColor = false;
    const background = scene.background;

    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background).convertSRGBToLinear();
        scene.background = null;
        const alpha = convertLinearToRGBE(backgroundMaterial.color);
        backgroundMaterial.opacity = alpha;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
      const alpha = convertLinearToRGBE(backgroundMaterial.color);
      backgroundMaterial.opacity = alpha;
      useSolidColor = true;
    }

    for (let i = 0; i < 6; i++) {
      const col = i % 3;

      if (col == 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col == 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }

      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);

      renderer.setRenderTarget(cubeUVRenderTarget);

      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }

      renderer.render(scene, cubeCamera);
    }

    renderer.toneMapping = toneMapping;
    renderer.outputEncoding = outputEncoding;
    renderer.autoClear = originalAutoClear;
  }

  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;

    if (texture.isCubeTexture) {
      if (this._cubemapShader == null) {
        this._cubemapShader = _getCubemapShader();
      }
    } else {
      if (this._equirectShader == null) {
        this._equirectShader = _getEquirectShader();
      }
    }

    const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
    const mesh = new Mesh(_lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms['envMap'].value = texture;

    if (!texture.isCubeTexture) {
      uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);
    }

    uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
    uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];

    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);

    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }

  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;

    for (let i = 1; i < TOTAL_LODS; i++) {
      const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];

      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }

    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */


  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;

    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);

    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
  }

  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;

    if (direction !== 'latitudinal' && direction !== 'longitudinal') {
      console.error('blur direction must be either latitudinal or longitudinal!');
    } // Number of standard deviations at which to cut off the discrete approximation.


    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = _sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;

    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }

    const weights = [];
    let sum = 0;

    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x = i / sigmaPixels;
      const weight = Math.exp(-x * x / 2);
      weights.push(weight);

      if (i == 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }

    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }

    blurUniforms['envMap'].value = targetIn.texture;
    blurUniforms['samples'].value = samples;
    blurUniforms['weights'].value = weights;
    blurUniforms['latitudinal'].value = direction === 'latitudinal';

    if (poleAxis) {
      blurUniforms['poleAxis'].value = poleAxis;
    }

    blurUniforms['dTheta'].value = radiansPerPixel;
    blurUniforms['mipInt'].value = LOD_MAX - lodIn;
    blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
    blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
    const outputSize = _sizeLods[lodOut];
    const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
    const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);

    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);

    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }

}

exports.PMREMGenerator = PMREMGenerator;

function _isLDR(texture) {
  if (texture === undefined || texture.type !== UnsignedByteType) return false;
  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}

function _createPlanes() {
  const _lodPlanes = [];
  const _sizeLods = [];
  const _sigmas = [];
  let lod = LOD_MAX;

  for (let i = 0; i < TOTAL_LODS; i++) {
    const sizeLod = Math.pow(2, lod);

    _sizeLods.push(sizeLod);

    let sigma = 1.0 / sizeLod;

    if (i > LOD_MAX - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
    } else if (i == 0) {
      sigma = 0;
    }

    _sigmas.push(sigma);

    const texelSize = 1.0 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }

    const planes = new BufferGeometry();
    planes.setAttribute('position', new BufferAttribute(position, positionSize));
    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));

    _lodPlanes.push(planes);

    if (lod > LOD_MIN) {
      lod--;
    }
  }

  return {
    _lodPlanes,
    _sizeLods,
    _sigmas
  };
}

function _createRenderTarget(params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}

function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}

function _getBlurShader(maxSamples) {
  const weights = new Float32Array(maxSamples);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new RawShaderMaterial({
    name: 'SphericalGaussianBlur',
    defines: {
      'n': maxSamples
    },
    uniforms: {
      'envMap': {
        value: null
      },
      'samples': {
        value: 1
      },
      'weights': {
        value: weights
      },
      'latitudinal': {
        value: false
      },
      'dTheta': {
        value: 0
      },
      'mipInt': {
        value: 0
      },
      'poleAxis': {
        value: poleAxis
      },
      'inputEncoding': {
        value: ENCODINGS[LinearEncoding]
      },
      'outputEncoding': {
        value: ENCODINGS[LinearEncoding]
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader:
    /* glsl */
    `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}

function _getEquirectShader() {
  const texelSize = new Vector2(1, 1);
  const shaderMaterial = new RawShaderMaterial({
    name: 'EquirectangularToCubeUV',
    uniforms: {
      'envMap': {
        value: null
      },
      'texelSize': {
        value: texelSize
      },
      'inputEncoding': {
        value: ENCODINGS[LinearEncoding]
      },
      'outputEncoding': {
        value: ENCODINGS[LinearEncoding]
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader:
    /* glsl */
    `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}

function _getCubemapShader() {
  const shaderMaterial = new RawShaderMaterial({
    name: 'CubemapToCubeUV',
    uniforms: {
      'envMap': {
        value: null
      },
      'inputEncoding': {
        value: ENCODINGS[LinearEncoding]
      },
      'outputEncoding': {
        value: ENCODINGS[LinearEncoding]
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader:
    /* glsl */
    `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}

function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}

function _getEncodings() {
  return (
    /* glsl */
    `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
  );
}

const LineStrip = 0;
exports.LineStrip = LineStrip;
const LinePieces = 1;
exports.LinePieces = LinePieces;
const NoColors = 0;
exports.NoColors = NoColors;
const FaceColors = 1;
exports.FaceColors = FaceColors;
const VertexColors = 2;
exports.VertexColors = VertexColors;

function MeshFaceMaterial(materials) {
  console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
  return materials;
}

function MultiMaterial(materials = []) {
  console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
  materials.isMultiMaterial = true;
  materials.materials = materials;

  materials.clone = function () {
    return materials.slice();
  };

  return materials;
}

function PointCloud(geometry, material) {
  console.warn('THREE.PointCloud has been renamed to THREE.Points.');
  return new Points(geometry, material);
}

function Particle(material) {
  console.warn('THREE.Particle has been renamed to THREE.Sprite.');
  return new Sprite(material);
}

function ParticleSystem(geometry, material) {
  console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
  return new Points(geometry, material);
}

function PointCloudMaterial(parameters) {
  console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function ParticleBasicMaterial(parameters) {
  console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function ParticleSystemMaterial(parameters) {
  console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function Vertex(x, y, z) {
  console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
  return new Vector3(x, y, z);
} //


function DynamicBufferAttribute(array, itemSize) {
  console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
  return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
}

function Int8Attribute(array, itemSize) {
  console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
  return new Int8BufferAttribute(array, itemSize);
}

function Uint8Attribute(array, itemSize) {
  console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
  return new Uint8BufferAttribute(array, itemSize);
}

function Uint8ClampedAttribute(array, itemSize) {
  console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
  return new Uint8ClampedBufferAttribute(array, itemSize);
}

function Int16Attribute(array, itemSize) {
  console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
  return new Int16BufferAttribute(array, itemSize);
}

function Uint16Attribute(array, itemSize) {
  console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
  return new Uint16BufferAttribute(array, itemSize);
}

function Int32Attribute(array, itemSize) {
  console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
  return new Int32BufferAttribute(array, itemSize);
}

function Uint32Attribute(array, itemSize) {
  console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
  return new Uint32BufferAttribute(array, itemSize);
}

function Float32Attribute(array, itemSize) {
  console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
  return new Float32BufferAttribute(array, itemSize);
}

function Float64Attribute(array, itemSize) {
  console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
  return new Float64BufferAttribute(array, itemSize);
} //


Curve.create = function (construct, getPoint) {
  console.log('THREE.Curve.create() has been deprecated');
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
}; //


Path.prototype.fromPoints = function (points) {
  console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
  return this.setFromPoints(points);
}; //


function AxisHelper(size) {
  console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
  return new AxesHelper(size);
}

function BoundingBoxHelper(object, color) {
  console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
  return new BoxHelper(object, color);
}

function EdgesHelper(object, hex) {
  console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
  return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
    color: hex !== undefined ? hex : 0xffffff
  }));
}

GridHelper.prototype.setColors = function () {
  console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
};

SkeletonHelper.prototype.update = function () {
  console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
};

function WireframeHelper(object, hex) {
  console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
  return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
    color: hex !== undefined ? hex : 0xffffff
  }));
} //


Loader.prototype.extractUrlBase = function (url) {
  console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
  return LoaderUtils.extractUrlBase(url);
};

Loader.Handlers = {
  add: function ()
  /* regex, loader */
  {
    console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
  },
  get: function ()
  /* file */
  {
    console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
  }
};

function XHRLoader(manager) {
  console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
  return new FileLoader(manager);
}

function BinaryTextureLoader(manager) {
  console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
  return new DataTextureLoader(manager);
} //


Box2.prototype.center = function (optionalTarget) {
  console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
  return this.getCenter(optionalTarget);
};

Box2.prototype.empty = function () {
  console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
  return this.isEmpty();
};

Box2.prototype.isIntersectionBox = function (box) {
  console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
  return this.intersectsBox(box);
};

Box2.prototype.size = function (optionalTarget) {
  console.warn('THREE.Box2: .size() has been renamed to .getSize().');
  return this.getSize(optionalTarget);
}; //


Box3.prototype.center = function (optionalTarget) {
  console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
  return this.getCenter(optionalTarget);
};

Box3.prototype.empty = function () {
  console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
  return this.isEmpty();
};

Box3.prototype.isIntersectionBox = function (box) {
  console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
  return this.intersectsBox(box);
};

Box3.prototype.isIntersectionSphere = function (sphere) {
  console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
  return this.intersectsSphere(sphere);
};

Box3.prototype.size = function (optionalTarget) {
  console.warn('THREE.Box3: .size() has been renamed to .getSize().');
  return this.getSize(optionalTarget);
}; //


Sphere.prototype.empty = function () {
  console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
  return this.isEmpty();
}; //


Frustum.prototype.setFromMatrix = function (m) {
  console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
  return this.setFromProjectionMatrix(m);
}; //


Line3.prototype.center = function (optionalTarget) {
  console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
  return this.getCenter(optionalTarget);
}; //


Matrix3.prototype.flattenToArrayOffset = function (array, offset) {
  console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
  return this.toArray(array, offset);
};

Matrix3.prototype.multiplyVector3 = function (vector) {
  console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
  return vector.applyMatrix3(this);
};

Matrix3.prototype.multiplyVector3Array = function ()
/* a */
{
  console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
};

Matrix3.prototype.applyToBufferAttribute = function (attribute) {
  console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
  return attribute.applyMatrix3(this);
};

Matrix3.prototype.applyToVector3Array = function ()
/* array, offset, length */
{
  console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
};

Matrix3.prototype.getInverse = function (matrix) {
  console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
  return this.copy(matrix).invert();
}; //


Matrix4.prototype.extractPosition = function (m) {
  console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
  return this.copyPosition(m);
};

Matrix4.prototype.flattenToArrayOffset = function (array, offset) {
  console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
  return this.toArray(array, offset);
};

Matrix4.prototype.getPosition = function () {
  console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
  return new Vector3().setFromMatrixColumn(this, 3);
};

Matrix4.prototype.setRotationFromQuaternion = function (q) {
  console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
  return this.makeRotationFromQuaternion(q);
};

Matrix4.prototype.multiplyToArray = function () {
  console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
};

Matrix4.prototype.multiplyVector3 = function (vector) {
  console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
  return vector.applyMatrix4(this);
};

Matrix4.prototype.multiplyVector4 = function (vector) {
  console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
  return vector.applyMatrix4(this);
};

Matrix4.prototype.multiplyVector3Array = function ()
/* a */
{
  console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
};

Matrix4.prototype.rotateAxis = function (v) {
  console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
  v.transformDirection(this);
};

Matrix4.prototype.crossVector = function (vector) {
  console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
  return vector.applyMatrix4(this);
};

Matrix4.prototype.translate = function () {
  console.error('THREE.Matrix4: .translate() has been removed.');
};

Matrix4.prototype.rotateX = function () {
  console.error('THREE.Matrix4: .rotateX() has been removed.');
};

Matrix4.prototype.rotateY = function () {
  console.error('THREE.Matrix4: .rotateY() has been removed.');
};

Matrix4.prototype.rotateZ = function () {
  console.error('THREE.Matrix4: .rotateZ() has been removed.');
};

Matrix4.prototype.rotateByAxis = function () {
  console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
};

Matrix4.prototype.applyToBufferAttribute = function (attribute) {
  console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
  return attribute.applyMatrix4(this);
};

Matrix4.prototype.applyToVector3Array = function ()
/* array, offset, length */
{
  console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
};

Matrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {
  console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
  return this.makePerspective(left, right, top, bottom, near, far);
};

Matrix4.prototype.getInverse = function (matrix) {
  console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
  return this.copy(matrix).invert();
}; //


Plane.prototype.isIntersectionLine = function (line) {
  console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
  return this.intersectsLine(line);
}; //


Quaternion.prototype.multiplyVector3 = function (vector) {
  console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
  return vector.applyQuaternion(this);
};

Quaternion.prototype.inverse = function () {
  console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
  return this.invert();
}; //


Ray.prototype.isIntersectionBox = function (box) {
  console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
  return this.intersectsBox(box);
};

Ray.prototype.isIntersectionPlane = function (plane) {
  console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
  return this.intersectsPlane(plane);
};

Ray.prototype.isIntersectionSphere = function (sphere) {
  console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
  return this.intersectsSphere(sphere);
}; //


Triangle.prototype.area = function () {
  console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
  return this.getArea();
};

Triangle.prototype.barycoordFromPoint = function (point, target) {
  console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
  return this.getBarycoord(point, target);
};

Triangle.prototype.midpoint = function (target) {
  console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
  return this.getMidpoint(target);
};

Triangle.prototypenormal = function (target) {
  console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
  return this.getNormal(target);
};

Triangle.prototype.plane = function (target) {
  console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
  return this.getPlane(target);
};

Triangle.barycoordFromPoint = function (point, a, b, c, target) {
  console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
  return Triangle.getBarycoord(point, a, b, c, target);
};

Triangle.normal = function (a, b, c, target) {
  console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
  return Triangle.getNormal(a, b, c, target);
}; //


Shape.prototype.extractAllPoints = function (divisions) {
  console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
  return this.extractPoints(divisions);
};

Shape.prototype.extrude = function (options) {
  console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
  return new ExtrudeGeometry(this, options);
};

Shape.prototype.makeGeometry = function (options) {
  console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
  return new ShapeGeometry(this, options);
}; //


Vector2.prototype.fromAttribute = function (attribute, index, offset) {
  console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
  return this.fromBufferAttribute(attribute, index, offset);
};

Vector2.prototype.distanceToManhattan = function (v) {
  console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
  return this.manhattanDistanceTo(v);
};

Vector2.prototype.lengthManhattan = function () {
  console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
  return this.manhattanLength();
}; //


Vector3.prototype.setEulerFromRotationMatrix = function () {
  console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
};

Vector3.prototype.setEulerFromQuaternion = function () {
  console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
};

Vector3.prototype.getPositionFromMatrix = function (m) {
  console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
  return this.setFromMatrixPosition(m);
};

Vector3.prototype.getScaleFromMatrix = function (m) {
  console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
  return this.setFromMatrixScale(m);
};

Vector3.prototype.getColumnFromMatrix = function (index, matrix) {
  console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
  return this.setFromMatrixColumn(matrix, index);
};

Vector3.prototype.applyProjection = function (m) {
  console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
  return this.applyMatrix4(m);
};

Vector3.prototype.fromAttribute = function (attribute, index, offset) {
  console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
  return this.fromBufferAttribute(attribute, index, offset);
};

Vector3.prototype.distanceToManhattan = function (v) {
  console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
  return this.manhattanDistanceTo(v);
};

Vector3.prototype.lengthManhattan = function () {
  console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
  return this.manhattanLength();
}; //


Vector4.prototype.fromAttribute = function (attribute, index, offset) {
  console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
  return this.fromBufferAttribute(attribute, index, offset);
};

Vector4.prototype.lengthManhattan = function () {
  console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
  return this.manhattanLength();
}; //


Object3D.prototype.getChildByName = function (name) {
  console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
  return this.getObjectByName(name);
};

Object3D.prototype.renderDepth = function () {
  console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
};

Object3D.prototype.translate = function (distance, axis) {
  console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
  return this.translateOnAxis(axis, distance);
};

Object3D.prototype.getWorldRotation = function () {
  console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
};

Object3D.prototype.applyMatrix = function (matrix) {
  console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
  return this.applyMatrix4(matrix);
};

Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function () {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      return this.rotation.order;
    },
    set: function (value) {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    },
    set: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    }
  }
});

Mesh.prototype.setDrawMode = function () {
  console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
};

Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function () {
      console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
      return TrianglesDrawMode;
    },
    set: function () {
      console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
    }
  }
});

SkinnedMesh.prototype.initBones = function () {
  console.error('THREE.SkinnedMesh: initBones() has been removed.');
}; //


PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
  console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');
  if (filmGauge !== undefined) this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
}; //


Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function () {
      console.warn('THREE.Light: .onlyShadow has been removed.');
    }
  },
  shadowCameraFov: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function () {
      console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
    }
  },
  shadowBias: {
    set: function (value) {
      console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function () {
      console.warn('THREE.Light: .shadowDarkness has been removed.');
    }
  },
  shadowMapWidth: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
      this.shadow.mapSize.height = value;
    }
  }
}); //

Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function () {
      console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
      return this.array.length;
    }
  },
  dynamic: {
    get: function () {
      console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
      return this.usage === DynamicDrawUsage;
    },
    set: function ()
    /* value */
    {
      console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
      this.setUsage(DynamicDrawUsage);
    }
  }
});

BufferAttribute.prototype.setDynamic = function (value) {
  console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};

BufferAttribute.prototype.copyIndicesArray = function ()
/* indices */
{
  console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
}, BufferAttribute.prototype.setArray = function ()
/* array */
{
  console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
}; //

BufferGeometry.prototype.addIndex = function (index) {
  console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
  this.setIndex(index);
};

BufferGeometry.prototype.addAttribute = function (name, attribute) {
  console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');

  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
    return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
  }

  if (name === 'index') {
    console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
    this.setIndex(attribute);
    return this;
  }

  return this.setAttribute(name, attribute);
};

BufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {
  if (indexOffset !== undefined) {
    console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
  }

  console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
  this.addGroup(start, count);
};

BufferGeometry.prototype.clearDrawCalls = function () {
  console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
  this.clearGroups();
};

BufferGeometry.prototype.computeOffsets = function () {
  console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
};

BufferGeometry.prototype.removeAttribute = function (name) {
  console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
  return this.deleteAttribute(name);
};

BufferGeometry.prototype.applyMatrix = function (matrix) {
  console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
  return this.applyMatrix4(matrix);
};

Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function () {
      console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
      return this.groups;
    }
  },
  offsets: {
    get: function () {
      console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
      return this.groups;
    }
  }
});

InterleavedBuffer.prototype.setDynamic = function (value) {
  console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};

InterleavedBuffer.prototype.setArray = function ()
/* array */
{
  console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
}; //


ExtrudeGeometry.prototype.getArrays = function () {
  console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
};

ExtrudeGeometry.prototype.addShapeList = function () {
  console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
};

ExtrudeGeometry.prototype.addShape = function () {
  console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
}; //


Scene.prototype.dispose = function () {
  console.error('THREE.Scene: .dispose() has been removed.');
}; //


Uniform.prototype.onUpdate = function () {
  console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
  return this;
}; //


Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function () {
      console.warn('THREE.Material: .wrapAround has been removed.');
    },
    set: function () {
      console.warn('THREE.Material: .wrapAround has been removed.');
    }
  },
  overdraw: {
    get: function () {
      console.warn('THREE.Material: .overdraw has been removed.');
    },
    set: function () {
      console.warn('THREE.Material: .overdraw has been removed.');
    }
  },
  wrapRGB: {
    get: function () {
      console.warn('THREE.Material: .wrapRGB has been removed.');
      return new Color();
    }
  },
  shading: {
    get: function () {
      console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
    },
    set: function (value) {
      console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function () {
      console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
      return this.stencilFuncMask;
    },
    set: function (value) {
      console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
      this.stencilFuncMask = value;
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function () {
      console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      return this.extensions.derivatives;
    },
    set: function (value) {
      console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      this.extensions.derivatives = value;
    }
  }
}); //

WebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {
  console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
  this.setRenderTarget(renderTarget);
  this.clear(color, depth, stencil);
};

WebGLRenderer.prototype.animate = function (callback) {
  console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
  this.setAnimationLoop(callback);
};

WebGLRenderer.prototype.getCurrentRenderTarget = function () {
  console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
  return this.getRenderTarget();
};

WebGLRenderer.prototype.getMaxAnisotropy = function () {
  console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
  return this.capabilities.getMaxAnisotropy();
};

WebGLRenderer.prototype.getPrecision = function () {
  console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
  return this.capabilities.precision;
};

WebGLRenderer.prototype.resetGLState = function () {
  console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
  return this.state.reset();
};

WebGLRenderer.prototype.supportsFloatTextures = function () {
  console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
  return this.extensions.get('OES_texture_float');
};

WebGLRenderer.prototype.supportsHalfFloatTextures = function () {
  console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
  return this.extensions.get('OES_texture_half_float');
};

WebGLRenderer.prototype.supportsStandardDerivatives = function () {
  console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
  return this.extensions.get('OES_standard_derivatives');
};

WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {
  console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
  return this.extensions.get('WEBGL_compressed_texture_s3tc');
};

WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {
  console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
  return this.extensions.get('WEBGL_compressed_texture_pvrtc');
};

WebGLRenderer.prototype.supportsBlendMinMax = function () {
  console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
  return this.extensions.get('EXT_blend_minmax');
};

WebGLRenderer.prototype.supportsVertexTextures = function () {
  console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
  return this.capabilities.vertexTextures;
};

WebGLRenderer.prototype.supportsInstancedArrays = function () {
  console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
  return this.extensions.get('ANGLE_instanced_arrays');
};

WebGLRenderer.prototype.enableScissorTest = function (boolean) {
  console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
  this.setScissorTest(boolean);
};

WebGLRenderer.prototype.initMaterial = function () {
  console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
};

WebGLRenderer.prototype.addPrePlugin = function () {
  console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
};

WebGLRenderer.prototype.addPostPlugin = function () {
  console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
};

WebGLRenderer.prototype.updateShadowMap = function () {
  console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
};

WebGLRenderer.prototype.setFaceCulling = function () {
  console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
};

WebGLRenderer.prototype.allocTextureUnit = function () {
  console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
};

WebGLRenderer.prototype.setTexture = function () {
  console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
};

WebGLRenderer.prototype.setTexture2D = function () {
  console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
};

WebGLRenderer.prototype.setTextureCube = function () {
  console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
};

WebGLRenderer.prototype.getActiveMipMapLevel = function () {
  console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
  return this.getActiveMipmapLevel();
};

Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function ()
    /* value */
    {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  context: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
      return this.getContext();
    }
  },
  vr: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
      return this.xr;
    }
  },
  gammaInput: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
      return false;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
    }
  },
  gammaOutput: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
      return false;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
      return 1.0;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function ()
    /* cullFace */
    {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  renderReverseSided: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
    }
  },
  renderSingleSided: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
    }
  }
});

function WebGLRenderTargetCube(width, height, options) {
  console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
  return new WebGLCubeRenderTarget(width, options);
} //


Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      return this.texture.wrapS;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      return this.texture.wrapT;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      return this.texture.magFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      return this.texture.minFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      return this.texture.anisotropy;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      return this.texture.offset;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      return this.texture.repeat;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      this.texture.repeat = value;
    }
  },
  format: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      return this.texture.format;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      this.texture.format = value;
    }
  },
  type: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      return this.texture.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      return this.texture.generateMipmaps;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      this.texture.generateMipmaps = value;
    }
  }
}); //

Audio.prototype.load = function (file) {
  console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
  const scope = this;
  const audioLoader = new AudioLoader();
  audioLoader.load(file, function (buffer) {
    scope.setBuffer(buffer);
  });
  return this;
};

AudioAnalyser.prototype.getData = function () {
  console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
  return this.getFrequencyData();
}; //


CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
  console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
  return this.update(renderer, scene);
};

CubeCamera.prototype.clear = function (renderer, color, depth, stencil) {
  console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
  return this.renderTarget.clear(renderer, color, depth, stencil);
};

ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};

ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};

ImageUtils.loadCompressedTexture = function () {
  console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
};

ImageUtils.loadCompressedTextureCube = function () {
  console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
}; //


function CanvasRenderer() {
  console.error('THREE.CanvasRenderer has been removed');
} //


function JSONLoader() {
  console.error('THREE.JSONLoader has been removed.');
} //


const SceneUtils = {
  createMultiMaterialObject: function ()
  /* geometry, materials */
  {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  },
  detach: function ()
  /* child, parent, scene */
  {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  },
  attach: function ()
  /* child, scene, parent */
  {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  }
}; //

exports.SceneUtils = SceneUtils;

function LensFlare() {
  console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
}

if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
  /* eslint-disable no-undef */
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
    detail: {
      revision: REVISION
    }
  }));
  /* eslint-enable no-undef */

}

if (typeof window !== 'undefined') {
  if (window.__THREE__) {
    console.warn('WARNING: Multiple instances of Three.js being imported.');
  } else {
    window.__THREE__ = REVISION;
  }
}
},{}],"node_modules/three/examples/jsm/controls/OrbitControls.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapControls = exports.OrbitControls = void 0;

var _three = require("three");

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
const _changeEvent = {
  type: 'change'
};
const _startEvent = {
  type: 'start'
};
const _endEvent = {
  type: 'end'
};

class OrbitControls extends _three.EventDispatcher {
  constructor(object, domElement) {
    super();
    if (domElement === undefined) console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
    if (domElement === document) console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
    this.object = object;
    this.domElement = domElement; // Set to false to disable this control

    this.enabled = true; // "target" sets the location of focus, where the object orbits around

    this.target = new _three.Vector3(); // How far you can dolly in and out ( PerspectiveCamera only )

    this.minDistance = 0;
    this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only )

    this.minZoom = 0;
    this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.
    // Range is 0 to Math.PI radians.

    this.minPolarAngle = 0; // radians

    this.maxPolarAngle = Math.PI; // radians
    // How far you can orbit horizontally, upper and lower limits.
    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )

    this.minAzimuthAngle = -Infinity; // radians

    this.maxAzimuthAngle = Infinity; // radians
    // Set to true to enable damping (inertia)
    // If damping is enabled, you must call controls.update() in your animation loop

    this.enableDamping = false;
    this.dampingFactor = 0.05; // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
    // Set to false to disable zooming

    this.enableZoom = true;
    this.zoomSpeed = 1.0; // Set to false to disable rotating

    this.enableRotate = true;
    this.rotateSpeed = 1.0; // Set to false to disable panning

    this.enablePan = true;
    this.panSpeed = 1.0;
    this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up

    this.keyPanSpeed = 7.0; // pixels moved per arrow key push
    // Set to true to automatically rotate around the target
    // If auto-rotate is enabled, you must call controls.update() in your animation loop

    this.autoRotate = false;
    this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60
    // The four arrow keys

    this.keys = {
      LEFT: 'ArrowLeft',
      UP: 'ArrowUp',
      RIGHT: 'ArrowRight',
      BOTTOM: 'ArrowDown'
    }; // Mouse buttons

    this.mouseButtons = {
      LEFT: _three.MOUSE.ROTATE,
      MIDDLE: _three.MOUSE.DOLLY,
      RIGHT: _three.MOUSE.PAN
    }; // Touch fingers

    this.touches = {
      ONE: _three.TOUCH.ROTATE,
      TWO: _three.TOUCH.DOLLY_PAN
    }; // for reset

    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom; // the target DOM element for key events

    this._domElementKeyEvents = null; //
    // public methods
    //

    this.getPolarAngle = function () {
      return spherical.phi;
    };

    this.getAzimuthalAngle = function () {
      return spherical.theta;
    };

    this.listenToKeyEvents = function (domElement) {
      domElement.addEventListener('keydown', onKeyDown);
      this._domElementKeyEvents = domElement;
    };

    this.saveState = function () {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };

    this.reset = function () {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent);
      scope.update();
      state = STATE.NONE;
    }; // this method is exposed, but perhaps it would be better if we can make it private...


    this.update = function () {
      const offset = new _three.Vector3(); // so camera.up is the orbit axis

      const quat = new _three.Quaternion().setFromUnitVectors(object.up, new _three.Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new _three.Vector3();
      const lastQuaternion = new _three.Quaternion();
      const twoPI = 2 * Math.PI;
      return function update() {
        const position = scope.object.position;
        offset.copy(position).sub(scope.target); // rotate offset to "y-axis-is-up" space

        offset.applyQuaternion(quat); // angle from z-axis around y-axis

        spherical.setFromVector3(offset);

        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle());
        }

        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        } // restrict theta to be between desired limits


        let min = scope.minAzimuthAngle;
        let max = scope.maxAzimuthAngle;

        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI) min += twoPI;else if (min > Math.PI) min -= twoPI;
          if (max < -Math.PI) max += twoPI;else if (max > Math.PI) max -= twoPI;

          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
          }
        } // restrict phi to be between desired limits


        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale; // restrict radius to be between desired limits

        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)); // move target to panned location

        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }

        offset.setFromSpherical(spherical); // rotate offset back to "camera-up-vector-is-up" space

        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);

        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }

        scale = 1; // update condition is:
        // min(camera displacement, camera rotation in radians)^2 > EPS
        // using small-angle approximation cos(x/2) = 1 - x^2 / 8

        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
          scope.dispatchEvent(_changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          zoomChanged = false;
          return true;
        }

        return false;
      };
    }();

    this.dispose = function () {
      scope.domElement.removeEventListener('contextmenu', onContextMenu);
      scope.domElement.removeEventListener('pointerdown', onPointerDown);
      scope.domElement.removeEventListener('wheel', onMouseWheel);
      scope.domElement.removeEventListener('touchstart', onTouchStart);
      scope.domElement.removeEventListener('touchend', onTouchEnd);
      scope.domElement.removeEventListener('touchmove', onTouchMove);
      scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);
      scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);

      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown);
      } //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

    }; //
    // internals
    //


    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE.NONE;
    const EPS = 0.000001; // current position in spherical coordinates

    const spherical = new _three.Spherical();
    const sphericalDelta = new _three.Spherical();
    let scale = 1;
    const panOffset = new _three.Vector3();
    let zoomChanged = false;
    const rotateStart = new _three.Vector2();
    const rotateEnd = new _three.Vector2();
    const rotateDelta = new _three.Vector2();
    const panStart = new _three.Vector2();
    const panEnd = new _three.Vector2();
    const panDelta = new _three.Vector2();
    const dollyStart = new _three.Vector2();
    const dollyEnd = new _three.Vector2();
    const dollyDelta = new _three.Vector2();

    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }

    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }

    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }

    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }

    const panLeft = function () {
      const v = new _three.Vector3();
      return function panLeft(distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix

        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    }();

    const panUp = function () {
      const v = new _three.Vector3();
      return function panUp(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }

        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    }(); // deltaX and deltaY are in pixels; right and down are positive


    const pan = function () {
      const offset = new _three.Vector3();
      return function pan(deltaX, deltaY) {
        const element = scope.domElement;

        if (scope.object.isPerspectiveCamera) {
          // perspective
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          let targetDistance = offset.length(); // half of the fov is center to top of screen

          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed

          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          // orthographic
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          // camera neither orthographic nor perspective
          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
          scope.enablePan = false;
        }
      };
    }();

    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale /= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
        scope.enableZoom = false;
      }
    }

    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale *= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
        scope.enableZoom = false;
      }
    } //
    // event callbacks - update the object state
    //


    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }

    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }

    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }

    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }

    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);

      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }

      dollyStart.copy(dollyEnd);
      scope.update();
    }

    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }

    function handleMouseUp()
    /*event*/
    {// no-op
    }

    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }

      scope.update();
    }

    function handleKeyDown(event) {
      let needsUpdate = false;

      switch (event.code) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed);
          needsUpdate = true;
          break;

        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed);
          needsUpdate = true;
          break;

        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;

        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }

      if (needsUpdate) {
        // prevent the browser from scrolling on cursor keys
        event.preventDefault();
        scope.update();
      }
    }

    function handleTouchStartRotate(event) {
      if (event.touches.length == 1) {
        rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        rotateStart.set(x, y);
      }
    }

    function handleTouchStartPan(event) {
      if (event.touches.length == 1) {
        panStart.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        panStart.set(x, y);
      }
    }

    function handleTouchStartDolly(event) {
      const dx = event.touches[0].pageX - event.touches[1].pageX;
      const dy = event.touches[0].pageY - event.touches[1].pageY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }

    function handleTouchStartDollyPan(event) {
      if (scope.enableZoom) handleTouchStartDolly(event);
      if (scope.enablePan) handleTouchStartPan(event);
    }

    function handleTouchStartDollyRotate(event) {
      if (scope.enableZoom) handleTouchStartDolly(event);
      if (scope.enableRotate) handleTouchStartRotate(event);
    }

    function handleTouchMoveRotate(event) {
      if (event.touches.length == 1) {
        rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        rotateEnd.set(x, y);
      }

      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }

    function handleTouchMovePan(event) {
      if (event.touches.length == 1) {
        panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        panEnd.set(x, y);
      }

      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }

    function handleTouchMoveDolly(event) {
      const dx = event.touches[0].pageX - event.touches[1].pageX;
      const dy = event.touches[0].pageY - event.touches[1].pageY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }

    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom) handleTouchMoveDolly(event);
      if (scope.enablePan) handleTouchMovePan(event);
    }

    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom) handleTouchMoveDolly(event);
      if (scope.enableRotate) handleTouchMoveRotate(event);
    }

    function handleTouchEnd()
    /*event*/
    {// no-op
    } //
    // event handlers - FSM: listen for events and reset state
    //


    function onPointerDown(event) {
      if (scope.enabled === false) return;

      switch (event.pointerType) {
        case 'mouse':
        case 'pen':
          onMouseDown(event);
          break;
        // TODO touch
      }
    }

    function onPointerMove(event) {
      if (scope.enabled === false) return;

      switch (event.pointerType) {
        case 'mouse':
        case 'pen':
          onMouseMove(event);
          break;
        // TODO touch
      }
    }

    function onPointerUp(event) {
      switch (event.pointerType) {
        case 'mouse':
        case 'pen':
          onMouseUp(event);
          break;
        // TODO touch
      }
    }

    function onMouseDown(event) {
      // Prevent the browser from scrolling.
      event.preventDefault(); // Manually set the focus since calling preventDefault above
      // prevents the browser from setting it automatically.

      scope.domElement.focus ? scope.domElement.focus() : window.focus();
      let mouseAction;

      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;

        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;

        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;

        default:
          mouseAction = -1;
      }

      switch (mouseAction) {
        case _three.MOUSE.DOLLY:
          if (scope.enableZoom === false) return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;

        case _three.MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false) return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false) return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }

          break;

        case _three.MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false) return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false) return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }

          break;

        default:
          state = STATE.NONE;
      }

      if (state !== STATE.NONE) {
        scope.domElement.ownerDocument.addEventListener('pointermove', onPointerMove);
        scope.domElement.ownerDocument.addEventListener('pointerup', onPointerUp);
        scope.dispatchEvent(_startEvent);
      }
    }

    function onMouseMove(event) {
      if (scope.enabled === false) return;
      event.preventDefault();

      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false) return;
          handleMouseMoveRotate(event);
          break;

        case STATE.DOLLY:
          if (scope.enableZoom === false) return;
          handleMouseMoveDolly(event);
          break;

        case STATE.PAN:
          if (scope.enablePan === false) return;
          handleMouseMovePan(event);
          break;
      }
    }

    function onMouseUp(event) {
      scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);
      scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
      if (scope.enabled === false) return;
      handleMouseUp(event);
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }

    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(_endEvent);
    }

    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false) return;
      handleKeyDown(event);
    }

    function onTouchStart(event) {
      if (scope.enabled === false) return;
      event.preventDefault(); // prevent scrolling

      switch (event.touches.length) {
        case 1:
          switch (scope.touches.ONE) {
            case _three.TOUCH.ROTATE:
              if (scope.enableRotate === false) return;
              handleTouchStartRotate(event);
              state = STATE.TOUCH_ROTATE;
              break;

            case _three.TOUCH.PAN:
              if (scope.enablePan === false) return;
              handleTouchStartPan(event);
              state = STATE.TOUCH_PAN;
              break;

            default:
              state = STATE.NONE;
          }

          break;

        case 2:
          switch (scope.touches.TWO) {
            case _three.TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false) return;
              handleTouchStartDollyPan(event);
              state = STATE.TOUCH_DOLLY_PAN;
              break;

            case _three.TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false) return;
              handleTouchStartDollyRotate(event);
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;

            default:
              state = STATE.NONE;
          }

          break;

        default:
          state = STATE.NONE;
      }

      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }

    function onTouchMove(event) {
      if (scope.enabled === false) return;
      event.preventDefault(); // prevent scrolling

      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false) return;
          handleTouchMoveRotate(event);
          scope.update();
          break;

        case STATE.TOUCH_PAN:
          if (scope.enablePan === false) return;
          handleTouchMovePan(event);
          scope.update();
          break;

        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false) return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;

        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false) return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;

        default:
          state = STATE.NONE;
      }
    }

    function onTouchEnd(event) {
      if (scope.enabled === false) return;
      handleTouchEnd(event);
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }

    function onContextMenu(event) {
      if (scope.enabled === false) return;
      event.preventDefault();
    } //


    scope.domElement.addEventListener('contextmenu', onContextMenu);
    scope.domElement.addEventListener('pointerdown', onPointerDown);
    scope.domElement.addEventListener('wheel', onMouseWheel, {
      passive: false
    });
    scope.domElement.addEventListener('touchstart', onTouchStart, {
      passive: false
    });
    scope.domElement.addEventListener('touchend', onTouchEnd);
    scope.domElement.addEventListener('touchmove', onTouchMove, {
      passive: false
    }); // force an update at start

    this.update();
  }

} // This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move


exports.OrbitControls = OrbitControls;

class MapControls extends OrbitControls {
  constructor(object, domElement) {
    super(object, domElement);
    this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up

    this.mouseButtons.LEFT = _three.MOUSE.PAN;
    this.mouseButtons.RIGHT = _three.MOUSE.ROTATE;
    this.touches.ONE = _three.TOUCH.PAN;
    this.touches.TWO = _three.TOUCH.DOLLY_ROTATE;
  }

}

exports.MapControls = MapControls;
},{"three":"node_modules/three/build/three.module.js"}],"node_modules/shader-park-core/dist/shader-park-core.umd.js":[function(require,module,exports) {
var define;
var global = arguments[3];
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['shader-park-core'] = {}));
}(this, (function (exports) { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  var REACT_ELEMENT_TYPE;

  function _jsx(type, props, key, children) {
    if (!REACT_ELEMENT_TYPE) {
      REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol["for"] && Symbol["for"]("react.element") || 0xeac7;
    }

    var defaultProps = type && type.defaultProps;
    var childrenLength = arguments.length - 3;

    if (!props && childrenLength !== 0) {
      props = {
        children: void 0
      };
    }

    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = new Array(childrenLength);

      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 3];
      }

      props.children = childArray;
    }

    if (props && defaultProps) {
      for (var propName in defaultProps) {
        if (props[propName] === void 0) {
          props[propName] = defaultProps[propName];
        }
      }
    } else if (!props) {
      props = defaultProps || {};
    }

    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key === undefined ? null : '' + key,
      ref: null,
      props: props,
      _owner: null
    };
  }

  function _asyncIterator(iterable) {
    var method;

    if (typeof Symbol !== "undefined") {
      if (Symbol.asyncIterator) {
        method = iterable[Symbol.asyncIterator];
        if (method != null) return method.call(iterable);
      }

      if (Symbol.iterator) {
        method = iterable[Symbol.iterator];
        if (method != null) return method.call(iterable);
      }
    }

    throw new TypeError("Object is not async iterable");
  }

  function _AwaitValue(value) {
    this.wrapped = value;
  }

  function _AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;
        var wrappedAwait = value instanceof _AwaitValue;
        Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
          if (wrappedAwait) {
            resume(key === "return" ? "return" : "next", arg);
            return;
          }

          settle(result.done ? "return" : "normal", arg);
        }, function (err) {
          resume("throw", err);
        });
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  _AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  _AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  _AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  function _wrapAsyncGenerator(fn) {
    return function () {
      return new _AsyncGenerator(fn.apply(this, arguments));
    };
  }

  function _awaitAsyncGenerator(value) {
    return new _AwaitValue(value);
  }

  function _asyncGeneratorDelegate(inner, awaitWrap) {
    var iter = {},
        waiting = false;

    function pump(key, value) {
      waiting = true;
      value = new Promise(function (resolve) {
        resolve(inner[key](value));
      });
      return {
        done: false,
        value: awaitWrap(value)
      };
    }

    ;

    if (typeof Symbol === "function" && Symbol.iterator) {
      iter[Symbol.iterator] = function () {
        return this;
      };
    }

    iter.next = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }

      return pump("next", value);
    };

    if (typeof inner.throw === "function") {
      iter.throw = function (value) {
        if (waiting) {
          waiting = false;
          throw value;
        }

        return pump("throw", value);
      };
    }

    if (typeof inner.return === "function") {
      iter.return = function (value) {
        if (waiting) {
          waiting = false;
          return value;
        }

        return pump("return", value);
      };
    }

    return iter;
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);

      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }

    return obj;
  }

  function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);

      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }

    return obj;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? Object(arguments[i]) : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();

    _getRequireWildcardCache = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {
        default: obj
      };
    }

    var cache = _getRequireWildcardCache();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }

  function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = _superPropBase(target, property);

        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }

        desc = Object.getOwnPropertyDescriptor(receiver, property);

        if (desc) {
          if (!desc.writable) {
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          _defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);

    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }

  function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    strings.raw = raw;
    return strings;
  }

  function _readOnlyError(name) {
    throw new TypeError("\"" + name + "\" is read-only");
  }

  function _writeOnlyError(name) {
    throw new TypeError("\"" + name + "\" is write-only");
  }

  function _classNameTDZError(name) {
    throw new Error("Class \"" + name + "\" cannot be referenced in computed property keys.");
  }

  function _temporalUndefined() {}

  function _tdz(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }

  function _temporalRef(val, name) {
    return val === _temporalUndefined ? _tdz(name) : val;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _slicedToArrayLoose(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimitLoose(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return _arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }

    return next(arr, i);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _iterableToArrayLimitLoose(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];

    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      _arr.push(_step.value);

      if (i && _arr.length === i) break;
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    it = o[Symbol.iterator]();
    return it.next.bind(it);
  }

  function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    };
  }

  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];

    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }

    return (hint === "string" ? String : Number)(input);
  }

  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");

    return typeof key === "symbol" ? key : String(key);
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.');
  }

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  var id = 0;

  function _classPrivateFieldLooseKey(name) {
    return "__private_" + id++ + "_" + name;
  }

  function _classPrivateFieldLooseBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }

    return receiver;
  }

  function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");

    return _classApplyDescriptorGet(receiver, descriptor);
  }

  function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");

    _classApplyDescriptorSet(receiver, descriptor, value);

    return value;
  }

  function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");

    return _classApplyDescriptorDestructureSet(receiver, descriptor);
  }

  function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }

    return privateMap.get(receiver);
  }

  function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    _classCheckPrivateStaticAccess(receiver, classConstructor);

    _classCheckPrivateStaticFieldDescriptor(descriptor, "get");

    return _classApplyDescriptorGet(receiver, descriptor);
  }

  function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    _classCheckPrivateStaticAccess(receiver, classConstructor);

    _classCheckPrivateStaticFieldDescriptor(descriptor, "set");

    _classApplyDescriptorSet(receiver, descriptor, value);

    return value;
  }

  function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    _classCheckPrivateStaticAccess(receiver, classConstructor);

    return method;
  }

  function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }

  function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }

    return descriptor.value;
  }

  function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        throw new TypeError("attempted to set read only private field");
      }

      descriptor.value = value;
    }
  }

  function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v);
          }

        };
      }

      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }

  function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    _classCheckPrivateStaticAccess(receiver, classConstructor);

    _classCheckPrivateStaticFieldDescriptor(descriptor, "set");

    return _classApplyDescriptorDestructureSet(receiver, descriptor);
  }

  function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
  }

  function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }

  function _decorate(decorators, factory, superClass, mixins) {
    var api = _getDecoratorsApi();

    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators);
    api.initializeClassElements(r.F, decorated.elements);
    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function () {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],
      initializeInstanceElements: function (O, elements) {
        ["method", "field"].forEach(function (kind) {
          elements.forEach(function (element) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },
      initializeClassElements: function (F, elements) {
        var proto = F.prototype;
        ["method", "field"].forEach(function (kind) {
          elements.forEach(function (element) {
            var placement = element.placement;

            if (element.kind === kind && (placement === "static" || placement === "prototype")) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },
      defineClassElement: function (receiver, element) {
        var descriptor = element.descriptor;

        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver)
          };
        }

        Object.defineProperty(receiver, element.key, descriptor);
      },
      decorateClass: function (elements, decorators) {
        var newElements = [];
        var finishers = [];
        var placements = {
          static: [],
          prototype: [],
          own: []
        };
        elements.forEach(function (element) {
          this.addElementPlacement(element, placements);
        }, this);
        elements.forEach(function (element) {
          if (!_hasDecorators(element)) return newElements.push(element);
          var elementFinishersExtras = this.decorateElement(element, placements);
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return {
            elements: newElements,
            finishers: finishers
          };
        }

        var result = this.decorateConstructor(newElements, decorators);
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;
        return result;
      },
      addElementPlacement: function (element, placements, silent) {
        var keys = placements[element.placement];

        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }

        keys.push(element.key);
      },
      decorateElement: function (element, placements) {
        var extras = [];
        var finishers = [];

        for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);
          var elementObject = this.fromElementDescriptor(element);
          var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject);
          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras = elementFinisherExtras.extras;

          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }

            extras.push.apply(extras, newExtras);
          }
        }

        return {
          element: element,
          finishers: finishers,
          extras: extras
        };
      },
      decorateConstructor: function (elements, decorators) {
        var finishers = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj = this.fromClassDescriptor(elements);
          var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj);

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) {
                  throw new TypeError("Duplicated element (" + elements[j].key + ")");
                }
              }
            }
          }
        }

        return {
          elements: elements,
          finishers: finishers
        };
      },
      fromElementDescriptor: function (element) {
        var obj = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor
        };
        var desc = {
          value: "Descriptor",
          configurable: true
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);
        if (element.kind === "field") obj.initializer = element.initializer;
        return obj;
      },
      toElementDescriptors: function (elementObjects) {
        if (elementObjects === undefined) return;
        return _toArray(elementObjects).map(function (elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },
      toElementDescriptor: function (elementObject) {
        var kind = String(elementObject.kind);

        if (kind !== "method" && kind !== "field") {
          throw new TypeError('An element descriptor\'s .kind property must be either "method" or' + ' "field", but a decorator created an element descriptor with' + ' .kind "' + kind + '"');
        }

        var key = _toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);

        if (placement !== "static" && placement !== "prototype" && placement !== "own") {
          throw new TypeError('An element descriptor\'s .placement property must be one of "static",' + ' "prototype" or "own", but a decorator created an element descriptor' + ' with .placement "' + placement + '"');
        }

        var descriptor = elementObject.descriptor;
        this.disallowProperty(elementObject, "elements", "An element descriptor");
        var element = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor)
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(descriptor, "get", "The property descriptor of a field descriptor");
          this.disallowProperty(descriptor, "set", "The property descriptor of a field descriptor");
          this.disallowProperty(descriptor, "value", "The property descriptor of a field descriptor");
          element.initializer = elementObject.initializer;
        }

        return element;
      },
      toElementFinisherExtras: function (elementObject) {
        var element = this.toElementDescriptor(elementObject);

        var finisher = _optionalCallableProperty(elementObject, "finisher");

        var extras = this.toElementDescriptors(elementObject.extras);
        return {
          element: element,
          finisher: finisher,
          extras: extras
        };
      },
      fromClassDescriptor: function (elements) {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this)
        };
        var desc = {
          value: "Descriptor",
          configurable: true
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);
        return obj;
      },
      toClassDescriptor: function (obj) {
        var kind = String(obj.kind);

        if (kind !== "class") {
          throw new TypeError('A class descriptor\'s .kind property must be "class", but a decorator' + ' created a class descriptor with .kind "' + kind + '"');
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");

        var elements = this.toElementDescriptors(obj.elements);
        return {
          elements: elements,
          finisher: finisher
        };
      },
      runClassFinishers: function (constructor, finishers) {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor = (0, finishers[i])(constructor);

          if (newConstructor !== undefined) {
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }

            constructor = newConstructor;
          }
        }

        return constructor;
      },
      disallowProperty: function (obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };
    return api;
  }

  function _createElementDescriptor(def) {
    var key = _toPropertyKey(def.key);

    var descriptor;

    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false
      };
    } else if (def.kind === "get") {
      descriptor = {
        get: def.value,
        configurable: true,
        enumerable: false
      };
    } else if (def.kind === "set") {
      descriptor = {
        set: def.value,
        configurable: true,
        enumerable: false
      };
    } else if (def.kind === "field") {
      descriptor = {
        configurable: true,
        writable: true,
        enumerable: true
      };
    }

    var element = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static ? "static" : def.kind === "field" ? "own" : "prototype",
      descriptor: descriptor
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;
    return element;
  }

  function _coalesceGetterSetter(element, other) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  function _coalesceClassElements(elements) {
    var newElements = [];

    var isSameElement = function (other) {
      return other.kind === "method" && other.key === element.key && other.placement === element.placement;
    };

    for (var i = 0; i < elements.length; i++) {
      var element = elements[i];
      var other;

      if (element.kind === "method" && (other = newElements.find(isSameElement))) {
        if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError("Duplicated methods (" + element.key + ") can't be decorated.");
          }

          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError("Decorators can't be placed on different accessors with for " + "the same property (" + element.key + ").");
            }

            other.decorators = element.decorators;
          }

          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element) {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc) {
    return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);
  }

  function _optionalCallableProperty(obj, name) {
    var value = obj[name];

    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }

    return value;
  }

  function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    return fn;
  }

  function _classPrivateMethodSet() {
    throw new TypeError("attempted to reassign private method");
  }

  function _wrapRegExp(re, groups) {
    _wrapRegExp = function (re, groups) {
      return new BabelRegExp(re, undefined, groups);
    };

    var _RegExp = _wrapNativeSuper(RegExp);

    var _super = RegExp.prototype;

    var _groups = new WeakMap();

    function BabelRegExp(re, flags, groups) {
      var _this = _RegExp.call(this, re, flags);

      _groups.set(_this, groups || _groups.get(re));

      return _this;
    }

    _inherits(BabelRegExp, _RegExp);

    BabelRegExp.prototype.exec = function (str) {
      var result = _super.exec.call(this, str);

      if (result) result.groups = buildGroups(result, this);
      return result;
    };

    BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
      if (typeof substitution === "string") {
        var groups = _groups.get(this);

        return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
          return "$" + groups[name];
        }));
      } else if (typeof substitution === "function") {
        var _this = this;

        return _super[Symbol.replace].call(this, str, function () {
          var args = [];
          args.push.apply(args, arguments);

          if (typeof args[args.length - 1] !== "object") {
            args.push(buildGroups(args, _this));
          }

          return substitution.apply(this, args);
        });
      } else {
        return _super[Symbol.replace].call(this, str, substitution);
      }
    };

    function buildGroups(result, re) {
      var g = _groups.get(re);

      return Object.keys(g).reduce(function (groups, name) {
        groups[name] = result[g[name]];
        return groups;
      }, Object.create(null));
    }

    return _wrapRegExp.apply(this, arguments);
  }

  // Numbers represent type - 
  // 1:float 2:vec2 3:vec3 4:vec4
  var geometryFunctions = {
    sphere: {
      args: [1]
    },
    line: {
      args: [3, 3, 1]
    },
    cone: {
      args: [1, 1]
    },
    roundCone: {
      args: [3, 3, 1, 1]
    },
    plane: {
      args: [1, 1, 1, 1]
    }
  };
  var mathFunctions = {
    nsin: {
      args: [1],
      ret: 1
    },
    ncos: {
      args: [1],
      ret: 1
    },
    round: {
      args: [1],
      ret: 1
    },
    hsv2rgb: {
      args: [3],
      ret: 3
    },
    rgb2hsv: {
      args: [3],
      ret: 3
    },
    toSpherical: {
      args: [3],
      ret: 3
    },
    fromSpherical: {
      args: [3],
      ret: 3
    },
    getRayDirection: {
      args: [],
      ret: 3
    },
    osc: {
      args: [1],
      ret: 1
    },
    _hash33: {
      args: [3],
      ret: 1
    },
    noise: {
      args: [3],
      ret: 1
    },
    fractalNoise: {
      args: [3],
      ret: 1
    },
    sphericalDistribution: {
      args: [3, 1],
      ret: 4
    }
  }; // these all have a single input/output and are overloaded for 
  // all types so a list of names is all we need to generate them

  var glslBuiltInOneToOne = ["sin", "cos", "tan", "asin", "acos", "exp", "log", "exp2", "log2", "sqrt", "inversesqrt", "abs", "sign", "floor", "ceil", "fract"]; // need better overloading system

  var glslBuiltInOther = {
    // overload pow somehow?
    pow: {
      args: [1, 1],
      ret: 1
    },
    mod: {
      args: [1, 1],
      ret: 1
    },
    min: {
      args: [1, 1],
      ret: 1
    },
    max: {
      args: [1, 1],
      ret: 1
    },
    atan: {
      args: [1, 1],
      ret: 1
    },
    clamp: {
      args: [1, 1, 1],
      ret: 1
    },
    step: {
      args: [1, 1],
      ret: 1
    },
    smoothstep: {
      args: [1, 1, 1],
      ret: 1
    },
    // also overload length for vec3 and vec2?
    length: {
      args: [3],
      ret: 1
    },
    distance: {
      args: [3, 3],
      ret: 1
    },
    dot: {
      args: [3, 3],
      ret: 1
    },
    cross: {
      args: [3, 3],
      ret: 3
    },
    normalize: {
      args: [3],
      ret: 3
    },
    reflect: {
      args: [3, 3],
      ret: 3
    },
    refract: {
      args: [3, 3],
      ret: 3
    }
  }; // let arg = {
  //     'mix' : (a, b, c) => (a.dim === b.dim && (c.dim === 1 || c.dim === a.dim))? a.dim: -1,
  // };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function getDefaultExportFromNamespaceIfPresent (n) {
  	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
  }

  function getDefaultExportFromNamespaceIfNotNamed (n) {
  	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
  }

  function getAugmentedNamespace(n) {
  	if (n.__esModule) return n;
  	var a = Object.defineProperty({}, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  function createCommonjsModule(fn) {
    var module = { exports: {} };
  	return fn(module, module.exports), module.exports;
  }

  function commonjsRequire (path) {
  	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }

  const name$1="estraverse";const description$1="ECMAScript JS AST traversal functions";const homepage$1="https://github.com/estools/estraverse";const main$1="estraverse.js";const version$1="4.3.0";const engines$1={node:">=4.0"};const maintainers$1=[{name:"Yusuke Suzuki",email:"utatane.tea@gmail.com",web:"http://github.com/Constellation"}];const repository$1={type:"git",url:"http://github.com/estools/estraverse.git"};const devDependencies$1={"babel-preset-env":"^1.6.1","babel-register":"^6.3.13",chai:"^2.1.1",espree:"^1.11.0",gulp:"^3.8.10","gulp-bump":"^0.2.2","gulp-filter":"^2.0.0","gulp-git":"^1.0.1","gulp-tag-version":"^1.3.0",jshint:"^2.5.6",mocha:"^2.1.0"};const license$1="BSD-2-Clause";const scripts$1={test:"npm run-script lint && npm run-script unit-test",lint:"jshint estraverse.js","unit-test":"mocha --compilers js:babel-register"};var require$$0 = {name:name$1,description:description$1,homepage:homepage$1,main:main$1,version:version$1,engines:engines$1,maintainers:maintainers$1,repository:repository$1,devDependencies:devDependencies$1,license:license$1,scripts:scripts$1};

  /*
    Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
    Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

      * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */

  var estraverse = createCommonjsModule(function (module, exports) {
  /*jslint vars:false, bitwise:true*/
  /*jshint indent:4*/
  /*global exports:true*/
  (function clone(exports) {
      'use strict';

      var Syntax,
          VisitorOption,
          VisitorKeys,
          BREAK,
          SKIP,
          REMOVE;

      function deepCopy(obj) {
          var ret = {}, key, val;
          for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                  val = obj[key];
                  if (typeof val === 'object' && val !== null) {
                      ret[key] = deepCopy(val);
                  } else {
                      ret[key] = val;
                  }
              }
          }
          return ret;
      }

      // based on LLVM libc++ upper_bound / lower_bound
      // MIT License

      function upperBound(array, func) {
          var diff, len, i, current;

          len = array.length;
          i = 0;

          while (len) {
              diff = len >>> 1;
              current = i + diff;
              if (func(array[current])) {
                  len = diff;
              } else {
                  i = current + 1;
                  len -= diff + 1;
              }
          }
          return i;
      }

      Syntax = {
          AssignmentExpression: 'AssignmentExpression',
          AssignmentPattern: 'AssignmentPattern',
          ArrayExpression: 'ArrayExpression',
          ArrayPattern: 'ArrayPattern',
          ArrowFunctionExpression: 'ArrowFunctionExpression',
          AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
          BlockStatement: 'BlockStatement',
          BinaryExpression: 'BinaryExpression',
          BreakStatement: 'BreakStatement',
          CallExpression: 'CallExpression',
          CatchClause: 'CatchClause',
          ClassBody: 'ClassBody',
          ClassDeclaration: 'ClassDeclaration',
          ClassExpression: 'ClassExpression',
          ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
          ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
          ConditionalExpression: 'ConditionalExpression',
          ContinueStatement: 'ContinueStatement',
          DebuggerStatement: 'DebuggerStatement',
          DirectiveStatement: 'DirectiveStatement',
          DoWhileStatement: 'DoWhileStatement',
          EmptyStatement: 'EmptyStatement',
          ExportAllDeclaration: 'ExportAllDeclaration',
          ExportDefaultDeclaration: 'ExportDefaultDeclaration',
          ExportNamedDeclaration: 'ExportNamedDeclaration',
          ExportSpecifier: 'ExportSpecifier',
          ExpressionStatement: 'ExpressionStatement',
          ForStatement: 'ForStatement',
          ForInStatement: 'ForInStatement',
          ForOfStatement: 'ForOfStatement',
          FunctionDeclaration: 'FunctionDeclaration',
          FunctionExpression: 'FunctionExpression',
          GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
          Identifier: 'Identifier',
          IfStatement: 'IfStatement',
          ImportExpression: 'ImportExpression',
          ImportDeclaration: 'ImportDeclaration',
          ImportDefaultSpecifier: 'ImportDefaultSpecifier',
          ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
          ImportSpecifier: 'ImportSpecifier',
          Literal: 'Literal',
          LabeledStatement: 'LabeledStatement',
          LogicalExpression: 'LogicalExpression',
          MemberExpression: 'MemberExpression',
          MetaProperty: 'MetaProperty',
          MethodDefinition: 'MethodDefinition',
          ModuleSpecifier: 'ModuleSpecifier',
          NewExpression: 'NewExpression',
          ObjectExpression: 'ObjectExpression',
          ObjectPattern: 'ObjectPattern',
          Program: 'Program',
          Property: 'Property',
          RestElement: 'RestElement',
          ReturnStatement: 'ReturnStatement',
          SequenceExpression: 'SequenceExpression',
          SpreadElement: 'SpreadElement',
          Super: 'Super',
          SwitchStatement: 'SwitchStatement',
          SwitchCase: 'SwitchCase',
          TaggedTemplateExpression: 'TaggedTemplateExpression',
          TemplateElement: 'TemplateElement',
          TemplateLiteral: 'TemplateLiteral',
          ThisExpression: 'ThisExpression',
          ThrowStatement: 'ThrowStatement',
          TryStatement: 'TryStatement',
          UnaryExpression: 'UnaryExpression',
          UpdateExpression: 'UpdateExpression',
          VariableDeclaration: 'VariableDeclaration',
          VariableDeclarator: 'VariableDeclarator',
          WhileStatement: 'WhileStatement',
          WithStatement: 'WithStatement',
          YieldExpression: 'YieldExpression'
      };

      VisitorKeys = {
          AssignmentExpression: ['left', 'right'],
          AssignmentPattern: ['left', 'right'],
          ArrayExpression: ['elements'],
          ArrayPattern: ['elements'],
          ArrowFunctionExpression: ['params', 'body'],
          AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
          BlockStatement: ['body'],
          BinaryExpression: ['left', 'right'],
          BreakStatement: ['label'],
          CallExpression: ['callee', 'arguments'],
          CatchClause: ['param', 'body'],
          ClassBody: ['body'],
          ClassDeclaration: ['id', 'superClass', 'body'],
          ClassExpression: ['id', 'superClass', 'body'],
          ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
          ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
          ConditionalExpression: ['test', 'consequent', 'alternate'],
          ContinueStatement: ['label'],
          DebuggerStatement: [],
          DirectiveStatement: [],
          DoWhileStatement: ['body', 'test'],
          EmptyStatement: [],
          ExportAllDeclaration: ['source'],
          ExportDefaultDeclaration: ['declaration'],
          ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
          ExportSpecifier: ['exported', 'local'],
          ExpressionStatement: ['expression'],
          ForStatement: ['init', 'test', 'update', 'body'],
          ForInStatement: ['left', 'right', 'body'],
          ForOfStatement: ['left', 'right', 'body'],
          FunctionDeclaration: ['id', 'params', 'body'],
          FunctionExpression: ['id', 'params', 'body'],
          GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
          Identifier: [],
          IfStatement: ['test', 'consequent', 'alternate'],
          ImportExpression: ['source'],
          ImportDeclaration: ['specifiers', 'source'],
          ImportDefaultSpecifier: ['local'],
          ImportNamespaceSpecifier: ['local'],
          ImportSpecifier: ['imported', 'local'],
          Literal: [],
          LabeledStatement: ['label', 'body'],
          LogicalExpression: ['left', 'right'],
          MemberExpression: ['object', 'property'],
          MetaProperty: ['meta', 'property'],
          MethodDefinition: ['key', 'value'],
          ModuleSpecifier: [],
          NewExpression: ['callee', 'arguments'],
          ObjectExpression: ['properties'],
          ObjectPattern: ['properties'],
          Program: ['body'],
          Property: ['key', 'value'],
          RestElement: [ 'argument' ],
          ReturnStatement: ['argument'],
          SequenceExpression: ['expressions'],
          SpreadElement: ['argument'],
          Super: [],
          SwitchStatement: ['discriminant', 'cases'],
          SwitchCase: ['test', 'consequent'],
          TaggedTemplateExpression: ['tag', 'quasi'],
          TemplateElement: [],
          TemplateLiteral: ['quasis', 'expressions'],
          ThisExpression: [],
          ThrowStatement: ['argument'],
          TryStatement: ['block', 'handler', 'finalizer'],
          UnaryExpression: ['argument'],
          UpdateExpression: ['argument'],
          VariableDeclaration: ['declarations'],
          VariableDeclarator: ['id', 'init'],
          WhileStatement: ['test', 'body'],
          WithStatement: ['object', 'body'],
          YieldExpression: ['argument']
      };

      // unique id
      BREAK = {};
      SKIP = {};
      REMOVE = {};

      VisitorOption = {
          Break: BREAK,
          Skip: SKIP,
          Remove: REMOVE
      };

      function Reference(parent, key) {
          this.parent = parent;
          this.key = key;
      }

      Reference.prototype.replace = function replace(node) {
          this.parent[this.key] = node;
      };

      Reference.prototype.remove = function remove() {
          if (Array.isArray(this.parent)) {
              this.parent.splice(this.key, 1);
              return true;
          } else {
              this.replace(null);
              return false;
          }
      };

      function Element(node, path, wrap, ref) {
          this.node = node;
          this.path = path;
          this.wrap = wrap;
          this.ref = ref;
      }

      function Controller() { }

      // API:
      // return property path array from root to current node
      Controller.prototype.path = function path() {
          var i, iz, j, jz, result, element;

          function addToPath(result, path) {
              if (Array.isArray(path)) {
                  for (j = 0, jz = path.length; j < jz; ++j) {
                      result.push(path[j]);
                  }
              } else {
                  result.push(path);
              }
          }

          // root node
          if (!this.__current.path) {
              return null;
          }

          // first node is sentinel, second node is root element
          result = [];
          for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
              element = this.__leavelist[i];
              addToPath(result, element.path);
          }
          addToPath(result, this.__current.path);
          return result;
      };

      // API:
      // return type of current node
      Controller.prototype.type = function () {
          var node = this.current();
          return node.type || this.__current.wrap;
      };

      // API:
      // return array of parent elements
      Controller.prototype.parents = function parents() {
          var i, iz, result;

          // first node is sentinel
          result = [];
          for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
              result.push(this.__leavelist[i].node);
          }

          return result;
      };

      // API:
      // return current node
      Controller.prototype.current = function current() {
          return this.__current.node;
      };

      Controller.prototype.__execute = function __execute(callback, element) {
          var previous, result;

          result = undefined;

          previous  = this.__current;
          this.__current = element;
          this.__state = null;
          if (callback) {
              result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
          }
          this.__current = previous;

          return result;
      };

      // API:
      // notify control skip / break
      Controller.prototype.notify = function notify(flag) {
          this.__state = flag;
      };

      // API:
      // skip child nodes of current node
      Controller.prototype.skip = function () {
          this.notify(SKIP);
      };

      // API:
      // break traversals
      Controller.prototype['break'] = function () {
          this.notify(BREAK);
      };

      // API:
      // remove node
      Controller.prototype.remove = function () {
          this.notify(REMOVE);
      };

      Controller.prototype.__initialize = function(root, visitor) {
          this.visitor = visitor;
          this.root = root;
          this.__worklist = [];
          this.__leavelist = [];
          this.__current = null;
          this.__state = null;
          this.__fallback = null;
          if (visitor.fallback === 'iteration') {
              this.__fallback = Object.keys;
          } else if (typeof visitor.fallback === 'function') {
              this.__fallback = visitor.fallback;
          }

          this.__keys = VisitorKeys;
          if (visitor.keys) {
              this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
          }
      };

      function isNode(node) {
          if (node == null) {
              return false;
          }
          return typeof node === 'object' && typeof node.type === 'string';
      }

      function isProperty(nodeType, key) {
          return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
      }

      Controller.prototype.traverse = function traverse(root, visitor) {
          var worklist,
              leavelist,
              element,
              node,
              nodeType,
              ret,
              key,
              current,
              current2,
              candidates,
              candidate,
              sentinel;

          this.__initialize(root, visitor);

          sentinel = {};

          // reference
          worklist = this.__worklist;
          leavelist = this.__leavelist;

          // initialize
          worklist.push(new Element(root, null, null, null));
          leavelist.push(new Element(null, null, null, null));

          while (worklist.length) {
              element = worklist.pop();

              if (element === sentinel) {
                  element = leavelist.pop();

                  ret = this.__execute(visitor.leave, element);

                  if (this.__state === BREAK || ret === BREAK) {
                      return;
                  }
                  continue;
              }

              if (element.node) {

                  ret = this.__execute(visitor.enter, element);

                  if (this.__state === BREAK || ret === BREAK) {
                      return;
                  }

                  worklist.push(sentinel);
                  leavelist.push(element);

                  if (this.__state === SKIP || ret === SKIP) {
                      continue;
                  }

                  node = element.node;
                  nodeType = node.type || element.wrap;
                  candidates = this.__keys[nodeType];
                  if (!candidates) {
                      if (this.__fallback) {
                          candidates = this.__fallback(node);
                      } else {
                          throw new Error('Unknown node type ' + nodeType + '.');
                      }
                  }

                  current = candidates.length;
                  while ((current -= 1) >= 0) {
                      key = candidates[current];
                      candidate = node[key];
                      if (!candidate) {
                          continue;
                      }

                      if (Array.isArray(candidate)) {
                          current2 = candidate.length;
                          while ((current2 -= 1) >= 0) {
                              if (!candidate[current2]) {
                                  continue;
                              }
                              if (isProperty(nodeType, candidates[current])) {
                                  element = new Element(candidate[current2], [key, current2], 'Property', null);
                              } else if (isNode(candidate[current2])) {
                                  element = new Element(candidate[current2], [key, current2], null, null);
                              } else {
                                  continue;
                              }
                              worklist.push(element);
                          }
                      } else if (isNode(candidate)) {
                          worklist.push(new Element(candidate, key, null, null));
                      }
                  }
              }
          }
      };

      Controller.prototype.replace = function replace(root, visitor) {
          var worklist,
              leavelist,
              node,
              nodeType,
              target,
              element,
              current,
              current2,
              candidates,
              candidate,
              sentinel,
              outer,
              key;

          function removeElem(element) {
              var i,
                  key,
                  nextElem,
                  parent;

              if (element.ref.remove()) {
                  // When the reference is an element of an array.
                  key = element.ref.key;
                  parent = element.ref.parent;

                  // If removed from array, then decrease following items' keys.
                  i = worklist.length;
                  while (i--) {
                      nextElem = worklist[i];
                      if (nextElem.ref && nextElem.ref.parent === parent) {
                          if  (nextElem.ref.key < key) {
                              break;
                          }
                          --nextElem.ref.key;
                      }
                  }
              }
          }

          this.__initialize(root, visitor);

          sentinel = {};

          // reference
          worklist = this.__worklist;
          leavelist = this.__leavelist;

          // initialize
          outer = {
              root: root
          };
          element = new Element(root, null, null, new Reference(outer, 'root'));
          worklist.push(element);
          leavelist.push(element);

          while (worklist.length) {
              element = worklist.pop();

              if (element === sentinel) {
                  element = leavelist.pop();

                  target = this.__execute(visitor.leave, element);

                  // node may be replaced with null,
                  // so distinguish between undefined and null in this place
                  if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                      // replace
                      element.ref.replace(target);
                  }

                  if (this.__state === REMOVE || target === REMOVE) {
                      removeElem(element);
                  }

                  if (this.__state === BREAK || target === BREAK) {
                      return outer.root;
                  }
                  continue;
              }

              target = this.__execute(visitor.enter, element);

              // node may be replaced with null,
              // so distinguish between undefined and null in this place
              if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                  // replace
                  element.ref.replace(target);
                  element.node = target;
              }

              if (this.__state === REMOVE || target === REMOVE) {
                  removeElem(element);
                  element.node = null;
              }

              if (this.__state === BREAK || target === BREAK) {
                  return outer.root;
              }

              // node may be null
              node = element.node;
              if (!node) {
                  continue;
              }

              worklist.push(sentinel);
              leavelist.push(element);

              if (this.__state === SKIP || target === SKIP) {
                  continue;
              }

              nodeType = node.type || element.wrap;
              candidates = this.__keys[nodeType];
              if (!candidates) {
                  if (this.__fallback) {
                      candidates = this.__fallback(node);
                  } else {
                      throw new Error('Unknown node type ' + nodeType + '.');
                  }
              }

              current = candidates.length;
              while ((current -= 1) >= 0) {
                  key = candidates[current];
                  candidate = node[key];
                  if (!candidate) {
                      continue;
                  }

                  if (Array.isArray(candidate)) {
                      current2 = candidate.length;
                      while ((current2 -= 1) >= 0) {
                          if (!candidate[current2]) {
                              continue;
                          }
                          if (isProperty(nodeType, candidates[current])) {
                              element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                          } else if (isNode(candidate[current2])) {
                              element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                          } else {
                              continue;
                          }
                          worklist.push(element);
                      }
                  } else if (isNode(candidate)) {
                      worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                  }
              }
          }

          return outer.root;
      };

      function traverse(root, visitor) {
          var controller = new Controller();
          return controller.traverse(root, visitor);
      }

      function replace(root, visitor) {
          var controller = new Controller();
          return controller.replace(root, visitor);
      }

      function extendCommentRange(comment, tokens) {
          var target;

          target = upperBound(tokens, function search(token) {
              return token.range[0] > comment.range[0];
          });

          comment.extendedRange = [comment.range[0], comment.range[1]];

          if (target !== tokens.length) {
              comment.extendedRange[1] = tokens[target].range[0];
          }

          target -= 1;
          if (target >= 0) {
              comment.extendedRange[0] = tokens[target].range[1];
          }

          return comment;
      }

      function attachComments(tree, providedComments, tokens) {
          // At first, we should calculate extended comment ranges.
          var comments = [], comment, len, i, cursor;

          if (!tree.range) {
              throw new Error('attachComments needs range information');
          }

          // tokens array is empty, we attach comments to tree as 'leadingComments'
          if (!tokens.length) {
              if (providedComments.length) {
                  for (i = 0, len = providedComments.length; i < len; i += 1) {
                      comment = deepCopy(providedComments[i]);
                      comment.extendedRange = [0, tree.range[0]];
                      comments.push(comment);
                  }
                  tree.leadingComments = comments;
              }
              return tree;
          }

          for (i = 0, len = providedComments.length; i < len; i += 1) {
              comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
          }

          // This is based on John Freeman's implementation.
          cursor = 0;
          traverse(tree, {
              enter: function (node) {
                  var comment;

                  while (cursor < comments.length) {
                      comment = comments[cursor];
                      if (comment.extendedRange[1] > node.range[0]) {
                          break;
                      }

                      if (comment.extendedRange[1] === node.range[0]) {
                          if (!node.leadingComments) {
                              node.leadingComments = [];
                          }
                          node.leadingComments.push(comment);
                          comments.splice(cursor, 1);
                      } else {
                          cursor += 1;
                      }
                  }

                  // already out of owned node
                  if (cursor === comments.length) {
                      return VisitorOption.Break;
                  }

                  if (comments[cursor].extendedRange[0] > node.range[1]) {
                      return VisitorOption.Skip;
                  }
              }
          });

          cursor = 0;
          traverse(tree, {
              leave: function (node) {
                  var comment;

                  while (cursor < comments.length) {
                      comment = comments[cursor];
                      if (node.range[1] < comment.extendedRange[0]) {
                          break;
                      }

                      if (node.range[1] === comment.extendedRange[0]) {
                          if (!node.trailingComments) {
                              node.trailingComments = [];
                          }
                          node.trailingComments.push(comment);
                          comments.splice(cursor, 1);
                      } else {
                          cursor += 1;
                      }
                  }

                  // already out of owned node
                  if (cursor === comments.length) {
                      return VisitorOption.Break;
                  }

                  if (comments[cursor].extendedRange[0] > node.range[1]) {
                      return VisitorOption.Skip;
                  }
              }
          });

          return tree;
      }

      exports.version = require$$0.version;
      exports.Syntax = Syntax;
      exports.traverse = traverse;
      exports.replace = replace;
      exports.attachComments = attachComments;
      exports.VisitorKeys = VisitorKeys;
      exports.VisitorOption = VisitorOption;
      exports.Controller = Controller;
      exports.cloneEnvironment = function () { return clone({}); };

      return exports;
  }(exports));
  /* vim: set sw=4 ts=4 et tw=80 : */
  });

  /*
    Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

      * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */

  var ast = createCommonjsModule(function (module) {
  (function () {
      'use strict';

      function isExpression(node) {
          if (node == null) { return false; }
          switch (node.type) {
              case 'ArrayExpression':
              case 'AssignmentExpression':
              case 'BinaryExpression':
              case 'CallExpression':
              case 'ConditionalExpression':
              case 'FunctionExpression':
              case 'Identifier':
              case 'Literal':
              case 'LogicalExpression':
              case 'MemberExpression':
              case 'NewExpression':
              case 'ObjectExpression':
              case 'SequenceExpression':
              case 'ThisExpression':
              case 'UnaryExpression':
              case 'UpdateExpression':
                  return true;
          }
          return false;
      }

      function isIterationStatement(node) {
          if (node == null) { return false; }
          switch (node.type) {
              case 'DoWhileStatement':
              case 'ForInStatement':
              case 'ForStatement':
              case 'WhileStatement':
                  return true;
          }
          return false;
      }

      function isStatement(node) {
          if (node == null) { return false; }
          switch (node.type) {
              case 'BlockStatement':
              case 'BreakStatement':
              case 'ContinueStatement':
              case 'DebuggerStatement':
              case 'DoWhileStatement':
              case 'EmptyStatement':
              case 'ExpressionStatement':
              case 'ForInStatement':
              case 'ForStatement':
              case 'IfStatement':
              case 'LabeledStatement':
              case 'ReturnStatement':
              case 'SwitchStatement':
              case 'ThrowStatement':
              case 'TryStatement':
              case 'VariableDeclaration':
              case 'WhileStatement':
              case 'WithStatement':
                  return true;
          }
          return false;
      }

      function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
      }

      function trailingStatement(node) {
          switch (node.type) {
          case 'IfStatement':
              if (node.alternate != null) {
                  return node.alternate;
              }
              return node.consequent;

          case 'LabeledStatement':
          case 'ForStatement':
          case 'ForInStatement':
          case 'WhileStatement':
          case 'WithStatement':
              return node.body;
          }
          return null;
      }

      function isProblematicIfStatement(node) {
          var current;

          if (node.type !== 'IfStatement') {
              return false;
          }
          if (node.alternate == null) {
              return false;
          }
          current = node.consequent;
          do {
              if (current.type === 'IfStatement') {
                  if (current.alternate == null)  {
                      return true;
                  }
              }
              current = trailingStatement(current);
          } while (current);

          return false;
      }

      module.exports = {
          isExpression: isExpression,
          isStatement: isStatement,
          isIterationStatement: isIterationStatement,
          isSourceElement: isSourceElement,
          isProblematicIfStatement: isProblematicIfStatement,

          trailingStatement: trailingStatement
      };
  }());
  /* vim: set sw=4 ts=4 et tw=80 : */
  });

  /*
    Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
    Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

      * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */

  var code = createCommonjsModule(function (module) {
  (function () {
      'use strict';

      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

      // See `tools/generate-identifier-regex.js`.
      ES5Regex = {
          // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
          NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
          // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
          NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      };

      ES6Regex = {
          // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
          NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
          // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
          NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };

      function isDecimalDigit(ch) {
          return 0x30 <= ch && ch <= 0x39;  // 0..9
      }

      function isHexDigit(ch) {
          return 0x30 <= ch && ch <= 0x39 ||  // 0..9
              0x61 <= ch && ch <= 0x66 ||     // a..f
              0x41 <= ch && ch <= 0x46;       // A..F
      }

      function isOctalDigit(ch) {
          return ch >= 0x30 && ch <= 0x37;  // 0..7
      }

      // 7.2 White Space

      NON_ASCII_WHITESPACES = [
          0x1680,
          0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
          0x202F, 0x205F,
          0x3000,
          0xFEFF
      ];

      function isWhiteSpace(ch) {
          return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
              ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
      }

      // 7.3 Line Terminators

      function isLineTerminator(ch) {
          return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
      }

      // 7.6 Identifier Names and Identifiers

      function fromCodePoint(cp) {
          if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
          var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
          var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
          return cu1 + cu2;
      }

      IDENTIFIER_START = new Array(0x80);
      for(ch = 0; ch < 0x80; ++ch) {
          IDENTIFIER_START[ch] =
              ch >= 0x61 && ch <= 0x7A ||  // a..z
              ch >= 0x41 && ch <= 0x5A ||  // A..Z
              ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
      }

      IDENTIFIER_PART = new Array(0x80);
      for(ch = 0; ch < 0x80; ++ch) {
          IDENTIFIER_PART[ch] =
              ch >= 0x61 && ch <= 0x7A ||  // a..z
              ch >= 0x41 && ch <= 0x5A ||  // A..Z
              ch >= 0x30 && ch <= 0x39 ||  // 0..9
              ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
      }

      function isIdentifierStartES5(ch) {
          return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
      }

      function isIdentifierPartES5(ch) {
          return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
      }

      function isIdentifierStartES6(ch) {
          return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
      }

      function isIdentifierPartES6(ch) {
          return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
      }

      module.exports = {
          isDecimalDigit: isDecimalDigit,
          isHexDigit: isHexDigit,
          isOctalDigit: isOctalDigit,
          isWhiteSpace: isWhiteSpace,
          isLineTerminator: isLineTerminator,
          isIdentifierStartES5: isIdentifierStartES5,
          isIdentifierPartES5: isIdentifierPartES5,
          isIdentifierStartES6: isIdentifierStartES6,
          isIdentifierPartES6: isIdentifierPartES6
      };
  }());
  /* vim: set sw=4 ts=4 et tw=80 : */
  });

  /*
    Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

      * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */

  var keyword = createCommonjsModule(function (module) {
  (function () {
      'use strict';

      var code$1 = code;

      function isStrictModeReservedWordES6(id) {
          switch (id) {
          case 'implements':
          case 'interface':
          case 'package':
          case 'private':
          case 'protected':
          case 'public':
          case 'static':
          case 'let':
              return true;
          default:
              return false;
          }
      }

      function isKeywordES5(id, strict) {
          // yield should not be treated as keyword under non-strict mode.
          if (!strict && id === 'yield') {
              return false;
          }
          return isKeywordES6(id, strict);
      }

      function isKeywordES6(id, strict) {
          if (strict && isStrictModeReservedWordES6(id)) {
              return true;
          }

          switch (id.length) {
          case 2:
              return (id === 'if') || (id === 'in') || (id === 'do');
          case 3:
              return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
          case 4:
              return (id === 'this') || (id === 'else') || (id === 'case') ||
                  (id === 'void') || (id === 'with') || (id === 'enum');
          case 5:
              return (id === 'while') || (id === 'break') || (id === 'catch') ||
                  (id === 'throw') || (id === 'const') || (id === 'yield') ||
                  (id === 'class') || (id === 'super');
          case 6:
              return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                  (id === 'switch') || (id === 'export') || (id === 'import');
          case 7:
              return (id === 'default') || (id === 'finally') || (id === 'extends');
          case 8:
              return (id === 'function') || (id === 'continue') || (id === 'debugger');
          case 10:
              return (id === 'instanceof');
          default:
              return false;
          }
      }

      function isReservedWordES5(id, strict) {
          return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
      }

      function isReservedWordES6(id, strict) {
          return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
      }

      function isRestrictedWord(id) {
          return id === 'eval' || id === 'arguments';
      }

      function isIdentifierNameES5(id) {
          var i, iz, ch;

          if (id.length === 0) { return false; }

          ch = id.charCodeAt(0);
          if (!code$1.isIdentifierStartES5(ch)) {
              return false;
          }

          for (i = 1, iz = id.length; i < iz; ++i) {
              ch = id.charCodeAt(i);
              if (!code$1.isIdentifierPartES5(ch)) {
                  return false;
              }
          }
          return true;
      }

      function decodeUtf16(lead, trail) {
          return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
      }

      function isIdentifierNameES6(id) {
          var i, iz, ch, lowCh, check;

          if (id.length === 0) { return false; }

          check = code$1.isIdentifierStartES6;
          for (i = 0, iz = id.length; i < iz; ++i) {
              ch = id.charCodeAt(i);
              if (0xD800 <= ch && ch <= 0xDBFF) {
                  ++i;
                  if (i >= iz) { return false; }
                  lowCh = id.charCodeAt(i);
                  if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                      return false;
                  }
                  ch = decodeUtf16(ch, lowCh);
              }
              if (!check(ch)) {
                  return false;
              }
              check = code$1.isIdentifierPartES6;
          }
          return true;
      }

      function isIdentifierES5(id, strict) {
          return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
      }

      function isIdentifierES6(id, strict) {
          return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
      }

      module.exports = {
          isKeywordES5: isKeywordES5,
          isKeywordES6: isKeywordES6,
          isReservedWordES5: isReservedWordES5,
          isReservedWordES6: isReservedWordES6,
          isRestrictedWord: isRestrictedWord,
          isIdentifierNameES5: isIdentifierNameES5,
          isIdentifierNameES6: isIdentifierNameES6,
          isIdentifierES5: isIdentifierES5,
          isIdentifierES6: isIdentifierES6
      };
  }());
  /* vim: set sw=4 ts=4 et tw=80 : */
  });

  /*
    Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

      * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */

  var utils = createCommonjsModule(function (module, exports) {
  (function () {
      'use strict';

      exports.ast = ast;
      exports.code = code;
      exports.keyword = keyword;
  }());
  /* vim: set sw=4 ts=4 et tw=80 : */
  });

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  var encode$1 = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };

  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */
  var decode$1 = function (charCode) {
    var bigA = 65;     // 'A'
    var bigZ = 90;     // 'Z'

    var littleA = 97;  // 'a'
    var littleZ = 122; // 'z'

    var zero = 48;     // '0'
    var nine = 57;     // '9'

    var plus = 43;     // '+'
    var slash = 47;    // '/'

    var littleOffset = 26;
    var numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
      return (charCode - bigA);
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
      return (charCode - littleA + littleOffset);
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
      return (charCode - zero + numberOffset);
    }

    // 62: +
    if (charCode == plus) {
      return 62;
    }

    // 63: /
    if (charCode == slash) {
      return 63;
    }

    // Invalid base64 digit.
    return -1;
  };

  var base64 = {
  	encode: encode$1,
  	decode: decode$1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   *
   * Based on the Base 64 VLQ implementation in Closure Compiler:
   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
   *
   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above
   *    copyright notice, this list of conditions and the following
   *    disclaimer in the documentation and/or other materials provided
   *    with the distribution.
   *  * Neither the name of Google Inc. nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */



  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  var encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  var decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };

  var base64Vlq = {
  	encode: encode,
  	decode: decode
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var util = createCommonjsModule(function (module, exports) {
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consecutive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
  };

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }

      // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    }

    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;

  var supportsNullProto = (function () {
    var obj = Object.create(null);
    return !('__proto__' in obj);
  }());

  function identity (s) {
    return s;
  }

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return '$' + aStr;
    }

    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9 /* "__proto__".length */) {
      return false;
    }

    if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
        s.charCodeAt(length - 2) !== 95  /* '_' */ ||
        s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
        s.charCodeAt(length - 4) !== 116 /* 't' */ ||
        s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
        s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
        s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
        s.charCodeAt(length - 8) !== 95  /* '_' */ ||
        s.charCodeAt(length - 9) !== 95  /* '_' */) {
      return false;
    }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36 /* '$' */) {
        return false;
      }
    }

    return true;
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 === null) {
      return 1; // aStr2 !== null
    }

    if (aStr2 === null) {
      return -1; // aStr1 !== null
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }

  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

  /**
   * Strip any JSON XSSI avoidance prefix from the string (as documented
   * in the source maps specification), and then parse the string as
   * JSON.
   */
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
  }
  exports.parseSourceMapInput = parseSourceMapInput;

  /**
   * Compute the URL of a source given the the source root, the source's
   * URL, and the source map's URL.
   */
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || '';

    if (sourceRoot) {
      // This follows what Chrome does.
      if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
        sourceRoot += '/';
      }
      // The spec says:
      //   Line 4: An optional source root, useful for relocating source
      //   files on a server or removing repeated values in the
      //   “sources” entry.  This value is prepended to the individual
      //   entries in the “source” field.
      sourceURL = sourceRoot + sourceURL;
    }

    // Historically, SourceMapConsumer did not take the sourceMapURL as
    // a parameter.  This mode is still somewhat supported, which is why
    // this code block is conditional.  However, it's preferable to pass
    // the source map URL to SourceMapConsumer, so that this function
    // can implement the source URL resolution algorithm as outlined in
    // the spec.  This block is basically the equivalent of:
    //    new URL(sourceURL, sourceMapURL).toString()
    // ... except it avoids using URL, which wasn't available in the
    // older releases of node still supported by this library.
    //
    // The spec says:
    //   If the sources are not absolute URLs after prepending of the
    //   “sourceRoot”, the sources are resolved relative to the
    //   SourceMap (like resolving script src in a html document).
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        // Strip the last path component, but keep the "/".
        var index = parsed.path.lastIndexOf('/');
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }

    return normalize(sourceURL);
  }
  exports.computeSourceURL = computeSourceURL;
  });

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */


  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet$2() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet$2();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  ArraySet$2.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet$2.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
          return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }

    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet$2.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  var ArraySet_1 = ArraySet$2;

  var arraySet = {
  	ArraySet: ArraySet_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2014 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */



  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList$1() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList$1.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList$1.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList$1.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };

  var MappingList_1 = MappingList$1;

  var mappingList = {
  	MappingList: MappingList_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */



  var ArraySet$1 = arraySet.ArraySet;
  var MappingList = mappingList.MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator$2(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet$1();
    this._names = new ArraySet$1();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator$2.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator$2.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator$2({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }

        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }

        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator$2.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }

      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator$2.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator$2.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet$1();
      var newNames = new ArraySet$1();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator$2.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      // When aOriginal is truthy but has empty values for .line and .column,
      // it is most likely a programmer error. In this case we throw a very
      // specific error message to try to guide them the right way.
      // For example: https://github.com/Polymer/polymer-bundler/pull/519
      if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
          throw new Error(
              'original.line and original.column are not numbers -- you probably meant to omit ' +
              'the original mapping entirely and only map the generated position. If so, pass ' +
              'null for the original mapping instead of an object with empty or null values.'
          );
      }

      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator$2.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;

      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = '';

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ',';
          }
        }

        next += base64Vlq.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64Vlq.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;

          // lines are stored 0-based in SourceMap spec version 3
          next += base64Vlq.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          next += base64Vlq.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64Vlq.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }

        result += next;
      }

      return result;
    };

  SourceMapGenerator$2.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator$2.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator$2.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };

  var SourceMapGenerator_1 = SourceMapGenerator$2;

  var sourceMapGenerator = {
  	SourceMapGenerator: SourceMapGenerator_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var binarySearch = createCommonjsModule(function (module, exports) {
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }

      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    }
    else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }

      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }

    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }

    return index;
  };
  });

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function randomIntInRange(low, high) {
    return Math.round(low + (Math.random() * (high - low)));
  }

  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;

      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */
  var quickSort_1 = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };

  var quickSort$1 = {
  	quickSort: quickSort_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */



  var ArraySet = arraySet.ArraySet;

  var quickSort = quickSort$1.quickSort;

  function SourceMapConsumer$1(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    return sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  }

  SourceMapConsumer$1.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer$1.prototype._version = 3;

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer$1.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer$1.prototype, '_generatedMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer$1.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer$1.prototype, '_originalMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer$1.prototype._charIsMappingSeparator =
    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer$1.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };

  SourceMapConsumer$1.GENERATED_ORDER = 1;
  SourceMapConsumer$1.ORIGINAL_ORDER = 2;

  SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer$1.LEAST_UPPER_BOUND = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer$1.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer$1.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer$1.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer$1.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number is 1-based.
   *   - column: Optional. the column number in the original source.
   *    The column number is 0-based.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *    line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *    The column number is 0-based.
   */
  SourceMapConsumer$1.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, 'line');

      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to 0, we thus find the last mapping for
      // the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util.getArg(aArgs, 'column', 0)
      };

      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions,
                                    binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (aArgs.column === undefined) {
          var originalLine = mapping.originalLine;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we found. Since
          // mappings are sorted, this is guaranteed to find all mappings for
          // the line we found.
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we were searching for.
          // Since mappings are sorted, this is guaranteed to find all mappings for
          // the line we are searching for.
          while (mapping &&
                 mapping.originalLine === line &&
                 mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        }
      }

      return mappings;
    };

  var SourceMapConsumer_1 = SourceMapConsumer$1;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The first parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }

    sources = sources
      .map(String)
      // Some source maps produce relative source paths like "./foo.js" instead of
      // "foo.js".  Normalize these first so that future comparisons will succeed.
      // See bugzil.la/1090768.
      .map(util.normalize)
      // Always ensure that absolute sources are internally stored relative to
      // the source root, if the source root is absolute. Not doing this would
      // be particularly problematic when the source root is a prefix of the
      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
      .map(function (source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
          ? util.relative(sourceRoot, source)
          : source;
      });

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);

    this._absoluteSources = this._sources.toArray().map(function (s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1;

  /**
   * Utility function to find the index of a source.  Returns -1 if not
   * found.
   */
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }

    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }

    return -1;
  };

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @param String aSourceMapURL
   *        The URL at which the source map can be found (optional)
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);

      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function (s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });

      // Because we are modifying the entries (by converting string sources and
      // names to indices into the sources and names ArraySets), we have to make
      // a copy of the entry or else bad things happen. Shared mutable state
      // strikes again! See github issue #191.

      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];

      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;

        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;

          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }

          destOriginalMappings.push(destMapping);
        }

        destGeneratedMappings.push(destMapping);
      }

      quickSort(smc.__originalMappings, util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._absoluteSources.slice();
    }
  });

  /**
   * Provide the JIT with a nice shape / hidden class.
   */
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;

      while (index < length) {
        if (aStr.charAt(index) === ';') {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        }
        else if (aStr.charAt(index) === ',') {
          index++;
        }
        else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;

          // Because each offset is encoded relative to the previous one,
          // many segments often have the same encoding. We can exploit this
          // fact by caching the parsed variable length fields of each segment,
          // allowing us to avoid a second parse if we encounter the same
          // segment again.
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);

          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64Vlq.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }

            if (segment.length === 2) {
              throw new Error('Found a source, but no line and column');
            }

            if (segment.length === 3) {
              throw new Error('Found a source and line, but no column');
            }

            cachedSegments[str] = segment;
          }

          // Generated column.
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;

          if (segment.length > 1) {
            // Original source.
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];

            // Original line.
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;

            // Original column.
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;

            if (segment.length > 4) {
              // Original name.
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }

          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            originalMappings.push(mapping);
          }
        }
      }

      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;

      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator, aBias) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, 'name', null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: name
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
    function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() &&
        !this.sourcesContent.some(function (sc) { return sc == null; });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }

      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }

      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }

      // This function is used recursively from
      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
      // don't want to throw if we can't find the source - we just want to
      // return null, so we provide a flag to exit gracefully.
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, 'source');
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }

      var needle = {
        source: source,
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          };
        }
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The first parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet();
    this._names = new ArraySet();

    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line ||
          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;

      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer$1(util.getArg(s, 'map'), aSourceMapURL)
      }
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      // Find the section containing the generated position we're trying to map
      // to an original position.
      var sectionIndex = binarySearch.search(needle, this._sections,
        function(needle, section) {
          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }

          return (needle.generatedColumn -
                  section.generatedOffset.generatedColumn);
        });
      var section = this._sections[sectionIndex];

      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }

      return section.consumer.originalPositionFor({
        line: needle.generatedLine -
          (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
           ? section.generatedOffset.generatedColumn - 1
           : 0),
        bias: aArgs.bias
      });
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function (s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based. 
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line +
              (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
               ? section.generatedOffset.generatedColumn - 1
               : 0)
          };
          return ret;
        }
      }

      return {
        line: null,
        column: null
      };
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];

          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);

          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }

          // The mappings coming from the consumer for the section have
          // generated positions relative to the start of the section, so we
          // need to offset them to be relative to the start of the concatenated
          // generated file.
          var adjustedMapping = {
            source: source,
            generatedLine: mapping.generatedLine +
              (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn +
              (section.generatedOffset.generatedLine === mapping.generatedLine
              ? section.generatedOffset.generatedColumn - 1
              : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name
          };

          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === 'number') {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }

      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };

  var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

  var sourceMapConsumer = {
  	SourceMapConsumer: SourceMapConsumer_1,
  	BasicSourceMapConsumer: BasicSourceMapConsumer_1,
  	IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;


  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode$1(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode$1.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode$1();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are accessed by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        // The last line of a file might not have a newline.
        var newLine = getNextLine() || "";
        return lineContents + newLine;

        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ?
              remainingLines[remainingLinesIndex++] : undefined;
        }
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[remainingLinesIndex] || '';
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || '';
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode$1(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode$1.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode$1.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode$1.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode$1.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode$1.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode$1.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode$1.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode$1.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode$1.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator$1(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  var SourceNode_1 = SourceNode$1;

  var sourceNode = {
  	SourceNode: SourceNode_1
  };

  /*
   * Copyright 2009-2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE.txt or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
  var SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;
  var SourceNode = sourceNode.SourceNode;

  var sourceMap = {
  	SourceMapGenerator: SourceMapGenerator,
  	SourceMapConsumer: SourceMapConsumer,
  	SourceNode: SourceNode
  };

  const name="escodegen";const description="ECMAScript code generator";const homepage="http://github.com/estools/escodegen";const main="escodegen.js";const bin={esgenerate:"./bin/esgenerate.js",escodegen:"./bin/escodegen.js"};const files=["LICENSE.BSD","README.md","bin","escodegen.js","package.json"];const version="1.14.1";const engines={node:">=4.0"};const maintainers=[{name:"Yusuke Suzuki",email:"utatane.tea@gmail.com",web:"http://github.com/Constellation"}];const repository={type:"git",url:"http://github.com/estools/escodegen.git"};const dependencies={estraverse:"^4.2.0",esutils:"^2.0.2",esprima:"^4.0.1",optionator:"^0.8.1"};const optionalDependencies={"source-map":"~0.6.1"};const devDependencies={acorn:"^7.1.0",bluebird:"^3.4.7","bower-registry-client":"^1.0.0",chai:"^3.5.0","commonjs-everywhere":"^0.9.7",gulp:"^3.8.10","gulp-eslint":"^3.0.1","gulp-mocha":"^3.0.1",semver:"^5.1.0"};const license="BSD-2-Clause";const scripts={test:"gulp travis","unit-test":"gulp test",lint:"gulp lint",release:"node tools/release.js","build-min":"./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",build:"./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"};var require$$3 = {name:name,description:description,homepage:homepage,main:main,bin:bin,files:files,version:version,engines:engines,maintainers:maintainers,repository:repository,dependencies:dependencies,optionalDependencies:optionalDependencies,devDependencies:devDependencies,license:license,scripts:scripts};

  /*
    Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
    Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>
    Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
    Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
    Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
    Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
    Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
    Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
    Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
    Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
    Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
    Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

      * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */

  var escodegen = createCommonjsModule(function (module, exports) {
  /*global exports:true, require:true, global:true*/
  (function () {
      'use strict';

      var Syntax,
          Precedence,
          BinaryPrecedence,
          SourceNode,
          estraverse$1,
          esutils,
          base,
          indent,
          json,
          renumber,
          hexadecimal,
          quotes,
          escapeless,
          newline,
          space,
          parentheses,
          semicolons,
          safeConcatenation,
          directive,
          extra,
          parse,
          sourceMap$1,
          sourceCode,
          preserveBlankLines,
          FORMAT_MINIFY,
          FORMAT_DEFAULTS;

      estraverse$1 = estraverse;
      esutils = utils;

      Syntax = estraverse$1.Syntax;

      // Generation is done by generateExpression.
      function isExpression(node) {
          return CodeGenerator.Expression.hasOwnProperty(node.type);
      }

      // Generation is done by generateStatement.
      function isStatement(node) {
          return CodeGenerator.Statement.hasOwnProperty(node.type);
      }

      Precedence = {
          Sequence: 0,
          Yield: 1,
          Assignment: 1,
          Conditional: 2,
          ArrowFunction: 2,
          LogicalOR: 3,
          LogicalAND: 4,
          BitwiseOR: 5,
          BitwiseXOR: 6,
          BitwiseAND: 7,
          Equality: 8,
          Relational: 9,
          BitwiseSHIFT: 10,
          Additive: 11,
          Multiplicative: 12,
          Exponentiation: 13,
          Await: 14,
          Unary: 14,
          Postfix: 15,
          Call: 16,
          New: 17,
          TaggedTemplate: 18,
          Member: 19,
          Primary: 20
      };

      BinaryPrecedence = {
          '||': Precedence.LogicalOR,
          '&&': Precedence.LogicalAND,
          '|': Precedence.BitwiseOR,
          '^': Precedence.BitwiseXOR,
          '&': Precedence.BitwiseAND,
          '==': Precedence.Equality,
          '!=': Precedence.Equality,
          '===': Precedence.Equality,
          '!==': Precedence.Equality,
          'is': Precedence.Equality,
          'isnt': Precedence.Equality,
          '<': Precedence.Relational,
          '>': Precedence.Relational,
          '<=': Precedence.Relational,
          '>=': Precedence.Relational,
          'in': Precedence.Relational,
          'instanceof': Precedence.Relational,
          '<<': Precedence.BitwiseSHIFT,
          '>>': Precedence.BitwiseSHIFT,
          '>>>': Precedence.BitwiseSHIFT,
          '+': Precedence.Additive,
          '-': Precedence.Additive,
          '*': Precedence.Multiplicative,
          '%': Precedence.Multiplicative,
          '/': Precedence.Multiplicative,
          '**': Precedence.Exponentiation
      };

      //Flags
      var F_ALLOW_IN = 1,
          F_ALLOW_CALL = 1 << 1,
          F_ALLOW_UNPARATH_NEW = 1 << 2,
          F_FUNC_BODY = 1 << 3,
          F_DIRECTIVE_CTX = 1 << 4,
          F_SEMICOLON_OPT = 1 << 5;

      //Expression flag sets
      //NOTE: Flag order:
      // F_ALLOW_IN
      // F_ALLOW_CALL
      // F_ALLOW_UNPARATH_NEW
      var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
          E_TTF = F_ALLOW_IN | F_ALLOW_CALL,
          E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
          E_TFF = F_ALLOW_IN,
          E_FFT = F_ALLOW_UNPARATH_NEW,
          E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;

      //Statement flag sets
      //NOTE: Flag order:
      // F_ALLOW_IN
      // F_FUNC_BODY
      // F_DIRECTIVE_CTX
      // F_SEMICOLON_OPT
      var S_TFFF = F_ALLOW_IN,
          S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,
          S_FFFF = 0x00,
          S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,
          S_TTFF = F_ALLOW_IN | F_FUNC_BODY;

      function getDefaultOptions() {
          // default options
          return {
              indent: null,
              base: null,
              parse: null,
              comment: false,
              format: {
                  indent: {
                      style: '    ',
                      base: 0,
                      adjustMultilineComment: false
                  },
                  newline: '\n',
                  space: ' ',
                  json: false,
                  renumber: false,
                  hexadecimal: false,
                  quotes: 'single',
                  escapeless: false,
                  compact: false,
                  parentheses: true,
                  semicolons: true,
                  safeConcatenation: false,
                  preserveBlankLines: false
              },
              moz: {
                  comprehensionExpressionStartsWithAssignment: false,
                  starlessGenerator: false
              },
              sourceMap: null,
              sourceMapRoot: null,
              sourceMapWithCode: false,
              directive: false,
              raw: true,
              verbatim: null,
              sourceCode: null
          };
      }

      function stringRepeat(str, num) {
          var result = '';

          for (num |= 0; num > 0; num >>>= 1, str += str) {
              if (num & 1) {
                  result += str;
              }
          }

          return result;
      }

      function hasLineTerminator(str) {
          return (/[\r\n]/g).test(str);
      }

      function endsWithLineTerminator(str) {
          var len = str.length;
          return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
      }

      function merge(target, override) {
          var key;
          for (key in override) {
              if (override.hasOwnProperty(key)) {
                  target[key] = override[key];
              }
          }
          return target;
      }

      function updateDeeply(target, override) {
          var key, val;

          function isHashObject(target) {
              return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
          }

          for (key in override) {
              if (override.hasOwnProperty(key)) {
                  val = override[key];
                  if (isHashObject(val)) {
                      if (isHashObject(target[key])) {
                          updateDeeply(target[key], val);
                      } else {
                          target[key] = updateDeeply({}, val);
                      }
                  } else {
                      target[key] = val;
                  }
              }
          }
          return target;
      }

      function generateNumber(value) {
          var result, point, temp, exponent, pos;

          if (value !== value) {
              throw new Error('Numeric literal whose value is NaN');
          }
          if (value < 0 || (value === 0 && 1 / value < 0)) {
              throw new Error('Numeric literal whose value is negative');
          }

          if (value === 1 / 0) {
              return json ? 'null' : renumber ? '1e400' : '1e+400';
          }

          result = '' + value;
          if (!renumber || result.length < 3) {
              return result;
          }

          point = result.indexOf('.');
          if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
              point = 0;
              result = result.slice(1);
          }
          temp = result;
          result = result.replace('e+', 'e');
          exponent = 0;
          if ((pos = temp.indexOf('e')) > 0) {
              exponent = +temp.slice(pos + 1);
              temp = temp.slice(0, pos);
          }
          if (point >= 0) {
              exponent -= temp.length - point - 1;
              temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
          }
          pos = 0;
          while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
              --pos;
          }
          if (pos !== 0) {
              exponent -= pos;
              temp = temp.slice(0, pos);
          }
          if (exponent !== 0) {
              temp += 'e' + exponent;
          }
          if ((temp.length < result.length ||
                      (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                  +temp === value) {
              result = temp;
          }

          return result;
      }

      // Generate valid RegExp expression.
      // This function is based on https://github.com/Constellation/iv Engine

      function escapeRegExpCharacter(ch, previousIsBackslash) {
          // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
          if ((ch & ~1) === 0x2028) {
              return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
          } else if (ch === 10 || ch === 13) {  // \n, \r
              return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
          }
          return String.fromCharCode(ch);
      }

      function generateRegExp(reg) {
          var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

          result = reg.toString();

          if (reg.source) {
              // extract flag from toString result
              match = result.match(/\/([^/]*)$/);
              if (!match) {
                  return result;
              }

              flags = match[1];
              result = '';

              characterInBrack = false;
              previousIsBackslash = false;
              for (i = 0, iz = reg.source.length; i < iz; ++i) {
                  ch = reg.source.charCodeAt(i);

                  if (!previousIsBackslash) {
                      if (characterInBrack) {
                          if (ch === 93) {  // ]
                              characterInBrack = false;
                          }
                      } else {
                          if (ch === 47) {  // /
                              result += '\\';
                          } else if (ch === 91) {  // [
                              characterInBrack = true;
                          }
                      }
                      result += escapeRegExpCharacter(ch, previousIsBackslash);
                      previousIsBackslash = ch === 92;  // \
                  } else {
                      // if new RegExp("\\\n') is provided, create /\n/
                      result += escapeRegExpCharacter(ch, previousIsBackslash);
                      // prevent like /\\[/]/
                      previousIsBackslash = false;
                  }
              }

              return '/' + result + '/' + flags;
          }

          return result;
      }

      function escapeAllowedCharacter(code, next) {
          var hex;

          if (code === 0x08  /* \b */) {
              return '\\b';
          }

          if (code === 0x0C  /* \f */) {
              return '\\f';
          }

          if (code === 0x09  /* \t */) {
              return '\\t';
          }

          hex = code.toString(16).toUpperCase();
          if (json || code > 0xFF) {
              return '\\u' + '0000'.slice(hex.length) + hex;
          } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
              return '\\0';
          } else if (code === 0x000B  /* \v */) { // '\v'
              return '\\x0B';
          } else {
              return '\\x' + '00'.slice(hex.length) + hex;
          }
      }

      function escapeDisallowedCharacter(code) {
          if (code === 0x5C  /* \ */) {
              return '\\\\';
          }

          if (code === 0x0A  /* \n */) {
              return '\\n';
          }

          if (code === 0x0D  /* \r */) {
              return '\\r';
          }

          if (code === 0x2028) {
              return '\\u2028';
          }

          if (code === 0x2029) {
              return '\\u2029';
          }

          throw new Error('Incorrectly classified character');
      }

      function escapeDirective(str) {
          var i, iz, code, quote;

          quote = quotes === 'double' ? '"' : '\'';
          for (i = 0, iz = str.length; i < iz; ++i) {
              code = str.charCodeAt(i);
              if (code === 0x27  /* ' */) {
                  quote = '"';
                  break;
              } else if (code === 0x22  /* " */) {
                  quote = '\'';
                  break;
              } else if (code === 0x5C  /* \ */) {
                  ++i;
              }
          }

          return quote + str + quote;
      }

      function escapeString(str) {
          var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;

          for (i = 0, len = str.length; i < len; ++i) {
              code = str.charCodeAt(i);
              if (code === 0x27  /* ' */) {
                  ++singleQuotes;
              } else if (code === 0x22  /* " */) {
                  ++doubleQuotes;
              } else if (code === 0x2F  /* / */ && json) {
                  result += '\\';
              } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                  result += escapeDisallowedCharacter(code);
                  continue;
              } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20  /* SP */ || !json && !escapeless && (code < 0x20  /* SP */ || code > 0x7E  /* ~ */))) {
                  result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                  continue;
              }
              result += String.fromCharCode(code);
          }

          single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
          quote = single ? '\'' : '"';

          if (!(single ? singleQuotes : doubleQuotes)) {
              return quote + result + quote;
          }

          str = result;
          result = quote;

          for (i = 0, len = str.length; i < len; ++i) {
              code = str.charCodeAt(i);
              if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                  result += '\\';
              }
              result += String.fromCharCode(code);
          }

          return result + quote;
      }

      /**
       * flatten an array to a string, where the array can contain
       * either strings or nested arrays
       */
      function flattenToString(arr) {
          var i, iz, elem, result = '';
          for (i = 0, iz = arr.length; i < iz; ++i) {
              elem = arr[i];
              result += Array.isArray(elem) ? flattenToString(elem) : elem;
          }
          return result;
      }

      /**
       * convert generated to a SourceNode when source maps are enabled.
       */
      function toSourceNodeWhenNeeded(generated, node) {
          if (!sourceMap$1) {
              // with no source maps, generated is either an
              // array or a string.  if an array, flatten it.
              // if a string, just return it
              if (Array.isArray(generated)) {
                  return flattenToString(generated);
              } else {
                  return generated;
              }
          }
          if (node == null) {
              if (generated instanceof SourceNode) {
                  return generated;
              } else {
                  node = {};
              }
          }
          if (node.loc == null) {
              return new SourceNode(null, null, sourceMap$1, generated, node.name || null);
          }
          return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap$1 === true ? node.loc.source || null : sourceMap$1), generated, node.name || null);
      }

      function noEmptySpace() {
          return (space) ? space : ' ';
      }

      function join(left, right) {
          var leftSource,
              rightSource,
              leftCharCode,
              rightCharCode;

          leftSource = toSourceNodeWhenNeeded(left).toString();
          if (leftSource.length === 0) {
              return [right];
          }

          rightSource = toSourceNodeWhenNeeded(right).toString();
          if (rightSource.length === 0) {
              return [left];
          }

          leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
          rightCharCode = rightSource.charCodeAt(0);

          if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
              esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) ||
              leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
              return [left, noEmptySpace(), right];
          } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                  esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
              return [left, right];
          }
          return [left, space, right];
      }

      function addIndent(stmt) {
          return [base, stmt];
      }

      function withIndent(fn) {
          var previousBase;
          previousBase = base;
          base += indent;
          fn(base);
          base = previousBase;
      }

      function calculateSpaces(str) {
          var i;
          for (i = str.length - 1; i >= 0; --i) {
              if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                  break;
              }
          }
          return (str.length - 1) - i;
      }

      function adjustMultilineComment(value, specialBase) {
          var array, i, len, line, j, spaces, previousBase, sn;

          array = value.split(/\r\n|[\r\n]/);
          spaces = Number.MAX_VALUE;

          // first line doesn't have indentation
          for (i = 1, len = array.length; i < len; ++i) {
              line = array[i];
              j = 0;
              while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                  ++j;
              }
              if (spaces > j) {
                  spaces = j;
              }
          }

          if (typeof specialBase !== 'undefined') {
              // pattern like
              // {
              //   var t = 20;  /*
              //                 * this is comment
              //                 */
              // }
              previousBase = base;
              if (array[1][spaces] === '*') {
                  specialBase += ' ';
              }
              base = specialBase;
          } else {
              if (spaces & 1) {
                  // /*
                  //  *
                  //  */
                  // If spaces are odd number, above pattern is considered.
                  // We waste 1 space.
                  --spaces;
              }
              previousBase = base;
          }

          for (i = 1, len = array.length; i < len; ++i) {
              sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
              array[i] = sourceMap$1 ? sn.join('') : sn;
          }

          base = previousBase;

          return array.join('\n');
      }

      function generateComment(comment, specialBase) {
          if (comment.type === 'Line') {
              if (endsWithLineTerminator(comment.value)) {
                  return '//' + comment.value;
              } else {
                  // Always use LineTerminator
                  var result = '//' + comment.value;
                  if (!preserveBlankLines) {
                      result += '\n';
                  }
                  return result;
              }
          }
          if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
              return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
          }
          return '/*' + comment.value + '*/';
      }

      function addComments(stmt, result) {
          var i, len, comment, save, tailingToStatement, specialBase, fragment,
              extRange, range, prevRange, prefix, infix, suffix, count;

          if (stmt.leadingComments && stmt.leadingComments.length > 0) {
              save = result;

              if (preserveBlankLines) {
                  comment = stmt.leadingComments[0];
                  result = [];

                  extRange = comment.extendedRange;
                  range = comment.range;

                  prefix = sourceCode.substring(extRange[0], range[0]);
                  count = (prefix.match(/\n/g) || []).length;
                  if (count > 0) {
                      result.push(stringRepeat('\n', count));
                      result.push(addIndent(generateComment(comment)));
                  } else {
                      result.push(prefix);
                      result.push(generateComment(comment));
                  }

                  prevRange = range;

                  for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
                      comment = stmt.leadingComments[i];
                      range = comment.range;

                      infix = sourceCode.substring(prevRange[1], range[0]);
                      count = (infix.match(/\n/g) || []).length;
                      result.push(stringRepeat('\n', count));
                      result.push(addIndent(generateComment(comment)));

                      prevRange = range;
                  }

                  suffix = sourceCode.substring(range[1], extRange[1]);
                  count = (suffix.match(/\n/g) || []).length;
                  result.push(stringRepeat('\n', count));
              } else {
                  comment = stmt.leadingComments[0];
                  result = [];
                  if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                      result.push('\n');
                  }
                  result.push(generateComment(comment));
                  if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                      result.push('\n');
                  }

                  for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                      comment = stmt.leadingComments[i];
                      fragment = [generateComment(comment)];
                      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                          fragment.push('\n');
                      }
                      result.push(addIndent(fragment));
                  }
              }

              result.push(addIndent(save));
          }

          if (stmt.trailingComments) {

              if (preserveBlankLines) {
                  comment = stmt.trailingComments[0];
                  extRange = comment.extendedRange;
                  range = comment.range;

                  prefix = sourceCode.substring(extRange[0], range[0]);
                  count = (prefix.match(/\n/g) || []).length;

                  if (count > 0) {
                      result.push(stringRepeat('\n', count));
                      result.push(addIndent(generateComment(comment)));
                  } else {
                      result.push(prefix);
                      result.push(generateComment(comment));
                  }
              } else {
                  tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
                  specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
                  for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                      comment = stmt.trailingComments[i];
                      if (tailingToStatement) {
                          // We assume target like following script
                          //
                          // var t = 20;  /**
                          //               * This is comment of t
                          //               */
                          if (i === 0) {
                              // first case
                              result = [result, indent];
                          } else {
                              result = [result, specialBase];
                          }
                          result.push(generateComment(comment, specialBase));
                      } else {
                          result = [result, addIndent(generateComment(comment))];
                      }
                      if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                          result = [result, '\n'];
                      }
                  }
              }
          }

          return result;
      }

      function generateBlankLines(start, end, result) {
          var j, newlineCount = 0;

          for (j = start; j < end; j++) {
              if (sourceCode[j] === '\n') {
                  newlineCount++;
              }
          }

          for (j = 1; j < newlineCount; j++) {
              result.push(newline);
          }
      }

      function parenthesize(text, current, should) {
          if (current < should) {
              return ['(', text, ')'];
          }
          return text;
      }

      function generateVerbatimString(string) {
          var i, iz, result;
          result = string.split(/\r\n|\n/);
          for (i = 1, iz = result.length; i < iz; i++) {
              result[i] = newline + base + result[i];
          }
          return result;
      }

      function generateVerbatim(expr, precedence) {
          var verbatim, result, prec;
          verbatim = expr[extra.verbatim];

          if (typeof verbatim === 'string') {
              result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
          } else {
              // verbatim is object
              result = generateVerbatimString(verbatim.content);
              prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
              result = parenthesize(result, prec, precedence);
          }

          return toSourceNodeWhenNeeded(result, expr);
      }

      function CodeGenerator() {
      }

      // Helpers.

      CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
          var result, noLeadingComment, that = this;

          noLeadingComment = !extra.comment || !stmt.leadingComments;

          if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
              return [space, this.generateStatement(stmt, flags)];
          }

          if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
              return ';';
          }

          withIndent(function () {
              result = [
                  newline,
                  addIndent(that.generateStatement(stmt, flags))
              ];
          });

          return result;
      };

      CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
          var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
          if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
              return [result, space];
          }
          if (ends) {
              return [result, base];
          }
          return [result, newline, base];
      };

      function generateIdentifier(node) {
          return toSourceNodeWhenNeeded(node.name, node);
      }

      function generateAsyncPrefix(node, spaceRequired) {
          return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';
      }

      function generateStarSuffix(node) {
          var isGenerator = node.generator && !extra.moz.starlessGenerator;
          return isGenerator ? '*' + space : '';
      }

      function generateMethodPrefix(prop) {
          var func = prop.value, prefix = '';
          if (func.async) {
              prefix += generateAsyncPrefix(func, !prop.computed);
          }
          if (func.generator) {
              // avoid space before method name
              prefix += generateStarSuffix(func) ? '*' : '';
          }
          return prefix;
      }

      CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
          if (node.type === Syntax.Identifier) {
              return generateIdentifier(node);
          }
          return this.generateExpression(node, precedence, flags);
      };

      CodeGenerator.prototype.generateFunctionParams = function (node) {
          var i, iz, result, hasDefault;

          hasDefault = false;

          if (node.type === Syntax.ArrowFunctionExpression &&
                  !node.rest && (!node.defaults || node.defaults.length === 0) &&
                  node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
              // arg => { } case
              result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
          } else {
              result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
              result.push('(');
              if (node.defaults) {
                  hasDefault = true;
              }
              for (i = 0, iz = node.params.length; i < iz; ++i) {
                  if (hasDefault && node.defaults[i]) {
                      // Handle default values.
                      result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));
                  } else {
                      result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
                  }
                  if (i + 1 < iz) {
                      result.push(',' + space);
                  }
              }

              if (node.rest) {
                  if (node.params.length) {
                      result.push(',' + space);
                  }
                  result.push('...');
                  result.push(generateIdentifier(node.rest));
              }

              result.push(')');
          }

          return result;
      };

      CodeGenerator.prototype.generateFunctionBody = function (node) {
          var result, expr;

          result = this.generateFunctionParams(node);

          if (node.type === Syntax.ArrowFunctionExpression) {
              result.push(space);
              result.push('=>');
          }

          if (node.expression) {
              result.push(space);
              expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
              if (expr.toString().charAt(0) === '{') {
                  expr = ['(', expr, ')'];
              }
              result.push(expr);
          } else {
              result.push(this.maybeBlock(node.body, S_TTFF));
          }

          return result;
      };

      CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
          var result = ['for' + (stmt.await ? noEmptySpace() + 'await' : '') + space + '('], that = this;
          withIndent(function () {
              if (stmt.left.type === Syntax.VariableDeclaration) {
                  withIndent(function () {
                      result.push(stmt.left.kind + noEmptySpace());
                      result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
                  });
              } else {
                  result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
              }

              result = join(result, operator);
              result = [join(
                  result,
                  that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)
              ), ')'];
          });
          result.push(this.maybeBlock(stmt.body, flags));
          return result;
      };

      CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
          var result = [];

          if (computed) {
              result.push('[');
          }

          result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));

          if (computed) {
              result.push(']');
          }

          return result;
      };

      CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
          if (Precedence.Assignment < precedence) {
              flags |= F_ALLOW_IN;
          }

          return parenthesize(
              [
                  this.generateExpression(left, Precedence.Call, flags),
                  space + operator + space,
                  this.generateExpression(right, Precedence.Assignment, flags)
              ],
              Precedence.Assignment,
              precedence
          );
      };

      CodeGenerator.prototype.semicolon = function (flags) {
          if (!semicolons && flags & F_SEMICOLON_OPT) {
              return '';
          }
          return ';';
      };

      // Statements.

      CodeGenerator.Statement = {

          BlockStatement: function (stmt, flags) {
              var range, content, result = ['{', newline], that = this;

              withIndent(function () {
                  // handle functions without any code
                  if (stmt.body.length === 0 && preserveBlankLines) {
                      range = stmt.range;
                      if (range[1] - range[0] > 2) {
                          content = sourceCode.substring(range[0] + 1, range[1] - 1);
                          if (content[0] === '\n') {
                              result = ['{'];
                          }
                          result.push(content);
                      }
                  }

                  var i, iz, fragment, bodyFlags;
                  bodyFlags = S_TFFF;
                  if (flags & F_FUNC_BODY) {
                      bodyFlags |= F_DIRECTIVE_CTX;
                  }

                  for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                      if (preserveBlankLines) {
                          // handle spaces before the first line
                          if (i === 0) {
                              if (stmt.body[0].leadingComments) {
                                  range = stmt.body[0].leadingComments[0].extendedRange;
                                  content = sourceCode.substring(range[0], range[1]);
                                  if (content[0] === '\n') {
                                      result = ['{'];
                                  }
                              }
                              if (!stmt.body[0].leadingComments) {
                                  generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                              }
                          }

                          // handle spaces between lines
                          if (i > 0) {
                              if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {
                                  generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                              }
                          }
                      }

                      if (i === iz - 1) {
                          bodyFlags |= F_SEMICOLON_OPT;
                      }

                      if (stmt.body[i].leadingComments && preserveBlankLines) {
                          fragment = that.generateStatement(stmt.body[i], bodyFlags);
                      } else {
                          fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
                      }

                      result.push(fragment);
                      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                          if (preserveBlankLines && i < iz - 1) {
                              // don't add a new line if there are leading coments
                              // in the next statement
                              if (!stmt.body[i + 1].leadingComments) {
                                  result.push(newline);
                              }
                          } else {
                              result.push(newline);
                          }
                      }

                      if (preserveBlankLines) {
                          // handle spaces after the last line
                          if (i === iz - 1) {
                              if (!stmt.body[i].trailingComments) {
                                  generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                              }
                          }
                      }
                  }
              });

              result.push(addIndent('}'));
              return result;
          },

          BreakStatement: function (stmt, flags) {
              if (stmt.label) {
                  return 'break ' + stmt.label.name + this.semicolon(flags);
              }
              return 'break' + this.semicolon(flags);
          },

          ContinueStatement: function (stmt, flags) {
              if (stmt.label) {
                  return 'continue ' + stmt.label.name + this.semicolon(flags);
              }
              return 'continue' + this.semicolon(flags);
          },

          ClassBody: function (stmt, flags) {
              var result = [ '{', newline], that = this;

              withIndent(function (indent) {
                  var i, iz;

                  for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                      result.push(indent);
                      result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
                      if (i + 1 < iz) {
                          result.push(newline);
                      }
                  }
              });

              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                  result.push(newline);
              }
              result.push(base);
              result.push('}');
              return result;
          },

          ClassDeclaration: function (stmt, flags) {
              var result, fragment;
              result  = ['class'];
              if (stmt.id) {
                  result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
              }
              if (stmt.superClass) {
                  fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
                  result = join(result, fragment);
              }
              result.push(space);
              result.push(this.generateStatement(stmt.body, S_TFFT));
              return result;
          },

          DirectiveStatement: function (stmt, flags) {
              if (extra.raw && stmt.raw) {
                  return stmt.raw + this.semicolon(flags);
              }
              return escapeDirective(stmt.directive) + this.semicolon(flags);
          },

          DoWhileStatement: function (stmt, flags) {
              // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
              var result = join('do', this.maybeBlock(stmt.body, S_TFFF));
              result = this.maybeBlockSuffix(stmt.body, result);
              return join(result, [
                  'while' + space + '(',
                  this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                  ')' + this.semicolon(flags)
              ]);
          },

          CatchClause: function (stmt, flags) {
              var result, that = this;
              withIndent(function () {
                  var guard;

                  if (stmt.param) {
                      result = [
                          'catch' + space + '(',
                          that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                          ')'
                      ];

                      if (stmt.guard) {
                          guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                          result.splice(2, 0, ' if ', guard);
                      }
                  } else {
                      result = ['catch'];
                  }
              });
              result.push(this.maybeBlock(stmt.body, S_TFFF));
              return result;
          },

          DebuggerStatement: function (stmt, flags) {
              return 'debugger' + this.semicolon(flags);
          },

          EmptyStatement: function (stmt, flags) {
              return ';';
          },

          ExportDefaultDeclaration: function (stmt, flags) {
              var result = [ 'export' ], bodyFlags;

              bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

              // export default HoistableDeclaration[Default]
              // export default AssignmentExpression[In] ;
              result = join(result, 'default');
              if (isStatement(stmt.declaration)) {
                  result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
              } else {
                  result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
              }
              return result;
          },

          ExportNamedDeclaration: function (stmt, flags) {
              var result = [ 'export' ], bodyFlags, that = this;

              bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

              // export VariableStatement
              // export Declaration[Default]
              if (stmt.declaration) {
                  return join(result, this.generateStatement(stmt.declaration, bodyFlags));
              }

              // export ExportClause[NoReference] FromClause ;
              // export ExportClause ;
              if (stmt.specifiers) {
                  if (stmt.specifiers.length === 0) {
                      result = join(result, '{' + space + '}');
                  } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
                      result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
                  } else {
                      result = join(result, '{');
                      withIndent(function (indent) {
                          var i, iz;
                          result.push(newline);
                          for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                              result.push(indent);
                              result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                              if (i + 1 < iz) {
                                  result.push(',' + newline);
                              }
                          }
                      });
                      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                          result.push(newline);
                      }
                      result.push(base + '}');
                  }

                  if (stmt.source) {
                      result = join(result, [
                          'from' + space,
                          // ModuleSpecifier
                          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                          this.semicolon(flags)
                      ]);
                  } else {
                      result.push(this.semicolon(flags));
                  }
              }
              return result;
          },

          ExportAllDeclaration: function (stmt, flags) {
              // export * FromClause ;
              return [
                  'export' + space,
                  '*' + space,
                  'from' + space,
                  // ModuleSpecifier
                  this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                  this.semicolon(flags)
              ];
          },

          ExpressionStatement: function (stmt, flags) {
              var result, fragment;

              function isClassPrefixed(fragment) {
                  var code;
                  if (fragment.slice(0, 5) !== 'class') {
                      return false;
                  }
                  code = fragment.charCodeAt(5);
                  return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
              }

              function isFunctionPrefixed(fragment) {
                  var code;
                  if (fragment.slice(0, 8) !== 'function') {
                      return false;
                  }
                  code = fragment.charCodeAt(8);
                  return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
              }

              function isAsyncPrefixed(fragment) {
                  var code, i, iz;
                  if (fragment.slice(0, 5) !== 'async') {
                      return false;
                  }
                  if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
                      return false;
                  }
                  for (i = 6, iz = fragment.length; i < iz; ++i) {
                      if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
                          break;
                      }
                  }
                  if (i === iz) {
                      return false;
                  }
                  if (fragment.slice(i, i + 8) !== 'function') {
                      return false;
                  }
                  code = fragment.charCodeAt(i + 8);
                  return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
              }

              result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
              // 12.4 '{', 'function', 'class' is not allowed in this position.
              // wrap expression with parentheses
              fragment = toSourceNodeWhenNeeded(result).toString();
              if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression
                      isClassPrefixed(fragment) ||
                      isFunctionPrefixed(fragment) ||
                      isAsyncPrefixed(fragment) ||
                      (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                  result = ['(', result, ')' + this.semicolon(flags)];
              } else {
                  result.push(this.semicolon(flags));
              }
              return result;
          },

          ImportDeclaration: function (stmt, flags) {
              // ES6: 15.2.1 valid import declarations:
              //     - import ImportClause FromClause ;
              //     - import ModuleSpecifier ;
              var result, cursor, that = this;

              // If no ImportClause is present,
              // this should be `import ModuleSpecifier` so skip `from`
              // ModuleSpecifier is StringLiteral.
              if (stmt.specifiers.length === 0) {
                  // import ModuleSpecifier ;
                  return [
                      'import',
                      space,
                      // ModuleSpecifier
                      this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                      this.semicolon(flags)
                  ];
              }

              // import ImportClause FromClause ;
              result = [
                  'import'
              ];
              cursor = 0;

              // ImportedBinding
              if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
                  result = join(result, [
                          this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                  ]);
                  ++cursor;
              }

              if (stmt.specifiers[cursor]) {
                  if (cursor !== 0) {
                      result.push(',');
                  }

                  if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
                      // NameSpaceImport
                      result = join(result, [
                              space,
                              this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                      ]);
                  } else {
                      // NamedImports
                      result.push(space + '{');

                      if ((stmt.specifiers.length - cursor) === 1) {
                          // import { ... } from "...";
                          result.push(space);
                          result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                          result.push(space + '}' + space);
                      } else {
                          // import {
                          //    ...,
                          //    ...,
                          // } from "...";
                          withIndent(function (indent) {
                              var i, iz;
                              result.push(newline);
                              for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                                  result.push(indent);
                                  result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                                  if (i + 1 < iz) {
                                      result.push(',' + newline);
                                  }
                              }
                          });
                          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                              result.push(newline);
                          }
                          result.push(base + '}' + space);
                      }
                  }
              }

              result = join(result, [
                  'from' + space,
                  // ModuleSpecifier
                  this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                  this.semicolon(flags)
              ]);
              return result;
          },

          VariableDeclarator: function (stmt, flags) {
              var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;
              if (stmt.init) {
                  return [
                      this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
                      space,
                      '=',
                      space,
                      this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
                  ];
              }
              return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
          },

          VariableDeclaration: function (stmt, flags) {
              // VariableDeclarator is typed as Statement,
              // but joined with comma (not LineTerminator).
              // So if comment is attached to target node, we should specialize.
              var result, i, iz, node, bodyFlags, that = this;

              result = [ stmt.kind ];

              bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;

              function block() {
                  node = stmt.declarations[0];
                  if (extra.comment && node.leadingComments) {
                      result.push('\n');
                      result.push(addIndent(that.generateStatement(node, bodyFlags)));
                  } else {
                      result.push(noEmptySpace());
                      result.push(that.generateStatement(node, bodyFlags));
                  }

                  for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
                      node = stmt.declarations[i];
                      if (extra.comment && node.leadingComments) {
                          result.push(',' + newline);
                          result.push(addIndent(that.generateStatement(node, bodyFlags)));
                      } else {
                          result.push(',' + space);
                          result.push(that.generateStatement(node, bodyFlags));
                      }
                  }
              }

              if (stmt.declarations.length > 1) {
                  withIndent(block);
              } else {
                  block();
              }

              result.push(this.semicolon(flags));

              return result;
          },

          ThrowStatement: function (stmt, flags) {
              return [join(
                  'throw',
                  this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
              ), this.semicolon(flags)];
          },

          TryStatement: function (stmt, flags) {
              var result, i, iz, guardedHandlers;

              result = ['try', this.maybeBlock(stmt.block, S_TFFF)];
              result = this.maybeBlockSuffix(stmt.block, result);

              if (stmt.handlers) {
                  // old interface
                  for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
                      result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
                      if (stmt.finalizer || i + 1 !== iz) {
                          result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
                      }
                  }
              } else {
                  guardedHandlers = stmt.guardedHandlers || [];

                  for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
                      result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
                      if (stmt.finalizer || i + 1 !== iz) {
                          result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
                      }
                  }

                  // new interface
                  if (stmt.handler) {
                      if (Array.isArray(stmt.handler)) {
                          for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                              result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                              if (stmt.finalizer || i + 1 !== iz) {
                                  result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                              }
                          }
                      } else {
                          result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                          if (stmt.finalizer) {
                              result = this.maybeBlockSuffix(stmt.handler.body, result);
                          }
                      }
                  }
              }
              if (stmt.finalizer) {
                  result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);
              }
              return result;
          },

          SwitchStatement: function (stmt, flags) {
              var result, fragment, i, iz, bodyFlags, that = this;
              withIndent(function () {
                  result = [
                      'switch' + space + '(',
                      that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
                      ')' + space + '{' + newline
                  ];
              });
              if (stmt.cases) {
                  bodyFlags = S_TFFF;
                  for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
                      if (i === iz - 1) {
                          bodyFlags |= F_SEMICOLON_OPT;
                      }
                      fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
                      result.push(fragment);
                      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                          result.push(newline);
                      }
                  }
              }
              result.push(addIndent('}'));
              return result;
          },

          SwitchCase: function (stmt, flags) {
              var result, fragment, i, iz, bodyFlags, that = this;
              withIndent(function () {
                  if (stmt.test) {
                      result = [
                          join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                          ':'
                      ];
                  } else {
                      result = ['default:'];
                  }

                  i = 0;
                  iz = stmt.consequent.length;
                  if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
                      fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
                      result.push(fragment);
                      i = 1;
                  }

                  if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                      result.push(newline);
                  }

                  bodyFlags = S_TFFF;
                  for (; i < iz; ++i) {
                      if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                          bodyFlags |= F_SEMICOLON_OPT;
                      }
                      fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
                      result.push(fragment);
                      if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                          result.push(newline);
                      }
                  }
              });
              return result;
          },

          IfStatement: function (stmt, flags) {
              var result, bodyFlags, semicolonOptional, that = this;
              withIndent(function () {
                  result = [
                      'if' + space + '(',
                      that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                      ')'
                  ];
              });
              semicolonOptional = flags & F_SEMICOLON_OPT;
              bodyFlags = S_TFFF;
              if (semicolonOptional) {
                  bodyFlags |= F_SEMICOLON_OPT;
              }
              if (stmt.alternate) {
                  result.push(this.maybeBlock(stmt.consequent, S_TFFF));
                  result = this.maybeBlockSuffix(stmt.consequent, result);
                  if (stmt.alternate.type === Syntax.IfStatement) {
                      result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);
                  } else {
                      result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));
                  }
              } else {
                  result.push(this.maybeBlock(stmt.consequent, bodyFlags));
              }
              return result;
          },

          ForStatement: function (stmt, flags) {
              var result, that = this;
              withIndent(function () {
                  result = ['for' + space + '('];
                  if (stmt.init) {
                      if (stmt.init.type === Syntax.VariableDeclaration) {
                          result.push(that.generateStatement(stmt.init, S_FFFF));
                      } else {
                          // F_ALLOW_IN becomes false.
                          result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                          result.push(';');
                      }
                  } else {
                      result.push(';');
                  }

                  if (stmt.test) {
                      result.push(space);
                      result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
                      result.push(';');
                  } else {
                      result.push(';');
                  }

                  if (stmt.update) {
                      result.push(space);
                      result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
                      result.push(')');
                  } else {
                      result.push(')');
                  }
              });

              result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
              return result;
          },

          ForInStatement: function (stmt, flags) {
              return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
          },

          ForOfStatement: function (stmt, flags) {
              return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
          },

          LabeledStatement: function (stmt, flags) {
              return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
          },

          Program: function (stmt, flags) {
              var result, fragment, i, iz, bodyFlags;
              iz = stmt.body.length;
              result = [safeConcatenation && iz > 0 ? '\n' : ''];
              bodyFlags = S_TFTF;
              for (i = 0; i < iz; ++i) {
                  if (!safeConcatenation && i === iz - 1) {
                      bodyFlags |= F_SEMICOLON_OPT;
                  }

                  if (preserveBlankLines) {
                      // handle spaces before the first line
                      if (i === 0) {
                          if (!stmt.body[0].leadingComments) {
                              generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                          }
                      }

                      // handle spaces between lines
                      if (i > 0) {
                          if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                              generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                          }
                      }
                  }

                  fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
                  result.push(fragment);
                  if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                      if (preserveBlankLines) {
                          if (!stmt.body[i + 1].leadingComments) {
                              result.push(newline);
                          }
                      } else {
                          result.push(newline);
                      }
                  }

                  if (preserveBlankLines) {
                      // handle spaces after the last line
                      if (i === iz - 1) {
                          if (!stmt.body[i].trailingComments) {
                              generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                          }
                      }
                  }
              }
              return result;
          },

          FunctionDeclaration: function (stmt, flags) {
              return [
                  generateAsyncPrefix(stmt, true),
                  'function',
                  generateStarSuffix(stmt) || noEmptySpace(),
                  stmt.id ? generateIdentifier(stmt.id) : '',
                  this.generateFunctionBody(stmt)
              ];
          },

          ReturnStatement: function (stmt, flags) {
              if (stmt.argument) {
                  return [join(
                      'return',
                      this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
                  ), this.semicolon(flags)];
              }
              return ['return' + this.semicolon(flags)];
          },

          WhileStatement: function (stmt, flags) {
              var result, that = this;
              withIndent(function () {
                  result = [
                      'while' + space + '(',
                      that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                      ')'
                  ];
              });
              result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
              return result;
          },

          WithStatement: function (stmt, flags) {
              var result, that = this;
              withIndent(function () {
                  result = [
                      'with' + space + '(',
                      that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
                      ')'
                  ];
              });
              result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
              return result;
          }

      };

      merge(CodeGenerator.prototype, CodeGenerator.Statement);

      // Expressions.

      CodeGenerator.Expression = {

          SequenceExpression: function (expr, precedence, flags) {
              var result, i, iz;
              if (Precedence.Sequence < precedence) {
                  flags |= F_ALLOW_IN;
              }
              result = [];
              for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
                  result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
                  if (i + 1 < iz) {
                      result.push(',' + space);
                  }
              }
              return parenthesize(result, Precedence.Sequence, precedence);
          },

          AssignmentExpression: function (expr, precedence, flags) {
              return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
          },

          ArrowFunctionExpression: function (expr, precedence, flags) {
              return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
          },

          ConditionalExpression: function (expr, precedence, flags) {
              if (Precedence.Conditional < precedence) {
                  flags |= F_ALLOW_IN;
              }
              return parenthesize(
                  [
                      this.generateExpression(expr.test, Precedence.LogicalOR, flags),
                      space + '?' + space,
                      this.generateExpression(expr.consequent, Precedence.Assignment, flags),
                      space + ':' + space,
                      this.generateExpression(expr.alternate, Precedence.Assignment, flags)
                  ],
                  Precedence.Conditional,
                  precedence
              );
          },

          LogicalExpression: function (expr, precedence, flags) {
              return this.BinaryExpression(expr, precedence, flags);
          },

          BinaryExpression: function (expr, precedence, flags) {
              var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
              currentPrecedence = BinaryPrecedence[expr.operator];
              leftPrecedence = expr.operator === '**' ? Precedence.Postfix : currentPrecedence;
              rightPrecedence = expr.operator === '**' ? currentPrecedence : currentPrecedence + 1;

              if (currentPrecedence < precedence) {
                  flags |= F_ALLOW_IN;
              }

              fragment = this.generateExpression(expr.left, leftPrecedence, flags);

              leftSource = fragment.toString();

              if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
                  result = [fragment, noEmptySpace(), expr.operator];
              } else {
                  result = join(fragment, expr.operator);
              }

              fragment = this.generateExpression(expr.right, rightPrecedence, flags);

              if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
              expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                  // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                  result.push(noEmptySpace());
                  result.push(fragment);
              } else {
                  result = join(result, fragment);
              }

              if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {
                  return ['(', result, ')'];
              }
              return parenthesize(result, currentPrecedence, precedence);
          },

          CallExpression: function (expr, precedence, flags) {
              var result, i, iz;
              // F_ALLOW_UNPARATH_NEW becomes false.
              result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
              result.push('(');
              for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {
                  result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                  if (i + 1 < iz) {
                      result.push(',' + space);
                  }
              }
              result.push(')');

              if (!(flags & F_ALLOW_CALL)) {
                  return ['(', result, ')'];
              }
              return parenthesize(result, Precedence.Call, precedence);
          },

          NewExpression: function (expr, precedence, flags) {
              var result, length, i, iz, itemFlags;
              length = expr['arguments'].length;

              // F_ALLOW_CALL becomes false.
              // F_ALLOW_UNPARATH_NEW may become false.
              itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;

              result = join(
                  'new',
                  this.generateExpression(expr.callee, Precedence.New, itemFlags)
              );

              if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
                  result.push('(');
                  for (i = 0, iz = length; i < iz; ++i) {
                      result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                      if (i + 1 < iz) {
                          result.push(',' + space);
                      }
                  }
                  result.push(')');
              }

              return parenthesize(result, Precedence.New, precedence);
          },

          MemberExpression: function (expr, precedence, flags) {
              var result, fragment;

              // F_ALLOW_UNPARATH_NEW becomes false.
              result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];

              if (expr.computed) {
                  result.push('[');
                  result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
                  result.push(']');
              } else {
                  if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                      fragment = toSourceNodeWhenNeeded(result).toString();
                      // When the following conditions are all true,
                      //   1. No floating point
                      //   2. Don't have exponents
                      //   3. The last character is a decimal digit
                      //   4. Not hexadecimal OR octal number literal
                      // we should add a floating point.
                      if (
                              fragment.indexOf('.') < 0 &&
                              !/[eExX]/.test(fragment) &&
                              esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                              !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                              ) {
                          result.push(' ');
                      }
                  }
                  result.push('.');
                  result.push(generateIdentifier(expr.property));
              }

              return parenthesize(result, Precedence.Member, precedence);
          },

          MetaProperty: function (expr, precedence, flags) {
              var result;
              result = [];
              result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
              result.push('.');
              result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
              return parenthesize(result, Precedence.Member, precedence);
          },

          UnaryExpression: function (expr, precedence, flags) {
              var result, fragment, rightCharCode, leftSource, leftCharCode;
              fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);

              if (space === '') {
                  result = join(expr.operator, fragment);
              } else {
                  result = [expr.operator];
                  if (expr.operator.length > 2) {
                      // delete, void, typeof
                      // get `typeof []`, not `typeof[]`
                      result = join(result, fragment);
                  } else {
                      // Prevent inserting spaces between operator and argument if it is unnecessary
                      // like, `!cond`
                      leftSource = toSourceNodeWhenNeeded(result).toString();
                      leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                      rightCharCode = fragment.toString().charCodeAt(0);

                      if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                              (esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode))) {
                          result.push(noEmptySpace());
                          result.push(fragment);
                      } else {
                          result.push(fragment);
                      }
                  }
              }
              return parenthesize(result, Precedence.Unary, precedence);
          },

          YieldExpression: function (expr, precedence, flags) {
              var result;
              if (expr.delegate) {
                  result = 'yield*';
              } else {
                  result = 'yield';
              }
              if (expr.argument) {
                  result = join(
                      result,
                      this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
                  );
              }
              return parenthesize(result, Precedence.Yield, precedence);
          },

          AwaitExpression: function (expr, precedence, flags) {
              var result = join(
                  expr.all ? 'await*' : 'await',
                  this.generateExpression(expr.argument, Precedence.Await, E_TTT)
              );
              return parenthesize(result, Precedence.Await, precedence);
          },

          UpdateExpression: function (expr, precedence, flags) {
              if (expr.prefix) {
                  return parenthesize(
                      [
                          expr.operator,
                          this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
                      ],
                      Precedence.Unary,
                      precedence
                  );
              }
              return parenthesize(
                  [
                      this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
                      expr.operator
                  ],
                  Precedence.Postfix,
                  precedence
              );
          },

          FunctionExpression: function (expr, precedence, flags) {
              var result = [
                  generateAsyncPrefix(expr, true),
                  'function'
              ];
              if (expr.id) {
                  result.push(generateStarSuffix(expr) || noEmptySpace());
                  result.push(generateIdentifier(expr.id));
              } else {
                  result.push(generateStarSuffix(expr) || space);
              }
              result.push(this.generateFunctionBody(expr));
              return result;
          },

          ArrayPattern: function (expr, precedence, flags) {
              return this.ArrayExpression(expr, precedence, flags, true);
          },

          ArrayExpression: function (expr, precedence, flags, isPattern) {
              var result, multiline, that = this;
              if (!expr.elements.length) {
                  return '[]';
              }
              multiline = isPattern ? false : expr.elements.length > 1;
              result = ['[', multiline ? newline : ''];
              withIndent(function (indent) {
                  var i, iz;
                  for (i = 0, iz = expr.elements.length; i < iz; ++i) {
                      if (!expr.elements[i]) {
                          if (multiline) {
                              result.push(indent);
                          }
                          if (i + 1 === iz) {
                              result.push(',');
                          }
                      } else {
                          result.push(multiline ? indent : '');
                          result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
                      }
                      if (i + 1 < iz) {
                          result.push(',' + (multiline ? newline : space));
                      }
                  }
              });
              if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                  result.push(newline);
              }
              result.push(multiline ? base : '');
              result.push(']');
              return result;
          },

          RestElement: function(expr, precedence, flags) {
              return '...' + this.generatePattern(expr.argument);
          },

          ClassExpression: function (expr, precedence, flags) {
              var result, fragment;
              result = ['class'];
              if (expr.id) {
                  result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
              }
              if (expr.superClass) {
                  fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
                  result = join(result, fragment);
              }
              result.push(space);
              result.push(this.generateStatement(expr.body, S_TFFT));
              return result;
          },

          MethodDefinition: function (expr, precedence, flags) {
              var result, fragment;
              if (expr['static']) {
                  result = ['static' + space];
              } else {
                  result = [];
              }
              if (expr.kind === 'get' || expr.kind === 'set') {
                  fragment = [
                      join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
                      this.generateFunctionBody(expr.value)
                  ];
              } else {
                  fragment = [
                      generateMethodPrefix(expr),
                      this.generatePropertyKey(expr.key, expr.computed),
                      this.generateFunctionBody(expr.value)
                  ];
              }
              return join(result, fragment);
          },

          Property: function (expr, precedence, flags) {
              if (expr.kind === 'get' || expr.kind === 'set') {
                  return [
                      expr.kind, noEmptySpace(),
                      this.generatePropertyKey(expr.key, expr.computed),
                      this.generateFunctionBody(expr.value)
                  ];
              }

              if (expr.shorthand) {
                  if (expr.value.type === "AssignmentPattern") {
                      return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
                  }
                  return this.generatePropertyKey(expr.key, expr.computed);
              }

              if (expr.method) {
                  return [
                      generateMethodPrefix(expr),
                      this.generatePropertyKey(expr.key, expr.computed),
                      this.generateFunctionBody(expr.value)
                  ];
              }

              return [
                  this.generatePropertyKey(expr.key, expr.computed),
                  ':' + space,
                  this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
              ];
          },

          ObjectExpression: function (expr, precedence, flags) {
              var multiline, result, fragment, that = this;

              if (!expr.properties.length) {
                  return '{}';
              }
              multiline = expr.properties.length > 1;

              withIndent(function () {
                  fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
              });

              if (!multiline) {
                  // issues 4
                  // Do not transform from
                  //   dejavu.Class.declare({
                  //       method2: function () {}
                  //   });
                  // to
                  //   dejavu.Class.declare({method2: function () {
                  //       }});
                  if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                      return [ '{', space, fragment, space, '}' ];
                  }
              }

              withIndent(function (indent) {
                  var i, iz;
                  result = [ '{', newline, indent, fragment ];

                  if (multiline) {
                      result.push(',' + newline);
                      for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                          result.push(indent);
                          result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                          if (i + 1 < iz) {
                              result.push(',' + newline);
                          }
                      }
                  }
              });

              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                  result.push(newline);
              }
              result.push(base);
              result.push('}');
              return result;
          },

          AssignmentPattern: function(expr, precedence, flags) {
              return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);
          },

          ObjectPattern: function (expr, precedence, flags) {
              var result, i, iz, multiline, property, that = this;
              if (!expr.properties.length) {
                  return '{}';
              }

              multiline = false;
              if (expr.properties.length === 1) {
                  property = expr.properties[0];
                  if (property.value.type !== Syntax.Identifier) {
                      multiline = true;
                  }
              } else {
                  for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                      property = expr.properties[i];
                      if (!property.shorthand) {
                          multiline = true;
                          break;
                      }
                  }
              }
              result = ['{', multiline ? newline : '' ];

              withIndent(function (indent) {
                  var i, iz;
                  for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                      result.push(multiline ? indent : '');
                      result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                      if (i + 1 < iz) {
                          result.push(',' + (multiline ? newline : space));
                      }
                  }
              });

              if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                  result.push(newline);
              }
              result.push(multiline ? base : '');
              result.push('}');
              return result;
          },

          ThisExpression: function (expr, precedence, flags) {
              return 'this';
          },

          Super: function (expr, precedence, flags) {
              return 'super';
          },

          Identifier: function (expr, precedence, flags) {
              return generateIdentifier(expr);
          },

          ImportDefaultSpecifier: function (expr, precedence, flags) {
              return generateIdentifier(expr.id || expr.local);
          },

          ImportNamespaceSpecifier: function (expr, precedence, flags) {
              var result = ['*'];
              var id = expr.id || expr.local;
              if (id) {
                  result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));
              }
              return result;
          },

          ImportSpecifier: function (expr, precedence, flags) {
              var imported = expr.imported;
              var result = [ imported.name ];
              var local = expr.local;
              if (local && local.name !== imported.name) {
                  result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));
              }
              return result;
          },

          ExportSpecifier: function (expr, precedence, flags) {
              var local = expr.local;
              var result = [ local.name ];
              var exported = expr.exported;
              if (exported && exported.name !== local.name) {
                  result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));
              }
              return result;
          },

          Literal: function (expr, precedence, flags) {
              var raw;
              if (expr.hasOwnProperty('raw') && parse && extra.raw) {
                  try {
                      raw = parse(expr.raw).body[0].expression;
                      if (raw.type === Syntax.Literal) {
                          if (raw.value === expr.value) {
                              return expr.raw;
                          }
                      }
                  } catch (e) {
                      // not use raw property
                  }
              }

              if (expr.regex) {
                return '/' + expr.regex.pattern + '/' + expr.regex.flags;
              }

              if (expr.value === null) {
                  return 'null';
              }

              if (typeof expr.value === 'string') {
                  return escapeString(expr.value);
              }

              if (typeof expr.value === 'number') {
                  return generateNumber(expr.value);
              }

              if (typeof expr.value === 'boolean') {
                  return expr.value ? 'true' : 'false';
              }

              return generateRegExp(expr.value);
          },

          GeneratorExpression: function (expr, precedence, flags) {
              return this.ComprehensionExpression(expr, precedence, flags);
          },

          ComprehensionExpression: function (expr, precedence, flags) {
              // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
              // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6

              var result, i, iz, fragment, that = this;
              result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];

              if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                  fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
                  result.push(fragment);
              }

              if (expr.blocks) {
                  withIndent(function () {
                      for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                          fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                          if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                              result = join(result, fragment);
                          } else {
                              result.push(fragment);
                          }
                      }
                  });
              }

              if (expr.filter) {
                  result = join(result, 'if' + space);
                  fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
                  result = join(result, [ '(', fragment, ')' ]);
              }

              if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                  fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);

                  result = join(result, fragment);
              }

              result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');
              return result;
          },

          ComprehensionBlock: function (expr, precedence, flags) {
              var fragment;
              if (expr.left.type === Syntax.VariableDeclaration) {
                  fragment = [
                      expr.left.kind, noEmptySpace(),
                      this.generateStatement(expr.left.declarations[0], S_FFFF)
                  ];
              } else {
                  fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
              }

              fragment = join(fragment, expr.of ? 'of' : 'in');
              fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));

              return [ 'for' + space + '(', fragment, ')' ];
          },

          SpreadElement: function (expr, precedence, flags) {
              return [
                  '...',
                  this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
              ];
          },

          TaggedTemplateExpression: function (expr, precedence, flags) {
              var itemFlags = E_TTF;
              if (!(flags & F_ALLOW_CALL)) {
                  itemFlags = E_TFF;
              }
              var result = [
                  this.generateExpression(expr.tag, Precedence.Call, itemFlags),
                  this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
              ];
              return parenthesize(result, Precedence.TaggedTemplate, precedence);
          },

          TemplateElement: function (expr, precedence, flags) {
              // Don't use "cooked". Since tagged template can use raw template
              // representation. So if we do so, it breaks the script semantics.
              return expr.value.raw;
          },

          TemplateLiteral: function (expr, precedence, flags) {
              var result, i, iz;
              result = [ '`' ];
              for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
                  result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
                  if (i + 1 < iz) {
                      result.push('${' + space);
                      result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
                      result.push(space + '}');
                  }
              }
              result.push('`');
              return result;
          },

          ModuleSpecifier: function (expr, precedence, flags) {
              return this.Literal(expr, precedence, flags);
          },

          ImportExpression: function(expr, precedence, flag) {
              return parenthesize([
                  'import(',
                  this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
                  ')'
              ], Precedence.Call, precedence);
          },

      };

      merge(CodeGenerator.prototype, CodeGenerator.Expression);

      CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
          var result, type;

          type = expr.type || Syntax.Property;

          if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
              return generateVerbatim(expr, precedence);
          }

          result = this[type](expr, precedence, flags);


          if (extra.comment) {
              result = addComments(expr, result);
          }
          return toSourceNodeWhenNeeded(result, expr);
      };

      CodeGenerator.prototype.generateStatement = function (stmt, flags) {
          var result,
              fragment;

          result = this[stmt.type](stmt, flags);

          // Attach comments

          if (extra.comment) {
              result = addComments(stmt, result);
          }

          fragment = toSourceNodeWhenNeeded(result).toString();
          if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
              result = sourceMap$1 ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
          }

          return toSourceNodeWhenNeeded(result, stmt);
      };

      function generateInternal(node) {
          var codegen;

          codegen = new CodeGenerator();
          if (isStatement(node)) {
              return codegen.generateStatement(node, S_TFFF);
          }

          if (isExpression(node)) {
              return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
          }

          throw new Error('Unknown node type: ' + node.type);
      }

      function generate(node, options) {
          var defaultOptions = getDefaultOptions(), result, pair;

          if (options != null) {
              // Obsolete options
              //
              //   `options.indent`
              //   `options.base`
              //
              // Instead of them, we can use `option.format.indent`.
              if (typeof options.indent === 'string') {
                  defaultOptions.format.indent.style = options.indent;
              }
              if (typeof options.base === 'number') {
                  defaultOptions.format.indent.base = options.base;
              }
              options = updateDeeply(defaultOptions, options);
              indent = options.format.indent.style;
              if (typeof options.base === 'string') {
                  base = options.base;
              } else {
                  base = stringRepeat(indent, options.format.indent.base);
              }
          } else {
              options = defaultOptions;
              indent = options.format.indent.style;
              base = stringRepeat(indent, options.format.indent.base);
          }
          json = options.format.json;
          renumber = options.format.renumber;
          hexadecimal = json ? false : options.format.hexadecimal;
          quotes = json ? 'double' : options.format.quotes;
          escapeless = options.format.escapeless;
          newline = options.format.newline;
          space = options.format.space;
          if (options.format.compact) {
              newline = space = indent = base = '';
          }
          parentheses = options.format.parentheses;
          semicolons = options.format.semicolons;
          safeConcatenation = options.format.safeConcatenation;
          directive = options.directive;
          parse = json ? null : options.parse;
          sourceMap$1 = options.sourceMap;
          sourceCode = options.sourceCode;
          preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
          extra = options;

          if (sourceMap$1) {
              if (!exports.browser) {
                  // We assume environment is node.js
                  // And prevent from including source-map by browserify
                  SourceNode = sourceMap.SourceNode;
              } else {
                  SourceNode = commonjsGlobal.sourceMap.SourceNode;
              }
          }

          result = generateInternal(node);

          if (!sourceMap$1) {
              pair = {code: result.toString(), map: null};
              return options.sourceMapWithCode ? pair : pair.code;
          }


          pair = result.toStringWithSourceMap({
              file: options.file,
              sourceRoot: options.sourceMapRoot
          });

          if (options.sourceContent) {
              pair.map.setSourceContent(options.sourceMap,
                                        options.sourceContent);
          }

          if (options.sourceMapWithCode) {
              return pair;
          }

          return pair.map.toString();
      }

      FORMAT_MINIFY = {
          indent: {
              style: '',
              base: 0
          },
          renumber: true,
          hexadecimal: true,
          quotes: 'auto',
          escapeless: true,
          compact: true,
          parentheses: false,
          semicolons: false
      };

      FORMAT_DEFAULTS = getDefaultOptions().format;

      exports.version = require$$3.version;
      exports.generate = generate;
      exports.attachComments = estraverse$1.attachComments;
      exports.Precedence = updateDeeply({}, Precedence);
      exports.browser = false;
      exports.FORMAT_MINIFY = FORMAT_MINIFY;
      exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
  }());
  /* vim: set sw=4 ts=4 et tw=80 : */
  });

  var esprima = createCommonjsModule(function (module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
  /* istanbul ignore next */
  	if('object' === 'object' && 'object' === 'object')
  		module.exports = factory();
  	else if(typeof undefined === 'function' && undefined.amd)
  		undefined([], factory);
  /* istanbul ignore next */
  	else if('object' === 'object')
  		exports["esprima"] = factory();
  	else
  		root["esprima"] = factory();
  })(commonjsGlobal, function() {
  return /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};

  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {

  /******/ 		// Check if module is in cache
  /* istanbul ignore if */
  /******/ 		if(installedModules[moduleId])
  /******/ 			return installedModules[moduleId].exports;

  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			exports: {},
  /******/ 			id: moduleId,
  /******/ 			loaded: false
  /******/ 		};

  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

  /******/ 		// Flag the module as loaded
  /******/ 		module.loaded = true;

  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}


  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;

  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;

  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";

  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(0);
  /******/ })
  /************************************************************************/
  /******/ ([
  /* 0 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	/*
  	  Copyright JS Foundation and other contributors, https://js.foundation/

  	  Redistribution and use in source and binary forms, with or without
  	  modification, are permitted provided that the following conditions are met:

  	    * Redistributions of source code must retain the above copyright
  	      notice, this list of conditions and the following disclaimer.
  	    * Redistributions in binary form must reproduce the above copyright
  	      notice, this list of conditions and the following disclaimer in the
  	      documentation and/or other materials provided with the distribution.

  	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*/
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var comment_handler_1 = __webpack_require__(1);
  	var jsx_parser_1 = __webpack_require__(3);
  	var parser_1 = __webpack_require__(8);
  	var tokenizer_1 = __webpack_require__(15);
  	function parse(code, options, delegate) {
  	    var commentHandler = null;
  	    var proxyDelegate = function (node, metadata) {
  	        if (delegate) {
  	            delegate(node, metadata);
  	        }
  	        if (commentHandler) {
  	            commentHandler.visit(node, metadata);
  	        }
  	    };
  	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
  	    var collectComment = false;
  	    if (options) {
  	        collectComment = (typeof options.comment === 'boolean' && options.comment);
  	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
  	        if (collectComment || attachComment) {
  	            commentHandler = new comment_handler_1.CommentHandler();
  	            commentHandler.attach = attachComment;
  	            options.comment = true;
  	            parserDelegate = proxyDelegate;
  	        }
  	    }
  	    var isModule = false;
  	    if (options && typeof options.sourceType === 'string') {
  	        isModule = (options.sourceType === 'module');
  	    }
  	    var parser;
  	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
  	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
  	    }
  	    else {
  	        parser = new parser_1.Parser(code, options, parserDelegate);
  	    }
  	    var program = isModule ? parser.parseModule() : parser.parseScript();
  	    var ast = program;
  	    if (collectComment && commentHandler) {
  	        ast.comments = commentHandler.comments;
  	    }
  	    if (parser.config.tokens) {
  	        ast.tokens = parser.tokens;
  	    }
  	    if (parser.config.tolerant) {
  	        ast.errors = parser.errorHandler.errors;
  	    }
  	    return ast;
  	}
  	exports.parse = parse;
  	function parseModule(code, options, delegate) {
  	    var parsingOptions = options || {};
  	    parsingOptions.sourceType = 'module';
  	    return parse(code, parsingOptions, delegate);
  	}
  	exports.parseModule = parseModule;
  	function parseScript(code, options, delegate) {
  	    var parsingOptions = options || {};
  	    parsingOptions.sourceType = 'script';
  	    return parse(code, parsingOptions, delegate);
  	}
  	exports.parseScript = parseScript;
  	function tokenize(code, options, delegate) {
  	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
  	    var tokens;
  	    tokens = [];
  	    try {
  	        while (true) {
  	            var token = tokenizer.getNextToken();
  	            if (!token) {
  	                break;
  	            }
  	            if (delegate) {
  	                token = delegate(token);
  	            }
  	            tokens.push(token);
  	        }
  	    }
  	    catch (e) {
  	        tokenizer.errorHandler.tolerate(e);
  	    }
  	    if (tokenizer.errorHandler.tolerant) {
  	        tokens.errors = tokenizer.errors();
  	    }
  	    return tokens;
  	}
  	exports.tokenize = tokenize;
  	var syntax_1 = __webpack_require__(2);
  	exports.Syntax = syntax_1.Syntax;
  	// Sync with *.json manifests.
  	exports.version = '4.0.1';


  /***/ },
  /* 1 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var syntax_1 = __webpack_require__(2);
  	var CommentHandler = (function () {
  	    function CommentHandler() {
  	        this.attach = false;
  	        this.comments = [];
  	        this.stack = [];
  	        this.leading = [];
  	        this.trailing = [];
  	    }
  	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
  	        //  innnerComments for properties empty block
  	        //  `function a() {/** comments **\/}`
  	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
  	            var innerComments = [];
  	            for (var i = this.leading.length - 1; i >= 0; --i) {
  	                var entry = this.leading[i];
  	                if (metadata.end.offset >= entry.start) {
  	                    innerComments.unshift(entry.comment);
  	                    this.leading.splice(i, 1);
  	                    this.trailing.splice(i, 1);
  	                }
  	            }
  	            if (innerComments.length) {
  	                node.innerComments = innerComments;
  	            }
  	        }
  	    };
  	    CommentHandler.prototype.findTrailingComments = function (metadata) {
  	        var trailingComments = [];
  	        if (this.trailing.length > 0) {
  	            for (var i = this.trailing.length - 1; i >= 0; --i) {
  	                var entry_1 = this.trailing[i];
  	                if (entry_1.start >= metadata.end.offset) {
  	                    trailingComments.unshift(entry_1.comment);
  	                }
  	            }
  	            this.trailing.length = 0;
  	            return trailingComments;
  	        }
  	        var entry = this.stack[this.stack.length - 1];
  	        if (entry && entry.node.trailingComments) {
  	            var firstComment = entry.node.trailingComments[0];
  	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
  	                trailingComments = entry.node.trailingComments;
  	                delete entry.node.trailingComments;
  	            }
  	        }
  	        return trailingComments;
  	    };
  	    CommentHandler.prototype.findLeadingComments = function (metadata) {
  	        var leadingComments = [];
  	        var target;
  	        while (this.stack.length > 0) {
  	            var entry = this.stack[this.stack.length - 1];
  	            if (entry && entry.start >= metadata.start.offset) {
  	                target = entry.node;
  	                this.stack.pop();
  	            }
  	            else {
  	                break;
  	            }
  	        }
  	        if (target) {
  	            var count = target.leadingComments ? target.leadingComments.length : 0;
  	            for (var i = count - 1; i >= 0; --i) {
  	                var comment = target.leadingComments[i];
  	                if (comment.range[1] <= metadata.start.offset) {
  	                    leadingComments.unshift(comment);
  	                    target.leadingComments.splice(i, 1);
  	                }
  	            }
  	            if (target.leadingComments && target.leadingComments.length === 0) {
  	                delete target.leadingComments;
  	            }
  	            return leadingComments;
  	        }
  	        for (var i = this.leading.length - 1; i >= 0; --i) {
  	            var entry = this.leading[i];
  	            if (entry.start <= metadata.start.offset) {
  	                leadingComments.unshift(entry.comment);
  	                this.leading.splice(i, 1);
  	            }
  	        }
  	        return leadingComments;
  	    };
  	    CommentHandler.prototype.visitNode = function (node, metadata) {
  	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
  	            return;
  	        }
  	        this.insertInnerComments(node, metadata);
  	        var trailingComments = this.findTrailingComments(metadata);
  	        var leadingComments = this.findLeadingComments(metadata);
  	        if (leadingComments.length > 0) {
  	            node.leadingComments = leadingComments;
  	        }
  	        if (trailingComments.length > 0) {
  	            node.trailingComments = trailingComments;
  	        }
  	        this.stack.push({
  	            node: node,
  	            start: metadata.start.offset
  	        });
  	    };
  	    CommentHandler.prototype.visitComment = function (node, metadata) {
  	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
  	        var comment = {
  	            type: type,
  	            value: node.value
  	        };
  	        if (node.range) {
  	            comment.range = node.range;
  	        }
  	        if (node.loc) {
  	            comment.loc = node.loc;
  	        }
  	        this.comments.push(comment);
  	        if (this.attach) {
  	            var entry = {
  	                comment: {
  	                    type: type,
  	                    value: node.value,
  	                    range: [metadata.start.offset, metadata.end.offset]
  	                },
  	                start: metadata.start.offset
  	            };
  	            if (node.loc) {
  	                entry.comment.loc = node.loc;
  	            }
  	            node.type = type;
  	            this.leading.push(entry);
  	            this.trailing.push(entry);
  	        }
  	    };
  	    CommentHandler.prototype.visit = function (node, metadata) {
  	        if (node.type === 'LineComment') {
  	            this.visitComment(node, metadata);
  	        }
  	        else if (node.type === 'BlockComment') {
  	            this.visitComment(node, metadata);
  	        }
  	        else if (this.attach) {
  	            this.visitNode(node, metadata);
  	        }
  	    };
  	    return CommentHandler;
  	}());
  	exports.CommentHandler = CommentHandler;


  /***/ },
  /* 2 */
  /***/ function(module, exports) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.Syntax = {
  	    AssignmentExpression: 'AssignmentExpression',
  	    AssignmentPattern: 'AssignmentPattern',
  	    ArrayExpression: 'ArrayExpression',
  	    ArrayPattern: 'ArrayPattern',
  	    ArrowFunctionExpression: 'ArrowFunctionExpression',
  	    AwaitExpression: 'AwaitExpression',
  	    BlockStatement: 'BlockStatement',
  	    BinaryExpression: 'BinaryExpression',
  	    BreakStatement: 'BreakStatement',
  	    CallExpression: 'CallExpression',
  	    CatchClause: 'CatchClause',
  	    ClassBody: 'ClassBody',
  	    ClassDeclaration: 'ClassDeclaration',
  	    ClassExpression: 'ClassExpression',
  	    ConditionalExpression: 'ConditionalExpression',
  	    ContinueStatement: 'ContinueStatement',
  	    DoWhileStatement: 'DoWhileStatement',
  	    DebuggerStatement: 'DebuggerStatement',
  	    EmptyStatement: 'EmptyStatement',
  	    ExportAllDeclaration: 'ExportAllDeclaration',
  	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
  	    ExportNamedDeclaration: 'ExportNamedDeclaration',
  	    ExportSpecifier: 'ExportSpecifier',
  	    ExpressionStatement: 'ExpressionStatement',
  	    ForStatement: 'ForStatement',
  	    ForOfStatement: 'ForOfStatement',
  	    ForInStatement: 'ForInStatement',
  	    FunctionDeclaration: 'FunctionDeclaration',
  	    FunctionExpression: 'FunctionExpression',
  	    Identifier: 'Identifier',
  	    IfStatement: 'IfStatement',
  	    ImportDeclaration: 'ImportDeclaration',
  	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
  	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
  	    ImportSpecifier: 'ImportSpecifier',
  	    Literal: 'Literal',
  	    LabeledStatement: 'LabeledStatement',
  	    LogicalExpression: 'LogicalExpression',
  	    MemberExpression: 'MemberExpression',
  	    MetaProperty: 'MetaProperty',
  	    MethodDefinition: 'MethodDefinition',
  	    NewExpression: 'NewExpression',
  	    ObjectExpression: 'ObjectExpression',
  	    ObjectPattern: 'ObjectPattern',
  	    Program: 'Program',
  	    Property: 'Property',
  	    RestElement: 'RestElement',
  	    ReturnStatement: 'ReturnStatement',
  	    SequenceExpression: 'SequenceExpression',
  	    SpreadElement: 'SpreadElement',
  	    Super: 'Super',
  	    SwitchCase: 'SwitchCase',
  	    SwitchStatement: 'SwitchStatement',
  	    TaggedTemplateExpression: 'TaggedTemplateExpression',
  	    TemplateElement: 'TemplateElement',
  	    TemplateLiteral: 'TemplateLiteral',
  	    ThisExpression: 'ThisExpression',
  	    ThrowStatement: 'ThrowStatement',
  	    TryStatement: 'TryStatement',
  	    UnaryExpression: 'UnaryExpression',
  	    UpdateExpression: 'UpdateExpression',
  	    VariableDeclaration: 'VariableDeclaration',
  	    VariableDeclarator: 'VariableDeclarator',
  	    WhileStatement: 'WhileStatement',
  	    WithStatement: 'WithStatement',
  	    YieldExpression: 'YieldExpression'
  	};


  /***/ },
  /* 3 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  /* istanbul ignore next */
  	var __extends = (this && this.__extends) || (function () {
  	    var extendStatics = Object.setPrototypeOf ||
  	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
  	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
  	    return function (d, b) {
  	        extendStatics(d, b);
  	        function __() { this.constructor = d; }
  	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  	    };
  	})();
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var character_1 = __webpack_require__(4);
  	var JSXNode = __webpack_require__(5);
  	var jsx_syntax_1 = __webpack_require__(6);
  	var Node = __webpack_require__(7);
  	var parser_1 = __webpack_require__(8);
  	var token_1 = __webpack_require__(13);
  	var xhtml_entities_1 = __webpack_require__(14);
  	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
  	token_1.TokenName[101 /* Text */] = 'JSXText';
  	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
  	function getQualifiedElementName(elementName) {
  	    var qualifiedName;
  	    switch (elementName.type) {
  	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
  	            var id = elementName;
  	            qualifiedName = id.name;
  	            break;
  	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
  	            var ns = elementName;
  	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
  	                getQualifiedElementName(ns.name);
  	            break;
  	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
  	            var expr = elementName;
  	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
  	                getQualifiedElementName(expr.property);
  	            break;
  	        /* istanbul ignore next */
  	        default:
  	            break;
  	    }
  	    return qualifiedName;
  	}
  	var JSXParser = (function (_super) {
  	    __extends(JSXParser, _super);
  	    function JSXParser(code, options, delegate) {
  	        return _super.call(this, code, options, delegate) || this;
  	    }
  	    JSXParser.prototype.parsePrimaryExpression = function () {
  	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
  	    };
  	    JSXParser.prototype.startJSX = function () {
  	        // Unwind the scanner before the lookahead token.
  	        this.scanner.index = this.startMarker.index;
  	        this.scanner.lineNumber = this.startMarker.line;
  	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
  	    };
  	    JSXParser.prototype.finishJSX = function () {
  	        // Prime the next lookahead.
  	        this.nextToken();
  	    };
  	    JSXParser.prototype.reenterJSX = function () {
  	        this.startJSX();
  	        this.expectJSX('}');
  	        // Pop the closing '}' added from the lookahead.
  	        if (this.config.tokens) {
  	            this.tokens.pop();
  	        }
  	    };
  	    JSXParser.prototype.createJSXNode = function () {
  	        this.collectComments();
  	        return {
  	            index: this.scanner.index,
  	            line: this.scanner.lineNumber,
  	            column: this.scanner.index - this.scanner.lineStart
  	        };
  	    };
  	    JSXParser.prototype.createJSXChildNode = function () {
  	        return {
  	            index: this.scanner.index,
  	            line: this.scanner.lineNumber,
  	            column: this.scanner.index - this.scanner.lineStart
  	        };
  	    };
  	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
  	        var result = '&';
  	        var valid = true;
  	        var terminated = false;
  	        var numeric = false;
  	        var hex = false;
  	        while (!this.scanner.eof() && valid && !terminated) {
  	            var ch = this.scanner.source[this.scanner.index];
  	            if (ch === quote) {
  	                break;
  	            }
  	            terminated = (ch === ';');
  	            result += ch;
  	            ++this.scanner.index;
  	            if (!terminated) {
  	                switch (result.length) {
  	                    case 2:
  	                        // e.g. '&#123;'
  	                        numeric = (ch === '#');
  	                        break;
  	                    case 3:
  	                        if (numeric) {
  	                            // e.g. '&#x41;'
  	                            hex = (ch === 'x');
  	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
  	                            numeric = numeric && !hex;
  	                        }
  	                        break;
  	                    default:
  	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
  	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
  	                        break;
  	                }
  	            }
  	        }
  	        if (valid && terminated && result.length > 2) {
  	            // e.g. '&#x41;' becomes just '#x41'
  	            var str = result.substr(1, result.length - 2);
  	            if (numeric && str.length > 1) {
  	                result = String.fromCharCode(parseInt(str.substr(1), 10));
  	            }
  	            else if (hex && str.length > 2) {
  	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
  	            }
  	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
  	                result = xhtml_entities_1.XHTMLEntities[str];
  	            }
  	        }
  	        return result;
  	    };
  	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
  	    JSXParser.prototype.lexJSX = function () {
  	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
  	        // < > / : = { }
  	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
  	            var value = this.scanner.source[this.scanner.index++];
  	            return {
  	                type: 7 /* Punctuator */,
  	                value: value,
  	                lineNumber: this.scanner.lineNumber,
  	                lineStart: this.scanner.lineStart,
  	                start: this.scanner.index - 1,
  	                end: this.scanner.index
  	            };
  	        }
  	        // " '
  	        if (cp === 34 || cp === 39) {
  	            var start = this.scanner.index;
  	            var quote = this.scanner.source[this.scanner.index++];
  	            var str = '';
  	            while (!this.scanner.eof()) {
  	                var ch = this.scanner.source[this.scanner.index++];
  	                if (ch === quote) {
  	                    break;
  	                }
  	                else if (ch === '&') {
  	                    str += this.scanXHTMLEntity(quote);
  	                }
  	                else {
  	                    str += ch;
  	                }
  	            }
  	            return {
  	                type: 8 /* StringLiteral */,
  	                value: str,
  	                lineNumber: this.scanner.lineNumber,
  	                lineStart: this.scanner.lineStart,
  	                start: start,
  	                end: this.scanner.index
  	            };
  	        }
  	        // ... or .
  	        if (cp === 46) {
  	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
  	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
  	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
  	            var start = this.scanner.index;
  	            this.scanner.index += value.length;
  	            return {
  	                type: 7 /* Punctuator */,
  	                value: value,
  	                lineNumber: this.scanner.lineNumber,
  	                lineStart: this.scanner.lineStart,
  	                start: start,
  	                end: this.scanner.index
  	            };
  	        }
  	        // `
  	        if (cp === 96) {
  	            // Only placeholder, since it will be rescanned as a real assignment expression.
  	            return {
  	                type: 10 /* Template */,
  	                value: '',
  	                lineNumber: this.scanner.lineNumber,
  	                lineStart: this.scanner.lineStart,
  	                start: this.scanner.index,
  	                end: this.scanner.index
  	            };
  	        }
  	        // Identifer can not contain backslash (char code 92).
  	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
  	            var start = this.scanner.index;
  	            ++this.scanner.index;
  	            while (!this.scanner.eof()) {
  	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
  	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
  	                    ++this.scanner.index;
  	                }
  	                else if (ch === 45) {
  	                    // Hyphen (char code 45) can be part of an identifier.
  	                    ++this.scanner.index;
  	                }
  	                else {
  	                    break;
  	                }
  	            }
  	            var id = this.scanner.source.slice(start, this.scanner.index);
  	            return {
  	                type: 100 /* Identifier */,
  	                value: id,
  	                lineNumber: this.scanner.lineNumber,
  	                lineStart: this.scanner.lineStart,
  	                start: start,
  	                end: this.scanner.index
  	            };
  	        }
  	        return this.scanner.lex();
  	    };
  	    JSXParser.prototype.nextJSXToken = function () {
  	        this.collectComments();
  	        this.startMarker.index = this.scanner.index;
  	        this.startMarker.line = this.scanner.lineNumber;
  	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
  	        var token = this.lexJSX();
  	        this.lastMarker.index = this.scanner.index;
  	        this.lastMarker.line = this.scanner.lineNumber;
  	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
  	        if (this.config.tokens) {
  	            this.tokens.push(this.convertToken(token));
  	        }
  	        return token;
  	    };
  	    JSXParser.prototype.nextJSXText = function () {
  	        this.startMarker.index = this.scanner.index;
  	        this.startMarker.line = this.scanner.lineNumber;
  	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
  	        var start = this.scanner.index;
  	        var text = '';
  	        while (!this.scanner.eof()) {
  	            var ch = this.scanner.source[this.scanner.index];
  	            if (ch === '{' || ch === '<') {
  	                break;
  	            }
  	            ++this.scanner.index;
  	            text += ch;
  	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                ++this.scanner.lineNumber;
  	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
  	                    ++this.scanner.index;
  	                }
  	                this.scanner.lineStart = this.scanner.index;
  	            }
  	        }
  	        this.lastMarker.index = this.scanner.index;
  	        this.lastMarker.line = this.scanner.lineNumber;
  	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
  	        var token = {
  	            type: 101 /* Text */,
  	            value: text,
  	            lineNumber: this.scanner.lineNumber,
  	            lineStart: this.scanner.lineStart,
  	            start: start,
  	            end: this.scanner.index
  	        };
  	        if ((text.length > 0) && this.config.tokens) {
  	            this.tokens.push(this.convertToken(token));
  	        }
  	        return token;
  	    };
  	    JSXParser.prototype.peekJSXToken = function () {
  	        var state = this.scanner.saveState();
  	        this.scanner.scanComments();
  	        var next = this.lexJSX();
  	        this.scanner.restoreState(state);
  	        return next;
  	    };
  	    // Expect the next JSX token to match the specified punctuator.
  	    // If not, an exception will be thrown.
  	    JSXParser.prototype.expectJSX = function (value) {
  	        var token = this.nextJSXToken();
  	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
  	            this.throwUnexpectedToken(token);
  	        }
  	    };
  	    // Return true if the next JSX token matches the specified punctuator.
  	    JSXParser.prototype.matchJSX = function (value) {
  	        var next = this.peekJSXToken();
  	        return next.type === 7 /* Punctuator */ && next.value === value;
  	    };
  	    JSXParser.prototype.parseJSXIdentifier = function () {
  	        var node = this.createJSXNode();
  	        var token = this.nextJSXToken();
  	        if (token.type !== 100 /* Identifier */) {
  	            this.throwUnexpectedToken(token);
  	        }
  	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
  	    };
  	    JSXParser.prototype.parseJSXElementName = function () {
  	        var node = this.createJSXNode();
  	        var elementName = this.parseJSXIdentifier();
  	        if (this.matchJSX(':')) {
  	            var namespace = elementName;
  	            this.expectJSX(':');
  	            var name_1 = this.parseJSXIdentifier();
  	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
  	        }
  	        else if (this.matchJSX('.')) {
  	            while (this.matchJSX('.')) {
  	                var object = elementName;
  	                this.expectJSX('.');
  	                var property = this.parseJSXIdentifier();
  	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
  	            }
  	        }
  	        return elementName;
  	    };
  	    JSXParser.prototype.parseJSXAttributeName = function () {
  	        var node = this.createJSXNode();
  	        var attributeName;
  	        var identifier = this.parseJSXIdentifier();
  	        if (this.matchJSX(':')) {
  	            var namespace = identifier;
  	            this.expectJSX(':');
  	            var name_2 = this.parseJSXIdentifier();
  	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
  	        }
  	        else {
  	            attributeName = identifier;
  	        }
  	        return attributeName;
  	    };
  	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
  	        var node = this.createJSXNode();
  	        var token = this.nextJSXToken();
  	        if (token.type !== 8 /* StringLiteral */) {
  	            this.throwUnexpectedToken(token);
  	        }
  	        var raw = this.getTokenRaw(token);
  	        return this.finalize(node, new Node.Literal(token.value, raw));
  	    };
  	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
  	        var node = this.createJSXNode();
  	        this.expectJSX('{');
  	        this.finishJSX();
  	        if (this.match('}')) {
  	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
  	        }
  	        var expression = this.parseAssignmentExpression();
  	        this.reenterJSX();
  	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
  	    };
  	    JSXParser.prototype.parseJSXAttributeValue = function () {
  	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
  	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
  	    };
  	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
  	        var node = this.createJSXNode();
  	        var name = this.parseJSXAttributeName();
  	        var value = null;
  	        if (this.matchJSX('=')) {
  	            this.expectJSX('=');
  	            value = this.parseJSXAttributeValue();
  	        }
  	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
  	    };
  	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
  	        var node = this.createJSXNode();
  	        this.expectJSX('{');
  	        this.expectJSX('...');
  	        this.finishJSX();
  	        var argument = this.parseAssignmentExpression();
  	        this.reenterJSX();
  	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
  	    };
  	    JSXParser.prototype.parseJSXAttributes = function () {
  	        var attributes = [];
  	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
  	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
  	                this.parseJSXNameValueAttribute();
  	            attributes.push(attribute);
  	        }
  	        return attributes;
  	    };
  	    JSXParser.prototype.parseJSXOpeningElement = function () {
  	        var node = this.createJSXNode();
  	        this.expectJSX('<');
  	        var name = this.parseJSXElementName();
  	        var attributes = this.parseJSXAttributes();
  	        var selfClosing = this.matchJSX('/');
  	        if (selfClosing) {
  	            this.expectJSX('/');
  	        }
  	        this.expectJSX('>');
  	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
  	    };
  	    JSXParser.prototype.parseJSXBoundaryElement = function () {
  	        var node = this.createJSXNode();
  	        this.expectJSX('<');
  	        if (this.matchJSX('/')) {
  	            this.expectJSX('/');
  	            var name_3 = this.parseJSXElementName();
  	            this.expectJSX('>');
  	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
  	        }
  	        var name = this.parseJSXElementName();
  	        var attributes = this.parseJSXAttributes();
  	        var selfClosing = this.matchJSX('/');
  	        if (selfClosing) {
  	            this.expectJSX('/');
  	        }
  	        this.expectJSX('>');
  	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
  	    };
  	    JSXParser.prototype.parseJSXEmptyExpression = function () {
  	        var node = this.createJSXChildNode();
  	        this.collectComments();
  	        this.lastMarker.index = this.scanner.index;
  	        this.lastMarker.line = this.scanner.lineNumber;
  	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
  	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
  	    };
  	    JSXParser.prototype.parseJSXExpressionContainer = function () {
  	        var node = this.createJSXNode();
  	        this.expectJSX('{');
  	        var expression;
  	        if (this.matchJSX('}')) {
  	            expression = this.parseJSXEmptyExpression();
  	            this.expectJSX('}');
  	        }
  	        else {
  	            this.finishJSX();
  	            expression = this.parseAssignmentExpression();
  	            this.reenterJSX();
  	        }
  	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
  	    };
  	    JSXParser.prototype.parseJSXChildren = function () {
  	        var children = [];
  	        while (!this.scanner.eof()) {
  	            var node = this.createJSXChildNode();
  	            var token = this.nextJSXText();
  	            if (token.start < token.end) {
  	                var raw = this.getTokenRaw(token);
  	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
  	                children.push(child);
  	            }
  	            if (this.scanner.source[this.scanner.index] === '{') {
  	                var container = this.parseJSXExpressionContainer();
  	                children.push(container);
  	            }
  	            else {
  	                break;
  	            }
  	        }
  	        return children;
  	    };
  	    JSXParser.prototype.parseComplexJSXElement = function (el) {
  	        var stack = [];
  	        while (!this.scanner.eof()) {
  	            el.children = el.children.concat(this.parseJSXChildren());
  	            var node = this.createJSXChildNode();
  	            var element = this.parseJSXBoundaryElement();
  	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
  	                var opening = element;
  	                if (opening.selfClosing) {
  	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
  	                    el.children.push(child);
  	                }
  	                else {
  	                    stack.push(el);
  	                    el = { node: node, opening: opening, closing: null, children: [] };
  	                }
  	            }
  	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
  	                el.closing = element;
  	                var open_1 = getQualifiedElementName(el.opening.name);
  	                var close_1 = getQualifiedElementName(el.closing.name);
  	                if (open_1 !== close_1) {
  	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
  	                }
  	                if (stack.length > 0) {
  	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
  	                    el = stack[stack.length - 1];
  	                    el.children.push(child);
  	                    stack.pop();
  	                }
  	                else {
  	                    break;
  	                }
  	            }
  	        }
  	        return el;
  	    };
  	    JSXParser.prototype.parseJSXElement = function () {
  	        var node = this.createJSXNode();
  	        var opening = this.parseJSXOpeningElement();
  	        var children = [];
  	        var closing = null;
  	        if (!opening.selfClosing) {
  	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
  	            children = el.children;
  	            closing = el.closing;
  	        }
  	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
  	    };
  	    JSXParser.prototype.parseJSXRoot = function () {
  	        // Pop the opening '<' added from the lookahead.
  	        if (this.config.tokens) {
  	            this.tokens.pop();
  	        }
  	        this.startJSX();
  	        var element = this.parseJSXElement();
  	        this.finishJSX();
  	        return element;
  	    };
  	    JSXParser.prototype.isStartOfExpression = function () {
  	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
  	    };
  	    return JSXParser;
  	}(parser_1.Parser));
  	exports.JSXParser = JSXParser;


  /***/ },
  /* 4 */
  /***/ function(module, exports) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	// See also tools/generate-unicode-regex.js.
  	var Regex = {
  	    // Unicode v8.0.0 NonAsciiIdentifierStart:
  	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  	    // Unicode v8.0.0 NonAsciiIdentifierPart:
  	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
  	};
  	exports.Character = {
  	    /* tslint:disable:no-bitwise */
  	    fromCodePoint: function (cp) {
  	        return (cp < 0x10000) ? String.fromCharCode(cp) :
  	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
  	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
  	    },
  	    // https://tc39.github.io/ecma262/#sec-white-space
  	    isWhiteSpace: function (cp) {
  	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
  	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
  	    },
  	    // https://tc39.github.io/ecma262/#sec-line-terminators
  	    isLineTerminator: function (cp) {
  	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
  	    },
  	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
  	    isIdentifierStart: function (cp) {
  	        return (cp === 0x24) || (cp === 0x5F) ||
  	            (cp >= 0x41 && cp <= 0x5A) ||
  	            (cp >= 0x61 && cp <= 0x7A) ||
  	            (cp === 0x5C) ||
  	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
  	    },
  	    isIdentifierPart: function (cp) {
  	        return (cp === 0x24) || (cp === 0x5F) ||
  	            (cp >= 0x41 && cp <= 0x5A) ||
  	            (cp >= 0x61 && cp <= 0x7A) ||
  	            (cp >= 0x30 && cp <= 0x39) ||
  	            (cp === 0x5C) ||
  	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
  	    },
  	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
  	    isDecimalDigit: function (cp) {
  	        return (cp >= 0x30 && cp <= 0x39); // 0..9
  	    },
  	    isHexDigit: function (cp) {
  	        return (cp >= 0x30 && cp <= 0x39) ||
  	            (cp >= 0x41 && cp <= 0x46) ||
  	            (cp >= 0x61 && cp <= 0x66); // a..f
  	    },
  	    isOctalDigit: function (cp) {
  	        return (cp >= 0x30 && cp <= 0x37); // 0..7
  	    }
  	};


  /***/ },
  /* 5 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var jsx_syntax_1 = __webpack_require__(6);
  	/* tslint:disable:max-classes-per-file */
  	var JSXClosingElement = (function () {
  	    function JSXClosingElement(name) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
  	        this.name = name;
  	    }
  	    return JSXClosingElement;
  	}());
  	exports.JSXClosingElement = JSXClosingElement;
  	var JSXElement = (function () {
  	    function JSXElement(openingElement, children, closingElement) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
  	        this.openingElement = openingElement;
  	        this.children = children;
  	        this.closingElement = closingElement;
  	    }
  	    return JSXElement;
  	}());
  	exports.JSXElement = JSXElement;
  	var JSXEmptyExpression = (function () {
  	    function JSXEmptyExpression() {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
  	    }
  	    return JSXEmptyExpression;
  	}());
  	exports.JSXEmptyExpression = JSXEmptyExpression;
  	var JSXExpressionContainer = (function () {
  	    function JSXExpressionContainer(expression) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
  	        this.expression = expression;
  	    }
  	    return JSXExpressionContainer;
  	}());
  	exports.JSXExpressionContainer = JSXExpressionContainer;
  	var JSXIdentifier = (function () {
  	    function JSXIdentifier(name) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
  	        this.name = name;
  	    }
  	    return JSXIdentifier;
  	}());
  	exports.JSXIdentifier = JSXIdentifier;
  	var JSXMemberExpression = (function () {
  	    function JSXMemberExpression(object, property) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
  	        this.object = object;
  	        this.property = property;
  	    }
  	    return JSXMemberExpression;
  	}());
  	exports.JSXMemberExpression = JSXMemberExpression;
  	var JSXAttribute = (function () {
  	    function JSXAttribute(name, value) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
  	        this.name = name;
  	        this.value = value;
  	    }
  	    return JSXAttribute;
  	}());
  	exports.JSXAttribute = JSXAttribute;
  	var JSXNamespacedName = (function () {
  	    function JSXNamespacedName(namespace, name) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
  	        this.namespace = namespace;
  	        this.name = name;
  	    }
  	    return JSXNamespacedName;
  	}());
  	exports.JSXNamespacedName = JSXNamespacedName;
  	var JSXOpeningElement = (function () {
  	    function JSXOpeningElement(name, selfClosing, attributes) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
  	        this.name = name;
  	        this.selfClosing = selfClosing;
  	        this.attributes = attributes;
  	    }
  	    return JSXOpeningElement;
  	}());
  	exports.JSXOpeningElement = JSXOpeningElement;
  	var JSXSpreadAttribute = (function () {
  	    function JSXSpreadAttribute(argument) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
  	        this.argument = argument;
  	    }
  	    return JSXSpreadAttribute;
  	}());
  	exports.JSXSpreadAttribute = JSXSpreadAttribute;
  	var JSXText = (function () {
  	    function JSXText(value, raw) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
  	        this.value = value;
  	        this.raw = raw;
  	    }
  	    return JSXText;
  	}());
  	exports.JSXText = JSXText;


  /***/ },
  /* 6 */
  /***/ function(module, exports) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.JSXSyntax = {
  	    JSXAttribute: 'JSXAttribute',
  	    JSXClosingElement: 'JSXClosingElement',
  	    JSXElement: 'JSXElement',
  	    JSXEmptyExpression: 'JSXEmptyExpression',
  	    JSXExpressionContainer: 'JSXExpressionContainer',
  	    JSXIdentifier: 'JSXIdentifier',
  	    JSXMemberExpression: 'JSXMemberExpression',
  	    JSXNamespacedName: 'JSXNamespacedName',
  	    JSXOpeningElement: 'JSXOpeningElement',
  	    JSXSpreadAttribute: 'JSXSpreadAttribute',
  	    JSXText: 'JSXText'
  	};


  /***/ },
  /* 7 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var syntax_1 = __webpack_require__(2);
  	/* tslint:disable:max-classes-per-file */
  	var ArrayExpression = (function () {
  	    function ArrayExpression(elements) {
  	        this.type = syntax_1.Syntax.ArrayExpression;
  	        this.elements = elements;
  	    }
  	    return ArrayExpression;
  	}());
  	exports.ArrayExpression = ArrayExpression;
  	var ArrayPattern = (function () {
  	    function ArrayPattern(elements) {
  	        this.type = syntax_1.Syntax.ArrayPattern;
  	        this.elements = elements;
  	    }
  	    return ArrayPattern;
  	}());
  	exports.ArrayPattern = ArrayPattern;
  	var ArrowFunctionExpression = (function () {
  	    function ArrowFunctionExpression(params, body, expression) {
  	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
  	        this.id = null;
  	        this.params = params;
  	        this.body = body;
  	        this.generator = false;
  	        this.expression = expression;
  	        this.async = false;
  	    }
  	    return ArrowFunctionExpression;
  	}());
  	exports.ArrowFunctionExpression = ArrowFunctionExpression;
  	var AssignmentExpression = (function () {
  	    function AssignmentExpression(operator, left, right) {
  	        this.type = syntax_1.Syntax.AssignmentExpression;
  	        this.operator = operator;
  	        this.left = left;
  	        this.right = right;
  	    }
  	    return AssignmentExpression;
  	}());
  	exports.AssignmentExpression = AssignmentExpression;
  	var AssignmentPattern = (function () {
  	    function AssignmentPattern(left, right) {
  	        this.type = syntax_1.Syntax.AssignmentPattern;
  	        this.left = left;
  	        this.right = right;
  	    }
  	    return AssignmentPattern;
  	}());
  	exports.AssignmentPattern = AssignmentPattern;
  	var AsyncArrowFunctionExpression = (function () {
  	    function AsyncArrowFunctionExpression(params, body, expression) {
  	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
  	        this.id = null;
  	        this.params = params;
  	        this.body = body;
  	        this.generator = false;
  	        this.expression = expression;
  	        this.async = true;
  	    }
  	    return AsyncArrowFunctionExpression;
  	}());
  	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
  	var AsyncFunctionDeclaration = (function () {
  	    function AsyncFunctionDeclaration(id, params, body) {
  	        this.type = syntax_1.Syntax.FunctionDeclaration;
  	        this.id = id;
  	        this.params = params;
  	        this.body = body;
  	        this.generator = false;
  	        this.expression = false;
  	        this.async = true;
  	    }
  	    return AsyncFunctionDeclaration;
  	}());
  	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
  	var AsyncFunctionExpression = (function () {
  	    function AsyncFunctionExpression(id, params, body) {
  	        this.type = syntax_1.Syntax.FunctionExpression;
  	        this.id = id;
  	        this.params = params;
  	        this.body = body;
  	        this.generator = false;
  	        this.expression = false;
  	        this.async = true;
  	    }
  	    return AsyncFunctionExpression;
  	}());
  	exports.AsyncFunctionExpression = AsyncFunctionExpression;
  	var AwaitExpression = (function () {
  	    function AwaitExpression(argument) {
  	        this.type = syntax_1.Syntax.AwaitExpression;
  	        this.argument = argument;
  	    }
  	    return AwaitExpression;
  	}());
  	exports.AwaitExpression = AwaitExpression;
  	var BinaryExpression = (function () {
  	    function BinaryExpression(operator, left, right) {
  	        var logical = (operator === '||' || operator === '&&');
  	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
  	        this.operator = operator;
  	        this.left = left;
  	        this.right = right;
  	    }
  	    return BinaryExpression;
  	}());
  	exports.BinaryExpression = BinaryExpression;
  	var BlockStatement = (function () {
  	    function BlockStatement(body) {
  	        this.type = syntax_1.Syntax.BlockStatement;
  	        this.body = body;
  	    }
  	    return BlockStatement;
  	}());
  	exports.BlockStatement = BlockStatement;
  	var BreakStatement = (function () {
  	    function BreakStatement(label) {
  	        this.type = syntax_1.Syntax.BreakStatement;
  	        this.label = label;
  	    }
  	    return BreakStatement;
  	}());
  	exports.BreakStatement = BreakStatement;
  	var CallExpression = (function () {
  	    function CallExpression(callee, args) {
  	        this.type = syntax_1.Syntax.CallExpression;
  	        this.callee = callee;
  	        this.arguments = args;
  	    }
  	    return CallExpression;
  	}());
  	exports.CallExpression = CallExpression;
  	var CatchClause = (function () {
  	    function CatchClause(param, body) {
  	        this.type = syntax_1.Syntax.CatchClause;
  	        this.param = param;
  	        this.body = body;
  	    }
  	    return CatchClause;
  	}());
  	exports.CatchClause = CatchClause;
  	var ClassBody = (function () {
  	    function ClassBody(body) {
  	        this.type = syntax_1.Syntax.ClassBody;
  	        this.body = body;
  	    }
  	    return ClassBody;
  	}());
  	exports.ClassBody = ClassBody;
  	var ClassDeclaration = (function () {
  	    function ClassDeclaration(id, superClass, body) {
  	        this.type = syntax_1.Syntax.ClassDeclaration;
  	        this.id = id;
  	        this.superClass = superClass;
  	        this.body = body;
  	    }
  	    return ClassDeclaration;
  	}());
  	exports.ClassDeclaration = ClassDeclaration;
  	var ClassExpression = (function () {
  	    function ClassExpression(id, superClass, body) {
  	        this.type = syntax_1.Syntax.ClassExpression;
  	        this.id = id;
  	        this.superClass = superClass;
  	        this.body = body;
  	    }
  	    return ClassExpression;
  	}());
  	exports.ClassExpression = ClassExpression;
  	var ComputedMemberExpression = (function () {
  	    function ComputedMemberExpression(object, property) {
  	        this.type = syntax_1.Syntax.MemberExpression;
  	        this.computed = true;
  	        this.object = object;
  	        this.property = property;
  	    }
  	    return ComputedMemberExpression;
  	}());
  	exports.ComputedMemberExpression = ComputedMemberExpression;
  	var ConditionalExpression = (function () {
  	    function ConditionalExpression(test, consequent, alternate) {
  	        this.type = syntax_1.Syntax.ConditionalExpression;
  	        this.test = test;
  	        this.consequent = consequent;
  	        this.alternate = alternate;
  	    }
  	    return ConditionalExpression;
  	}());
  	exports.ConditionalExpression = ConditionalExpression;
  	var ContinueStatement = (function () {
  	    function ContinueStatement(label) {
  	        this.type = syntax_1.Syntax.ContinueStatement;
  	        this.label = label;
  	    }
  	    return ContinueStatement;
  	}());
  	exports.ContinueStatement = ContinueStatement;
  	var DebuggerStatement = (function () {
  	    function DebuggerStatement() {
  	        this.type = syntax_1.Syntax.DebuggerStatement;
  	    }
  	    return DebuggerStatement;
  	}());
  	exports.DebuggerStatement = DebuggerStatement;
  	var Directive = (function () {
  	    function Directive(expression, directive) {
  	        this.type = syntax_1.Syntax.ExpressionStatement;
  	        this.expression = expression;
  	        this.directive = directive;
  	    }
  	    return Directive;
  	}());
  	exports.Directive = Directive;
  	var DoWhileStatement = (function () {
  	    function DoWhileStatement(body, test) {
  	        this.type = syntax_1.Syntax.DoWhileStatement;
  	        this.body = body;
  	        this.test = test;
  	    }
  	    return DoWhileStatement;
  	}());
  	exports.DoWhileStatement = DoWhileStatement;
  	var EmptyStatement = (function () {
  	    function EmptyStatement() {
  	        this.type = syntax_1.Syntax.EmptyStatement;
  	    }
  	    return EmptyStatement;
  	}());
  	exports.EmptyStatement = EmptyStatement;
  	var ExportAllDeclaration = (function () {
  	    function ExportAllDeclaration(source) {
  	        this.type = syntax_1.Syntax.ExportAllDeclaration;
  	        this.source = source;
  	    }
  	    return ExportAllDeclaration;
  	}());
  	exports.ExportAllDeclaration = ExportAllDeclaration;
  	var ExportDefaultDeclaration = (function () {
  	    function ExportDefaultDeclaration(declaration) {
  	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
  	        this.declaration = declaration;
  	    }
  	    return ExportDefaultDeclaration;
  	}());
  	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
  	var ExportNamedDeclaration = (function () {
  	    function ExportNamedDeclaration(declaration, specifiers, source) {
  	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
  	        this.declaration = declaration;
  	        this.specifiers = specifiers;
  	        this.source = source;
  	    }
  	    return ExportNamedDeclaration;
  	}());
  	exports.ExportNamedDeclaration = ExportNamedDeclaration;
  	var ExportSpecifier = (function () {
  	    function ExportSpecifier(local, exported) {
  	        this.type = syntax_1.Syntax.ExportSpecifier;
  	        this.exported = exported;
  	        this.local = local;
  	    }
  	    return ExportSpecifier;
  	}());
  	exports.ExportSpecifier = ExportSpecifier;
  	var ExpressionStatement = (function () {
  	    function ExpressionStatement(expression) {
  	        this.type = syntax_1.Syntax.ExpressionStatement;
  	        this.expression = expression;
  	    }
  	    return ExpressionStatement;
  	}());
  	exports.ExpressionStatement = ExpressionStatement;
  	var ForInStatement = (function () {
  	    function ForInStatement(left, right, body) {
  	        this.type = syntax_1.Syntax.ForInStatement;
  	        this.left = left;
  	        this.right = right;
  	        this.body = body;
  	        this.each = false;
  	    }
  	    return ForInStatement;
  	}());
  	exports.ForInStatement = ForInStatement;
  	var ForOfStatement = (function () {
  	    function ForOfStatement(left, right, body) {
  	        this.type = syntax_1.Syntax.ForOfStatement;
  	        this.left = left;
  	        this.right = right;
  	        this.body = body;
  	    }
  	    return ForOfStatement;
  	}());
  	exports.ForOfStatement = ForOfStatement;
  	var ForStatement = (function () {
  	    function ForStatement(init, test, update, body) {
  	        this.type = syntax_1.Syntax.ForStatement;
  	        this.init = init;
  	        this.test = test;
  	        this.update = update;
  	        this.body = body;
  	    }
  	    return ForStatement;
  	}());
  	exports.ForStatement = ForStatement;
  	var FunctionDeclaration = (function () {
  	    function FunctionDeclaration(id, params, body, generator) {
  	        this.type = syntax_1.Syntax.FunctionDeclaration;
  	        this.id = id;
  	        this.params = params;
  	        this.body = body;
  	        this.generator = generator;
  	        this.expression = false;
  	        this.async = false;
  	    }
  	    return FunctionDeclaration;
  	}());
  	exports.FunctionDeclaration = FunctionDeclaration;
  	var FunctionExpression = (function () {
  	    function FunctionExpression(id, params, body, generator) {
  	        this.type = syntax_1.Syntax.FunctionExpression;
  	        this.id = id;
  	        this.params = params;
  	        this.body = body;
  	        this.generator = generator;
  	        this.expression = false;
  	        this.async = false;
  	    }
  	    return FunctionExpression;
  	}());
  	exports.FunctionExpression = FunctionExpression;
  	var Identifier = (function () {
  	    function Identifier(name) {
  	        this.type = syntax_1.Syntax.Identifier;
  	        this.name = name;
  	    }
  	    return Identifier;
  	}());
  	exports.Identifier = Identifier;
  	var IfStatement = (function () {
  	    function IfStatement(test, consequent, alternate) {
  	        this.type = syntax_1.Syntax.IfStatement;
  	        this.test = test;
  	        this.consequent = consequent;
  	        this.alternate = alternate;
  	    }
  	    return IfStatement;
  	}());
  	exports.IfStatement = IfStatement;
  	var ImportDeclaration = (function () {
  	    function ImportDeclaration(specifiers, source) {
  	        this.type = syntax_1.Syntax.ImportDeclaration;
  	        this.specifiers = specifiers;
  	        this.source = source;
  	    }
  	    return ImportDeclaration;
  	}());
  	exports.ImportDeclaration = ImportDeclaration;
  	var ImportDefaultSpecifier = (function () {
  	    function ImportDefaultSpecifier(local) {
  	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
  	        this.local = local;
  	    }
  	    return ImportDefaultSpecifier;
  	}());
  	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
  	var ImportNamespaceSpecifier = (function () {
  	    function ImportNamespaceSpecifier(local) {
  	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
  	        this.local = local;
  	    }
  	    return ImportNamespaceSpecifier;
  	}());
  	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
  	var ImportSpecifier = (function () {
  	    function ImportSpecifier(local, imported) {
  	        this.type = syntax_1.Syntax.ImportSpecifier;
  	        this.local = local;
  	        this.imported = imported;
  	    }
  	    return ImportSpecifier;
  	}());
  	exports.ImportSpecifier = ImportSpecifier;
  	var LabeledStatement = (function () {
  	    function LabeledStatement(label, body) {
  	        this.type = syntax_1.Syntax.LabeledStatement;
  	        this.label = label;
  	        this.body = body;
  	    }
  	    return LabeledStatement;
  	}());
  	exports.LabeledStatement = LabeledStatement;
  	var Literal = (function () {
  	    function Literal(value, raw) {
  	        this.type = syntax_1.Syntax.Literal;
  	        this.value = value;
  	        this.raw = raw;
  	    }
  	    return Literal;
  	}());
  	exports.Literal = Literal;
  	var MetaProperty = (function () {
  	    function MetaProperty(meta, property) {
  	        this.type = syntax_1.Syntax.MetaProperty;
  	        this.meta = meta;
  	        this.property = property;
  	    }
  	    return MetaProperty;
  	}());
  	exports.MetaProperty = MetaProperty;
  	var MethodDefinition = (function () {
  	    function MethodDefinition(key, computed, value, kind, isStatic) {
  	        this.type = syntax_1.Syntax.MethodDefinition;
  	        this.key = key;
  	        this.computed = computed;
  	        this.value = value;
  	        this.kind = kind;
  	        this.static = isStatic;
  	    }
  	    return MethodDefinition;
  	}());
  	exports.MethodDefinition = MethodDefinition;
  	var Module = (function () {
  	    function Module(body) {
  	        this.type = syntax_1.Syntax.Program;
  	        this.body = body;
  	        this.sourceType = 'module';
  	    }
  	    return Module;
  	}());
  	exports.Module = Module;
  	var NewExpression = (function () {
  	    function NewExpression(callee, args) {
  	        this.type = syntax_1.Syntax.NewExpression;
  	        this.callee = callee;
  	        this.arguments = args;
  	    }
  	    return NewExpression;
  	}());
  	exports.NewExpression = NewExpression;
  	var ObjectExpression = (function () {
  	    function ObjectExpression(properties) {
  	        this.type = syntax_1.Syntax.ObjectExpression;
  	        this.properties = properties;
  	    }
  	    return ObjectExpression;
  	}());
  	exports.ObjectExpression = ObjectExpression;
  	var ObjectPattern = (function () {
  	    function ObjectPattern(properties) {
  	        this.type = syntax_1.Syntax.ObjectPattern;
  	        this.properties = properties;
  	    }
  	    return ObjectPattern;
  	}());
  	exports.ObjectPattern = ObjectPattern;
  	var Property = (function () {
  	    function Property(kind, key, computed, value, method, shorthand) {
  	        this.type = syntax_1.Syntax.Property;
  	        this.key = key;
  	        this.computed = computed;
  	        this.value = value;
  	        this.kind = kind;
  	        this.method = method;
  	        this.shorthand = shorthand;
  	    }
  	    return Property;
  	}());
  	exports.Property = Property;
  	var RegexLiteral = (function () {
  	    function RegexLiteral(value, raw, pattern, flags) {
  	        this.type = syntax_1.Syntax.Literal;
  	        this.value = value;
  	        this.raw = raw;
  	        this.regex = { pattern: pattern, flags: flags };
  	    }
  	    return RegexLiteral;
  	}());
  	exports.RegexLiteral = RegexLiteral;
  	var RestElement = (function () {
  	    function RestElement(argument) {
  	        this.type = syntax_1.Syntax.RestElement;
  	        this.argument = argument;
  	    }
  	    return RestElement;
  	}());
  	exports.RestElement = RestElement;
  	var ReturnStatement = (function () {
  	    function ReturnStatement(argument) {
  	        this.type = syntax_1.Syntax.ReturnStatement;
  	        this.argument = argument;
  	    }
  	    return ReturnStatement;
  	}());
  	exports.ReturnStatement = ReturnStatement;
  	var Script = (function () {
  	    function Script(body) {
  	        this.type = syntax_1.Syntax.Program;
  	        this.body = body;
  	        this.sourceType = 'script';
  	    }
  	    return Script;
  	}());
  	exports.Script = Script;
  	var SequenceExpression = (function () {
  	    function SequenceExpression(expressions) {
  	        this.type = syntax_1.Syntax.SequenceExpression;
  	        this.expressions = expressions;
  	    }
  	    return SequenceExpression;
  	}());
  	exports.SequenceExpression = SequenceExpression;
  	var SpreadElement = (function () {
  	    function SpreadElement(argument) {
  	        this.type = syntax_1.Syntax.SpreadElement;
  	        this.argument = argument;
  	    }
  	    return SpreadElement;
  	}());
  	exports.SpreadElement = SpreadElement;
  	var StaticMemberExpression = (function () {
  	    function StaticMemberExpression(object, property) {
  	        this.type = syntax_1.Syntax.MemberExpression;
  	        this.computed = false;
  	        this.object = object;
  	        this.property = property;
  	    }
  	    return StaticMemberExpression;
  	}());
  	exports.StaticMemberExpression = StaticMemberExpression;
  	var Super = (function () {
  	    function Super() {
  	        this.type = syntax_1.Syntax.Super;
  	    }
  	    return Super;
  	}());
  	exports.Super = Super;
  	var SwitchCase = (function () {
  	    function SwitchCase(test, consequent) {
  	        this.type = syntax_1.Syntax.SwitchCase;
  	        this.test = test;
  	        this.consequent = consequent;
  	    }
  	    return SwitchCase;
  	}());
  	exports.SwitchCase = SwitchCase;
  	var SwitchStatement = (function () {
  	    function SwitchStatement(discriminant, cases) {
  	        this.type = syntax_1.Syntax.SwitchStatement;
  	        this.discriminant = discriminant;
  	        this.cases = cases;
  	    }
  	    return SwitchStatement;
  	}());
  	exports.SwitchStatement = SwitchStatement;
  	var TaggedTemplateExpression = (function () {
  	    function TaggedTemplateExpression(tag, quasi) {
  	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
  	        this.tag = tag;
  	        this.quasi = quasi;
  	    }
  	    return TaggedTemplateExpression;
  	}());
  	exports.TaggedTemplateExpression = TaggedTemplateExpression;
  	var TemplateElement = (function () {
  	    function TemplateElement(value, tail) {
  	        this.type = syntax_1.Syntax.TemplateElement;
  	        this.value = value;
  	        this.tail = tail;
  	    }
  	    return TemplateElement;
  	}());
  	exports.TemplateElement = TemplateElement;
  	var TemplateLiteral = (function () {
  	    function TemplateLiteral(quasis, expressions) {
  	        this.type = syntax_1.Syntax.TemplateLiteral;
  	        this.quasis = quasis;
  	        this.expressions = expressions;
  	    }
  	    return TemplateLiteral;
  	}());
  	exports.TemplateLiteral = TemplateLiteral;
  	var ThisExpression = (function () {
  	    function ThisExpression() {
  	        this.type = syntax_1.Syntax.ThisExpression;
  	    }
  	    return ThisExpression;
  	}());
  	exports.ThisExpression = ThisExpression;
  	var ThrowStatement = (function () {
  	    function ThrowStatement(argument) {
  	        this.type = syntax_1.Syntax.ThrowStatement;
  	        this.argument = argument;
  	    }
  	    return ThrowStatement;
  	}());
  	exports.ThrowStatement = ThrowStatement;
  	var TryStatement = (function () {
  	    function TryStatement(block, handler, finalizer) {
  	        this.type = syntax_1.Syntax.TryStatement;
  	        this.block = block;
  	        this.handler = handler;
  	        this.finalizer = finalizer;
  	    }
  	    return TryStatement;
  	}());
  	exports.TryStatement = TryStatement;
  	var UnaryExpression = (function () {
  	    function UnaryExpression(operator, argument) {
  	        this.type = syntax_1.Syntax.UnaryExpression;
  	        this.operator = operator;
  	        this.argument = argument;
  	        this.prefix = true;
  	    }
  	    return UnaryExpression;
  	}());
  	exports.UnaryExpression = UnaryExpression;
  	var UpdateExpression = (function () {
  	    function UpdateExpression(operator, argument, prefix) {
  	        this.type = syntax_1.Syntax.UpdateExpression;
  	        this.operator = operator;
  	        this.argument = argument;
  	        this.prefix = prefix;
  	    }
  	    return UpdateExpression;
  	}());
  	exports.UpdateExpression = UpdateExpression;
  	var VariableDeclaration = (function () {
  	    function VariableDeclaration(declarations, kind) {
  	        this.type = syntax_1.Syntax.VariableDeclaration;
  	        this.declarations = declarations;
  	        this.kind = kind;
  	    }
  	    return VariableDeclaration;
  	}());
  	exports.VariableDeclaration = VariableDeclaration;
  	var VariableDeclarator = (function () {
  	    function VariableDeclarator(id, init) {
  	        this.type = syntax_1.Syntax.VariableDeclarator;
  	        this.id = id;
  	        this.init = init;
  	    }
  	    return VariableDeclarator;
  	}());
  	exports.VariableDeclarator = VariableDeclarator;
  	var WhileStatement = (function () {
  	    function WhileStatement(test, body) {
  	        this.type = syntax_1.Syntax.WhileStatement;
  	        this.test = test;
  	        this.body = body;
  	    }
  	    return WhileStatement;
  	}());
  	exports.WhileStatement = WhileStatement;
  	var WithStatement = (function () {
  	    function WithStatement(object, body) {
  	        this.type = syntax_1.Syntax.WithStatement;
  	        this.object = object;
  	        this.body = body;
  	    }
  	    return WithStatement;
  	}());
  	exports.WithStatement = WithStatement;
  	var YieldExpression = (function () {
  	    function YieldExpression(argument, delegate) {
  	        this.type = syntax_1.Syntax.YieldExpression;
  	        this.argument = argument;
  	        this.delegate = delegate;
  	    }
  	    return YieldExpression;
  	}());
  	exports.YieldExpression = YieldExpression;


  /***/ },
  /* 8 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var assert_1 = __webpack_require__(9);
  	var error_handler_1 = __webpack_require__(10);
  	var messages_1 = __webpack_require__(11);
  	var Node = __webpack_require__(7);
  	var scanner_1 = __webpack_require__(12);
  	var syntax_1 = __webpack_require__(2);
  	var token_1 = __webpack_require__(13);
  	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
  	var Parser = (function () {
  	    function Parser(code, options, delegate) {
  	        if (options === void 0) { options = {}; }
  	        this.config = {
  	            range: (typeof options.range === 'boolean') && options.range,
  	            loc: (typeof options.loc === 'boolean') && options.loc,
  	            source: null,
  	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
  	            comment: (typeof options.comment === 'boolean') && options.comment,
  	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
  	        };
  	        if (this.config.loc && options.source && options.source !== null) {
  	            this.config.source = String(options.source);
  	        }
  	        this.delegate = delegate;
  	        this.errorHandler = new error_handler_1.ErrorHandler();
  	        this.errorHandler.tolerant = this.config.tolerant;
  	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
  	        this.scanner.trackComment = this.config.comment;
  	        this.operatorPrecedence = {
  	            ')': 0,
  	            ';': 0,
  	            ',': 0,
  	            '=': 0,
  	            ']': 0,
  	            '||': 1,
  	            '&&': 2,
  	            '|': 3,
  	            '^': 4,
  	            '&': 5,
  	            '==': 6,
  	            '!=': 6,
  	            '===': 6,
  	            '!==': 6,
  	            '<': 7,
  	            '>': 7,
  	            '<=': 7,
  	            '>=': 7,
  	            '<<': 8,
  	            '>>': 8,
  	            '>>>': 8,
  	            '+': 9,
  	            '-': 9,
  	            '*': 11,
  	            '/': 11,
  	            '%': 11
  	        };
  	        this.lookahead = {
  	            type: 2 /* EOF */,
  	            value: '',
  	            lineNumber: this.scanner.lineNumber,
  	            lineStart: 0,
  	            start: 0,
  	            end: 0
  	        };
  	        this.hasLineTerminator = false;
  	        this.context = {
  	            isModule: false,
  	            await: false,
  	            allowIn: true,
  	            allowStrictDirective: true,
  	            allowYield: true,
  	            firstCoverInitializedNameError: null,
  	            isAssignmentTarget: false,
  	            isBindingElement: false,
  	            inFunctionBody: false,
  	            inIteration: false,
  	            inSwitch: false,
  	            labelSet: {},
  	            strict: false
  	        };
  	        this.tokens = [];
  	        this.startMarker = {
  	            index: 0,
  	            line: this.scanner.lineNumber,
  	            column: 0
  	        };
  	        this.lastMarker = {
  	            index: 0,
  	            line: this.scanner.lineNumber,
  	            column: 0
  	        };
  	        this.nextToken();
  	        this.lastMarker = {
  	            index: this.scanner.index,
  	            line: this.scanner.lineNumber,
  	            column: this.scanner.index - this.scanner.lineStart
  	        };
  	    }
  	    Parser.prototype.throwError = function (messageFormat) {
  	        var values = [];
  	        for (var _i = 1; _i < arguments.length; _i++) {
  	            values[_i - 1] = arguments[_i];
  	        }
  	        var args = Array.prototype.slice.call(arguments, 1);
  	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
  	            assert_1.assert(idx < args.length, 'Message reference must be in range');
  	            return args[idx];
  	        });
  	        var index = this.lastMarker.index;
  	        var line = this.lastMarker.line;
  	        var column = this.lastMarker.column + 1;
  	        throw this.errorHandler.createError(index, line, column, msg);
  	    };
  	    Parser.prototype.tolerateError = function (messageFormat) {
  	        var values = [];
  	        for (var _i = 1; _i < arguments.length; _i++) {
  	            values[_i - 1] = arguments[_i];
  	        }
  	        var args = Array.prototype.slice.call(arguments, 1);
  	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
  	            assert_1.assert(idx < args.length, 'Message reference must be in range');
  	            return args[idx];
  	        });
  	        var index = this.lastMarker.index;
  	        var line = this.scanner.lineNumber;
  	        var column = this.lastMarker.column + 1;
  	        this.errorHandler.tolerateError(index, line, column, msg);
  	    };
  	    // Throw an exception because of the token.
  	    Parser.prototype.unexpectedTokenError = function (token, message) {
  	        var msg = message || messages_1.Messages.UnexpectedToken;
  	        var value;
  	        if (token) {
  	            if (!message) {
  	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
  	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
  	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
  	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
  	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
  	                                    messages_1.Messages.UnexpectedToken;
  	                if (token.type === 4 /* Keyword */) {
  	                    if (this.scanner.isFutureReservedWord(token.value)) {
  	                        msg = messages_1.Messages.UnexpectedReserved;
  	                    }
  	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
  	                        msg = messages_1.Messages.StrictReservedWord;
  	                    }
  	                }
  	            }
  	            value = token.value;
  	        }
  	        else {
  	            value = 'ILLEGAL';
  	        }
  	        msg = msg.replace('%0', value);
  	        if (token && typeof token.lineNumber === 'number') {
  	            var index = token.start;
  	            var line = token.lineNumber;
  	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
  	            var column = token.start - lastMarkerLineStart + 1;
  	            return this.errorHandler.createError(index, line, column, msg);
  	        }
  	        else {
  	            var index = this.lastMarker.index;
  	            var line = this.lastMarker.line;
  	            var column = this.lastMarker.column + 1;
  	            return this.errorHandler.createError(index, line, column, msg);
  	        }
  	    };
  	    Parser.prototype.throwUnexpectedToken = function (token, message) {
  	        throw this.unexpectedTokenError(token, message);
  	    };
  	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
  	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
  	    };
  	    Parser.prototype.collectComments = function () {
  	        if (!this.config.comment) {
  	            this.scanner.scanComments();
  	        }
  	        else {
  	            var comments = this.scanner.scanComments();
  	            if (comments.length > 0 && this.delegate) {
  	                for (var i = 0; i < comments.length; ++i) {
  	                    var e = comments[i];
  	                    var node = void 0;
  	                    node = {
  	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
  	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
  	                    };
  	                    if (this.config.range) {
  	                        node.range = e.range;
  	                    }
  	                    if (this.config.loc) {
  	                        node.loc = e.loc;
  	                    }
  	                    var metadata = {
  	                        start: {
  	                            line: e.loc.start.line,
  	                            column: e.loc.start.column,
  	                            offset: e.range[0]
  	                        },
  	                        end: {
  	                            line: e.loc.end.line,
  	                            column: e.loc.end.column,
  	                            offset: e.range[1]
  	                        }
  	                    };
  	                    this.delegate(node, metadata);
  	                }
  	            }
  	        }
  	    };
  	    // From internal representation to an external structure
  	    Parser.prototype.getTokenRaw = function (token) {
  	        return this.scanner.source.slice(token.start, token.end);
  	    };
  	    Parser.prototype.convertToken = function (token) {
  	        var t = {
  	            type: token_1.TokenName[token.type],
  	            value: this.getTokenRaw(token)
  	        };
  	        if (this.config.range) {
  	            t.range = [token.start, token.end];
  	        }
  	        if (this.config.loc) {
  	            t.loc = {
  	                start: {
  	                    line: this.startMarker.line,
  	                    column: this.startMarker.column
  	                },
  	                end: {
  	                    line: this.scanner.lineNumber,
  	                    column: this.scanner.index - this.scanner.lineStart
  	                }
  	            };
  	        }
  	        if (token.type === 9 /* RegularExpression */) {
  	            var pattern = token.pattern;
  	            var flags = token.flags;
  	            t.regex = { pattern: pattern, flags: flags };
  	        }
  	        return t;
  	    };
  	    Parser.prototype.nextToken = function () {
  	        var token = this.lookahead;
  	        this.lastMarker.index = this.scanner.index;
  	        this.lastMarker.line = this.scanner.lineNumber;
  	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
  	        this.collectComments();
  	        if (this.scanner.index !== this.startMarker.index) {
  	            this.startMarker.index = this.scanner.index;
  	            this.startMarker.line = this.scanner.lineNumber;
  	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
  	        }
  	        var next = this.scanner.lex();
  	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
  	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
  	            if (this.scanner.isStrictModeReservedWord(next.value)) {
  	                next.type = 4 /* Keyword */;
  	            }
  	        }
  	        this.lookahead = next;
  	        if (this.config.tokens && next.type !== 2 /* EOF */) {
  	            this.tokens.push(this.convertToken(next));
  	        }
  	        return token;
  	    };
  	    Parser.prototype.nextRegexToken = function () {
  	        this.collectComments();
  	        var token = this.scanner.scanRegExp();
  	        if (this.config.tokens) {
  	            // Pop the previous token, '/' or '/='
  	            // This is added from the lookahead token.
  	            this.tokens.pop();
  	            this.tokens.push(this.convertToken(token));
  	        }
  	        // Prime the next lookahead.
  	        this.lookahead = token;
  	        this.nextToken();
  	        return token;
  	    };
  	    Parser.prototype.createNode = function () {
  	        return {
  	            index: this.startMarker.index,
  	            line: this.startMarker.line,
  	            column: this.startMarker.column
  	        };
  	    };
  	    Parser.prototype.startNode = function (token, lastLineStart) {
  	        if (lastLineStart === void 0) { lastLineStart = 0; }
  	        var column = token.start - token.lineStart;
  	        var line = token.lineNumber;
  	        if (column < 0) {
  	            column += lastLineStart;
  	            line--;
  	        }
  	        return {
  	            index: token.start,
  	            line: line,
  	            column: column
  	        };
  	    };
  	    Parser.prototype.finalize = function (marker, node) {
  	        if (this.config.range) {
  	            node.range = [marker.index, this.lastMarker.index];
  	        }
  	        if (this.config.loc) {
  	            node.loc = {
  	                start: {
  	                    line: marker.line,
  	                    column: marker.column,
  	                },
  	                end: {
  	                    line: this.lastMarker.line,
  	                    column: this.lastMarker.column
  	                }
  	            };
  	            if (this.config.source) {
  	                node.loc.source = this.config.source;
  	            }
  	        }
  	        if (this.delegate) {
  	            var metadata = {
  	                start: {
  	                    line: marker.line,
  	                    column: marker.column,
  	                    offset: marker.index
  	                },
  	                end: {
  	                    line: this.lastMarker.line,
  	                    column: this.lastMarker.column,
  	                    offset: this.lastMarker.index
  	                }
  	            };
  	            this.delegate(node, metadata);
  	        }
  	        return node;
  	    };
  	    // Expect the next token to match the specified punctuator.
  	    // If not, an exception will be thrown.
  	    Parser.prototype.expect = function (value) {
  	        var token = this.nextToken();
  	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
  	            this.throwUnexpectedToken(token);
  	        }
  	    };
  	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
  	    Parser.prototype.expectCommaSeparator = function () {
  	        if (this.config.tolerant) {
  	            var token = this.lookahead;
  	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
  	                this.nextToken();
  	            }
  	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
  	                this.nextToken();
  	                this.tolerateUnexpectedToken(token);
  	            }
  	            else {
  	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
  	            }
  	        }
  	        else {
  	            this.expect(',');
  	        }
  	    };
  	    // Expect the next token to match the specified keyword.
  	    // If not, an exception will be thrown.
  	    Parser.prototype.expectKeyword = function (keyword) {
  	        var token = this.nextToken();
  	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
  	            this.throwUnexpectedToken(token);
  	        }
  	    };
  	    // Return true if the next token matches the specified punctuator.
  	    Parser.prototype.match = function (value) {
  	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
  	    };
  	    // Return true if the next token matches the specified keyword
  	    Parser.prototype.matchKeyword = function (keyword) {
  	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
  	    };
  	    // Return true if the next token matches the specified contextual keyword
  	    // (where an identifier is sometimes a keyword depending on the context)
  	    Parser.prototype.matchContextualKeyword = function (keyword) {
  	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
  	    };
  	    // Return true if the next token is an assignment operator
  	    Parser.prototype.matchAssign = function () {
  	        if (this.lookahead.type !== 7 /* Punctuator */) {
  	            return false;
  	        }
  	        var op = this.lookahead.value;
  	        return op === '=' ||
  	            op === '*=' ||
  	            op === '**=' ||
  	            op === '/=' ||
  	            op === '%=' ||
  	            op === '+=' ||
  	            op === '-=' ||
  	            op === '<<=' ||
  	            op === '>>=' ||
  	            op === '>>>=' ||
  	            op === '&=' ||
  	            op === '^=' ||
  	            op === '|=';
  	    };
  	    // Cover grammar support.
  	    //
  	    // When an assignment expression position starts with an left parenthesis, the determination of the type
  	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
  	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
  	    //
  	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
  	    // after the outermost pair is closed. They are:
  	    //
  	    //   1. AssignmentExpression
  	    //   2. BindingElements
  	    //   3. AssignmentTargets
  	    //
  	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
  	    // binding element or assignment target.
  	    //
  	    // The three productions have the relationship:
  	    //
  	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
  	    //
  	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
  	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
  	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
  	    //
  	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
  	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
  	    // the CoverInitializedName check is conducted.
  	    //
  	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
  	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
  	    // pattern. The CoverInitializedName check is deferred.
  	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
  	        var previousIsBindingElement = this.context.isBindingElement;
  	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
  	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
  	        this.context.isBindingElement = true;
  	        this.context.isAssignmentTarget = true;
  	        this.context.firstCoverInitializedNameError = null;
  	        var result = parseFunction.call(this);
  	        if (this.context.firstCoverInitializedNameError !== null) {
  	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
  	        }
  	        this.context.isBindingElement = previousIsBindingElement;
  	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
  	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
  	        return result;
  	    };
  	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
  	        var previousIsBindingElement = this.context.isBindingElement;
  	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
  	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
  	        this.context.isBindingElement = true;
  	        this.context.isAssignmentTarget = true;
  	        this.context.firstCoverInitializedNameError = null;
  	        var result = parseFunction.call(this);
  	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
  	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
  	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
  	        return result;
  	    };
  	    Parser.prototype.consumeSemicolon = function () {
  	        if (this.match(';')) {
  	            this.nextToken();
  	        }
  	        else if (!this.hasLineTerminator) {
  	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
  	                this.throwUnexpectedToken(this.lookahead);
  	            }
  	            this.lastMarker.index = this.startMarker.index;
  	            this.lastMarker.line = this.startMarker.line;
  	            this.lastMarker.column = this.startMarker.column;
  	        }
  	    };
  	    // https://tc39.github.io/ecma262/#sec-primary-expression
  	    Parser.prototype.parsePrimaryExpression = function () {
  	        var node = this.createNode();
  	        var expr;
  	        var token, raw;
  	        switch (this.lookahead.type) {
  	            case 3 /* Identifier */:
  	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
  	                    this.tolerateUnexpectedToken(this.lookahead);
  	                }
  	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
  	                break;
  	            case 6 /* NumericLiteral */:
  	            case 8 /* StringLiteral */:
  	                if (this.context.strict && this.lookahead.octal) {
  	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
  	                }
  	                this.context.isAssignmentTarget = false;
  	                this.context.isBindingElement = false;
  	                token = this.nextToken();
  	                raw = this.getTokenRaw(token);
  	                expr = this.finalize(node, new Node.Literal(token.value, raw));
  	                break;
  	            case 1 /* BooleanLiteral */:
  	                this.context.isAssignmentTarget = false;
  	                this.context.isBindingElement = false;
  	                token = this.nextToken();
  	                raw = this.getTokenRaw(token);
  	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
  	                break;
  	            case 5 /* NullLiteral */:
  	                this.context.isAssignmentTarget = false;
  	                this.context.isBindingElement = false;
  	                token = this.nextToken();
  	                raw = this.getTokenRaw(token);
  	                expr = this.finalize(node, new Node.Literal(null, raw));
  	                break;
  	            case 10 /* Template */:
  	                expr = this.parseTemplateLiteral();
  	                break;
  	            case 7 /* Punctuator */:
  	                switch (this.lookahead.value) {
  	                    case '(':
  	                        this.context.isBindingElement = false;
  	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
  	                        break;
  	                    case '[':
  	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
  	                        break;
  	                    case '{':
  	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
  	                        break;
  	                    case '/':
  	                    case '/=':
  	                        this.context.isAssignmentTarget = false;
  	                        this.context.isBindingElement = false;
  	                        this.scanner.index = this.startMarker.index;
  	                        token = this.nextRegexToken();
  	                        raw = this.getTokenRaw(token);
  	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
  	                        break;
  	                    default:
  	                        expr = this.throwUnexpectedToken(this.nextToken());
  	                }
  	                break;
  	            case 4 /* Keyword */:
  	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
  	                    expr = this.parseIdentifierName();
  	                }
  	                else if (!this.context.strict && this.matchKeyword('let')) {
  	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
  	                }
  	                else {
  	                    this.context.isAssignmentTarget = false;
  	                    this.context.isBindingElement = false;
  	                    if (this.matchKeyword('function')) {
  	                        expr = this.parseFunctionExpression();
  	                    }
  	                    else if (this.matchKeyword('this')) {
  	                        this.nextToken();
  	                        expr = this.finalize(node, new Node.ThisExpression());
  	                    }
  	                    else if (this.matchKeyword('class')) {
  	                        expr = this.parseClassExpression();
  	                    }
  	                    else {
  	                        expr = this.throwUnexpectedToken(this.nextToken());
  	                    }
  	                }
  	                break;
  	            default:
  	                expr = this.throwUnexpectedToken(this.nextToken());
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-array-initializer
  	    Parser.prototype.parseSpreadElement = function () {
  	        var node = this.createNode();
  	        this.expect('...');
  	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
  	        return this.finalize(node, new Node.SpreadElement(arg));
  	    };
  	    Parser.prototype.parseArrayInitializer = function () {
  	        var node = this.createNode();
  	        var elements = [];
  	        this.expect('[');
  	        while (!this.match(']')) {
  	            if (this.match(',')) {
  	                this.nextToken();
  	                elements.push(null);
  	            }
  	            else if (this.match('...')) {
  	                var element = this.parseSpreadElement();
  	                if (!this.match(']')) {
  	                    this.context.isAssignmentTarget = false;
  	                    this.context.isBindingElement = false;
  	                    this.expect(',');
  	                }
  	                elements.push(element);
  	            }
  	            else {
  	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
  	                if (!this.match(']')) {
  	                    this.expect(',');
  	                }
  	            }
  	        }
  	        this.expect(']');
  	        return this.finalize(node, new Node.ArrayExpression(elements));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-object-initializer
  	    Parser.prototype.parsePropertyMethod = function (params) {
  	        this.context.isAssignmentTarget = false;
  	        this.context.isBindingElement = false;
  	        var previousStrict = this.context.strict;
  	        var previousAllowStrictDirective = this.context.allowStrictDirective;
  	        this.context.allowStrictDirective = params.simple;
  	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
  	        if (this.context.strict && params.firstRestricted) {
  	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
  	        }
  	        if (this.context.strict && params.stricted) {
  	            this.tolerateUnexpectedToken(params.stricted, params.message);
  	        }
  	        this.context.strict = previousStrict;
  	        this.context.allowStrictDirective = previousAllowStrictDirective;
  	        return body;
  	    };
  	    Parser.prototype.parsePropertyMethodFunction = function () {
  	        var isGenerator = false;
  	        var node = this.createNode();
  	        var previousAllowYield = this.context.allowYield;
  	        this.context.allowYield = true;
  	        var params = this.parseFormalParameters();
  	        var method = this.parsePropertyMethod(params);
  	        this.context.allowYield = previousAllowYield;
  	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
  	    };
  	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
  	        var node = this.createNode();
  	        var previousAllowYield = this.context.allowYield;
  	        var previousAwait = this.context.await;
  	        this.context.allowYield = false;
  	        this.context.await = true;
  	        var params = this.parseFormalParameters();
  	        var method = this.parsePropertyMethod(params);
  	        this.context.allowYield = previousAllowYield;
  	        this.context.await = previousAwait;
  	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
  	    };
  	    Parser.prototype.parseObjectPropertyKey = function () {
  	        var node = this.createNode();
  	        var token = this.nextToken();
  	        var key;
  	        switch (token.type) {
  	            case 8 /* StringLiteral */:
  	            case 6 /* NumericLiteral */:
  	                if (this.context.strict && token.octal) {
  	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
  	                }
  	                var raw = this.getTokenRaw(token);
  	                key = this.finalize(node, new Node.Literal(token.value, raw));
  	                break;
  	            case 3 /* Identifier */:
  	            case 1 /* BooleanLiteral */:
  	            case 5 /* NullLiteral */:
  	            case 4 /* Keyword */:
  	                key = this.finalize(node, new Node.Identifier(token.value));
  	                break;
  	            case 7 /* Punctuator */:
  	                if (token.value === '[') {
  	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	                    this.expect(']');
  	                }
  	                else {
  	                    key = this.throwUnexpectedToken(token);
  	                }
  	                break;
  	            default:
  	                key = this.throwUnexpectedToken(token);
  	        }
  	        return key;
  	    };
  	    Parser.prototype.isPropertyKey = function (key, value) {
  	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
  	            (key.type === syntax_1.Syntax.Literal && key.value === value);
  	    };
  	    Parser.prototype.parseObjectProperty = function (hasProto) {
  	        var node = this.createNode();
  	        var token = this.lookahead;
  	        var kind;
  	        var key = null;
  	        var value = null;
  	        var computed = false;
  	        var method = false;
  	        var shorthand = false;
  	        var isAsync = false;
  	        if (token.type === 3 /* Identifier */) {
  	            var id = token.value;
  	            this.nextToken();
  	            computed = this.match('[');
  	            isAsync = !this.hasLineTerminator && (id === 'async') &&
  	                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
  	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
  	        }
  	        else if (this.match('*')) {
  	            this.nextToken();
  	        }
  	        else {
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	        }
  	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
  	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
  	            kind = 'get';
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	            this.context.allowYield = false;
  	            value = this.parseGetterMethod();
  	        }
  	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
  	            kind = 'set';
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	            value = this.parseSetterMethod();
  	        }
  	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
  	            kind = 'init';
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	            value = this.parseGeneratorMethod();
  	            method = true;
  	        }
  	        else {
  	            if (!key) {
  	                this.throwUnexpectedToken(this.lookahead);
  	            }
  	            kind = 'init';
  	            if (this.match(':') && !isAsync) {
  	                if (!computed && this.isPropertyKey(key, '__proto__')) {
  	                    if (hasProto.value) {
  	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
  	                    }
  	                    hasProto.value = true;
  	                }
  	                this.nextToken();
  	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
  	            }
  	            else if (this.match('(')) {
  	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
  	                method = true;
  	            }
  	            else if (token.type === 3 /* Identifier */) {
  	                var id = this.finalize(node, new Node.Identifier(token.value));
  	                if (this.match('=')) {
  	                    this.context.firstCoverInitializedNameError = this.lookahead;
  	                    this.nextToken();
  	                    shorthand = true;
  	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
  	                }
  	                else {
  	                    shorthand = true;
  	                    value = id;
  	                }
  	            }
  	            else {
  	                this.throwUnexpectedToken(this.nextToken());
  	            }
  	        }
  	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
  	    };
  	    Parser.prototype.parseObjectInitializer = function () {
  	        var node = this.createNode();
  	        this.expect('{');
  	        var properties = [];
  	        var hasProto = { value: false };
  	        while (!this.match('}')) {
  	            properties.push(this.parseObjectProperty(hasProto));
  	            if (!this.match('}')) {
  	                this.expectCommaSeparator();
  	            }
  	        }
  	        this.expect('}');
  	        return this.finalize(node, new Node.ObjectExpression(properties));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-template-literals
  	    Parser.prototype.parseTemplateHead = function () {
  	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
  	        var node = this.createNode();
  	        var token = this.nextToken();
  	        var raw = token.value;
  	        var cooked = token.cooked;
  	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
  	    };
  	    Parser.prototype.parseTemplateElement = function () {
  	        if (this.lookahead.type !== 10 /* Template */) {
  	            this.throwUnexpectedToken();
  	        }
  	        var node = this.createNode();
  	        var token = this.nextToken();
  	        var raw = token.value;
  	        var cooked = token.cooked;
  	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
  	    };
  	    Parser.prototype.parseTemplateLiteral = function () {
  	        var node = this.createNode();
  	        var expressions = [];
  	        var quasis = [];
  	        var quasi = this.parseTemplateHead();
  	        quasis.push(quasi);
  	        while (!quasi.tail) {
  	            expressions.push(this.parseExpression());
  	            quasi = this.parseTemplateElement();
  	            quasis.push(quasi);
  	        }
  	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-grouping-operator
  	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
  	        switch (expr.type) {
  	            case syntax_1.Syntax.Identifier:
  	            case syntax_1.Syntax.MemberExpression:
  	            case syntax_1.Syntax.RestElement:
  	            case syntax_1.Syntax.AssignmentPattern:
  	                break;
  	            case syntax_1.Syntax.SpreadElement:
  	                expr.type = syntax_1.Syntax.RestElement;
  	                this.reinterpretExpressionAsPattern(expr.argument);
  	                break;
  	            case syntax_1.Syntax.ArrayExpression:
  	                expr.type = syntax_1.Syntax.ArrayPattern;
  	                for (var i = 0; i < expr.elements.length; i++) {
  	                    if (expr.elements[i] !== null) {
  	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
  	                    }
  	                }
  	                break;
  	            case syntax_1.Syntax.ObjectExpression:
  	                expr.type = syntax_1.Syntax.ObjectPattern;
  	                for (var i = 0; i < expr.properties.length; i++) {
  	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
  	                }
  	                break;
  	            case syntax_1.Syntax.AssignmentExpression:
  	                expr.type = syntax_1.Syntax.AssignmentPattern;
  	                delete expr.operator;
  	                this.reinterpretExpressionAsPattern(expr.left);
  	                break;
  	            default:
  	                // Allow other node type for tolerant parsing.
  	                break;
  	        }
  	    };
  	    Parser.prototype.parseGroupExpression = function () {
  	        var expr;
  	        this.expect('(');
  	        if (this.match(')')) {
  	            this.nextToken();
  	            if (!this.match('=>')) {
  	                this.expect('=>');
  	            }
  	            expr = {
  	                type: ArrowParameterPlaceHolder,
  	                params: [],
  	                async: false
  	            };
  	        }
  	        else {
  	            var startToken = this.lookahead;
  	            var params = [];
  	            if (this.match('...')) {
  	                expr = this.parseRestElement(params);
  	                this.expect(')');
  	                if (!this.match('=>')) {
  	                    this.expect('=>');
  	                }
  	                expr = {
  	                    type: ArrowParameterPlaceHolder,
  	                    params: [expr],
  	                    async: false
  	                };
  	            }
  	            else {
  	                var arrow = false;
  	                this.context.isBindingElement = true;
  	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
  	                if (this.match(',')) {
  	                    var expressions = [];
  	                    this.context.isAssignmentTarget = false;
  	                    expressions.push(expr);
  	                    while (this.lookahead.type !== 2 /* EOF */) {
  	                        if (!this.match(',')) {
  	                            break;
  	                        }
  	                        this.nextToken();
  	                        if (this.match(')')) {
  	                            this.nextToken();
  	                            for (var i = 0; i < expressions.length; i++) {
  	                                this.reinterpretExpressionAsPattern(expressions[i]);
  	                            }
  	                            arrow = true;
  	                            expr = {
  	                                type: ArrowParameterPlaceHolder,
  	                                params: expressions,
  	                                async: false
  	                            };
  	                        }
  	                        else if (this.match('...')) {
  	                            if (!this.context.isBindingElement) {
  	                                this.throwUnexpectedToken(this.lookahead);
  	                            }
  	                            expressions.push(this.parseRestElement(params));
  	                            this.expect(')');
  	                            if (!this.match('=>')) {
  	                                this.expect('=>');
  	                            }
  	                            this.context.isBindingElement = false;
  	                            for (var i = 0; i < expressions.length; i++) {
  	                                this.reinterpretExpressionAsPattern(expressions[i]);
  	                            }
  	                            arrow = true;
  	                            expr = {
  	                                type: ArrowParameterPlaceHolder,
  	                                params: expressions,
  	                                async: false
  	                            };
  	                        }
  	                        else {
  	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
  	                        }
  	                        if (arrow) {
  	                            break;
  	                        }
  	                    }
  	                    if (!arrow) {
  	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
  	                    }
  	                }
  	                if (!arrow) {
  	                    this.expect(')');
  	                    if (this.match('=>')) {
  	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
  	                            arrow = true;
  	                            expr = {
  	                                type: ArrowParameterPlaceHolder,
  	                                params: [expr],
  	                                async: false
  	                            };
  	                        }
  	                        if (!arrow) {
  	                            if (!this.context.isBindingElement) {
  	                                this.throwUnexpectedToken(this.lookahead);
  	                            }
  	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
  	                                for (var i = 0; i < expr.expressions.length; i++) {
  	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
  	                                }
  	                            }
  	                            else {
  	                                this.reinterpretExpressionAsPattern(expr);
  	                            }
  	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
  	                            expr = {
  	                                type: ArrowParameterPlaceHolder,
  	                                params: parameters,
  	                                async: false
  	                            };
  	                        }
  	                    }
  	                    this.context.isBindingElement = false;
  	                }
  	            }
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
  	    Parser.prototype.parseArguments = function () {
  	        this.expect('(');
  	        var args = [];
  	        if (!this.match(')')) {
  	            while (true) {
  	                var expr = this.match('...') ? this.parseSpreadElement() :
  	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
  	                args.push(expr);
  	                if (this.match(')')) {
  	                    break;
  	                }
  	                this.expectCommaSeparator();
  	                if (this.match(')')) {
  	                    break;
  	                }
  	            }
  	        }
  	        this.expect(')');
  	        return args;
  	    };
  	    Parser.prototype.isIdentifierName = function (token) {
  	        return token.type === 3 /* Identifier */ ||
  	            token.type === 4 /* Keyword */ ||
  	            token.type === 1 /* BooleanLiteral */ ||
  	            token.type === 5 /* NullLiteral */;
  	    };
  	    Parser.prototype.parseIdentifierName = function () {
  	        var node = this.createNode();
  	        var token = this.nextToken();
  	        if (!this.isIdentifierName(token)) {
  	            this.throwUnexpectedToken(token);
  	        }
  	        return this.finalize(node, new Node.Identifier(token.value));
  	    };
  	    Parser.prototype.parseNewExpression = function () {
  	        var node = this.createNode();
  	        var id = this.parseIdentifierName();
  	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
  	        var expr;
  	        if (this.match('.')) {
  	            this.nextToken();
  	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
  	                var property = this.parseIdentifierName();
  	                expr = new Node.MetaProperty(id, property);
  	            }
  	            else {
  	                this.throwUnexpectedToken(this.lookahead);
  	            }
  	        }
  	        else {
  	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
  	            var args = this.match('(') ? this.parseArguments() : [];
  	            expr = new Node.NewExpression(callee, args);
  	            this.context.isAssignmentTarget = false;
  	            this.context.isBindingElement = false;
  	        }
  	        return this.finalize(node, expr);
  	    };
  	    Parser.prototype.parseAsyncArgument = function () {
  	        var arg = this.parseAssignmentExpression();
  	        this.context.firstCoverInitializedNameError = null;
  	        return arg;
  	    };
  	    Parser.prototype.parseAsyncArguments = function () {
  	        this.expect('(');
  	        var args = [];
  	        if (!this.match(')')) {
  	            while (true) {
  	                var expr = this.match('...') ? this.parseSpreadElement() :
  	                    this.isolateCoverGrammar(this.parseAsyncArgument);
  	                args.push(expr);
  	                if (this.match(')')) {
  	                    break;
  	                }
  	                this.expectCommaSeparator();
  	                if (this.match(')')) {
  	                    break;
  	                }
  	            }
  	        }
  	        this.expect(')');
  	        return args;
  	    };
  	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
  	        var startToken = this.lookahead;
  	        var maybeAsync = this.matchContextualKeyword('async');
  	        var previousAllowIn = this.context.allowIn;
  	        this.context.allowIn = true;
  	        var expr;
  	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
  	            expr = this.createNode();
  	            this.nextToken();
  	            expr = this.finalize(expr, new Node.Super());
  	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
  	                this.throwUnexpectedToken(this.lookahead);
  	            }
  	        }
  	        else {
  	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
  	        }
  	        while (true) {
  	            if (this.match('.')) {
  	                this.context.isBindingElement = false;
  	                this.context.isAssignmentTarget = true;
  	                this.expect('.');
  	                var property = this.parseIdentifierName();
  	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
  	            }
  	            else if (this.match('(')) {
  	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
  	                this.context.isBindingElement = false;
  	                this.context.isAssignmentTarget = false;
  	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
  	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
  	                if (asyncArrow && this.match('=>')) {
  	                    for (var i = 0; i < args.length; ++i) {
  	                        this.reinterpretExpressionAsPattern(args[i]);
  	                    }
  	                    expr = {
  	                        type: ArrowParameterPlaceHolder,
  	                        params: args,
  	                        async: true
  	                    };
  	                }
  	            }
  	            else if (this.match('[')) {
  	                this.context.isBindingElement = false;
  	                this.context.isAssignmentTarget = true;
  	                this.expect('[');
  	                var property = this.isolateCoverGrammar(this.parseExpression);
  	                this.expect(']');
  	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
  	            }
  	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
  	                var quasi = this.parseTemplateLiteral();
  	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
  	            }
  	            else {
  	                break;
  	            }
  	        }
  	        this.context.allowIn = previousAllowIn;
  	        return expr;
  	    };
  	    Parser.prototype.parseSuper = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('super');
  	        if (!this.match('[') && !this.match('.')) {
  	            this.throwUnexpectedToken(this.lookahead);
  	        }
  	        return this.finalize(node, new Node.Super());
  	    };
  	    Parser.prototype.parseLeftHandSideExpression = function () {
  	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
  	        var node = this.startNode(this.lookahead);
  	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
  	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
  	        while (true) {
  	            if (this.match('[')) {
  	                this.context.isBindingElement = false;
  	                this.context.isAssignmentTarget = true;
  	                this.expect('[');
  	                var property = this.isolateCoverGrammar(this.parseExpression);
  	                this.expect(']');
  	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
  	            }
  	            else if (this.match('.')) {
  	                this.context.isBindingElement = false;
  	                this.context.isAssignmentTarget = true;
  	                this.expect('.');
  	                var property = this.parseIdentifierName();
  	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
  	            }
  	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
  	                var quasi = this.parseTemplateLiteral();
  	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
  	            }
  	            else {
  	                break;
  	            }
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-update-expressions
  	    Parser.prototype.parseUpdateExpression = function () {
  	        var expr;
  	        var startToken = this.lookahead;
  	        if (this.match('++') || this.match('--')) {
  	            var node = this.startNode(startToken);
  	            var token = this.nextToken();
  	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
  	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
  	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
  	            }
  	            if (!this.context.isAssignmentTarget) {
  	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
  	            }
  	            var prefix = true;
  	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
  	            this.context.isAssignmentTarget = false;
  	            this.context.isBindingElement = false;
  	        }
  	        else {
  	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
  	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
  	                if (this.match('++') || this.match('--')) {
  	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
  	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
  	                    }
  	                    if (!this.context.isAssignmentTarget) {
  	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
  	                    }
  	                    this.context.isAssignmentTarget = false;
  	                    this.context.isBindingElement = false;
  	                    var operator = this.nextToken().value;
  	                    var prefix = false;
  	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
  	                }
  	            }
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-unary-operators
  	    Parser.prototype.parseAwaitExpression = function () {
  	        var node = this.createNode();
  	        this.nextToken();
  	        var argument = this.parseUnaryExpression();
  	        return this.finalize(node, new Node.AwaitExpression(argument));
  	    };
  	    Parser.prototype.parseUnaryExpression = function () {
  	        var expr;
  	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
  	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
  	            var node = this.startNode(this.lookahead);
  	            var token = this.nextToken();
  	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
  	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
  	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
  	                this.tolerateError(messages_1.Messages.StrictDelete);
  	            }
  	            this.context.isAssignmentTarget = false;
  	            this.context.isBindingElement = false;
  	        }
  	        else if (this.context.await && this.matchContextualKeyword('await')) {
  	            expr = this.parseAwaitExpression();
  	        }
  	        else {
  	            expr = this.parseUpdateExpression();
  	        }
  	        return expr;
  	    };
  	    Parser.prototype.parseExponentiationExpression = function () {
  	        var startToken = this.lookahead;
  	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
  	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
  	            this.nextToken();
  	            this.context.isAssignmentTarget = false;
  	            this.context.isBindingElement = false;
  	            var left = expr;
  	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
  	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-exp-operator
  	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
  	    // https://tc39.github.io/ecma262/#sec-additive-operators
  	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
  	    // https://tc39.github.io/ecma262/#sec-relational-operators
  	    // https://tc39.github.io/ecma262/#sec-equality-operators
  	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
  	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
  	    Parser.prototype.binaryPrecedence = function (token) {
  	        var op = token.value;
  	        var precedence;
  	        if (token.type === 7 /* Punctuator */) {
  	            precedence = this.operatorPrecedence[op] || 0;
  	        }
  	        else if (token.type === 4 /* Keyword */) {
  	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
  	        }
  	        else {
  	            precedence = 0;
  	        }
  	        return precedence;
  	    };
  	    Parser.prototype.parseBinaryExpression = function () {
  	        var startToken = this.lookahead;
  	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
  	        var token = this.lookahead;
  	        var prec = this.binaryPrecedence(token);
  	        if (prec > 0) {
  	            this.nextToken();
  	            this.context.isAssignmentTarget = false;
  	            this.context.isBindingElement = false;
  	            var markers = [startToken, this.lookahead];
  	            var left = expr;
  	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
  	            var stack = [left, token.value, right];
  	            var precedences = [prec];
  	            while (true) {
  	                prec = this.binaryPrecedence(this.lookahead);
  	                if (prec <= 0) {
  	                    break;
  	                }
  	                // Reduce: make a binary expression from the three topmost entries.
  	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
  	                    right = stack.pop();
  	                    var operator = stack.pop();
  	                    precedences.pop();
  	                    left = stack.pop();
  	                    markers.pop();
  	                    var node = this.startNode(markers[markers.length - 1]);
  	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
  	                }
  	                // Shift.
  	                stack.push(this.nextToken().value);
  	                precedences.push(prec);
  	                markers.push(this.lookahead);
  	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
  	            }
  	            // Final reduce to clean-up the stack.
  	            var i = stack.length - 1;
  	            expr = stack[i];
  	            var lastMarker = markers.pop();
  	            while (i > 1) {
  	                var marker = markers.pop();
  	                var lastLineStart = lastMarker && lastMarker.lineStart;
  	                var node = this.startNode(marker, lastLineStart);
  	                var operator = stack[i - 1];
  	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
  	                i -= 2;
  	                lastMarker = marker;
  	            }
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-conditional-operator
  	    Parser.prototype.parseConditionalExpression = function () {
  	        var startToken = this.lookahead;
  	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
  	        if (this.match('?')) {
  	            this.nextToken();
  	            var previousAllowIn = this.context.allowIn;
  	            this.context.allowIn = true;
  	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	            this.context.allowIn = previousAllowIn;
  	            this.expect(':');
  	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
  	            this.context.isAssignmentTarget = false;
  	            this.context.isBindingElement = false;
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-assignment-operators
  	    Parser.prototype.checkPatternParam = function (options, param) {
  	        switch (param.type) {
  	            case syntax_1.Syntax.Identifier:
  	                this.validateParam(options, param, param.name);
  	                break;
  	            case syntax_1.Syntax.RestElement:
  	                this.checkPatternParam(options, param.argument);
  	                break;
  	            case syntax_1.Syntax.AssignmentPattern:
  	                this.checkPatternParam(options, param.left);
  	                break;
  	            case syntax_1.Syntax.ArrayPattern:
  	                for (var i = 0; i < param.elements.length; i++) {
  	                    if (param.elements[i] !== null) {
  	                        this.checkPatternParam(options, param.elements[i]);
  	                    }
  	                }
  	                break;
  	            case syntax_1.Syntax.ObjectPattern:
  	                for (var i = 0; i < param.properties.length; i++) {
  	                    this.checkPatternParam(options, param.properties[i].value);
  	                }
  	                break;
  	            default:
  	                break;
  	        }
  	        options.simple = options.simple && (param instanceof Node.Identifier);
  	    };
  	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
  	        var params = [expr];
  	        var options;
  	        var asyncArrow = false;
  	        switch (expr.type) {
  	            case syntax_1.Syntax.Identifier:
  	                break;
  	            case ArrowParameterPlaceHolder:
  	                params = expr.params;
  	                asyncArrow = expr.async;
  	                break;
  	            default:
  	                return null;
  	        }
  	        options = {
  	            simple: true,
  	            paramSet: {}
  	        };
  	        for (var i = 0; i < params.length; ++i) {
  	            var param = params[i];
  	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
  	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
  	                    if (param.right.argument) {
  	                        this.throwUnexpectedToken(this.lookahead);
  	                    }
  	                    param.right.type = syntax_1.Syntax.Identifier;
  	                    param.right.name = 'yield';
  	                    delete param.right.argument;
  	                    delete param.right.delegate;
  	                }
  	            }
  	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
  	                this.throwUnexpectedToken(this.lookahead);
  	            }
  	            this.checkPatternParam(options, param);
  	            params[i] = param;
  	        }
  	        if (this.context.strict || !this.context.allowYield) {
  	            for (var i = 0; i < params.length; ++i) {
  	                var param = params[i];
  	                if (param.type === syntax_1.Syntax.YieldExpression) {
  	                    this.throwUnexpectedToken(this.lookahead);
  	                }
  	            }
  	        }
  	        if (options.message === messages_1.Messages.StrictParamDupe) {
  	            var token = this.context.strict ? options.stricted : options.firstRestricted;
  	            this.throwUnexpectedToken(token, options.message);
  	        }
  	        return {
  	            simple: options.simple,
  	            params: params,
  	            stricted: options.stricted,
  	            firstRestricted: options.firstRestricted,
  	            message: options.message
  	        };
  	    };
  	    Parser.prototype.parseAssignmentExpression = function () {
  	        var expr;
  	        if (!this.context.allowYield && this.matchKeyword('yield')) {
  	            expr = this.parseYieldExpression();
  	        }
  	        else {
  	            var startToken = this.lookahead;
  	            var token = startToken;
  	            expr = this.parseConditionalExpression();
  	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
  	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
  	                    var arg = this.parsePrimaryExpression();
  	                    this.reinterpretExpressionAsPattern(arg);
  	                    expr = {
  	                        type: ArrowParameterPlaceHolder,
  	                        params: [arg],
  	                        async: true
  	                    };
  	                }
  	            }
  	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
  	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
  	                this.context.isAssignmentTarget = false;
  	                this.context.isBindingElement = false;
  	                var isAsync = expr.async;
  	                var list = this.reinterpretAsCoverFormalsList(expr);
  	                if (list) {
  	                    if (this.hasLineTerminator) {
  	                        this.tolerateUnexpectedToken(this.lookahead);
  	                    }
  	                    this.context.firstCoverInitializedNameError = null;
  	                    var previousStrict = this.context.strict;
  	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
  	                    this.context.allowStrictDirective = list.simple;
  	                    var previousAllowYield = this.context.allowYield;
  	                    var previousAwait = this.context.await;
  	                    this.context.allowYield = true;
  	                    this.context.await = isAsync;
  	                    var node = this.startNode(startToken);
  	                    this.expect('=>');
  	                    var body = void 0;
  	                    if (this.match('{')) {
  	                        var previousAllowIn = this.context.allowIn;
  	                        this.context.allowIn = true;
  	                        body = this.parseFunctionSourceElements();
  	                        this.context.allowIn = previousAllowIn;
  	                    }
  	                    else {
  	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	                    }
  	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
  	                    if (this.context.strict && list.firstRestricted) {
  	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
  	                    }
  	                    if (this.context.strict && list.stricted) {
  	                        this.tolerateUnexpectedToken(list.stricted, list.message);
  	                    }
  	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
  	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
  	                    this.context.strict = previousStrict;
  	                    this.context.allowStrictDirective = previousAllowStrictDirective;
  	                    this.context.allowYield = previousAllowYield;
  	                    this.context.await = previousAwait;
  	                }
  	            }
  	            else {
  	                if (this.matchAssign()) {
  	                    if (!this.context.isAssignmentTarget) {
  	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
  	                    }
  	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
  	                        var id = expr;
  	                        if (this.scanner.isRestrictedWord(id.name)) {
  	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
  	                        }
  	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
  	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
  	                        }
  	                    }
  	                    if (!this.match('=')) {
  	                        this.context.isAssignmentTarget = false;
  	                        this.context.isBindingElement = false;
  	                    }
  	                    else {
  	                        this.reinterpretExpressionAsPattern(expr);
  	                    }
  	                    token = this.nextToken();
  	                    var operator = token.value;
  	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
  	                    this.context.firstCoverInitializedNameError = null;
  	                }
  	            }
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-comma-operator
  	    Parser.prototype.parseExpression = function () {
  	        var startToken = this.lookahead;
  	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	        if (this.match(',')) {
  	            var expressions = [];
  	            expressions.push(expr);
  	            while (this.lookahead.type !== 2 /* EOF */) {
  	                if (!this.match(',')) {
  	                    break;
  	                }
  	                this.nextToken();
  	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
  	            }
  	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-block
  	    Parser.prototype.parseStatementListItem = function () {
  	        var statement;
  	        this.context.isAssignmentTarget = true;
  	        this.context.isBindingElement = true;
  	        if (this.lookahead.type === 4 /* Keyword */) {
  	            switch (this.lookahead.value) {
  	                case 'export':
  	                    if (!this.context.isModule) {
  	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
  	                    }
  	                    statement = this.parseExportDeclaration();
  	                    break;
  	                case 'import':
  	                    if (!this.context.isModule) {
  	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
  	                    }
  	                    statement = this.parseImportDeclaration();
  	                    break;
  	                case 'const':
  	                    statement = this.parseLexicalDeclaration({ inFor: false });
  	                    break;
  	                case 'function':
  	                    statement = this.parseFunctionDeclaration();
  	                    break;
  	                case 'class':
  	                    statement = this.parseClassDeclaration();
  	                    break;
  	                case 'let':
  	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
  	                    break;
  	                default:
  	                    statement = this.parseStatement();
  	                    break;
  	            }
  	        }
  	        else {
  	            statement = this.parseStatement();
  	        }
  	        return statement;
  	    };
  	    Parser.prototype.parseBlock = function () {
  	        var node = this.createNode();
  	        this.expect('{');
  	        var block = [];
  	        while (true) {
  	            if (this.match('}')) {
  	                break;
  	            }
  	            block.push(this.parseStatementListItem());
  	        }
  	        this.expect('}');
  	        return this.finalize(node, new Node.BlockStatement(block));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
  	    Parser.prototype.parseLexicalBinding = function (kind, options) {
  	        var node = this.createNode();
  	        var params = [];
  	        var id = this.parsePattern(params, kind);
  	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
  	            if (this.scanner.isRestrictedWord(id.name)) {
  	                this.tolerateError(messages_1.Messages.StrictVarName);
  	            }
  	        }
  	        var init = null;
  	        if (kind === 'const') {
  	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
  	                if (this.match('=')) {
  	                    this.nextToken();
  	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	                }
  	                else {
  	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
  	                }
  	            }
  	        }
  	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
  	            this.expect('=');
  	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	        }
  	        return this.finalize(node, new Node.VariableDeclarator(id, init));
  	    };
  	    Parser.prototype.parseBindingList = function (kind, options) {
  	        var list = [this.parseLexicalBinding(kind, options)];
  	        while (this.match(',')) {
  	            this.nextToken();
  	            list.push(this.parseLexicalBinding(kind, options));
  	        }
  	        return list;
  	    };
  	    Parser.prototype.isLexicalDeclaration = function () {
  	        var state = this.scanner.saveState();
  	        this.scanner.scanComments();
  	        var next = this.scanner.lex();
  	        this.scanner.restoreState(state);
  	        return (next.type === 3 /* Identifier */) ||
  	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
  	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
  	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
  	            (next.type === 4 /* Keyword */ && next.value === 'yield');
  	    };
  	    Parser.prototype.parseLexicalDeclaration = function (options) {
  	        var node = this.createNode();
  	        var kind = this.nextToken().value;
  	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
  	        var declarations = this.parseBindingList(kind, options);
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
  	    Parser.prototype.parseBindingRestElement = function (params, kind) {
  	        var node = this.createNode();
  	        this.expect('...');
  	        var arg = this.parsePattern(params, kind);
  	        return this.finalize(node, new Node.RestElement(arg));
  	    };
  	    Parser.prototype.parseArrayPattern = function (params, kind) {
  	        var node = this.createNode();
  	        this.expect('[');
  	        var elements = [];
  	        while (!this.match(']')) {
  	            if (this.match(',')) {
  	                this.nextToken();
  	                elements.push(null);
  	            }
  	            else {
  	                if (this.match('...')) {
  	                    elements.push(this.parseBindingRestElement(params, kind));
  	                    break;
  	                }
  	                else {
  	                    elements.push(this.parsePatternWithDefault(params, kind));
  	                }
  	                if (!this.match(']')) {
  	                    this.expect(',');
  	                }
  	            }
  	        }
  	        this.expect(']');
  	        return this.finalize(node, new Node.ArrayPattern(elements));
  	    };
  	    Parser.prototype.parsePropertyPattern = function (params, kind) {
  	        var node = this.createNode();
  	        var computed = false;
  	        var shorthand = false;
  	        var method = false;
  	        var key;
  	        var value;
  	        if (this.lookahead.type === 3 /* Identifier */) {
  	            var keyToken = this.lookahead;
  	            key = this.parseVariableIdentifier();
  	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
  	            if (this.match('=')) {
  	                params.push(keyToken);
  	                shorthand = true;
  	                this.nextToken();
  	                var expr = this.parseAssignmentExpression();
  	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
  	            }
  	            else if (!this.match(':')) {
  	                params.push(keyToken);
  	                shorthand = true;
  	                value = init;
  	            }
  	            else {
  	                this.expect(':');
  	                value = this.parsePatternWithDefault(params, kind);
  	            }
  	        }
  	        else {
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	            this.expect(':');
  	            value = this.parsePatternWithDefault(params, kind);
  	        }
  	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
  	    };
  	    Parser.prototype.parseObjectPattern = function (params, kind) {
  	        var node = this.createNode();
  	        var properties = [];
  	        this.expect('{');
  	        while (!this.match('}')) {
  	            properties.push(this.parsePropertyPattern(params, kind));
  	            if (!this.match('}')) {
  	                this.expect(',');
  	            }
  	        }
  	        this.expect('}');
  	        return this.finalize(node, new Node.ObjectPattern(properties));
  	    };
  	    Parser.prototype.parsePattern = function (params, kind) {
  	        var pattern;
  	        if (this.match('[')) {
  	            pattern = this.parseArrayPattern(params, kind);
  	        }
  	        else if (this.match('{')) {
  	            pattern = this.parseObjectPattern(params, kind);
  	        }
  	        else {
  	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
  	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
  	            }
  	            params.push(this.lookahead);
  	            pattern = this.parseVariableIdentifier(kind);
  	        }
  	        return pattern;
  	    };
  	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
  	        var startToken = this.lookahead;
  	        var pattern = this.parsePattern(params, kind);
  	        if (this.match('=')) {
  	            this.nextToken();
  	            var previousAllowYield = this.context.allowYield;
  	            this.context.allowYield = true;
  	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	            this.context.allowYield = previousAllowYield;
  	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
  	        }
  	        return pattern;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-variable-statement
  	    Parser.prototype.parseVariableIdentifier = function (kind) {
  	        var node = this.createNode();
  	        var token = this.nextToken();
  	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
  	            if (this.context.strict) {
  	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
  	            }
  	            else if (!this.context.allowYield) {
  	                this.throwUnexpectedToken(token);
  	            }
  	        }
  	        else if (token.type !== 3 /* Identifier */) {
  	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
  	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
  	            }
  	            else {
  	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
  	                    this.throwUnexpectedToken(token);
  	                }
  	            }
  	        }
  	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
  	            this.tolerateUnexpectedToken(token);
  	        }
  	        return this.finalize(node, new Node.Identifier(token.value));
  	    };
  	    Parser.prototype.parseVariableDeclaration = function (options) {
  	        var node = this.createNode();
  	        var params = [];
  	        var id = this.parsePattern(params, 'var');
  	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
  	            if (this.scanner.isRestrictedWord(id.name)) {
  	                this.tolerateError(messages_1.Messages.StrictVarName);
  	            }
  	        }
  	        var init = null;
  	        if (this.match('=')) {
  	            this.nextToken();
  	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	        }
  	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
  	            this.expect('=');
  	        }
  	        return this.finalize(node, new Node.VariableDeclarator(id, init));
  	    };
  	    Parser.prototype.parseVariableDeclarationList = function (options) {
  	        var opt = { inFor: options.inFor };
  	        var list = [];
  	        list.push(this.parseVariableDeclaration(opt));
  	        while (this.match(',')) {
  	            this.nextToken();
  	            list.push(this.parseVariableDeclaration(opt));
  	        }
  	        return list;
  	    };
  	    Parser.prototype.parseVariableStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('var');
  	        var declarations = this.parseVariableDeclarationList({ inFor: false });
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-empty-statement
  	    Parser.prototype.parseEmptyStatement = function () {
  	        var node = this.createNode();
  	        this.expect(';');
  	        return this.finalize(node, new Node.EmptyStatement());
  	    };
  	    // https://tc39.github.io/ecma262/#sec-expression-statement
  	    Parser.prototype.parseExpressionStatement = function () {
  	        var node = this.createNode();
  	        var expr = this.parseExpression();
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.ExpressionStatement(expr));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-if-statement
  	    Parser.prototype.parseIfClause = function () {
  	        if (this.context.strict && this.matchKeyword('function')) {
  	            this.tolerateError(messages_1.Messages.StrictFunction);
  	        }
  	        return this.parseStatement();
  	    };
  	    Parser.prototype.parseIfStatement = function () {
  	        var node = this.createNode();
  	        var consequent;
  	        var alternate = null;
  	        this.expectKeyword('if');
  	        this.expect('(');
  	        var test = this.parseExpression();
  	        if (!this.match(')') && this.config.tolerant) {
  	            this.tolerateUnexpectedToken(this.nextToken());
  	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
  	        }
  	        else {
  	            this.expect(')');
  	            consequent = this.parseIfClause();
  	            if (this.matchKeyword('else')) {
  	                this.nextToken();
  	                alternate = this.parseIfClause();
  	            }
  	        }
  	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-do-while-statement
  	    Parser.prototype.parseDoWhileStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('do');
  	        var previousInIteration = this.context.inIteration;
  	        this.context.inIteration = true;
  	        var body = this.parseStatement();
  	        this.context.inIteration = previousInIteration;
  	        this.expectKeyword('while');
  	        this.expect('(');
  	        var test = this.parseExpression();
  	        if (!this.match(')') && this.config.tolerant) {
  	            this.tolerateUnexpectedToken(this.nextToken());
  	        }
  	        else {
  	            this.expect(')');
  	            if (this.match(';')) {
  	                this.nextToken();
  	            }
  	        }
  	        return this.finalize(node, new Node.DoWhileStatement(body, test));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-while-statement
  	    Parser.prototype.parseWhileStatement = function () {
  	        var node = this.createNode();
  	        var body;
  	        this.expectKeyword('while');
  	        this.expect('(');
  	        var test = this.parseExpression();
  	        if (!this.match(')') && this.config.tolerant) {
  	            this.tolerateUnexpectedToken(this.nextToken());
  	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
  	        }
  	        else {
  	            this.expect(')');
  	            var previousInIteration = this.context.inIteration;
  	            this.context.inIteration = true;
  	            body = this.parseStatement();
  	            this.context.inIteration = previousInIteration;
  	        }
  	        return this.finalize(node, new Node.WhileStatement(test, body));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-for-statement
  	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
  	    Parser.prototype.parseForStatement = function () {
  	        var init = null;
  	        var test = null;
  	        var update = null;
  	        var forIn = true;
  	        var left, right;
  	        var node = this.createNode();
  	        this.expectKeyword('for');
  	        this.expect('(');
  	        if (this.match(';')) {
  	            this.nextToken();
  	        }
  	        else {
  	            if (this.matchKeyword('var')) {
  	                init = this.createNode();
  	                this.nextToken();
  	                var previousAllowIn = this.context.allowIn;
  	                this.context.allowIn = false;
  	                var declarations = this.parseVariableDeclarationList({ inFor: true });
  	                this.context.allowIn = previousAllowIn;
  	                if (declarations.length === 1 && this.matchKeyword('in')) {
  	                    var decl = declarations[0];
  	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
  	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
  	                    }
  	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
  	                    this.nextToken();
  	                    left = init;
  	                    right = this.parseExpression();
  	                    init = null;
  	                }
  	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
  	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
  	                    this.nextToken();
  	                    left = init;
  	                    right = this.parseAssignmentExpression();
  	                    init = null;
  	                    forIn = false;
  	                }
  	                else {
  	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
  	                    this.expect(';');
  	                }
  	            }
  	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
  	                init = this.createNode();
  	                var kind = this.nextToken().value;
  	                if (!this.context.strict && this.lookahead.value === 'in') {
  	                    init = this.finalize(init, new Node.Identifier(kind));
  	                    this.nextToken();
  	                    left = init;
  	                    right = this.parseExpression();
  	                    init = null;
  	                }
  	                else {
  	                    var previousAllowIn = this.context.allowIn;
  	                    this.context.allowIn = false;
  	                    var declarations = this.parseBindingList(kind, { inFor: true });
  	                    this.context.allowIn = previousAllowIn;
  	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
  	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
  	                        this.nextToken();
  	                        left = init;
  	                        right = this.parseExpression();
  	                        init = null;
  	                    }
  	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
  	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
  	                        this.nextToken();
  	                        left = init;
  	                        right = this.parseAssignmentExpression();
  	                        init = null;
  	                        forIn = false;
  	                    }
  	                    else {
  	                        this.consumeSemicolon();
  	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
  	                    }
  	                }
  	            }
  	            else {
  	                var initStartToken = this.lookahead;
  	                var previousAllowIn = this.context.allowIn;
  	                this.context.allowIn = false;
  	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
  	                this.context.allowIn = previousAllowIn;
  	                if (this.matchKeyword('in')) {
  	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
  	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
  	                    }
  	                    this.nextToken();
  	                    this.reinterpretExpressionAsPattern(init);
  	                    left = init;
  	                    right = this.parseExpression();
  	                    init = null;
  	                }
  	                else if (this.matchContextualKeyword('of')) {
  	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
  	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
  	                    }
  	                    this.nextToken();
  	                    this.reinterpretExpressionAsPattern(init);
  	                    left = init;
  	                    right = this.parseAssignmentExpression();
  	                    init = null;
  	                    forIn = false;
  	                }
  	                else {
  	                    if (this.match(',')) {
  	                        var initSeq = [init];
  	                        while (this.match(',')) {
  	                            this.nextToken();
  	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
  	                        }
  	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
  	                    }
  	                    this.expect(';');
  	                }
  	            }
  	        }
  	        if (typeof left === 'undefined') {
  	            if (!this.match(';')) {
  	                test = this.parseExpression();
  	            }
  	            this.expect(';');
  	            if (!this.match(')')) {
  	                update = this.parseExpression();
  	            }
  	        }
  	        var body;
  	        if (!this.match(')') && this.config.tolerant) {
  	            this.tolerateUnexpectedToken(this.nextToken());
  	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
  	        }
  	        else {
  	            this.expect(')');
  	            var previousInIteration = this.context.inIteration;
  	            this.context.inIteration = true;
  	            body = this.isolateCoverGrammar(this.parseStatement);
  	            this.context.inIteration = previousInIteration;
  	        }
  	        return (typeof left === 'undefined') ?
  	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
  	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
  	                this.finalize(node, new Node.ForOfStatement(left, right, body));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-continue-statement
  	    Parser.prototype.parseContinueStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('continue');
  	        var label = null;
  	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
  	            var id = this.parseVariableIdentifier();
  	            label = id;
  	            var key = '$' + id.name;
  	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
  	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
  	            }
  	        }
  	        this.consumeSemicolon();
  	        if (label === null && !this.context.inIteration) {
  	            this.throwError(messages_1.Messages.IllegalContinue);
  	        }
  	        return this.finalize(node, new Node.ContinueStatement(label));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-break-statement
  	    Parser.prototype.parseBreakStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('break');
  	        var label = null;
  	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
  	            var id = this.parseVariableIdentifier();
  	            var key = '$' + id.name;
  	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
  	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
  	            }
  	            label = id;
  	        }
  	        this.consumeSemicolon();
  	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
  	            this.throwError(messages_1.Messages.IllegalBreak);
  	        }
  	        return this.finalize(node, new Node.BreakStatement(label));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-return-statement
  	    Parser.prototype.parseReturnStatement = function () {
  	        if (!this.context.inFunctionBody) {
  	            this.tolerateError(messages_1.Messages.IllegalReturn);
  	        }
  	        var node = this.createNode();
  	        this.expectKeyword('return');
  	        var hasArgument = (!this.match(';') && !this.match('}') &&
  	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */) ||
  	            this.lookahead.type === 8 /* StringLiteral */ ||
  	            this.lookahead.type === 10 /* Template */;
  	        var argument = hasArgument ? this.parseExpression() : null;
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.ReturnStatement(argument));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-with-statement
  	    Parser.prototype.parseWithStatement = function () {
  	        if (this.context.strict) {
  	            this.tolerateError(messages_1.Messages.StrictModeWith);
  	        }
  	        var node = this.createNode();
  	        var body;
  	        this.expectKeyword('with');
  	        this.expect('(');
  	        var object = this.parseExpression();
  	        if (!this.match(')') && this.config.tolerant) {
  	            this.tolerateUnexpectedToken(this.nextToken());
  	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
  	        }
  	        else {
  	            this.expect(')');
  	            body = this.parseStatement();
  	        }
  	        return this.finalize(node, new Node.WithStatement(object, body));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-switch-statement
  	    Parser.prototype.parseSwitchCase = function () {
  	        var node = this.createNode();
  	        var test;
  	        if (this.matchKeyword('default')) {
  	            this.nextToken();
  	            test = null;
  	        }
  	        else {
  	            this.expectKeyword('case');
  	            test = this.parseExpression();
  	        }
  	        this.expect(':');
  	        var consequent = [];
  	        while (true) {
  	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
  	                break;
  	            }
  	            consequent.push(this.parseStatementListItem());
  	        }
  	        return this.finalize(node, new Node.SwitchCase(test, consequent));
  	    };
  	    Parser.prototype.parseSwitchStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('switch');
  	        this.expect('(');
  	        var discriminant = this.parseExpression();
  	        this.expect(')');
  	        var previousInSwitch = this.context.inSwitch;
  	        this.context.inSwitch = true;
  	        var cases = [];
  	        var defaultFound = false;
  	        this.expect('{');
  	        while (true) {
  	            if (this.match('}')) {
  	                break;
  	            }
  	            var clause = this.parseSwitchCase();
  	            if (clause.test === null) {
  	                if (defaultFound) {
  	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
  	                }
  	                defaultFound = true;
  	            }
  	            cases.push(clause);
  	        }
  	        this.expect('}');
  	        this.context.inSwitch = previousInSwitch;
  	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-labelled-statements
  	    Parser.prototype.parseLabelledStatement = function () {
  	        var node = this.createNode();
  	        var expr = this.parseExpression();
  	        var statement;
  	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
  	            this.nextToken();
  	            var id = expr;
  	            var key = '$' + id.name;
  	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
  	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
  	            }
  	            this.context.labelSet[key] = true;
  	            var body = void 0;
  	            if (this.matchKeyword('class')) {
  	                this.tolerateUnexpectedToken(this.lookahead);
  	                body = this.parseClassDeclaration();
  	            }
  	            else if (this.matchKeyword('function')) {
  	                var token = this.lookahead;
  	                var declaration = this.parseFunctionDeclaration();
  	                if (this.context.strict) {
  	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
  	                }
  	                else if (declaration.generator) {
  	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
  	                }
  	                body = declaration;
  	            }
  	            else {
  	                body = this.parseStatement();
  	            }
  	            delete this.context.labelSet[key];
  	            statement = new Node.LabeledStatement(id, body);
  	        }
  	        else {
  	            this.consumeSemicolon();
  	            statement = new Node.ExpressionStatement(expr);
  	        }
  	        return this.finalize(node, statement);
  	    };
  	    // https://tc39.github.io/ecma262/#sec-throw-statement
  	    Parser.prototype.parseThrowStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('throw');
  	        if (this.hasLineTerminator) {
  	            this.throwError(messages_1.Messages.NewlineAfterThrow);
  	        }
  	        var argument = this.parseExpression();
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.ThrowStatement(argument));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-try-statement
  	    Parser.prototype.parseCatchClause = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('catch');
  	        this.expect('(');
  	        if (this.match(')')) {
  	            this.throwUnexpectedToken(this.lookahead);
  	        }
  	        var params = [];
  	        var param = this.parsePattern(params);
  	        var paramMap = {};
  	        for (var i = 0; i < params.length; i++) {
  	            var key = '$' + params[i].value;
  	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
  	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
  	            }
  	            paramMap[key] = true;
  	        }
  	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
  	            if (this.scanner.isRestrictedWord(param.name)) {
  	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
  	            }
  	        }
  	        this.expect(')');
  	        var body = this.parseBlock();
  	        return this.finalize(node, new Node.CatchClause(param, body));
  	    };
  	    Parser.prototype.parseFinallyClause = function () {
  	        this.expectKeyword('finally');
  	        return this.parseBlock();
  	    };
  	    Parser.prototype.parseTryStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('try');
  	        var block = this.parseBlock();
  	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
  	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
  	        if (!handler && !finalizer) {
  	            this.throwError(messages_1.Messages.NoCatchOrFinally);
  	        }
  	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-debugger-statement
  	    Parser.prototype.parseDebuggerStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('debugger');
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.DebuggerStatement());
  	    };
  	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
  	    Parser.prototype.parseStatement = function () {
  	        var statement;
  	        switch (this.lookahead.type) {
  	            case 1 /* BooleanLiteral */:
  	            case 5 /* NullLiteral */:
  	            case 6 /* NumericLiteral */:
  	            case 8 /* StringLiteral */:
  	            case 10 /* Template */:
  	            case 9 /* RegularExpression */:
  	                statement = this.parseExpressionStatement();
  	                break;
  	            case 7 /* Punctuator */:
  	                var value = this.lookahead.value;
  	                if (value === '{') {
  	                    statement = this.parseBlock();
  	                }
  	                else if (value === '(') {
  	                    statement = this.parseExpressionStatement();
  	                }
  	                else if (value === ';') {
  	                    statement = this.parseEmptyStatement();
  	                }
  	                else {
  	                    statement = this.parseExpressionStatement();
  	                }
  	                break;
  	            case 3 /* Identifier */:
  	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
  	                break;
  	            case 4 /* Keyword */:
  	                switch (this.lookahead.value) {
  	                    case 'break':
  	                        statement = this.parseBreakStatement();
  	                        break;
  	                    case 'continue':
  	                        statement = this.parseContinueStatement();
  	                        break;
  	                    case 'debugger':
  	                        statement = this.parseDebuggerStatement();
  	                        break;
  	                    case 'do':
  	                        statement = this.parseDoWhileStatement();
  	                        break;
  	                    case 'for':
  	                        statement = this.parseForStatement();
  	                        break;
  	                    case 'function':
  	                        statement = this.parseFunctionDeclaration();
  	                        break;
  	                    case 'if':
  	                        statement = this.parseIfStatement();
  	                        break;
  	                    case 'return':
  	                        statement = this.parseReturnStatement();
  	                        break;
  	                    case 'switch':
  	                        statement = this.parseSwitchStatement();
  	                        break;
  	                    case 'throw':
  	                        statement = this.parseThrowStatement();
  	                        break;
  	                    case 'try':
  	                        statement = this.parseTryStatement();
  	                        break;
  	                    case 'var':
  	                        statement = this.parseVariableStatement();
  	                        break;
  	                    case 'while':
  	                        statement = this.parseWhileStatement();
  	                        break;
  	                    case 'with':
  	                        statement = this.parseWithStatement();
  	                        break;
  	                    default:
  	                        statement = this.parseExpressionStatement();
  	                        break;
  	                }
  	                break;
  	            default:
  	                statement = this.throwUnexpectedToken(this.lookahead);
  	        }
  	        return statement;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-function-definitions
  	    Parser.prototype.parseFunctionSourceElements = function () {
  	        var node = this.createNode();
  	        this.expect('{');
  	        var body = this.parseDirectivePrologues();
  	        var previousLabelSet = this.context.labelSet;
  	        var previousInIteration = this.context.inIteration;
  	        var previousInSwitch = this.context.inSwitch;
  	        var previousInFunctionBody = this.context.inFunctionBody;
  	        this.context.labelSet = {};
  	        this.context.inIteration = false;
  	        this.context.inSwitch = false;
  	        this.context.inFunctionBody = true;
  	        while (this.lookahead.type !== 2 /* EOF */) {
  	            if (this.match('}')) {
  	                break;
  	            }
  	            body.push(this.parseStatementListItem());
  	        }
  	        this.expect('}');
  	        this.context.labelSet = previousLabelSet;
  	        this.context.inIteration = previousInIteration;
  	        this.context.inSwitch = previousInSwitch;
  	        this.context.inFunctionBody = previousInFunctionBody;
  	        return this.finalize(node, new Node.BlockStatement(body));
  	    };
  	    Parser.prototype.validateParam = function (options, param, name) {
  	        var key = '$' + name;
  	        if (this.context.strict) {
  	            if (this.scanner.isRestrictedWord(name)) {
  	                options.stricted = param;
  	                options.message = messages_1.Messages.StrictParamName;
  	            }
  	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
  	                options.stricted = param;
  	                options.message = messages_1.Messages.StrictParamDupe;
  	            }
  	        }
  	        else if (!options.firstRestricted) {
  	            if (this.scanner.isRestrictedWord(name)) {
  	                options.firstRestricted = param;
  	                options.message = messages_1.Messages.StrictParamName;
  	            }
  	            else if (this.scanner.isStrictModeReservedWord(name)) {
  	                options.firstRestricted = param;
  	                options.message = messages_1.Messages.StrictReservedWord;
  	            }
  	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
  	                options.stricted = param;
  	                options.message = messages_1.Messages.StrictParamDupe;
  	            }
  	        }
  	        /* istanbul ignore next */
  	        if (typeof Object.defineProperty === 'function') {
  	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
  	        }
  	        else {
  	            options.paramSet[key] = true;
  	        }
  	    };
  	    Parser.prototype.parseRestElement = function (params) {
  	        var node = this.createNode();
  	        this.expect('...');
  	        var arg = this.parsePattern(params);
  	        if (this.match('=')) {
  	            this.throwError(messages_1.Messages.DefaultRestParameter);
  	        }
  	        if (!this.match(')')) {
  	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
  	        }
  	        return this.finalize(node, new Node.RestElement(arg));
  	    };
  	    Parser.prototype.parseFormalParameter = function (options) {
  	        var params = [];
  	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
  	        for (var i = 0; i < params.length; i++) {
  	            this.validateParam(options, params[i], params[i].value);
  	        }
  	        options.simple = options.simple && (param instanceof Node.Identifier);
  	        options.params.push(param);
  	    };
  	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
  	        var options;
  	        options = {
  	            simple: true,
  	            params: [],
  	            firstRestricted: firstRestricted
  	        };
  	        this.expect('(');
  	        if (!this.match(')')) {
  	            options.paramSet = {};
  	            while (this.lookahead.type !== 2 /* EOF */) {
  	                this.parseFormalParameter(options);
  	                if (this.match(')')) {
  	                    break;
  	                }
  	                this.expect(',');
  	                if (this.match(')')) {
  	                    break;
  	                }
  	            }
  	        }
  	        this.expect(')');
  	        return {
  	            simple: options.simple,
  	            params: options.params,
  	            stricted: options.stricted,
  	            firstRestricted: options.firstRestricted,
  	            message: options.message
  	        };
  	    };
  	    Parser.prototype.matchAsyncFunction = function () {
  	        var match = this.matchContextualKeyword('async');
  	        if (match) {
  	            var state = this.scanner.saveState();
  	            this.scanner.scanComments();
  	            var next = this.scanner.lex();
  	            this.scanner.restoreState(state);
  	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
  	        }
  	        return match;
  	    };
  	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
  	        var node = this.createNode();
  	        var isAsync = this.matchContextualKeyword('async');
  	        if (isAsync) {
  	            this.nextToken();
  	        }
  	        this.expectKeyword('function');
  	        var isGenerator = isAsync ? false : this.match('*');
  	        if (isGenerator) {
  	            this.nextToken();
  	        }
  	        var message;
  	        var id = null;
  	        var firstRestricted = null;
  	        if (!identifierIsOptional || !this.match('(')) {
  	            var token = this.lookahead;
  	            id = this.parseVariableIdentifier();
  	            if (this.context.strict) {
  	                if (this.scanner.isRestrictedWord(token.value)) {
  	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
  	                }
  	            }
  	            else {
  	                if (this.scanner.isRestrictedWord(token.value)) {
  	                    firstRestricted = token;
  	                    message = messages_1.Messages.StrictFunctionName;
  	                }
  	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
  	                    firstRestricted = token;
  	                    message = messages_1.Messages.StrictReservedWord;
  	                }
  	            }
  	        }
  	        var previousAllowAwait = this.context.await;
  	        var previousAllowYield = this.context.allowYield;
  	        this.context.await = isAsync;
  	        this.context.allowYield = !isGenerator;
  	        var formalParameters = this.parseFormalParameters(firstRestricted);
  	        var params = formalParameters.params;
  	        var stricted = formalParameters.stricted;
  	        firstRestricted = formalParameters.firstRestricted;
  	        if (formalParameters.message) {
  	            message = formalParameters.message;
  	        }
  	        var previousStrict = this.context.strict;
  	        var previousAllowStrictDirective = this.context.allowStrictDirective;
  	        this.context.allowStrictDirective = formalParameters.simple;
  	        var body = this.parseFunctionSourceElements();
  	        if (this.context.strict && firstRestricted) {
  	            this.throwUnexpectedToken(firstRestricted, message);
  	        }
  	        if (this.context.strict && stricted) {
  	            this.tolerateUnexpectedToken(stricted, message);
  	        }
  	        this.context.strict = previousStrict;
  	        this.context.allowStrictDirective = previousAllowStrictDirective;
  	        this.context.await = previousAllowAwait;
  	        this.context.allowYield = previousAllowYield;
  	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
  	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
  	    };
  	    Parser.prototype.parseFunctionExpression = function () {
  	        var node = this.createNode();
  	        var isAsync = this.matchContextualKeyword('async');
  	        if (isAsync) {
  	            this.nextToken();
  	        }
  	        this.expectKeyword('function');
  	        var isGenerator = isAsync ? false : this.match('*');
  	        if (isGenerator) {
  	            this.nextToken();
  	        }
  	        var message;
  	        var id = null;
  	        var firstRestricted;
  	        var previousAllowAwait = this.context.await;
  	        var previousAllowYield = this.context.allowYield;
  	        this.context.await = isAsync;
  	        this.context.allowYield = !isGenerator;
  	        if (!this.match('(')) {
  	            var token = this.lookahead;
  	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
  	            if (this.context.strict) {
  	                if (this.scanner.isRestrictedWord(token.value)) {
  	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
  	                }
  	            }
  	            else {
  	                if (this.scanner.isRestrictedWord(token.value)) {
  	                    firstRestricted = token;
  	                    message = messages_1.Messages.StrictFunctionName;
  	                }
  	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
  	                    firstRestricted = token;
  	                    message = messages_1.Messages.StrictReservedWord;
  	                }
  	            }
  	        }
  	        var formalParameters = this.parseFormalParameters(firstRestricted);
  	        var params = formalParameters.params;
  	        var stricted = formalParameters.stricted;
  	        firstRestricted = formalParameters.firstRestricted;
  	        if (formalParameters.message) {
  	            message = formalParameters.message;
  	        }
  	        var previousStrict = this.context.strict;
  	        var previousAllowStrictDirective = this.context.allowStrictDirective;
  	        this.context.allowStrictDirective = formalParameters.simple;
  	        var body = this.parseFunctionSourceElements();
  	        if (this.context.strict && firstRestricted) {
  	            this.throwUnexpectedToken(firstRestricted, message);
  	        }
  	        if (this.context.strict && stricted) {
  	            this.tolerateUnexpectedToken(stricted, message);
  	        }
  	        this.context.strict = previousStrict;
  	        this.context.allowStrictDirective = previousAllowStrictDirective;
  	        this.context.await = previousAllowAwait;
  	        this.context.allowYield = previousAllowYield;
  	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
  	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
  	    Parser.prototype.parseDirective = function () {
  	        var token = this.lookahead;
  	        var node = this.createNode();
  	        var expr = this.parseExpression();
  	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
  	        this.consumeSemicolon();
  	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
  	    };
  	    Parser.prototype.parseDirectivePrologues = function () {
  	        var firstRestricted = null;
  	        var body = [];
  	        while (true) {
  	            var token = this.lookahead;
  	            if (token.type !== 8 /* StringLiteral */) {
  	                break;
  	            }
  	            var statement = this.parseDirective();
  	            body.push(statement);
  	            var directive = statement.directive;
  	            if (typeof directive !== 'string') {
  	                break;
  	            }
  	            if (directive === 'use strict') {
  	                this.context.strict = true;
  	                if (firstRestricted) {
  	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
  	                }
  	                if (!this.context.allowStrictDirective) {
  	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
  	                }
  	            }
  	            else {
  	                if (!firstRestricted && token.octal) {
  	                    firstRestricted = token;
  	                }
  	            }
  	        }
  	        return body;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-method-definitions
  	    Parser.prototype.qualifiedPropertyName = function (token) {
  	        switch (token.type) {
  	            case 3 /* Identifier */:
  	            case 8 /* StringLiteral */:
  	            case 1 /* BooleanLiteral */:
  	            case 5 /* NullLiteral */:
  	            case 6 /* NumericLiteral */:
  	            case 4 /* Keyword */:
  	                return true;
  	            case 7 /* Punctuator */:
  	                return token.value === '[';
  	            default:
  	                break;
  	        }
  	        return false;
  	    };
  	    Parser.prototype.parseGetterMethod = function () {
  	        var node = this.createNode();
  	        var isGenerator = false;
  	        var previousAllowYield = this.context.allowYield;
  	        this.context.allowYield = !isGenerator;
  	        var formalParameters = this.parseFormalParameters();
  	        if (formalParameters.params.length > 0) {
  	            this.tolerateError(messages_1.Messages.BadGetterArity);
  	        }
  	        var method = this.parsePropertyMethod(formalParameters);
  	        this.context.allowYield = previousAllowYield;
  	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
  	    };
  	    Parser.prototype.parseSetterMethod = function () {
  	        var node = this.createNode();
  	        var isGenerator = false;
  	        var previousAllowYield = this.context.allowYield;
  	        this.context.allowYield = !isGenerator;
  	        var formalParameters = this.parseFormalParameters();
  	        if (formalParameters.params.length !== 1) {
  	            this.tolerateError(messages_1.Messages.BadSetterArity);
  	        }
  	        else if (formalParameters.params[0] instanceof Node.RestElement) {
  	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
  	        }
  	        var method = this.parsePropertyMethod(formalParameters);
  	        this.context.allowYield = previousAllowYield;
  	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
  	    };
  	    Parser.prototype.parseGeneratorMethod = function () {
  	        var node = this.createNode();
  	        var isGenerator = true;
  	        var previousAllowYield = this.context.allowYield;
  	        this.context.allowYield = true;
  	        var params = this.parseFormalParameters();
  	        this.context.allowYield = false;
  	        var method = this.parsePropertyMethod(params);
  	        this.context.allowYield = previousAllowYield;
  	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
  	    Parser.prototype.isStartOfExpression = function () {
  	        var start = true;
  	        var value = this.lookahead.value;
  	        switch (this.lookahead.type) {
  	            case 7 /* Punctuator */:
  	                start = (value === '[') || (value === '(') || (value === '{') ||
  	                    (value === '+') || (value === '-') ||
  	                    (value === '!') || (value === '~') ||
  	                    (value === '++') || (value === '--') ||
  	                    (value === '/') || (value === '/='); // regular expression literal
  	                break;
  	            case 4 /* Keyword */:
  	                start = (value === 'class') || (value === 'delete') ||
  	                    (value === 'function') || (value === 'let') || (value === 'new') ||
  	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
  	                    (value === 'void') || (value === 'yield');
  	                break;
  	            default:
  	                break;
  	        }
  	        return start;
  	    };
  	    Parser.prototype.parseYieldExpression = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('yield');
  	        var argument = null;
  	        var delegate = false;
  	        if (!this.hasLineTerminator) {
  	            var previousAllowYield = this.context.allowYield;
  	            this.context.allowYield = false;
  	            delegate = this.match('*');
  	            if (delegate) {
  	                this.nextToken();
  	                argument = this.parseAssignmentExpression();
  	            }
  	            else if (this.isStartOfExpression()) {
  	                argument = this.parseAssignmentExpression();
  	            }
  	            this.context.allowYield = previousAllowYield;
  	        }
  	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-class-definitions
  	    Parser.prototype.parseClassElement = function (hasConstructor) {
  	        var token = this.lookahead;
  	        var node = this.createNode();
  	        var kind = '';
  	        var key = null;
  	        var value = null;
  	        var computed = false;
  	        var method = false;
  	        var isStatic = false;
  	        var isAsync = false;
  	        if (this.match('*')) {
  	            this.nextToken();
  	        }
  	        else {
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	            var id = key;
  	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
  	                token = this.lookahead;
  	                isStatic = true;
  	                computed = this.match('[');
  	                if (this.match('*')) {
  	                    this.nextToken();
  	                }
  	                else {
  	                    key = this.parseObjectPropertyKey();
  	                }
  	            }
  	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
  	                var punctuator = this.lookahead.value;
  	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
  	                    isAsync = true;
  	                    token = this.lookahead;
  	                    key = this.parseObjectPropertyKey();
  	                    if (token.type === 3 /* Identifier */ && token.value === 'constructor') {
  	                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
  	                    }
  	                }
  	            }
  	        }
  	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
  	        if (token.type === 3 /* Identifier */) {
  	            if (token.value === 'get' && lookaheadPropertyKey) {
  	                kind = 'get';
  	                computed = this.match('[');
  	                key = this.parseObjectPropertyKey();
  	                this.context.allowYield = false;
  	                value = this.parseGetterMethod();
  	            }
  	            else if (token.value === 'set' && lookaheadPropertyKey) {
  	                kind = 'set';
  	                computed = this.match('[');
  	                key = this.parseObjectPropertyKey();
  	                value = this.parseSetterMethod();
  	            }
  	        }
  	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
  	            kind = 'init';
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	            value = this.parseGeneratorMethod();
  	            method = true;
  	        }
  	        if (!kind && key && this.match('(')) {
  	            kind = 'init';
  	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
  	            method = true;
  	        }
  	        if (!kind) {
  	            this.throwUnexpectedToken(this.lookahead);
  	        }
  	        if (kind === 'init') {
  	            kind = 'method';
  	        }
  	        if (!computed) {
  	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
  	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
  	            }
  	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
  	                if (kind !== 'method' || !method || (value && value.generator)) {
  	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
  	                }
  	                if (hasConstructor.value) {
  	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
  	                }
  	                else {
  	                    hasConstructor.value = true;
  	                }
  	                kind = 'constructor';
  	            }
  	        }
  	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
  	    };
  	    Parser.prototype.parseClassElementList = function () {
  	        var body = [];
  	        var hasConstructor = { value: false };
  	        this.expect('{');
  	        while (!this.match('}')) {
  	            if (this.match(';')) {
  	                this.nextToken();
  	            }
  	            else {
  	                body.push(this.parseClassElement(hasConstructor));
  	            }
  	        }
  	        this.expect('}');
  	        return body;
  	    };
  	    Parser.prototype.parseClassBody = function () {
  	        var node = this.createNode();
  	        var elementList = this.parseClassElementList();
  	        return this.finalize(node, new Node.ClassBody(elementList));
  	    };
  	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
  	        var node = this.createNode();
  	        var previousStrict = this.context.strict;
  	        this.context.strict = true;
  	        this.expectKeyword('class');
  	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
  	        var superClass = null;
  	        if (this.matchKeyword('extends')) {
  	            this.nextToken();
  	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
  	        }
  	        var classBody = this.parseClassBody();
  	        this.context.strict = previousStrict;
  	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
  	    };
  	    Parser.prototype.parseClassExpression = function () {
  	        var node = this.createNode();
  	        var previousStrict = this.context.strict;
  	        this.context.strict = true;
  	        this.expectKeyword('class');
  	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
  	        var superClass = null;
  	        if (this.matchKeyword('extends')) {
  	            this.nextToken();
  	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
  	        }
  	        var classBody = this.parseClassBody();
  	        this.context.strict = previousStrict;
  	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-scripts
  	    // https://tc39.github.io/ecma262/#sec-modules
  	    Parser.prototype.parseModule = function () {
  	        this.context.strict = true;
  	        this.context.isModule = true;
  	        this.scanner.isModule = true;
  	        var node = this.createNode();
  	        var body = this.parseDirectivePrologues();
  	        while (this.lookahead.type !== 2 /* EOF */) {
  	            body.push(this.parseStatementListItem());
  	        }
  	        return this.finalize(node, new Node.Module(body));
  	    };
  	    Parser.prototype.parseScript = function () {
  	        var node = this.createNode();
  	        var body = this.parseDirectivePrologues();
  	        while (this.lookahead.type !== 2 /* EOF */) {
  	            body.push(this.parseStatementListItem());
  	        }
  	        return this.finalize(node, new Node.Script(body));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-imports
  	    Parser.prototype.parseModuleSpecifier = function () {
  	        var node = this.createNode();
  	        if (this.lookahead.type !== 8 /* StringLiteral */) {
  	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
  	        }
  	        var token = this.nextToken();
  	        var raw = this.getTokenRaw(token);
  	        return this.finalize(node, new Node.Literal(token.value, raw));
  	    };
  	    // import {<foo as bar>} ...;
  	    Parser.prototype.parseImportSpecifier = function () {
  	        var node = this.createNode();
  	        var imported;
  	        var local;
  	        if (this.lookahead.type === 3 /* Identifier */) {
  	            imported = this.parseVariableIdentifier();
  	            local = imported;
  	            if (this.matchContextualKeyword('as')) {
  	                this.nextToken();
  	                local = this.parseVariableIdentifier();
  	            }
  	        }
  	        else {
  	            imported = this.parseIdentifierName();
  	            local = imported;
  	            if (this.matchContextualKeyword('as')) {
  	                this.nextToken();
  	                local = this.parseVariableIdentifier();
  	            }
  	            else {
  	                this.throwUnexpectedToken(this.nextToken());
  	            }
  	        }
  	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
  	    };
  	    // {foo, bar as bas}
  	    Parser.prototype.parseNamedImports = function () {
  	        this.expect('{');
  	        var specifiers = [];
  	        while (!this.match('}')) {
  	            specifiers.push(this.parseImportSpecifier());
  	            if (!this.match('}')) {
  	                this.expect(',');
  	            }
  	        }
  	        this.expect('}');
  	        return specifiers;
  	    };
  	    // import <foo> ...;
  	    Parser.prototype.parseImportDefaultSpecifier = function () {
  	        var node = this.createNode();
  	        var local = this.parseIdentifierName();
  	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
  	    };
  	    // import <* as foo> ...;
  	    Parser.prototype.parseImportNamespaceSpecifier = function () {
  	        var node = this.createNode();
  	        this.expect('*');
  	        if (!this.matchContextualKeyword('as')) {
  	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
  	        }
  	        this.nextToken();
  	        var local = this.parseIdentifierName();
  	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
  	    };
  	    Parser.prototype.parseImportDeclaration = function () {
  	        if (this.context.inFunctionBody) {
  	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
  	        }
  	        var node = this.createNode();
  	        this.expectKeyword('import');
  	        var src;
  	        var specifiers = [];
  	        if (this.lookahead.type === 8 /* StringLiteral */) {
  	            // import 'foo';
  	            src = this.parseModuleSpecifier();
  	        }
  	        else {
  	            if (this.match('{')) {
  	                // import {bar}
  	                specifiers = specifiers.concat(this.parseNamedImports());
  	            }
  	            else if (this.match('*')) {
  	                // import * as foo
  	                specifiers.push(this.parseImportNamespaceSpecifier());
  	            }
  	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
  	                // import foo
  	                specifiers.push(this.parseImportDefaultSpecifier());
  	                if (this.match(',')) {
  	                    this.nextToken();
  	                    if (this.match('*')) {
  	                        // import foo, * as foo
  	                        specifiers.push(this.parseImportNamespaceSpecifier());
  	                    }
  	                    else if (this.match('{')) {
  	                        // import foo, {bar}
  	                        specifiers = specifiers.concat(this.parseNamedImports());
  	                    }
  	                    else {
  	                        this.throwUnexpectedToken(this.lookahead);
  	                    }
  	                }
  	            }
  	            else {
  	                this.throwUnexpectedToken(this.nextToken());
  	            }
  	            if (!this.matchContextualKeyword('from')) {
  	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
  	                this.throwError(message, this.lookahead.value);
  	            }
  	            this.nextToken();
  	            src = this.parseModuleSpecifier();
  	        }
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-exports
  	    Parser.prototype.parseExportSpecifier = function () {
  	        var node = this.createNode();
  	        var local = this.parseIdentifierName();
  	        var exported = local;
  	        if (this.matchContextualKeyword('as')) {
  	            this.nextToken();
  	            exported = this.parseIdentifierName();
  	        }
  	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
  	    };
  	    Parser.prototype.parseExportDeclaration = function () {
  	        if (this.context.inFunctionBody) {
  	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
  	        }
  	        var node = this.createNode();
  	        this.expectKeyword('export');
  	        var exportDeclaration;
  	        if (this.matchKeyword('default')) {
  	            // export default ...
  	            this.nextToken();
  	            if (this.matchKeyword('function')) {
  	                // export default function foo () {}
  	                // export default function () {}
  	                var declaration = this.parseFunctionDeclaration(true);
  	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
  	            }
  	            else if (this.matchKeyword('class')) {
  	                // export default class foo {}
  	                var declaration = this.parseClassDeclaration(true);
  	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
  	            }
  	            else if (this.matchContextualKeyword('async')) {
  	                // export default async function f () {}
  	                // export default async function () {}
  	                // export default async x => x
  	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
  	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
  	            }
  	            else {
  	                if (this.matchContextualKeyword('from')) {
  	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
  	                }
  	                // export default {};
  	                // export default [];
  	                // export default (1 + 2);
  	                var declaration = this.match('{') ? this.parseObjectInitializer() :
  	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
  	                this.consumeSemicolon();
  	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
  	            }
  	        }
  	        else if (this.match('*')) {
  	            // export * from 'foo';
  	            this.nextToken();
  	            if (!this.matchContextualKeyword('from')) {
  	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
  	                this.throwError(message, this.lookahead.value);
  	            }
  	            this.nextToken();
  	            var src = this.parseModuleSpecifier();
  	            this.consumeSemicolon();
  	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
  	        }
  	        else if (this.lookahead.type === 4 /* Keyword */) {
  	            // export var f = 1;
  	            var declaration = void 0;
  	            switch (this.lookahead.value) {
  	                case 'let':
  	                case 'const':
  	                    declaration = this.parseLexicalDeclaration({ inFor: false });
  	                    break;
  	                case 'var':
  	                case 'class':
  	                case 'function':
  	                    declaration = this.parseStatementListItem();
  	                    break;
  	                default:
  	                    this.throwUnexpectedToken(this.lookahead);
  	            }
  	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
  	        }
  	        else if (this.matchAsyncFunction()) {
  	            var declaration = this.parseFunctionDeclaration();
  	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
  	        }
  	        else {
  	            var specifiers = [];
  	            var source = null;
  	            var isExportFromIdentifier = false;
  	            this.expect('{');
  	            while (!this.match('}')) {
  	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
  	                specifiers.push(this.parseExportSpecifier());
  	                if (!this.match('}')) {
  	                    this.expect(',');
  	                }
  	            }
  	            this.expect('}');
  	            if (this.matchContextualKeyword('from')) {
  	                // export {default} from 'foo';
  	                // export {foo} from 'foo';
  	                this.nextToken();
  	                source = this.parseModuleSpecifier();
  	                this.consumeSemicolon();
  	            }
  	            else if (isExportFromIdentifier) {
  	                // export {default}; // missing fromClause
  	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
  	                this.throwError(message, this.lookahead.value);
  	            }
  	            else {
  	                // export {foo};
  	                this.consumeSemicolon();
  	            }
  	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
  	        }
  	        return exportDeclaration;
  	    };
  	    return Parser;
  	}());
  	exports.Parser = Parser;


  /***/ },
  /* 9 */
  /***/ function(module, exports) {

  	"use strict";
  	// Ensure the condition is true, otherwise throw an error.
  	// This is only to have a better contract semantic, i.e. another safety net
  	// to catch a logic error. The condition shall be fulfilled in normal case.
  	// Do NOT use this to enforce a certain condition on any user input.
  	Object.defineProperty(exports, "__esModule", { value: true });
  	function assert(condition, message) {
  	    /* istanbul ignore if */
  	    if (!condition) {
  	        throw new Error('ASSERT: ' + message);
  	    }
  	}
  	exports.assert = assert;


  /***/ },
  /* 10 */
  /***/ function(module, exports) {

  	"use strict";
  	/* tslint:disable:max-classes-per-file */
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var ErrorHandler = (function () {
  	    function ErrorHandler() {
  	        this.errors = [];
  	        this.tolerant = false;
  	    }
  	    ErrorHandler.prototype.recordError = function (error) {
  	        this.errors.push(error);
  	    };
  	    ErrorHandler.prototype.tolerate = function (error) {
  	        if (this.tolerant) {
  	            this.recordError(error);
  	        }
  	        else {
  	            throw error;
  	        }
  	    };
  	    ErrorHandler.prototype.constructError = function (msg, column) {
  	        var error = new Error(msg);
  	        try {
  	            throw error;
  	        }
  	        catch (base) {
  	            /* istanbul ignore else */
  	            if (Object.create && Object.defineProperty) {
  	                error = Object.create(base);
  	                Object.defineProperty(error, 'column', { value: column });
  	            }
  	        }
  	        /* istanbul ignore next */
  	        return error;
  	    };
  	    ErrorHandler.prototype.createError = function (index, line, col, description) {
  	        var msg = 'Line ' + line + ': ' + description;
  	        var error = this.constructError(msg, col);
  	        error.index = index;
  	        error.lineNumber = line;
  	        error.description = description;
  	        return error;
  	    };
  	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
  	        throw this.createError(index, line, col, description);
  	    };
  	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
  	        var error = this.createError(index, line, col, description);
  	        if (this.tolerant) {
  	            this.recordError(error);
  	        }
  	        else {
  	            throw error;
  	        }
  	    };
  	    return ErrorHandler;
  	}());
  	exports.ErrorHandler = ErrorHandler;


  /***/ },
  /* 11 */
  /***/ function(module, exports) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	// Error messages should be identical to V8.
  	exports.Messages = {
  	    BadGetterArity: 'Getter must not have any formal parameters',
  	    BadSetterArity: 'Setter must have exactly one formal parameter',
  	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
  	    ConstructorIsAsync: 'Class constructor may not be an async method',
  	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
  	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
  	    DefaultRestParameter: 'Unexpected token =',
  	    DuplicateBinding: 'Duplicate binding %0',
  	    DuplicateConstructor: 'A class may only have one constructor',
  	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
  	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
  	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
  	    IllegalBreak: 'Illegal break statement',
  	    IllegalContinue: 'Illegal continue statement',
  	    IllegalExportDeclaration: 'Unexpected token',
  	    IllegalImportDeclaration: 'Unexpected token',
  	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
  	    IllegalReturn: 'Illegal return statement',
  	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
  	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
  	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
  	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
  	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
  	    InvalidModuleSpecifier: 'Unexpected token',
  	    InvalidRegExp: 'Invalid regular expression',
  	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
  	    MissingFromClause: 'Unexpected token',
  	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
  	    NewlineAfterThrow: 'Illegal newline after throw',
  	    NoAsAfterImportNamespace: 'Unexpected token',
  	    NoCatchOrFinally: 'Missing catch or finally after try',
  	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
  	    Redeclaration: '%0 \'%1\' has already been declared',
  	    StaticPrototype: 'Classes may not have static property named prototype',
  	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
  	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
  	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
  	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
  	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
  	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
  	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
  	    StrictModeWith: 'Strict mode code may not include a with statement',
  	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
  	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
  	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
  	    StrictReservedWord: 'Use of future reserved word in strict mode',
  	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
  	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
  	    UnexpectedEOS: 'Unexpected end of input',
  	    UnexpectedIdentifier: 'Unexpected identifier',
  	    UnexpectedNumber: 'Unexpected number',
  	    UnexpectedReserved: 'Unexpected reserved word',
  	    UnexpectedString: 'Unexpected string',
  	    UnexpectedTemplate: 'Unexpected quasi %0',
  	    UnexpectedToken: 'Unexpected token %0',
  	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
  	    UnknownLabel: 'Undefined label \'%0\'',
  	    UnterminatedRegExp: 'Invalid regular expression: missing /'
  	};


  /***/ },
  /* 12 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var assert_1 = __webpack_require__(9);
  	var character_1 = __webpack_require__(4);
  	var messages_1 = __webpack_require__(11);
  	function hexValue(ch) {
  	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
  	}
  	function octalValue(ch) {
  	    return '01234567'.indexOf(ch);
  	}
  	var Scanner = (function () {
  	    function Scanner(code, handler) {
  	        this.source = code;
  	        this.errorHandler = handler;
  	        this.trackComment = false;
  	        this.isModule = false;
  	        this.length = code.length;
  	        this.index = 0;
  	        this.lineNumber = (code.length > 0) ? 1 : 0;
  	        this.lineStart = 0;
  	        this.curlyStack = [];
  	    }
  	    Scanner.prototype.saveState = function () {
  	        return {
  	            index: this.index,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart
  	        };
  	    };
  	    Scanner.prototype.restoreState = function (state) {
  	        this.index = state.index;
  	        this.lineNumber = state.lineNumber;
  	        this.lineStart = state.lineStart;
  	    };
  	    Scanner.prototype.eof = function () {
  	        return this.index >= this.length;
  	    };
  	    Scanner.prototype.throwUnexpectedToken = function (message) {
  	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
  	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
  	    };
  	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
  	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
  	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
  	    };
  	    // https://tc39.github.io/ecma262/#sec-comments
  	    Scanner.prototype.skipSingleLineComment = function (offset) {
  	        var comments = [];
  	        var start, loc;
  	        if (this.trackComment) {
  	            comments = [];
  	            start = this.index - offset;
  	            loc = {
  	                start: {
  	                    line: this.lineNumber,
  	                    column: this.index - this.lineStart - offset
  	                },
  	                end: {}
  	            };
  	        }
  	        while (!this.eof()) {
  	            var ch = this.source.charCodeAt(this.index);
  	            ++this.index;
  	            if (character_1.Character.isLineTerminator(ch)) {
  	                if (this.trackComment) {
  	                    loc.end = {
  	                        line: this.lineNumber,
  	                        column: this.index - this.lineStart - 1
  	                    };
  	                    var entry = {
  	                        multiLine: false,
  	                        slice: [start + offset, this.index - 1],
  	                        range: [start, this.index - 1],
  	                        loc: loc
  	                    };
  	                    comments.push(entry);
  	                }
  	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
  	                    ++this.index;
  	                }
  	                ++this.lineNumber;
  	                this.lineStart = this.index;
  	                return comments;
  	            }
  	        }
  	        if (this.trackComment) {
  	            loc.end = {
  	                line: this.lineNumber,
  	                column: this.index - this.lineStart
  	            };
  	            var entry = {
  	                multiLine: false,
  	                slice: [start + offset, this.index],
  	                range: [start, this.index],
  	                loc: loc
  	            };
  	            comments.push(entry);
  	        }
  	        return comments;
  	    };
  	    Scanner.prototype.skipMultiLineComment = function () {
  	        var comments = [];
  	        var start, loc;
  	        if (this.trackComment) {
  	            comments = [];
  	            start = this.index - 2;
  	            loc = {
  	                start: {
  	                    line: this.lineNumber,
  	                    column: this.index - this.lineStart - 2
  	                },
  	                end: {}
  	            };
  	        }
  	        while (!this.eof()) {
  	            var ch = this.source.charCodeAt(this.index);
  	            if (character_1.Character.isLineTerminator(ch)) {
  	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
  	                    ++this.index;
  	                }
  	                ++this.lineNumber;
  	                ++this.index;
  	                this.lineStart = this.index;
  	            }
  	            else if (ch === 0x2A) {
  	                // Block comment ends with '*/'.
  	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
  	                    this.index += 2;
  	                    if (this.trackComment) {
  	                        loc.end = {
  	                            line: this.lineNumber,
  	                            column: this.index - this.lineStart
  	                        };
  	                        var entry = {
  	                            multiLine: true,
  	                            slice: [start + 2, this.index - 2],
  	                            range: [start, this.index],
  	                            loc: loc
  	                        };
  	                        comments.push(entry);
  	                    }
  	                    return comments;
  	                }
  	                ++this.index;
  	            }
  	            else {
  	                ++this.index;
  	            }
  	        }
  	        // Ran off the end of the file - the whole thing is a comment
  	        if (this.trackComment) {
  	            loc.end = {
  	                line: this.lineNumber,
  	                column: this.index - this.lineStart
  	            };
  	            var entry = {
  	                multiLine: true,
  	                slice: [start + 2, this.index],
  	                range: [start, this.index],
  	                loc: loc
  	            };
  	            comments.push(entry);
  	        }
  	        this.tolerateUnexpectedToken();
  	        return comments;
  	    };
  	    Scanner.prototype.scanComments = function () {
  	        var comments;
  	        if (this.trackComment) {
  	            comments = [];
  	        }
  	        var start = (this.index === 0);
  	        while (!this.eof()) {
  	            var ch = this.source.charCodeAt(this.index);
  	            if (character_1.Character.isWhiteSpace(ch)) {
  	                ++this.index;
  	            }
  	            else if (character_1.Character.isLineTerminator(ch)) {
  	                ++this.index;
  	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
  	                    ++this.index;
  	                }
  	                ++this.lineNumber;
  	                this.lineStart = this.index;
  	                start = true;
  	            }
  	            else if (ch === 0x2F) {
  	                ch = this.source.charCodeAt(this.index + 1);
  	                if (ch === 0x2F) {
  	                    this.index += 2;
  	                    var comment = this.skipSingleLineComment(2);
  	                    if (this.trackComment) {
  	                        comments = comments.concat(comment);
  	                    }
  	                    start = true;
  	                }
  	                else if (ch === 0x2A) {
  	                    this.index += 2;
  	                    var comment = this.skipMultiLineComment();
  	                    if (this.trackComment) {
  	                        comments = comments.concat(comment);
  	                    }
  	                }
  	                else {
  	                    break;
  	                }
  	            }
  	            else if (start && ch === 0x2D) {
  	                // U+003E is '>'
  	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
  	                    // '-->' is a single-line comment
  	                    this.index += 3;
  	                    var comment = this.skipSingleLineComment(3);
  	                    if (this.trackComment) {
  	                        comments = comments.concat(comment);
  	                    }
  	                }
  	                else {
  	                    break;
  	                }
  	            }
  	            else if (ch === 0x3C && !this.isModule) {
  	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
  	                    this.index += 4; // `<!--`
  	                    var comment = this.skipSingleLineComment(4);
  	                    if (this.trackComment) {
  	                        comments = comments.concat(comment);
  	                    }
  	                }
  	                else {
  	                    break;
  	                }
  	            }
  	            else {
  	                break;
  	            }
  	        }
  	        return comments;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
  	    Scanner.prototype.isFutureReservedWord = function (id) {
  	        switch (id) {
  	            case 'enum':
  	            case 'export':
  	            case 'import':
  	            case 'super':
  	                return true;
  	            default:
  	                return false;
  	        }
  	    };
  	    Scanner.prototype.isStrictModeReservedWord = function (id) {
  	        switch (id) {
  	            case 'implements':
  	            case 'interface':
  	            case 'package':
  	            case 'private':
  	            case 'protected':
  	            case 'public':
  	            case 'static':
  	            case 'yield':
  	            case 'let':
  	                return true;
  	            default:
  	                return false;
  	        }
  	    };
  	    Scanner.prototype.isRestrictedWord = function (id) {
  	        return id === 'eval' || id === 'arguments';
  	    };
  	    // https://tc39.github.io/ecma262/#sec-keywords
  	    Scanner.prototype.isKeyword = function (id) {
  	        switch (id.length) {
  	            case 2:
  	                return (id === 'if') || (id === 'in') || (id === 'do');
  	            case 3:
  	                return (id === 'var') || (id === 'for') || (id === 'new') ||
  	                    (id === 'try') || (id === 'let');
  	            case 4:
  	                return (id === 'this') || (id === 'else') || (id === 'case') ||
  	                    (id === 'void') || (id === 'with') || (id === 'enum');
  	            case 5:
  	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
  	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
  	                    (id === 'class') || (id === 'super');
  	            case 6:
  	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
  	                    (id === 'switch') || (id === 'export') || (id === 'import');
  	            case 7:
  	                return (id === 'default') || (id === 'finally') || (id === 'extends');
  	            case 8:
  	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
  	            case 10:
  	                return (id === 'instanceof');
  	            default:
  	                return false;
  	        }
  	    };
  	    Scanner.prototype.codePointAt = function (i) {
  	        var cp = this.source.charCodeAt(i);
  	        if (cp >= 0xD800 && cp <= 0xDBFF) {
  	            var second = this.source.charCodeAt(i + 1);
  	            if (second >= 0xDC00 && second <= 0xDFFF) {
  	                var first = cp;
  	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
  	            }
  	        }
  	        return cp;
  	    };
  	    Scanner.prototype.scanHexEscape = function (prefix) {
  	        var len = (prefix === 'u') ? 4 : 2;
  	        var code = 0;
  	        for (var i = 0; i < len; ++i) {
  	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
  	                code = code * 16 + hexValue(this.source[this.index++]);
  	            }
  	            else {
  	                return null;
  	            }
  	        }
  	        return String.fromCharCode(code);
  	    };
  	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
  	        var ch = this.source[this.index];
  	        var code = 0;
  	        // At least, one hex digit is required.
  	        if (ch === '}') {
  	            this.throwUnexpectedToken();
  	        }
  	        while (!this.eof()) {
  	            ch = this.source[this.index++];
  	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
  	                break;
  	            }
  	            code = code * 16 + hexValue(ch);
  	        }
  	        if (code > 0x10FFFF || ch !== '}') {
  	            this.throwUnexpectedToken();
  	        }
  	        return character_1.Character.fromCodePoint(code);
  	    };
  	    Scanner.prototype.getIdentifier = function () {
  	        var start = this.index++;
  	        while (!this.eof()) {
  	            var ch = this.source.charCodeAt(this.index);
  	            if (ch === 0x5C) {
  	                // Blackslash (U+005C) marks Unicode escape sequence.
  	                this.index = start;
  	                return this.getComplexIdentifier();
  	            }
  	            else if (ch >= 0xD800 && ch < 0xDFFF) {
  	                // Need to handle surrogate pairs.
  	                this.index = start;
  	                return this.getComplexIdentifier();
  	            }
  	            if (character_1.Character.isIdentifierPart(ch)) {
  	                ++this.index;
  	            }
  	            else {
  	                break;
  	            }
  	        }
  	        return this.source.slice(start, this.index);
  	    };
  	    Scanner.prototype.getComplexIdentifier = function () {
  	        var cp = this.codePointAt(this.index);
  	        var id = character_1.Character.fromCodePoint(cp);
  	        this.index += id.length;
  	        // '\u' (U+005C, U+0075) denotes an escaped character.
  	        var ch;
  	        if (cp === 0x5C) {
  	            if (this.source.charCodeAt(this.index) !== 0x75) {
  	                this.throwUnexpectedToken();
  	            }
  	            ++this.index;
  	            if (this.source[this.index] === '{') {
  	                ++this.index;
  	                ch = this.scanUnicodeCodePointEscape();
  	            }
  	            else {
  	                ch = this.scanHexEscape('u');
  	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
  	                    this.throwUnexpectedToken();
  	                }
  	            }
  	            id = ch;
  	        }
  	        while (!this.eof()) {
  	            cp = this.codePointAt(this.index);
  	            if (!character_1.Character.isIdentifierPart(cp)) {
  	                break;
  	            }
  	            ch = character_1.Character.fromCodePoint(cp);
  	            id += ch;
  	            this.index += ch.length;
  	            // '\u' (U+005C, U+0075) denotes an escaped character.
  	            if (cp === 0x5C) {
  	                id = id.substr(0, id.length - 1);
  	                if (this.source.charCodeAt(this.index) !== 0x75) {
  	                    this.throwUnexpectedToken();
  	                }
  	                ++this.index;
  	                if (this.source[this.index] === '{') {
  	                    ++this.index;
  	                    ch = this.scanUnicodeCodePointEscape();
  	                }
  	                else {
  	                    ch = this.scanHexEscape('u');
  	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
  	                        this.throwUnexpectedToken();
  	                    }
  	                }
  	                id += ch;
  	            }
  	        }
  	        return id;
  	    };
  	    Scanner.prototype.octalToDecimal = function (ch) {
  	        // \0 is not octal escape sequence
  	        var octal = (ch !== '0');
  	        var code = octalValue(ch);
  	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
  	            octal = true;
  	            code = code * 8 + octalValue(this.source[this.index++]);
  	            // 3 digits are only allowed when string starts
  	            // with 0, 1, 2, 3
  	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
  	                code = code * 8 + octalValue(this.source[this.index++]);
  	            }
  	        }
  	        return {
  	            code: code,
  	            octal: octal
  	        };
  	    };
  	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
  	    Scanner.prototype.scanIdentifier = function () {
  	        var type;
  	        var start = this.index;
  	        // Backslash (U+005C) starts an escaped character.
  	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
  	        // There is no keyword or literal with only one character.
  	        // Thus, it must be an identifier.
  	        if (id.length === 1) {
  	            type = 3 /* Identifier */;
  	        }
  	        else if (this.isKeyword(id)) {
  	            type = 4 /* Keyword */;
  	        }
  	        else if (id === 'null') {
  	            type = 5 /* NullLiteral */;
  	        }
  	        else if (id === 'true' || id === 'false') {
  	            type = 1 /* BooleanLiteral */;
  	        }
  	        else {
  	            type = 3 /* Identifier */;
  	        }
  	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
  	            var restore = this.index;
  	            this.index = start;
  	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
  	            this.index = restore;
  	        }
  	        return {
  	            type: type,
  	            value: id,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    // https://tc39.github.io/ecma262/#sec-punctuators
  	    Scanner.prototype.scanPunctuator = function () {
  	        var start = this.index;
  	        // Check for most common single-character punctuators.
  	        var str = this.source[this.index];
  	        switch (str) {
  	            case '(':
  	            case '{':
  	                if (str === '{') {
  	                    this.curlyStack.push('{');
  	                }
  	                ++this.index;
  	                break;
  	            case '.':
  	                ++this.index;
  	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
  	                    // Spread operator: ...
  	                    this.index += 2;
  	                    str = '...';
  	                }
  	                break;
  	            case '}':
  	                ++this.index;
  	                this.curlyStack.pop();
  	                break;
  	            case ')':
  	            case ';':
  	            case ',':
  	            case '[':
  	            case ']':
  	            case ':':
  	            case '?':
  	            case '~':
  	                ++this.index;
  	                break;
  	            default:
  	                // 4-character punctuator.
  	                str = this.source.substr(this.index, 4);
  	                if (str === '>>>=') {
  	                    this.index += 4;
  	                }
  	                else {
  	                    // 3-character punctuators.
  	                    str = str.substr(0, 3);
  	                    if (str === '===' || str === '!==' || str === '>>>' ||
  	                        str === '<<=' || str === '>>=' || str === '**=') {
  	                        this.index += 3;
  	                    }
  	                    else {
  	                        // 2-character punctuators.
  	                        str = str.substr(0, 2);
  	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
  	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
  	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
  	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
  	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
  	                            this.index += 2;
  	                        }
  	                        else {
  	                            // 1-character punctuators.
  	                            str = this.source[this.index];
  	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
  	                                ++this.index;
  	                            }
  	                        }
  	                    }
  	                }
  	        }
  	        if (this.index === start) {
  	            this.throwUnexpectedToken();
  	        }
  	        return {
  	            type: 7 /* Punctuator */,
  	            value: str,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
  	    Scanner.prototype.scanHexLiteral = function (start) {
  	        var num = '';
  	        while (!this.eof()) {
  	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
  	                break;
  	            }
  	            num += this.source[this.index++];
  	        }
  	        if (num.length === 0) {
  	            this.throwUnexpectedToken();
  	        }
  	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
  	            this.throwUnexpectedToken();
  	        }
  	        return {
  	            type: 6 /* NumericLiteral */,
  	            value: parseInt('0x' + num, 16),
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    Scanner.prototype.scanBinaryLiteral = function (start) {
  	        var num = '';
  	        var ch;
  	        while (!this.eof()) {
  	            ch = this.source[this.index];
  	            if (ch !== '0' && ch !== '1') {
  	                break;
  	            }
  	            num += this.source[this.index++];
  	        }
  	        if (num.length === 0) {
  	            // only 0b or 0B
  	            this.throwUnexpectedToken();
  	        }
  	        if (!this.eof()) {
  	            ch = this.source.charCodeAt(this.index);
  	            /* istanbul ignore else */
  	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
  	                this.throwUnexpectedToken();
  	            }
  	        }
  	        return {
  	            type: 6 /* NumericLiteral */,
  	            value: parseInt(num, 2),
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
  	        var num = '';
  	        var octal = false;
  	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
  	            octal = true;
  	            num = '0' + this.source[this.index++];
  	        }
  	        else {
  	            ++this.index;
  	        }
  	        while (!this.eof()) {
  	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
  	                break;
  	            }
  	            num += this.source[this.index++];
  	        }
  	        if (!octal && num.length === 0) {
  	            // only 0o or 0O
  	            this.throwUnexpectedToken();
  	        }
  	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
  	            this.throwUnexpectedToken();
  	        }
  	        return {
  	            type: 6 /* NumericLiteral */,
  	            value: parseInt(num, 8),
  	            octal: octal,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    Scanner.prototype.isImplicitOctalLiteral = function () {
  	        // Implicit octal, unless there is a non-octal digit.
  	        // (Annex B.1.1 on Numeric Literals)
  	        for (var i = this.index + 1; i < this.length; ++i) {
  	            var ch = this.source[i];
  	            if (ch === '8' || ch === '9') {
  	                return false;
  	            }
  	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
  	                return true;
  	            }
  	        }
  	        return true;
  	    };
  	    Scanner.prototype.scanNumericLiteral = function () {
  	        var start = this.index;
  	        var ch = this.source[start];
  	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
  	        var num = '';
  	        if (ch !== '.') {
  	            num = this.source[this.index++];
  	            ch = this.source[this.index];
  	            // Hex number starts with '0x'.
  	            // Octal number starts with '0'.
  	            // Octal number in ES6 starts with '0o'.
  	            // Binary number in ES6 starts with '0b'.
  	            if (num === '0') {
  	                if (ch === 'x' || ch === 'X') {
  	                    ++this.index;
  	                    return this.scanHexLiteral(start);
  	                }
  	                if (ch === 'b' || ch === 'B') {
  	                    ++this.index;
  	                    return this.scanBinaryLiteral(start);
  	                }
  	                if (ch === 'o' || ch === 'O') {
  	                    return this.scanOctalLiteral(ch, start);
  	                }
  	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
  	                    if (this.isImplicitOctalLiteral()) {
  	                        return this.scanOctalLiteral(ch, start);
  	                    }
  	                }
  	            }
  	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
  	                num += this.source[this.index++];
  	            }
  	            ch = this.source[this.index];
  	        }
  	        if (ch === '.') {
  	            num += this.source[this.index++];
  	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
  	                num += this.source[this.index++];
  	            }
  	            ch = this.source[this.index];
  	        }
  	        if (ch === 'e' || ch === 'E') {
  	            num += this.source[this.index++];
  	            ch = this.source[this.index];
  	            if (ch === '+' || ch === '-') {
  	                num += this.source[this.index++];
  	            }
  	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
  	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
  	                    num += this.source[this.index++];
  	                }
  	            }
  	            else {
  	                this.throwUnexpectedToken();
  	            }
  	        }
  	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
  	            this.throwUnexpectedToken();
  	        }
  	        return {
  	            type: 6 /* NumericLiteral */,
  	            value: parseFloat(num),
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
  	    Scanner.prototype.scanStringLiteral = function () {
  	        var start = this.index;
  	        var quote = this.source[start];
  	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
  	        ++this.index;
  	        var octal = false;
  	        var str = '';
  	        while (!this.eof()) {
  	            var ch = this.source[this.index++];
  	            if (ch === quote) {
  	                quote = '';
  	                break;
  	            }
  	            else if (ch === '\\') {
  	                ch = this.source[this.index++];
  	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                    switch (ch) {
  	                        case 'u':
  	                            if (this.source[this.index] === '{') {
  	                                ++this.index;
  	                                str += this.scanUnicodeCodePointEscape();
  	                            }
  	                            else {
  	                                var unescaped_1 = this.scanHexEscape(ch);
  	                                if (unescaped_1 === null) {
  	                                    this.throwUnexpectedToken();
  	                                }
  	                                str += unescaped_1;
  	                            }
  	                            break;
  	                        case 'x':
  	                            var unescaped = this.scanHexEscape(ch);
  	                            if (unescaped === null) {
  	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
  	                            }
  	                            str += unescaped;
  	                            break;
  	                        case 'n':
  	                            str += '\n';
  	                            break;
  	                        case 'r':
  	                            str += '\r';
  	                            break;
  	                        case 't':
  	                            str += '\t';
  	                            break;
  	                        case 'b':
  	                            str += '\b';
  	                            break;
  	                        case 'f':
  	                            str += '\f';
  	                            break;
  	                        case 'v':
  	                            str += '\x0B';
  	                            break;
  	                        case '8':
  	                        case '9':
  	                            str += ch;
  	                            this.tolerateUnexpectedToken();
  	                            break;
  	                        default:
  	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
  	                                var octToDec = this.octalToDecimal(ch);
  	                                octal = octToDec.octal || octal;
  	                                str += String.fromCharCode(octToDec.code);
  	                            }
  	                            else {
  	                                str += ch;
  	                            }
  	                            break;
  	                    }
  	                }
  	                else {
  	                    ++this.lineNumber;
  	                    if (ch === '\r' && this.source[this.index] === '\n') {
  	                        ++this.index;
  	                    }
  	                    this.lineStart = this.index;
  	                }
  	            }
  	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                break;
  	            }
  	            else {
  	                str += ch;
  	            }
  	        }
  	        if (quote !== '') {
  	            this.index = start;
  	            this.throwUnexpectedToken();
  	        }
  	        return {
  	            type: 8 /* StringLiteral */,
  	            value: str,
  	            octal: octal,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
  	    Scanner.prototype.scanTemplate = function () {
  	        var cooked = '';
  	        var terminated = false;
  	        var start = this.index;
  	        var head = (this.source[start] === '`');
  	        var tail = false;
  	        var rawOffset = 2;
  	        ++this.index;
  	        while (!this.eof()) {
  	            var ch = this.source[this.index++];
  	            if (ch === '`') {
  	                rawOffset = 1;
  	                tail = true;
  	                terminated = true;
  	                break;
  	            }
  	            else if (ch === '$') {
  	                if (this.source[this.index] === '{') {
  	                    this.curlyStack.push('${');
  	                    ++this.index;
  	                    terminated = true;
  	                    break;
  	                }
  	                cooked += ch;
  	            }
  	            else if (ch === '\\') {
  	                ch = this.source[this.index++];
  	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                    switch (ch) {
  	                        case 'n':
  	                            cooked += '\n';
  	                            break;
  	                        case 'r':
  	                            cooked += '\r';
  	                            break;
  	                        case 't':
  	                            cooked += '\t';
  	                            break;
  	                        case 'u':
  	                            if (this.source[this.index] === '{') {
  	                                ++this.index;
  	                                cooked += this.scanUnicodeCodePointEscape();
  	                            }
  	                            else {
  	                                var restore = this.index;
  	                                var unescaped_2 = this.scanHexEscape(ch);
  	                                if (unescaped_2 !== null) {
  	                                    cooked += unescaped_2;
  	                                }
  	                                else {
  	                                    this.index = restore;
  	                                    cooked += ch;
  	                                }
  	                            }
  	                            break;
  	                        case 'x':
  	                            var unescaped = this.scanHexEscape(ch);
  	                            if (unescaped === null) {
  	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
  	                            }
  	                            cooked += unescaped;
  	                            break;
  	                        case 'b':
  	                            cooked += '\b';
  	                            break;
  	                        case 'f':
  	                            cooked += '\f';
  	                            break;
  	                        case 'v':
  	                            cooked += '\v';
  	                            break;
  	                        default:
  	                            if (ch === '0') {
  	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
  	                                    // Illegal: \01 \02 and so on
  	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
  	                                }
  	                                cooked += '\0';
  	                            }
  	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
  	                                // Illegal: \1 \2
  	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
  	                            }
  	                            else {
  	                                cooked += ch;
  	                            }
  	                            break;
  	                    }
  	                }
  	                else {
  	                    ++this.lineNumber;
  	                    if (ch === '\r' && this.source[this.index] === '\n') {
  	                        ++this.index;
  	                    }
  	                    this.lineStart = this.index;
  	                }
  	            }
  	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                ++this.lineNumber;
  	                if (ch === '\r' && this.source[this.index] === '\n') {
  	                    ++this.index;
  	                }
  	                this.lineStart = this.index;
  	                cooked += '\n';
  	            }
  	            else {
  	                cooked += ch;
  	            }
  	        }
  	        if (!terminated) {
  	            this.throwUnexpectedToken();
  	        }
  	        if (!head) {
  	            this.curlyStack.pop();
  	        }
  	        return {
  	            type: 10 /* Template */,
  	            value: this.source.slice(start + 1, this.index - rawOffset),
  	            cooked: cooked,
  	            head: head,
  	            tail: tail,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
  	    Scanner.prototype.testRegExp = function (pattern, flags) {
  	        // The BMP character to use as a replacement for astral symbols when
  	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
  	        // approximation.
  	        // Note: replacing with '\uFFFF' enables false positives in unlikely
  	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
  	        // pattern that would not be detected by this substitution.
  	        var astralSubstitute = '\uFFFF';
  	        var tmp = pattern;
  	        var self = this;
  	        if (flags.indexOf('u') >= 0) {
  	            tmp = tmp
  	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
  	                var codePoint = parseInt($1 || $2, 16);
  	                if (codePoint > 0x10FFFF) {
  	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
  	                }
  	                if (codePoint <= 0xFFFF) {
  	                    return String.fromCharCode(codePoint);
  	                }
  	                return astralSubstitute;
  	            })
  	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
  	        }
  	        // First, detect invalid regular expressions.
  	        try {
  	            RegExp(tmp);
  	        }
  	        catch (e) {
  	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
  	        }
  	        // Return a regular expression object for this pattern-flag pair, or
  	        // `null` in case the current environment doesn't support the flags it
  	        // uses.
  	        try {
  	            return new RegExp(pattern, flags);
  	        }
  	        catch (exception) {
  	            /* istanbul ignore next */
  	            return null;
  	        }
  	    };
  	    Scanner.prototype.scanRegExpBody = function () {
  	        var ch = this.source[this.index];
  	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
  	        var str = this.source[this.index++];
  	        var classMarker = false;
  	        var terminated = false;
  	        while (!this.eof()) {
  	            ch = this.source[this.index++];
  	            str += ch;
  	            if (ch === '\\') {
  	                ch = this.source[this.index++];
  	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
  	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
  	                }
  	                str += ch;
  	            }
  	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
  	            }
  	            else if (classMarker) {
  	                if (ch === ']') {
  	                    classMarker = false;
  	                }
  	            }
  	            else {
  	                if (ch === '/') {
  	                    terminated = true;
  	                    break;
  	                }
  	                else if (ch === '[') {
  	                    classMarker = true;
  	                }
  	            }
  	        }
  	        if (!terminated) {
  	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
  	        }
  	        // Exclude leading and trailing slash.
  	        return str.substr(1, str.length - 2);
  	    };
  	    Scanner.prototype.scanRegExpFlags = function () {
  	        var str = '';
  	        var flags = '';
  	        while (!this.eof()) {
  	            var ch = this.source[this.index];
  	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
  	                break;
  	            }
  	            ++this.index;
  	            if (ch === '\\' && !this.eof()) {
  	                ch = this.source[this.index];
  	                if (ch === 'u') {
  	                    ++this.index;
  	                    var restore = this.index;
  	                    var char = this.scanHexEscape('u');
  	                    if (char !== null) {
  	                        flags += char;
  	                        for (str += '\\u'; restore < this.index; ++restore) {
  	                            str += this.source[restore];
  	                        }
  	                    }
  	                    else {
  	                        this.index = restore;
  	                        flags += 'u';
  	                        str += '\\u';
  	                    }
  	                    this.tolerateUnexpectedToken();
  	                }
  	                else {
  	                    str += '\\';
  	                    this.tolerateUnexpectedToken();
  	                }
  	            }
  	            else {
  	                flags += ch;
  	                str += ch;
  	            }
  	        }
  	        return flags;
  	    };
  	    Scanner.prototype.scanRegExp = function () {
  	        var start = this.index;
  	        var pattern = this.scanRegExpBody();
  	        var flags = this.scanRegExpFlags();
  	        var value = this.testRegExp(pattern, flags);
  	        return {
  	            type: 9 /* RegularExpression */,
  	            value: '',
  	            pattern: pattern,
  	            flags: flags,
  	            regex: value,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    Scanner.prototype.lex = function () {
  	        if (this.eof()) {
  	            return {
  	                type: 2 /* EOF */,
  	                value: '',
  	                lineNumber: this.lineNumber,
  	                lineStart: this.lineStart,
  	                start: this.index,
  	                end: this.index
  	            };
  	        }
  	        var cp = this.source.charCodeAt(this.index);
  	        if (character_1.Character.isIdentifierStart(cp)) {
  	            return this.scanIdentifier();
  	        }
  	        // Very common: ( and ) and ;
  	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
  	            return this.scanPunctuator();
  	        }
  	        // String literal starts with single quote (U+0027) or double quote (U+0022).
  	        if (cp === 0x27 || cp === 0x22) {
  	            return this.scanStringLiteral();
  	        }
  	        // Dot (.) U+002E can also start a floating-point number, hence the need
  	        // to check the next character.
  	        if (cp === 0x2E) {
  	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
  	                return this.scanNumericLiteral();
  	            }
  	            return this.scanPunctuator();
  	        }
  	        if (character_1.Character.isDecimalDigit(cp)) {
  	            return this.scanNumericLiteral();
  	        }
  	        // Template literals start with ` (U+0060) for template head
  	        // or } (U+007D) for template middle or template tail.
  	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
  	            return this.scanTemplate();
  	        }
  	        // Possible identifier start in a surrogate pair.
  	        if (cp >= 0xD800 && cp < 0xDFFF) {
  	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
  	                return this.scanIdentifier();
  	            }
  	        }
  	        return this.scanPunctuator();
  	    };
  	    return Scanner;
  	}());
  	exports.Scanner = Scanner;


  /***/ },
  /* 13 */
  /***/ function(module, exports) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.TokenName = {};
  	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
  	exports.TokenName[2 /* EOF */] = '<end>';
  	exports.TokenName[3 /* Identifier */] = 'Identifier';
  	exports.TokenName[4 /* Keyword */] = 'Keyword';
  	exports.TokenName[5 /* NullLiteral */] = 'Null';
  	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
  	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
  	exports.TokenName[8 /* StringLiteral */] = 'String';
  	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
  	exports.TokenName[10 /* Template */] = 'Template';


  /***/ },
  /* 14 */
  /***/ function(module, exports) {

  	"use strict";
  	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.XHTMLEntities = {
  	    quot: '\u0022',
  	    amp: '\u0026',
  	    apos: '\u0027',
  	    gt: '\u003E',
  	    nbsp: '\u00A0',
  	    iexcl: '\u00A1',
  	    cent: '\u00A2',
  	    pound: '\u00A3',
  	    curren: '\u00A4',
  	    yen: '\u00A5',
  	    brvbar: '\u00A6',
  	    sect: '\u00A7',
  	    uml: '\u00A8',
  	    copy: '\u00A9',
  	    ordf: '\u00AA',
  	    laquo: '\u00AB',
  	    not: '\u00AC',
  	    shy: '\u00AD',
  	    reg: '\u00AE',
  	    macr: '\u00AF',
  	    deg: '\u00B0',
  	    plusmn: '\u00B1',
  	    sup2: '\u00B2',
  	    sup3: '\u00B3',
  	    acute: '\u00B4',
  	    micro: '\u00B5',
  	    para: '\u00B6',
  	    middot: '\u00B7',
  	    cedil: '\u00B8',
  	    sup1: '\u00B9',
  	    ordm: '\u00BA',
  	    raquo: '\u00BB',
  	    frac14: '\u00BC',
  	    frac12: '\u00BD',
  	    frac34: '\u00BE',
  	    iquest: '\u00BF',
  	    Agrave: '\u00C0',
  	    Aacute: '\u00C1',
  	    Acirc: '\u00C2',
  	    Atilde: '\u00C3',
  	    Auml: '\u00C4',
  	    Aring: '\u00C5',
  	    AElig: '\u00C6',
  	    Ccedil: '\u00C7',
  	    Egrave: '\u00C8',
  	    Eacute: '\u00C9',
  	    Ecirc: '\u00CA',
  	    Euml: '\u00CB',
  	    Igrave: '\u00CC',
  	    Iacute: '\u00CD',
  	    Icirc: '\u00CE',
  	    Iuml: '\u00CF',
  	    ETH: '\u00D0',
  	    Ntilde: '\u00D1',
  	    Ograve: '\u00D2',
  	    Oacute: '\u00D3',
  	    Ocirc: '\u00D4',
  	    Otilde: '\u00D5',
  	    Ouml: '\u00D6',
  	    times: '\u00D7',
  	    Oslash: '\u00D8',
  	    Ugrave: '\u00D9',
  	    Uacute: '\u00DA',
  	    Ucirc: '\u00DB',
  	    Uuml: '\u00DC',
  	    Yacute: '\u00DD',
  	    THORN: '\u00DE',
  	    szlig: '\u00DF',
  	    agrave: '\u00E0',
  	    aacute: '\u00E1',
  	    acirc: '\u00E2',
  	    atilde: '\u00E3',
  	    auml: '\u00E4',
  	    aring: '\u00E5',
  	    aelig: '\u00E6',
  	    ccedil: '\u00E7',
  	    egrave: '\u00E8',
  	    eacute: '\u00E9',
  	    ecirc: '\u00EA',
  	    euml: '\u00EB',
  	    igrave: '\u00EC',
  	    iacute: '\u00ED',
  	    icirc: '\u00EE',
  	    iuml: '\u00EF',
  	    eth: '\u00F0',
  	    ntilde: '\u00F1',
  	    ograve: '\u00F2',
  	    oacute: '\u00F3',
  	    ocirc: '\u00F4',
  	    otilde: '\u00F5',
  	    ouml: '\u00F6',
  	    divide: '\u00F7',
  	    oslash: '\u00F8',
  	    ugrave: '\u00F9',
  	    uacute: '\u00FA',
  	    ucirc: '\u00FB',
  	    uuml: '\u00FC',
  	    yacute: '\u00FD',
  	    thorn: '\u00FE',
  	    yuml: '\u00FF',
  	    OElig: '\u0152',
  	    oelig: '\u0153',
  	    Scaron: '\u0160',
  	    scaron: '\u0161',
  	    Yuml: '\u0178',
  	    fnof: '\u0192',
  	    circ: '\u02C6',
  	    tilde: '\u02DC',
  	    Alpha: '\u0391',
  	    Beta: '\u0392',
  	    Gamma: '\u0393',
  	    Delta: '\u0394',
  	    Epsilon: '\u0395',
  	    Zeta: '\u0396',
  	    Eta: '\u0397',
  	    Theta: '\u0398',
  	    Iota: '\u0399',
  	    Kappa: '\u039A',
  	    Lambda: '\u039B',
  	    Mu: '\u039C',
  	    Nu: '\u039D',
  	    Xi: '\u039E',
  	    Omicron: '\u039F',
  	    Pi: '\u03A0',
  	    Rho: '\u03A1',
  	    Sigma: '\u03A3',
  	    Tau: '\u03A4',
  	    Upsilon: '\u03A5',
  	    Phi: '\u03A6',
  	    Chi: '\u03A7',
  	    Psi: '\u03A8',
  	    Omega: '\u03A9',
  	    alpha: '\u03B1',
  	    beta: '\u03B2',
  	    gamma: '\u03B3',
  	    delta: '\u03B4',
  	    epsilon: '\u03B5',
  	    zeta: '\u03B6',
  	    eta: '\u03B7',
  	    theta: '\u03B8',
  	    iota: '\u03B9',
  	    kappa: '\u03BA',
  	    lambda: '\u03BB',
  	    mu: '\u03BC',
  	    nu: '\u03BD',
  	    xi: '\u03BE',
  	    omicron: '\u03BF',
  	    pi: '\u03C0',
  	    rho: '\u03C1',
  	    sigmaf: '\u03C2',
  	    sigma: '\u03C3',
  	    tau: '\u03C4',
  	    upsilon: '\u03C5',
  	    phi: '\u03C6',
  	    chi: '\u03C7',
  	    psi: '\u03C8',
  	    omega: '\u03C9',
  	    thetasym: '\u03D1',
  	    upsih: '\u03D2',
  	    piv: '\u03D6',
  	    ensp: '\u2002',
  	    emsp: '\u2003',
  	    thinsp: '\u2009',
  	    zwnj: '\u200C',
  	    zwj: '\u200D',
  	    lrm: '\u200E',
  	    rlm: '\u200F',
  	    ndash: '\u2013',
  	    mdash: '\u2014',
  	    lsquo: '\u2018',
  	    rsquo: '\u2019',
  	    sbquo: '\u201A',
  	    ldquo: '\u201C',
  	    rdquo: '\u201D',
  	    bdquo: '\u201E',
  	    dagger: '\u2020',
  	    Dagger: '\u2021',
  	    bull: '\u2022',
  	    hellip: '\u2026',
  	    permil: '\u2030',
  	    prime: '\u2032',
  	    Prime: '\u2033',
  	    lsaquo: '\u2039',
  	    rsaquo: '\u203A',
  	    oline: '\u203E',
  	    frasl: '\u2044',
  	    euro: '\u20AC',
  	    image: '\u2111',
  	    weierp: '\u2118',
  	    real: '\u211C',
  	    trade: '\u2122',
  	    alefsym: '\u2135',
  	    larr: '\u2190',
  	    uarr: '\u2191',
  	    rarr: '\u2192',
  	    darr: '\u2193',
  	    harr: '\u2194',
  	    crarr: '\u21B5',
  	    lArr: '\u21D0',
  	    uArr: '\u21D1',
  	    rArr: '\u21D2',
  	    dArr: '\u21D3',
  	    hArr: '\u21D4',
  	    forall: '\u2200',
  	    part: '\u2202',
  	    exist: '\u2203',
  	    empty: '\u2205',
  	    nabla: '\u2207',
  	    isin: '\u2208',
  	    notin: '\u2209',
  	    ni: '\u220B',
  	    prod: '\u220F',
  	    sum: '\u2211',
  	    minus: '\u2212',
  	    lowast: '\u2217',
  	    radic: '\u221A',
  	    prop: '\u221D',
  	    infin: '\u221E',
  	    ang: '\u2220',
  	    and: '\u2227',
  	    or: '\u2228',
  	    cap: '\u2229',
  	    cup: '\u222A',
  	    int: '\u222B',
  	    there4: '\u2234',
  	    sim: '\u223C',
  	    cong: '\u2245',
  	    asymp: '\u2248',
  	    ne: '\u2260',
  	    equiv: '\u2261',
  	    le: '\u2264',
  	    ge: '\u2265',
  	    sub: '\u2282',
  	    sup: '\u2283',
  	    nsub: '\u2284',
  	    sube: '\u2286',
  	    supe: '\u2287',
  	    oplus: '\u2295',
  	    otimes: '\u2297',
  	    perp: '\u22A5',
  	    sdot: '\u22C5',
  	    lceil: '\u2308',
  	    rceil: '\u2309',
  	    lfloor: '\u230A',
  	    rfloor: '\u230B',
  	    loz: '\u25CA',
  	    spades: '\u2660',
  	    clubs: '\u2663',
  	    hearts: '\u2665',
  	    diams: '\u2666',
  	    lang: '\u27E8',
  	    rang: '\u27E9'
  	};


  /***/ },
  /* 15 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var error_handler_1 = __webpack_require__(10);
  	var scanner_1 = __webpack_require__(12);
  	var token_1 = __webpack_require__(13);
  	var Reader = (function () {
  	    function Reader() {
  	        this.values = [];
  	        this.curly = this.paren = -1;
  	    }
  	    // A function following one of those tokens is an expression.
  	    Reader.prototype.beforeFunctionExpression = function (t) {
  	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
  	            'return', 'case', 'delete', 'throw', 'void',
  	            // assignment operators
  	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
  	            '&=', '|=', '^=', ',',
  	            // binary/unary operators
  	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
  	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
  	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
  	    };
  	    // Determine if forward slash (/) is an operator or part of a regular expression
  	    // https://github.com/mozilla/sweet.js/wiki/design
  	    Reader.prototype.isRegexStart = function () {
  	        var previous = this.values[this.values.length - 1];
  	        var regex = (previous !== null);
  	        switch (previous) {
  	            case 'this':
  	            case ']':
  	                regex = false;
  	                break;
  	            case ')':
  	                var keyword = this.values[this.paren - 1];
  	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
  	                break;
  	            case '}':
  	                // Dividing a function by anything makes little sense,
  	                // but we have to check for that.
  	                regex = false;
  	                if (this.values[this.curly - 3] === 'function') {
  	                    // Anonymous function, e.g. function(){} /42
  	                    var check = this.values[this.curly - 4];
  	                    regex = check ? !this.beforeFunctionExpression(check) : false;
  	                }
  	                else if (this.values[this.curly - 4] === 'function') {
  	                    // Named function, e.g. function f(){} /42/
  	                    var check = this.values[this.curly - 5];
  	                    regex = check ? !this.beforeFunctionExpression(check) : true;
  	                }
  	                break;
  	            default:
  	                break;
  	        }
  	        return regex;
  	    };
  	    Reader.prototype.push = function (token) {
  	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
  	            if (token.value === '{') {
  	                this.curly = this.values.length;
  	            }
  	            else if (token.value === '(') {
  	                this.paren = this.values.length;
  	            }
  	            this.values.push(token.value);
  	        }
  	        else {
  	            this.values.push(null);
  	        }
  	    };
  	    return Reader;
  	}());
  	var Tokenizer = (function () {
  	    function Tokenizer(code, config) {
  	        this.errorHandler = new error_handler_1.ErrorHandler();
  	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
  	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
  	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
  	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
  	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
  	        this.buffer = [];
  	        this.reader = new Reader();
  	    }
  	    Tokenizer.prototype.errors = function () {
  	        return this.errorHandler.errors;
  	    };
  	    Tokenizer.prototype.getNextToken = function () {
  	        if (this.buffer.length === 0) {
  	            var comments = this.scanner.scanComments();
  	            if (this.scanner.trackComment) {
  	                for (var i = 0; i < comments.length; ++i) {
  	                    var e = comments[i];
  	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
  	                    var comment = {
  	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
  	                        value: value
  	                    };
  	                    if (this.trackRange) {
  	                        comment.range = e.range;
  	                    }
  	                    if (this.trackLoc) {
  	                        comment.loc = e.loc;
  	                    }
  	                    this.buffer.push(comment);
  	                }
  	            }
  	            if (!this.scanner.eof()) {
  	                var loc = void 0;
  	                if (this.trackLoc) {
  	                    loc = {
  	                        start: {
  	                            line: this.scanner.lineNumber,
  	                            column: this.scanner.index - this.scanner.lineStart
  	                        },
  	                        end: {}
  	                    };
  	                }
  	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
  	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
  	                this.reader.push(token);
  	                var entry = {
  	                    type: token_1.TokenName[token.type],
  	                    value: this.scanner.source.slice(token.start, token.end)
  	                };
  	                if (this.trackRange) {
  	                    entry.range = [token.start, token.end];
  	                }
  	                if (this.trackLoc) {
  	                    loc.end = {
  	                        line: this.scanner.lineNumber,
  	                        column: this.scanner.index - this.scanner.lineStart
  	                    };
  	                    entry.loc = loc;
  	                }
  	                if (token.type === 9 /* RegularExpression */) {
  	                    var pattern = token.pattern;
  	                    var flags = token.flags;
  	                    entry.regex = { pattern: pattern, flags: flags };
  	                }
  	                this.buffer.push(entry);
  	            }
  	        }
  	        return this.buffer.shift();
  	    };
  	    return Tokenizer;
  	}());
  	exports.Tokenizer = Tokenizer;


  /***/ }
  /******/ ])
  });
  ;
  });

  var esprima$1 = /*@__PURE__*/getDefaultExportFromCjs(esprima);

  function buildGeoSource(geo) {
    return "\nfloat surfaceDistance(vec3 p) {\n\tvec3 normal = vec3(0.0,1.0,0.0);\n\tvec3 mouseIntersect = vec3(0.0,1.0,0.0);\n    float d = 100.0;\n    vec3 op = p;\n".concat(geo, "\n    return scope_0_d;\n}");
  }

  function buildColorSource(col, useLighting) {
    var lgt = useLighting ? '' : '    return scope_0_material.albedo;';
    return "\nvec3 shade(vec3 p, vec3 normal) {\n    float d = 100.0;\n    vec3 op = p;\n\tvec3 lightDirection = vec3(0.0, 1.0, 0.0);\n\tvec3 backgroundColor = vec3(1.0, 1.0, 1.0);\n\tvec3 mouseIntersect = vec3(0.0,1.0,0.0);\n\t#ifdef USE_PBR\n\tMaterial material = Material(vec3(1.0),0.5,0.7,1.0);\n\tMaterial selectedMaterial = Material(vec3(1.0),0.5,0.7,1.0);\n\t#else\n\tfloat light = 1.0;\n\tfloat occ = 1.0;\n    vec3 color = vec3(1.0,1.0,1.0);\n\tvec3 selectedColor = vec3(1.0,1.0,1.0);\n\t#endif\n".concat(col, "\n").concat(lgt, "\n\t#ifdef USE_PBR\n\treturn pbrLighting(\n\t\tworldPos.xyz,\n\t\tnormal,\n\t\tlightDirection,\n\t\tscope_0_material,\n\t\tbackgroundColor\n\t\t);\n\t#else\n\treturn scope_0_material.albedo*simpleLighting(p, normal, lightDirection, );*occ;\n\t#endif\n}");
  } // Converts binary math operators to our own version


  function replaceBinaryOp(syntaxTree) {
    if (_typeof(syntaxTree) === 'object') {
      for (var node in syntaxTree) {
        if (syntaxTree.hasOwnProperty(node)) {
          replaceBinaryOp(syntaxTree[node]);
        }
      }
    }

    if (syntaxTree !== null && syntaxTree['type'] === 'BinaryExpression') {
      var op = syntaxTree['operator'];

      if (op === '*' || op === '/' || op === '-' || op === '+') {
        if (op === '*') {
          syntaxTree['callee'] = {
            type: 'Identifier',
            name: 'mult'
          };
        } else if (op === '/') {
          syntaxTree['callee'] = {
            type: 'Identifier',
            name: 'divide'
          };
        } else if (op === '-') {
          syntaxTree['callee'] = {
            type: 'Identifier',
            name: 'sub'
          };
        } else if (op === '+') {
          syntaxTree['callee'] = {
            type: 'Identifier',
            name: 'add'
          };
        }

        syntaxTree['type'] = 'CallExpression';
        syntaxTree['arguments'] = [syntaxTree['left'], syntaxTree['right']];
        syntaxTree['operator'] = undefined;
      }
    }
  }

  function replaceOperatorOverload(syntaxTree) {
    try {
      if (syntaxTree && _typeof(syntaxTree) === "object") {
        for (var node in syntaxTree) {
          if (syntaxTree.hasOwnProperty(node)) {
            replaceOperatorOverload(syntaxTree[node]);
          }
        }
      }

      if (syntaxTree && _typeof(syntaxTree) === "object" && 'type' in syntaxTree && syntaxTree.type === 'ExpressionStatement' && 'expression' in syntaxTree && syntaxTree.expression.type === 'AssignmentExpression') {
        var op = syntaxTree.expression.operator;

        if (op === '+=' || op === '-=' || op === '/=' || op === '*=' || op === '%=') {
          syntaxTree.expression.operator = "=";
          syntaxTree.expression.right = {
            type: 'BinaryExpression',
            left: syntaxTree.expression.left,
            right: syntaxTree.expression.right
          };

          if (op === '+=') {
            syntaxTree.expression.right.operator = '+';
          } else if (op === '-=') {
            syntaxTree.expression.right.operator = '-';
          } else if (op === '/=') {
            syntaxTree.expression.right.operator = '/';
          } else if (op === '*=') {
            syntaxTree.expression.right.operator = '*';
          } else if (op === '%=') {
            syntaxTree.expression.right.operator = '%';
          }
        }
      }
    } catch (e) {
      console.error(e);
    }
  }

  function replaceSliderInput(syntaxTree) {
    try {
      if (syntaxTree && _typeof(syntaxTree) === "object") {
        for (var node in syntaxTree) {
          if (syntaxTree.hasOwnProperty(node)) {
            replaceSliderInput(syntaxTree[node]);
          }
        }
      }

      if (syntaxTree && _typeof(syntaxTree) === "object" && 'type' in syntaxTree && syntaxTree['type'] === 'VariableDeclaration') {
        var d = syntaxTree['declarations'][0];
        var name = d.id.name;

        if (d && d.init && d.init.callee !== undefined && (d.init.callee.name === 'input' || d.init.callee.name === 'input2D')) {
          d.init.arguments.unshift({
            type: "Literal",
            value: name,
            raw: name
          });
        }
      }
    } catch (e) {
      console.error(e);
    }
  }

  function uniformsToGLSL(uniforms) {
    var uniformsHeader = '';

    for (var i = 0; i < uniforms.length; i++) {
      var uniform = uniforms[i];
      uniformsHeader += "uniform ".concat(uniform.type, " ").concat(uniform.name, ";\n");
    }

    return uniformsHeader;
  }
  function baseUniforms() {
    return [{
      name: 'time',
      type: 'float',
      value: 0.0
    }, {
      name: 'opacity',
      type: 'float',
      value: 1.0
    }, {
      name: '_scale',
      type: 'float',
      value: 1.0
    }, // {name:'sculptureCenter', type: 'vec3', value: [0,0,0]},
    {
      name: 'mouse',
      type: 'vec3',
      value: [0.5, 0.5, 0.5]
    }, {
      name: 'stepSize',
      type: 'float',
      value: 0.85
    }, {
      name: 'resolution',
      type: 'vec2',
      value: [800, 600]
    }];
  }
  function sculptToGLSL(userProvidedSrc) {
    var PI = Math.PI;
    var TWO_PI = Math.PI * 2;
    var TAU = TWO_PI;
    var debug = false;
    var tree = esprima.parse(userProvidedSrc);
    replaceOperatorOverload(tree);
    replaceBinaryOp(tree);
    replaceSliderInput(tree);
    userProvidedSrc = escodegen.generate(tree);

    if (debug) {
      console.log('tree', tree);
    }

    var generatedJSFuncsSource = "";
    var geoSrc = "";
    var colorSrc = "";
    var varCount = 0;
    var primCount = 0;
    var stateCount = 0;
    var useLighting = true;
    var enable2DFlag = false;
    var stateStack = [];
    var uniforms = baseUniforms();
    var stepSizeConstant = 0.85;
    var maxIterations = 300; ////////////////////////////////////////////////////////////
    // Generates JS from headers referenced in the bindings.js
    //

    function box(arg_0, arg_1, arg_2) {
      if (arg_1 !== undefined) {
        ensureScalar('box', arg_0);
        ensureScalar('box', arg_1);
        ensureScalar('box', arg_2);
        applyMode("box(".concat(getCurrentState().p, ", ").concat(collapseToString(arg_0), ", ").concat(collapseToString(arg_1), ", ").concat(collapseToString(arg_2), ")"));
      } else if (arg_0.type === 'vec3') {
        applyMode("box(".concat(getCurrentState().p, ", ").concat(collapseToString(arg_0), ")"));
      } else {
        compileError("'box' accepts either an x, y, z, or a vec3");
      }
    }

    function torus(arg_0, arg_1) {
      overloadVec2GeomFunc('torus', arg_0, arg_1);
    }

    function cylinder(arg_0, arg_1) {
      overloadVec2GeomFunc('cylinder', arg_0, arg_1);
    }

    function overloadVec2GeomFunc(funcName, arg_0, arg_1) {
      if (arg_1 !== undefined) {
        ensureScalar(funcName, arg_0);
        ensureScalar(funcName, arg_1);
        applyMode("".concat(funcName, "(").concat(getCurrentState().p, ", ").concat(collapseToString(arg_0), ", ").concat(collapseToString(arg_1), ")"));
      } else if (arg_0.type === 'vec2') {
        applyMode("".concat(funcName, "(").concat(getCurrentState().p, ", ").concat(collapseToString(arg_0), ")"));
      } else {
        compileError("'".concat(funcName, "' accepts either an x, y or a vec2"));
      }
    }

    var primitivesJS = "";

    for (var _i = 0, _Object$entries = Object.entries(geometryFunctions); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          funcName = _Object$entries$_i[0],
          body = _Object$entries$_i[1];

      var argList = body['args'];
      primitivesJS += "function " + funcName + "(";

      for (var argIdx = 0; argIdx < argList.length; argIdx++) {
        if (argIdx !== 0) primitivesJS += ", ";
        primitivesJS += "arg_" + argIdx;
      }

      primitivesJS += ") {\n";
      var argIdxB = 0;

      var _iterator = _createForOfIteratorHelper(argList),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var argDim = _step.value;

          if (argDim === 1) {
            primitivesJS += "    ensureScalar(\"" + funcName + "\", arg_" + argIdxB + ");\n";
          }

          argIdxB += 1;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      primitivesJS += "    applyMode(\"" + funcName + "(\"+getCurrentState().p+\", \" + ";

      for (var _argIdx = 0; _argIdx < argList.length; _argIdx++) {
        primitivesJS += "collapseToString(arg_" + _argIdx + ") + ";
        if (_argIdx < argList.length - 1) primitivesJS += "\", \" + ";
      }

      primitivesJS += "\")\");\n}\n\n";
    }

    generatedJSFuncsSource += primitivesJS;

    function generateGLSLWrapper(funcJSON) {
      var wrapperSrc = "";

      for (var _i2 = 0, _Object$entries2 = Object.entries(funcJSON); _i2 < _Object$entries2.length; _i2++) {
        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
            _funcName = _Object$entries2$_i[0],
            _body = _Object$entries2$_i[1];

        var _argList = _body['args'];
        var returnType = _body['ret'];
        wrapperSrc += "function " + _funcName + "(";

        for (var _argIdx2 = 0; _argIdx2 < _argList.length; _argIdx2++) {
          if (_argIdx2 !== 0) wrapperSrc += ", ";
          wrapperSrc += "arg_" + _argIdx2;
        }

        wrapperSrc += ") {\n";
        var _argIdxB = 0;

        var _iterator2 = _createForOfIteratorHelper(_argList),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var arg = _step2.value;
            wrapperSrc += "    arg_" + _argIdxB + " = tryMakeNum(arg_" + _argIdxB + ");\n";
            _argIdxB += 1;
          } // debug here

        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        wrapperSrc += "    return new makeVarWithDims(\"" + _funcName + "(\" + ";

        for (var _argIdx3 = 0; _argIdx3 < _argList.length; _argIdx3++) {
          wrapperSrc += "arg_" + _argIdx3 + " + ";
          if (_argIdx3 < _argList.length - 1) wrapperSrc += "\", \" + ";
        }

        wrapperSrc += "\")\", " + returnType + ");\n}\n";
      }

      return wrapperSrc;
    }

    function mix(arg_0, arg_1, arg_2) {
      ensureSameDims('mix', arg_0, arg_1);

      if (arg_2.dims !== 1 && arg_2.dims !== arg_0.dims) {
        compileError("'mix' third argument must be float or match dim of first args");
      }

      ensureScalar('mix', arg_2);
      arg_0 = tryMakeNum(arg_0);
      arg_1 = tryMakeNum(arg_1);
      arg_2 = tryMakeNum(arg_2);
      return new makeVarWithDims("mix(".concat(arg_0, ", ").concat(arg_1, ", ").concat(arg_2, ")"), arg_0.dims);
    }

    function ensureSameDims(funcName) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var dims = args.map(function (arg) {
        return arg.dim;
      });
      var initialDim = dims[0];

      for (var i = 1; i < dims.length; i++) {
        var next = dims[i];

        if (initialDim !== next) {
          compileError("'".concat(funcName, "' argument dimensions do not match"));
        }
      }
    }

    var mathFunctionsJS = generateGLSLWrapper(mathFunctions);
    generatedJSFuncsSource += mathFunctionsJS;
    var builtInOtherJS = generateGLSLWrapper(glslBuiltInOther);
    generatedJSFuncsSource += builtInOtherJS;
    var builtInOneToOneJS = "";

    var _iterator3 = _createForOfIteratorHelper(glslBuiltInOneToOne),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _funcName2 = _step3.value;
        builtInOneToOneJS += "function ".concat(_funcName2, "(x) {\n    x = tryMakeNum(x);\n\t// debug here\n\treturn new makeVarWithDims(\"").concat(_funcName2, "(\" + x + \")\", x.dims);\n}\n");
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    generatedJSFuncsSource += builtInOneToOneJS; ////////////////////////////////////////////////////////////
    //End Auto Generated Code
    // set step size directly

    function setStepSize(val) {
      if (typeof val !== 'number') {
        compileError("setStepSize accepts only a constant number. Was given: '" + val.type + "'");
      }

      stepSizeConstant = val;
    } // set step size on a scale 0-100


    function setGeometryQuality(val) {
      if (typeof val !== 'number') {
        compileError("setGeometryQuality accepts only a constant number between 0 and 100. Was given: '" + val.type + "'");
      }

      stepSizeConstant = 1 - 0.01 * val * 0.995;
    }

    function setMaxIterations(val) {
      if (typeof val !== 'number' || val < 0) {
        compileError("setMaxIterations accepts only a constant number >= 0. Was given: '" + val.type + "'");
      }

      maxIterations = Math.round(val);
    }

    function getCurrentState() {
      return stateStack[stateStack.length - 1];
    }

    function getCurrentMode() {
      return getCurrentState().mode;
    }

    function getCurrentDist() {
      return getCurrentState().id + "d";
    }

    function getCurrentPos() {
      return getCurrentState().id + "p";
    }

    function getMainMaterial() {
      return getCurrentState().id + "material";
    }

    function getCurrentMaterial() {
      return getCurrentState().id + "currentMaterial";
    }

    function appendSources(source) {
      geoSrc += "    " + source;
      colorSrc += "    " + source;
    }

    function appendColorSource(source) {
      colorSrc += "    " + source;
    } // General Variable class


    function makeVar(source, type, dims, inline) {
      this.type = type;
      this.dims = dims;

      if (inline) {
        this.name = source;
      } else {
        var vname = "v_" + varCount;
        appendSources(this.type + " " + vname + " = " + source + ";\n");
        varCount += 1;
        this.name = vname;
      }

      this.toString = function () {
        return this.name;
      };

      return this;
    } // Need to handle cases like - vec3(v.x, 0.1, mult(0.1, time))


    function float(source, inline) {
      //if (typeof source !== 'string') {
      source = collapseToString(source); //}

      return new makeVar(source, 'float', 1, inline);
    }

    function vec2(source, y, inline) {
      if (y === undefined) {
        y = source;
      }

      if (typeof source !== 'string') {
        source = "vec2(" + collapseToString(source) + ", " + collapseToString(y) + ")";
      }

      var self = new makeVar(source, 'vec2', 2, inline);
      var currX = new makeVarWithDims(self.name + ".x", 1, true);
      var currY = new makeVarWithDims(self.name + ".y", 1, true);
      var objs = {
        'x': currX,
        'y': currY
      };
      applyVectorAssignmentOverload(self, objs);
      return self;
    }

    function vec3(source, y, z, inline) {
      if (y === undefined) {
        y = source;
        z = source;
      }

      if (typeof source !== 'string') {
        source = "vec3(" + collapseToString(source) + ", " + collapseToString(y) + ", " + collapseToString(z) + ")";
      }

      var self = new makeVar(source, 'vec3', 3, inline);
      var currX = new makeVarWithDims(self.name + ".x", 1, true);
      var currY = new makeVarWithDims(self.name + ".y", 1, true);
      var currZ = new makeVarWithDims(self.name + ".z", 1, true);
      var objs = {
        'x': currX,
        'y': currY,
        'z': currZ
      };
      applyVectorAssignmentOverload(self, objs);
      return self;
    }

    function vec4(source, y, z, w, inline) {
      if (y === undefined && z === undefined) {
        y = source;
        z = source;
        w = source;
      }

      if (typeof source !== 'string') {
        source = "vec4(" + collapseToString(source) + ", " + collapseToString(y) + ", " + collapseToString(z) + ", " + collapseToString(w) + ")";
      }

      var self = new makeVar(source, 'vec4', 4, inline);
      var currX = new makeVarWithDims(self.name + ".x", 1, true);
      var currY = new makeVarWithDims(self.name + ".y", 1, true);
      var currZ = new makeVarWithDims(self.name + ".z", 1, true);
      var currW = new makeVarWithDims(self.name + ".w", 1, true);
      var objs = {
        'x': currX,
        'y': currY,
        'z': currZ,
        'w': currW
      };
      applyVectorAssignmentOverload(self, objs);
      return self;
    } // allows the user to re-assign a vector's components


    function applyVectorAssignmentOverload(self, objs) {
      Object.entries(objs).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            func = _ref2[1];

        Object.defineProperty(self, key, {
          get: function get() {
            return func;
          },
          set: function set(val) {
            return appendSources("".concat(self.name, ".").concat(key, " = ").concat(val, ";\n"));
          }
        });
      });
    }

    function makeVarWithDims(source, dims, inline) {
      if (dims < 1 || dims > 4) compileError("Tried creating variable with dim: " + dims);
      if (dims === 1) return new float(source, inline);
      if (dims === 2) return new vec2(source, null, inline);
      if (dims === 3) return new vec3(source, null, null, inline);
      if (dims === 4) return new vec4(source, null, null, null, inline);
    } // Modes enum


    var modes = {
      UNION: 10,
      DIFFERENCE: 11,
      INTERSECT: 12,
      BLEND: 13,
      MIXGEO: 14
    };
    var additiveModes = [modes.UNION, modes.BLEND, modes.MIXGEO];
    var time = new float("time", true);
    var mouse = new vec3("mouse", null, null, true);
    var normal = new vec3("normal", null, null, true);

    function mouseIntersection() {
      appendColorSource("mouseIntersect = mouseIntersection();\n");
      return new vec3("mouseIntersect", null, null, true);
    }

    function getRayDirection() {
      return new vec3("getRayDirection()", null, null, false);
    }

    function compileError(err) {
      // todo: throw actual error (and color error?)
      console.error(err, " char: " + geoSrc.length);
      throw err;
    }

    function ensureScalar(funcName, val) {
      var tp = _typeof(val);

      if (typeof val !== 'number' && val.type !== 'float') {
        compileError("'" + funcName + "'" + " accepts only a scalar. Was given: '" + val.type + "'");
      }
    }

    function ensureGroupOp(funcName, a, b) {
      if (typeof a !== 'string' && typeof b !== 'string') {
        if (a.dims !== 1 && b.dims !== 1 && a.dims !== b.dims) {
          compileError("'" + funcName + "'" + " dimension mismatch. Was given: '" + a.type + "' and '" + b.type + "'");
        }
      }
    }

    function collapseToString(val) {
      if (typeof val === 'string') {
        return val;
      } else if (typeof val === 'number') {
        return val.toFixed(8);
      } else {
        return val.toString();
      }
    } // Modes (prepend these with GEO or something to indicate they are geometry modes?)
    // Also 'mix' name needs to be changed to avoid collision with built in


    function union() {
      stateStack[stateStack.length - 1].mode = modes.UNION;
    }

    function difference() {
      stateStack[stateStack.length - 1].mode = modes.DIFFERENCE;
    }

    function intersect() {
      stateStack[stateStack.length - 1].mode = modes.INTERSECT;
    }

    function blend(amount) {
      stateStack[stateStack.length - 1].mode = modes.BLEND;
      ensureScalar("blend", amount);
      stateStack[stateStack.length - 1].blendAmount = amount;
    }

    function mixGeo(amount) {
      stateStack[stateStack.length - 1].mode = modes.MIXGEO;
      ensureScalar("mixGeo", amount);
      stateStack[stateStack.length - 1].mixAmount = amount;
    }

    function getMode() {
      switch (getCurrentState().mode) {
        case modes.UNION:
          return ["add"];
          break;

        case modes.DIFFERENCE:
          return ["subtract"];
          break;

        case modes.INTERSECT:
          return ["intersect"];
          break;

        case modes.BLEND:
          return ["smoothAdd", getCurrentState().blendAmount];
          break;

        case modes.MIXGEO:
          return ["mix", getCurrentState().mixAmount];
          break;

        default:
          return ["add"];
      }
    }

    function applyMode(prim, finalCol) {
      var cmode = getMode();
      var primName = "prim_" + primCount;
      primCount += 1;
      appendSources("float " + primName + " = " + prim + ";\n");

      if (additiveModes.includes(getCurrentState().mode)) {
        var selectedCC = finalCol !== undefined ? finalCol : getCurrentMaterial();
        appendColorSource("if (" + primName + " < " + getCurrentDist() + ") { " + getMainMaterial() + " = " + selectedCC + "; }\n");
      }

      appendSources(getCurrentDist() + " = " + cmode[0] + "( " + primName + ", " + getCurrentDist() + " " + (cmode.length > 1 ? "," + collapseToString(cmode[1]) : "") + " );\n");
    }

    function getSpace() {
      return makeVarWithDims(getCurrentState().p.name, 3);
    }

    function pushState() {
      stateStack.push({
        id: "scope_" + stateCount + "_",
        mode: modes.UNION,
        blendAmount: 0.0,
        mixAmount: 0.0
      });
      appendSources("float " + getCurrentDist() + " = 100.0;\n");
      var lastP = stateStack.length > 1 ? stateStack[stateStack.length - 2].id + "p" : "p";
      var lastMat = stateStack.length > 1 ? stateStack[stateStack.length - 2].id + "currentMaterial" : "material";
      appendSources("vec3 " + getCurrentPos() + " = " + lastP + ";\n");
      appendColorSource("Material " + getMainMaterial() + " = " + lastMat + ";\n");
      appendColorSource("Material " + getCurrentMaterial() + " = " + lastMat + ";\n");
      stateStack[stateStack.length - 1].p = vec3(stateStack[stateStack.length - 1].id + "p", null, null, true);
      stateCount++;
    }

    function popState() {
      var lastDist = getCurrentDist();
      var lastMaty = getMainMaterial();
      stateStack.pop();
      applyMode(lastDist, lastMaty);
    } // !!! puts initial state on stack, this never comes off !!!


    pushState();

    function shape(func) {
      var makeShape = function makeShape() {
        pushState();
        var output = func.apply(this, arguments);
        popState();
        return output;
      };

      return makeShape;
    }

    function tryMakeNum(v) {
      if (typeof v === 'number') {
        return new float(v);
      } else {
        return v;
      }
    } /// Math ///
    // Group ops


    function mult(a, b) {
      if (typeof a === 'number' && typeof b === 'number') return a * b;
      a = tryMakeNum(a);
      b = tryMakeNum(b);

      if (debug) {
        console.log("multiplying...");
        console.log("a: ", a);
        console.log("b: ", b);
      }

      ensureGroupOp("mult", a, b);
      var dims = Math.max(a.dims, b.dims);
      return new makeVarWithDims("(" + collapseToString(a) + "*" + collapseToString(b) + ")", dims);
    }

    function add(a, b) {
      if (typeof a === 'number' && typeof b === 'number') return a + b;
      a = tryMakeNum(a);
      b = tryMakeNum(b);

      if (debug) {
        console.log("adding...");
        console.log("a: ", a);
        console.log("b: ", b);
      }

      ensureGroupOp("add", a, b);
      var dims = Math.max(a.dims, b.dims);
      return new makeVarWithDims("(" + collapseToString(a) + "+" + collapseToString(b) + ")", dims);
    }

    function sub(a, b) {
      if (typeof a === 'number' && typeof b === 'number') return a - b;
      a = tryMakeNum(a);
      b = tryMakeNum(b);

      if (debug) {
        console.log("subtracting...");
        console.log("a: ", a);
        console.log("b: ", b);
      }

      ensureGroupOp("sub", a, b);
      var dims = Math.max(a.dims, b.dims);
      return new makeVarWithDims("(" + collapseToString(a) + "-" + collapseToString(b) + ")", dims);
    }

    function divide(a, b) {
      if (typeof a === 'number' && typeof b === 'number') return a / b;
      a = tryMakeNum(a);
      b = tryMakeNum(b);

      if (debug) {
        console.log("dividing...");
        console.log("a: ", a);
        console.log("b: ", b);
      }

      ensureGroupOp("divide", a, b);
      var dims = Math.max(a.dims, b.dims);
      return new makeVarWithDims("(" + collapseToString(a) + "/" + collapseToString(b) + ")", dims);
    }

    function setSDF(dist) {
      ensureScalar("setSDF", dist);
      applyMode(collapseToString(dist));
    }

    function getSDF() {
      return float(getCurrentDist(), true);
    } // Displacements


    function reset() {
      if (stateStack.length > 1) {
        appendSources(getCurrentPos() + " = " + stateStack[stateStack.length - 2].id + "p;\n");
      } else {
        appendSources(getCurrentPos() + " = op;\n");
      }
    }

    function displace(xc, yc, zc) {
      if (yc === undefined || zc === undefined) {
        appendSources(getCurrentPos() + " -= " + collapseToString(xc) + ";\n");
      } else {
        ensureScalar("displace", xc);
        ensureScalar("displace", yc);
        ensureScalar("displace", zc);
        appendSources(getCurrentPos() + " -= vec3( " + collapseToString(xc) + ", " + collapseToString(yc) + ", " + collapseToString(zc) + ");\n");
      }
    }

    function setSpace(xc, yc, zc) {
      if (yc === undefined || zc === undefined) {
        appendSources(getCurrentPos() + " = " + collapseToString(xc) + ";\n");
      } else {
        ensureScalar("setSpace", xc);
        ensureScalar("setSpace", yc);
        ensureScalar("setSpace", zc);
        appendSources(getCurrentPos() + " = vec3( " + collapseToString(xc) + ", " + collapseToString(yc) + ", " + collapseToString(zc) + ");\n");
      }
    }

    function repeat(spacing, repetitions) {
      var spc = collapseToString(spacing);
      var reps = collapseToString(repetitions);
      appendSources(getCurrentPos() + " = " + getCurrentPos() + "-" + spc + "*clamp(round(" + getCurrentPos() + "/" + spc + "),-" + reps + " ," + reps + ");\n");
    }

    function rotateX(angle) {
      ensureScalar("rotateX", angle);
      appendSources(getCurrentPos() + ".yz = " + getCurrentPos() + ".yz*rot2(" + collapseToString(angle) + ");\n");
    }

    function rotateY(angle) {
      ensureScalar("rotateY", angle);
      appendSources(getCurrentPos() + ".xz = " + getCurrentPos() + ".xz*rot2(" + collapseToString(angle) + ");\n");
    }

    function rotateZ(angle) {
      ensureScalar("rotateZ", angle);
      appendSources(getCurrentPos() + ".xy = " + getCurrentPos() + ".xy*rot2(" + collapseToString(angle) + ");\n");
    }

    function mirrorX() {
      appendSources(getCurrentPos() + ".x = abs(" + getCurrentPos() + ".x);\n");
    }

    function mirrorY() {
      appendSources(getCurrentPos() + ".y = abs(" + getCurrentPos() + ".y);\n");
    }

    function mirrorZ() {
      appendSources(getCurrentPos() + ".z = abs(" + getCurrentPos() + ".z);\n");
    }

    function mirrorXYZ() {
      appendSources(getCurrentPos() + " = abs(" + getCurrentPos() + ");\n");
    }

    function flipX() {
      appendSources(getCurrentPos() + ".x = -" + getCurrentPos() + ".x;\n");
    }

    function flipY() {
      appendSources(getCurrentPos() + ".y = -" + getCurrentPos() + ".y;\n");
    }

    function flipZ() {
      appendSources(getCurrentPos() + ".z = -" + getCurrentPos() + ".z;\n");
    }

    function expand(amount) {
      ensureScalar("expand", amount);
      appendSources(getCurrentDist() + " -= " + collapseToString(amount) + ";\n");
    }

    function shell(depth) {
      ensureScalar("shell", depth);
      appendSources(getCurrentDist() + " = shell( " + getCurrentDist() + "," + collapseToString(depth) + ");\n");
    } // Color/Lighting


    function color(col, green, blue) {
      if (green !== undefined) {
        ensureScalar("color", col);
        ensureScalar("color", green);
        ensureScalar("color", blue);
        appendColorSource(getCurrentMaterial() + ".albedo = vec3(" + collapseToString(col) + ", " + collapseToString(green) + ", " + collapseToString(blue) + ");\n");
      } else {
        if (col.type !== 'vec3') compileError("albedo must be vec3");
        appendColorSource(getCurrentMaterial() + ".albedo = " + collapseToString(col) + ";\n");
      }
    }

    function metal(val) {
      ensureScalar("metal", val);
      appendColorSource(getCurrentMaterial() + ".metallic = " + collapseToString(val) + ";\n");
    }

    function shine(val) {
      ensureScalar("shine", val);
      appendColorSource(getCurrentMaterial() + ".roughness = 1.0-" + collapseToString(val) + ";\n");
    }

    function lightDirection(x, y, z) {
      if (y === undefined || z === undefined) {
        appendColorSource("lightDirection = " + collapseToString(x) + ";\n");
      } else {
        ensureScalar("lightDirection", x);
        ensureScalar("lightDirection", y);
        ensureScalar("lightDirection", z);
        appendColorSource("lightDirection = vec3( " + collapseToString(x) + ", " + collapseToString(y) + ", " + collapseToString(z) + ");\n");
      }
    }

    function backgroundColor(x, y, z) {
      if (y === undefined || z === undefined) {
        appendColorSource("backgroundColor = " + collapseToString(x) + ";\n");
      } else {
        ensureScalar("backgroundColor", x);
        ensureScalar("backgroundColor", y);
        ensureScalar("backgroundColor", z);
        appendColorSource("backgroundColor = vec3( " + collapseToString(x) + ", " + collapseToString(y) + ", " + collapseToString(z) + ");\n");
      }
    } // should this also be 'op'? 


    function noLighting() {
      useLighting = false;
    } // replaced with a noop for now to prevent errors


    function basicLighting() {}

    function occlusion(amount) {
      var amt = "1.0";

      if (amount !== undefined) {
        ensureScalar("occlusion", amount);
        amt = collapseToString(amount);
      }

      appendColorSource(getCurrentMaterial() + ".ao = mix(1.0, occlusion(op,normal), " + amt + ");\n");
    }

    function test() {
      appendSources("//this is a test\n");
    }

    function input(name) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;
      var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0;
      var max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;

      if (typeof value !== 'number' || typeof min !== 'number' || typeof max !== 'number') {
        compileError('input value, min, and max must be constant numbers');
      }

      uniforms.push({
        name: name,
        type: 'float',
        value: value,
        min: min,
        max: max
      });
      return new float(name, true);
    }

    function input2D(name) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        x: 0.0,
        y: 0.0
      };
      var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        x: 0.0,
        y: 0.0
      };
      var max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        x: 1.0,
        y: 1.0
      };

      if (typeof value === 'number' && typeof min === 'number' && _typeof(max) === 'object') {
        // syntax input2D(.2, 1.2);
        var x = value;
        var y = min;
        uniforms.push({
          name: name,
          type: 'vec2',
          value: {
            x: x,
            y: y
          },
          min: {
            x: 0,
            y: 0
          },
          max: {
            x: 1,
            y: 1
          }
        });
        return new vec2(name, true);
      }

      if (_typeof(value) !== 'object' || _typeof(min) !== 'object' || _typeof(max) !== 'object') {
        compileError('input2D: value, min, and max must be a vec2');
      }

      var xyExist = [value, min, max].reduce(function (acc, curr) {
        return acc && 'x' in curr && 'y' in curr;
      });

      if (!xyExist) {
        compileError('input2D: value, min, and max must be a vec2');
      }

      uniforms.push({
        name: name,
        type: 'vec2',
        value: value,
        min: min,
        max: max
      });
      return new vec2(name, true);
    }

    function getPixelCoord() {
      return makeVarWithDims('gl_FragCoord.xy', 2, true);
    }

    function getResolution() {
      return makeVarWithDims('resolution', 2, true);
    }

    function get2DCoords() {
      return makeVarWithDims('vec2((gl_FragCoord.x/resolution.x-0.5)*(resolution.x/resolution.y),gl_FragCoord.y/resolution.y-0.5)', 2, false);
    }

    function enable2D() {
      setMaxIterations(0);
      noLighting();
      enable2DFlag = true;
      return get2DCoords();
    }
    /*
    function input2(name, x, y) {
    	console.log('input2',name, x, y);
    	let uniform = {name, type: 'vec2'};
    	let out = x;
    	if(y === undefined) {
    		uniform.value = x;
    	} else {
    		out = new vec2(x, y, true);
    		uniform.value = out;
    	}
    	uniforms.push(uniform);
    	return out;
    }
    */


    var error = undefined;

    function getSpherical() {
      return toSpherical(getSpace());
    } // Define any code that needs to reference auto generated from bindings.js code here


    var postGeneratedFunctions = [getSpherical].map(function (el) {
      return el.toString();
    }).join('\n');
    eval(generatedJSFuncsSource + postGeneratedFunctions + userProvidedSrc);

    if (enable2DFlag) {
      setSDF(0);
    }

    var geoFinal = buildGeoSource(geoSrc);
    var colorFinal = buildColorSource(colorSrc, useLighting);
    return {
      uniforms: uniforms,
      stepSizeConstant: stepSizeConstant,
      maxIterations: maxIterations,
      geoGLSL: geoFinal,
      colorGLSL: colorFinal,
      error: error
    };
  }

  var defaultFragSourceGLSL = "float surfaceDistance(vec3 p) {\n    float d = sphere(p, 0.3);\n\treturn d;\n}\n\nvec3 shade(vec3 p, vec3 normal) {\n    vec3 lightDirection = vec3(0.0, 1.0, 0.0);\n    float light = simpleLighting(p, normal, lightDirection);\n    vec3 color = vec3(1.0, 1.0, 1.0);\n\treturn color*light;\n}\n";
  var threeJSVertexSource = "\nvarying vec4 worldPos;\n//varying vec2 vUv;\nvarying vec3 sculptureCenter;\nvoid main()\n{\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    worldPos = modelMatrix*vec4(position,1.0);\n    sculptureCenter = (modelMatrix * vec4(0., 0., 0., 1.)).xyz;\n    //vUv = uv;\n    gl_Position = projectionMatrix * mvPosition;\n}\n";
  var minimalVertexSource = "\nattribute vec3 coordinates;\nvarying vec3 sculptureCenter;\nvoid main(void) {\n     sculptureCenter = vec3(0.0);\n     gl_Position = vec4(coordinates, 1.0);\n}";
  var threeHeader = "\n#define GLSL_NEED_ROUND\nuniform mat4 projectionMatrix;\nuniform sampler2D msdf;\n\n//varying vec2 vUv;\nvarying vec4 worldPos;\nvarying vec3 sculptureCenter;\n";
  var minimalHeader = "\nprecision highp float;\n#define GLSL_NEED_ROUND\nuniform mat4 projectionMatrix;\nvarying vec3 sculptureCenter;\n#define cameraPosition vec3(0.0,0.0,-2.0)\n#define vUv vec2(0.0)\n#define worldPos vec4(vec2((gl_FragCoord.x/resolution.x-0.5)*(resolution.x/resolution.y),gl_FragCoord.y/resolution.y-0.5)*1.75,0.0,0.0)\n";
  var usePBRHeader = '#define USE_PBR\n';
  var useHemisphereLight = '#define HEMISPHERE_LIGHT\n';
  var sculptureStarterCode = "\nfloat surfaceDistance(vec3 p);\n\nconst float PI = 3.14159265;\nconst float TAU = PI*2.0;\nconst float TWO_PI = TAU;\n\nconst float max_dist = 100.0;\nconst float intersection_threshold = 0.00001;\n\nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    float ao;\n};\n\n// Trig functions normalized to the range 0.0-1.0\nfloat nsin(float x) {\n    return sin(x)*0.5+0.5;\n}\n\nfloat ncos(float x) {\n    return cos(x)*0.5+0.5;\n}\n\n#ifdef GLSL_NEED_ROUND\nfloat round(float x) {\n    return floor(x+0.5);\n}\nvec2 round(vec2 x) {\n    return floor(x+0.5);\n}\nvec3 round(vec3 x) {\n    return floor(x+0.5);\n}\nvec4 round(vec4 x) {\n    return floor(x+0.5);\n}\n#endif\n\nfloat softSquare(float x, int pw) {\n    return 1.0/(pow(tan(x),float(pw+1)*2.0)+1.0);\n}\n\n// Simple oscillators \n\nfloat osc(float freq, float amp, float base, float phase) {\n    return base+amp*sin(TWO_PI*(freq*time+phase));\n}\n\nfloat osc(float freq, float amp, float base) {\n    return osc(freq, amp, base, 0.0);\n}\n\nfloat osc(float freq, float amp) {\n    return osc(freq, amp, 1.0);\n}\n\nfloat osc(float freq) {\n    return osc(freq, 0.5);\n}\n\nfloat osc() {\n    return osc(1.0);\n}\n\n// Color Conversion\n// https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( vec3 c)\n{\n    const float eps = 0.0000001;\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\n\n// Primitives\n\nfloat line(vec3 p, vec3 a, vec3 b) {\n\tvec3 pa = p-a;\n  \tvec3 ba = b-a;\n\tfloat t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  \treturn length(pa - ba*t);\n}\n\n//line with radius\nfloat line( vec3 p, vec3 a, vec3 b, float radius ){\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - radius;\n}\n\nfloat sphere( vec3 p, float size ){\n  return length(p)-size;\n}\n\nfloat uBox( vec3 p, vec3 b ){\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat uRoundBox( vec3 p, vec3 b, float r ){\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat box( vec3 p, vec3 box ){\n  vec3 d = abs(p) - box;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat box( vec3 p, float bx, float by, float bz) {\n    vec3 box = vec3(bx,by,bz);\n    vec3 d = abs(p) - box;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat roundedBox( vec3 p, vec3 box , float r){\n  return length(max(abs(p)-box,0.0))-r;\n}\n\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat torus( vec3 p, float tx, float ty ){\n    vec2 q = vec2(length(p.xz)-tx,p.y);\n    return length(q)-ty;\n}\n\nfloat infCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat cylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylinder( vec3 p, float hx, float hy)\n{\n    return cylinder(p, vec2(hx,hy));\n}\n\nfloat cone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat plane( vec3 p, float nx, float ny, float nz, float nw)\n{\n  // n must be normalized\n  return dot(p,normalize(vec3(nx,ny,nz))) + nw;\n}\n\nfloat hexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat triPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat triangularPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat cappedCone( vec3 p, vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat roundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    vec3 rv = pa*l2 - ba*y;\n    float x2 = dot(rv,rv);\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat ellipsoid( vec3 p, vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nvec3 toSpherical(vec3 p) {\n    float phi = atan(p.x,p.z);\n    float r = length(p);\n    float theta = acos(-p.y/r);\n    return vec3(r,theta,phi);\n}\n\nvec3 fromSpherical(vec3 p) {\n    return vec3(p.x*sin(p.y)*cos(p.z), p.x*sin(p.y)*sin(p.z), p.x*cos(p.y));\n}\n\nfloat dot2( vec3 v ) { return dot(v,v); }\n\nfloat uTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat add( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat add(float d1, float d2, float d3) {\n   return min(d1, min(d2,d3));\n}\n\nfloat add(float d1, float d2, float d3, float d4) {\n    return min(min(d1,d2),min(d3,d4));\n}\n\nfloat add(float d1, float d2, float d3, float d4, float d5) {\n    return min(min(min(d1,d2), min(d3,d4)),d5);\n}\n\nfloat add(float d1, float d2, float d3, float d4, float d5, float d6) {\n    return min(min(min(d1,d2),min(d3,d4)),min(d5,d6));\n}\n\nfloat add(float d1, float d2, float d3, float d4, float d5, float d6, float d7) {\n    return min(min(min(d1,d2),min(d3,d4)),min(min(d5,d6),d7));\n}\n\nfloat subtract( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat intersect( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat shell(float d, float thickness) {\n    return abs(d)-thickness;\n}\n\nvec3 repeat3D(vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat repeat1D(float p, float size)\n{\n\tfloat halfSize = size * 0.5;\n\tfloat c = floor((p + halfSize) / size);\n  \tp = mod(p + halfSize, size)-halfSize;\n  \treturn c;\n}\n\nmat2 rot2(float a){\n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// polynomial smooth min (k = 0.1) (from IQ)\nfloat smoothAdd( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smoothSubtract(float a,float b, float k)\n{\n    return -smoothAdd(-a,-b,k);\n}\n\nvec2 _hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,_hash(i+0.0)), dot(b,_hash(i+o)), dot(c,_hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvec3 _hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// simplex noise from https://www.shadertoy.com/view/4sc3z2\nfloat noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    // thx nikita: https://www.shadertoy.com/view/XsX3zB\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, _hash33(i)), dot(d1, _hash33(i + i1)), dot(d2, _hash33(i + i2)), dot(d3, _hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat fractalNoise(vec3 p, float falloff, int iterations) {\n    float v = 0.0;\n    float amp = 1.0;\n    float invFalloff = 1.0/falloff;\n    for (int i=0; i<10; i++) {\n        v += noise(p)*amp;\n\tif (i>=iterations) break;\n        amp *= invFalloff;\n        p *= falloff;\n    }\n    return v;\n} \n\nfloat fractalNoise(vec3 p) {\n    return fractalNoise(p, 2.0, 5);\n}\n\n// Adapted from IQ's usage at https://www.shadertoy.com/view/lllXz4\n// Spherical Fibonnacci points, Benjamin Keinert, Matthias Innmann,\n// Michael Sanger and Marc Stamminger\n\nconst float PHI = 1.61803398875;\n\nvec4 sphericalDistribution( vec3 p, float n )\n{\n    p = normalize(p);\n    float m = 1.0 - 1.0/n;\n\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n\n    float k = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2 F = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );\n\n    mat2 iB = mat2( ka.y, -ka.x,\n    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n\n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    vec3 bestQ = vec3(0.0,0.0,8.0);\n    for( int s=0; s<4; s++ )\n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n\n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n\n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d)\n        {\n            d = squaredDistance;\n            j = i;\n            bestQ = q;\n        }\n    }\n    return vec4(bestQ,sqrt(d));\n}\n\n// Compute intersection of ray and SDF. You probably won't need to modify this.\nfloat intersect(vec3 ro, vec3 rd, float stepFraction) {\n    float t = 0.0;\n\tfor(int i = 0; i < MAX_ITERATIONS; ++i) {\n\t\tfloat h = surfaceDistance((ro+rd*t));\n\t\tif(h < intersection_threshold || t > max_dist) break;\n\t\tt += h*STEP_SIZE_CONSTANT;\n    }\n\treturn t;\n}\n\nvec3 getRayDirection() {\n\treturn normalize(worldPos.xyz-cameraPosition);\n}\n\nvec3 mouseIntersection() {\n    vec3 rayDirection = getRayDirection();\n    return mouse+rayDirection*intersect(mouse, rayDirection, 0.8);\n}\n\n// Calculate the normal of a SDF\nvec3 calcNormal( vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.0005;\n    return normalize( e.xyy*surfaceDistance( pos + e.xyy ) + \n\t\t      e.yyx*surfaceDistance( pos + e.yyx ) + \n\t\t      e.yxy*surfaceDistance( pos + e.yxy ) + \n\t\t      e.xxx*surfaceDistance( pos + e.xxx ) );\n}\n\n// from https://learnopengl.com/PBR/Lighting\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\n// adapted from https://learnopengl.com/PBR/Lighting\nvec3 pbrLighting(vec3 WordPos, vec3 N, vec3 lightdir, Material mat, vec3 backgroundColor) {\n\n    vec3 V = -getRayDirection();\n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, mat.albedo, mat.metallic);\n\t\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n\n    // calculate per-light radiance\n    vec3 L = normalize(lightdir);\n    vec3 H = normalize(V + L);        \n    \n    // cook-torrance brdf\n    float NDF = DistributionGGX(N, H, mat.roughness);        \n    float G   = GeometrySmith(N, V, L, mat.roughness);      \n    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n\n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - mat.metallic;\t  \n    \n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n    vec3 specular     = numerator / max(denominator, 0.001);  \n    \n    // add to outgoing radiance Lo\n    float NdotL = max(dot(N, L), 0.0);                \n    Lo += (kD * mat.albedo / PI + specular) * NdotL;  \n  \n    float hemi = 1.0;\n    #ifdef HEMISPHERE_LIGHT\n    // ground is black, taken into account by ambient light\n    hemi = NdotL*1.25;\n    #endif\n\n    vec3 ambient = (vec3(1.2+hemi) * mat.albedo) * mat.ao;\n    vec3 color = ambient + Lo*1.7;\n    \n    /// this section adds edge glow as if there were a white env map ///\n    /// there should probably be a way to disable it //\n    float lt = 1.0-max(dot(N,V),0.0);\n    lt = pow(lt,6.0);\n    color += 16.0*lt*(0.2+mat.albedo)*mat.metallic*backgroundColor*(1.3-mat.roughness);\n    ///\n    \n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));\n   \n    return color;\n}\n\nfloat simpleLighting(vec3 p, vec3 normal, vec3 lightdir) {\n    // Simple phong-like shading\n    float value = clamp(dot(normal, normalize(lightdir)),0.0, 1.0);\n    return value * 0.3 + 0.7;\n}\n\nfloat specularLighting(vec3 p, vec3 normal, vec3 lightDirection, float shine) {\n    float lamb = clamp(dot(normal,normalize(lightDirection)),0.0,1.0);\n    float spec = pow(lamb, exp(10.0*shine));\n    lamb = 0.4*lamb + 0.4 + 0.2*spec;\n    return lamb;\n}\n\nfloat shadow(vec3 p, vec3 lightDirection, float amount) {\n    float t = intersect(p+0.001*lightDirection, lightDirection, stepSize);\n    return t < (max_dist - 0.1) ? 1.0-amount : 1.0;\n}\n\n// From https://www.shadertoy.com/view/XslSWl\nfloat occlusion(vec3 p,vec3 n) { \n    const int AO_SAMPLES = 8;\n    const float INV_AO_SAMPLES = 1.0/float(AO_SAMPLES);\n    const float R = 0.9;\n    const float D = 0.8;\n    float r = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.05+f*R;\n        float d = surfaceDistance(p + n * h) - 0.003;\n        r += clamp(h*D-d,0.0,1.0) * (1.0-f);\n    }    \n    return clamp(1.0-r,0.0,1.0);\n}\n";
  var fragFooter = "\n// For advanced users //\nvoid main() {\n\n    vec3 rayOrigin = (cameraPosition - sculptureCenter) / max(intersection_threshold, _scale);\n    vec3 rayDirection = getRayDirection();\n    float t = intersect(rayOrigin, rayDirection, stepSize);\n    if(t < max_dist) {\n        vec3 p = (rayOrigin + rayDirection*t);\n        //vec4 sp = projectionMatrix*viewMatrix*vec4(p,1.0); //could be used to set FragDepth\n        vec3 normal = calcNormal(p);\n        // p *= _scale;\n        vec3 col = shade(p, normal);\n        gl_FragColor = vec4(col, opacity);\n        \n    } else {\n        discard;\n    }\n}\n";

  /**
   * @license
   * Copyright 2010-2021 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  const REVISION = '129';
  const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
  const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
  const CullFaceNone = 0;
  const CullFaceBack = 1;
  const CullFaceFront = 2;
  const CullFaceFrontBack = 3;
  const BasicShadowMap = 0;
  const PCFShadowMap = 1;
  const PCFSoftShadowMap = 2;
  const VSMShadowMap = 3;
  const FrontSide = 0;
  const BackSide = 1;
  const DoubleSide = 2;
  const FlatShading = 1;
  const SmoothShading = 2;
  const NoBlending = 0;
  const NormalBlending = 1;
  const AdditiveBlending = 2;
  const SubtractiveBlending = 3;
  const MultiplyBlending = 4;
  const CustomBlending = 5;
  const AddEquation = 100;
  const SubtractEquation = 101;
  const ReverseSubtractEquation = 102;
  const MinEquation = 103;
  const MaxEquation = 104;
  const ZeroFactor = 200;
  const OneFactor = 201;
  const SrcColorFactor = 202;
  const OneMinusSrcColorFactor = 203;
  const SrcAlphaFactor = 204;
  const OneMinusSrcAlphaFactor = 205;
  const DstAlphaFactor = 206;
  const OneMinusDstAlphaFactor = 207;
  const DstColorFactor = 208;
  const OneMinusDstColorFactor = 209;
  const SrcAlphaSaturateFactor = 210;
  const NeverDepth = 0;
  const AlwaysDepth = 1;
  const LessDepth = 2;
  const LessEqualDepth = 3;
  const EqualDepth = 4;
  const GreaterEqualDepth = 5;
  const GreaterDepth = 6;
  const NotEqualDepth = 7;
  const MultiplyOperation = 0;
  const MixOperation = 1;
  const AddOperation = 2;
  const NoToneMapping = 0;
  const LinearToneMapping = 1;
  const ReinhardToneMapping = 2;
  const CineonToneMapping = 3;
  const ACESFilmicToneMapping = 4;
  const CustomToneMapping = 5;

  const UVMapping = 300;
  const CubeReflectionMapping = 301;
  const CubeRefractionMapping = 302;
  const EquirectangularReflectionMapping = 303;
  const EquirectangularRefractionMapping = 304;
  const CubeUVReflectionMapping = 306;
  const CubeUVRefractionMapping = 307;
  const RepeatWrapping = 1000;
  const ClampToEdgeWrapping = 1001;
  const MirroredRepeatWrapping = 1002;
  const NearestFilter = 1003;
  const NearestMipmapNearestFilter = 1004;
  const NearestMipMapNearestFilter = 1004;
  const NearestMipmapLinearFilter = 1005;
  const NearestMipMapLinearFilter = 1005;
  const LinearFilter = 1006;
  const LinearMipmapNearestFilter = 1007;
  const LinearMipMapNearestFilter = 1007;
  const LinearMipmapLinearFilter = 1008;
  const LinearMipMapLinearFilter = 1008;
  const UnsignedByteType = 1009;
  const ByteType = 1010;
  const ShortType = 1011;
  const UnsignedShortType = 1012;
  const IntType = 1013;
  const UnsignedIntType = 1014;
  const FloatType = 1015;
  const HalfFloatType = 1016;
  const UnsignedShort4444Type = 1017;
  const UnsignedShort5551Type = 1018;
  const UnsignedShort565Type = 1019;
  const UnsignedInt248Type = 1020;
  const AlphaFormat = 1021;
  const RGBFormat = 1022;
  const RGBAFormat = 1023;
  const LuminanceFormat = 1024;
  const LuminanceAlphaFormat = 1025;
  const RGBEFormat = RGBAFormat;
  const DepthFormat = 1026;
  const DepthStencilFormat = 1027;
  const RedFormat = 1028;
  const RedIntegerFormat = 1029;
  const RGFormat = 1030;
  const RGIntegerFormat = 1031;
  const RGBIntegerFormat = 1032;
  const RGBAIntegerFormat = 1033;

  const RGB_S3TC_DXT1_Format = 33776;
  const RGBA_S3TC_DXT1_Format = 33777;
  const RGBA_S3TC_DXT3_Format = 33778;
  const RGBA_S3TC_DXT5_Format = 33779;
  const RGB_PVRTC_4BPPV1_Format = 35840;
  const RGB_PVRTC_2BPPV1_Format = 35841;
  const RGBA_PVRTC_4BPPV1_Format = 35842;
  const RGBA_PVRTC_2BPPV1_Format = 35843;
  const RGB_ETC1_Format = 36196;
  const RGB_ETC2_Format = 37492;
  const RGBA_ETC2_EAC_Format = 37496;
  const RGBA_ASTC_4x4_Format = 37808;
  const RGBA_ASTC_5x4_Format = 37809;
  const RGBA_ASTC_5x5_Format = 37810;
  const RGBA_ASTC_6x5_Format = 37811;
  const RGBA_ASTC_6x6_Format = 37812;
  const RGBA_ASTC_8x5_Format = 37813;
  const RGBA_ASTC_8x6_Format = 37814;
  const RGBA_ASTC_8x8_Format = 37815;
  const RGBA_ASTC_10x5_Format = 37816;
  const RGBA_ASTC_10x6_Format = 37817;
  const RGBA_ASTC_10x8_Format = 37818;
  const RGBA_ASTC_10x10_Format = 37819;
  const RGBA_ASTC_12x10_Format = 37820;
  const RGBA_ASTC_12x12_Format = 37821;
  const RGBA_BPTC_Format = 36492;
  const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
  const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
  const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
  const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
  const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
  const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
  const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
  const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
  const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
  const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
  const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
  const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
  const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
  const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
  const LoopOnce = 2200;
  const LoopRepeat = 2201;
  const LoopPingPong = 2202;
  const InterpolateDiscrete = 2300;
  const InterpolateLinear = 2301;
  const InterpolateSmooth = 2302;
  const ZeroCurvatureEnding = 2400;
  const ZeroSlopeEnding = 2401;
  const WrapAroundEnding = 2402;
  const NormalAnimationBlendMode = 2500;
  const AdditiveAnimationBlendMode = 2501;
  const TrianglesDrawMode = 0;
  const TriangleStripDrawMode = 1;
  const TriangleFanDrawMode = 2;
  const LinearEncoding = 3000;
  const sRGBEncoding = 3001;
  const GammaEncoding = 3007;
  const RGBEEncoding = 3002;
  const LogLuvEncoding = 3003;
  const RGBM7Encoding = 3004;
  const RGBM16Encoding = 3005;
  const RGBDEncoding = 3006;
  const BasicDepthPacking = 3200;
  const RGBADepthPacking = 3201;
  const TangentSpaceNormalMap = 0;
  const ObjectSpaceNormalMap = 1;

  const ZeroStencilOp = 0;
  const KeepStencilOp = 7680;
  const ReplaceStencilOp = 7681;
  const IncrementStencilOp = 7682;
  const DecrementStencilOp = 7683;
  const IncrementWrapStencilOp = 34055;
  const DecrementWrapStencilOp = 34056;
  const InvertStencilOp = 5386;

  const NeverStencilFunc = 512;
  const LessStencilFunc = 513;
  const EqualStencilFunc = 514;
  const LessEqualStencilFunc = 515;
  const GreaterStencilFunc = 516;
  const NotEqualStencilFunc = 517;
  const GreaterEqualStencilFunc = 518;
  const AlwaysStencilFunc = 519;

  const StaticDrawUsage = 35044;
  const DynamicDrawUsage = 35048;
  const StreamDrawUsage = 35040;
  const StaticReadUsage = 35045;
  const DynamicReadUsage = 35049;
  const StreamReadUsage = 35041;
  const StaticCopyUsage = 35046;
  const DynamicCopyUsage = 35050;
  const StreamCopyUsage = 35042;

  const GLSL1 = '100';
  const GLSL3 = '300 es';

  /**
   * https://github.com/mrdoob/eventdispatcher.js/
   */

  class EventDispatcher {

  	addEventListener( type, listener ) {

  		if ( this._listeners === undefined ) this._listeners = {};

  		const listeners = this._listeners;

  		if ( listeners[ type ] === undefined ) {

  			listeners[ type ] = [];

  		}

  		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

  			listeners[ type ].push( listener );

  		}

  	}

  	hasEventListener( type, listener ) {

  		if ( this._listeners === undefined ) return false;

  		const listeners = this._listeners;

  		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

  	}

  	removeEventListener( type, listener ) {

  		if ( this._listeners === undefined ) return;

  		const listeners = this._listeners;
  		const listenerArray = listeners[ type ];

  		if ( listenerArray !== undefined ) {

  			const index = listenerArray.indexOf( listener );

  			if ( index !== - 1 ) {

  				listenerArray.splice( index, 1 );

  			}

  		}

  	}

  	dispatchEvent( event ) {

  		if ( this._listeners === undefined ) return;

  		const listeners = this._listeners;
  		const listenerArray = listeners[ event.type ];

  		if ( listenerArray !== undefined ) {

  			event.target = this;

  			// Make a copy, in case listeners are removed while iterating.
  			const array = listenerArray.slice( 0 );

  			for ( let i = 0, l = array.length; i < l; i ++ ) {

  				array[ i ].call( this, event );

  			}

  			event.target = null;

  		}

  	}

  }

  const _lut = [];

  for ( let i = 0; i < 256; i ++ ) {

  	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

  }

  let _seed = 1234567;


  const DEG2RAD = Math.PI / 180;
  const RAD2DEG = 180 / Math.PI;

  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  function generateUUID() {

  	const d0 = Math.random() * 0xffffffff | 0;
  	const d1 = Math.random() * 0xffffffff | 0;
  	const d2 = Math.random() * 0xffffffff | 0;
  	const d3 = Math.random() * 0xffffffff | 0;
  	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
  			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
  			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
  			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

  	// .toUpperCase() here flattens concatenated strings to save heap memory space.
  	return uuid.toUpperCase();

  }

  function clamp( value, min, max ) {

  	return Math.max( min, Math.min( max, value ) );

  }

  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  function euclideanModulo( n, m ) {

  	return ( ( n % m ) + m ) % m;

  }

  // Linear mapping from range <a1, a2> to range <b1, b2>
  function mapLinear( x, a1, a2, b1, b2 ) {

  	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  }

  // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
  function inverseLerp( x, y, value ) {

  	if ( x !== y ) {

  		return ( value - x ) / ( y - x );

  		 } else {

  		return 0;

  		 }

  }

  // https://en.wikipedia.org/wiki/Linear_interpolation
  function lerp( x, y, t ) {

  	return ( 1 - t ) * x + t * y;

  }

  // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
  function damp( x, y, lambda, dt ) {

  	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

  }

  // https://www.desmos.com/calculator/vcsjnyz7x4
  function pingpong( x, length = 1 ) {

  	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

  }

  // http://en.wikipedia.org/wiki/Smoothstep
  function smoothstep( x, min, max ) {

  	if ( x <= min ) return 0;
  	if ( x >= max ) return 1;

  	x = ( x - min ) / ( max - min );

  	return x * x * ( 3 - 2 * x );

  }

  function smootherstep( x, min, max ) {

  	if ( x <= min ) return 0;
  	if ( x >= max ) return 1;

  	x = ( x - min ) / ( max - min );

  	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  }

  // Random integer from <low, high> interval
  function randInt( low, high ) {

  	return low + Math.floor( Math.random() * ( high - low + 1 ) );

  }

  // Random float from <low, high> interval
  function randFloat( low, high ) {

  	return low + Math.random() * ( high - low );

  }

  // Random float from <-range/2, range/2> interval
  function randFloatSpread( range ) {

  	return range * ( 0.5 - Math.random() );

  }

  // Deterministic pseudo-random float in the interval [ 0, 1 ]
  function seededRandom( s ) {

  	if ( s !== undefined ) _seed = s % 2147483647;

  	// Park-Miller algorithm

  	_seed = _seed * 16807 % 2147483647;

  	return ( _seed - 1 ) / 2147483646;

  }

  function degToRad( degrees ) {

  	return degrees * DEG2RAD;

  }

  function radToDeg( radians ) {

  	return radians * RAD2DEG;

  }

  function isPowerOfTwo( value ) {

  	return ( value & ( value - 1 ) ) === 0 && value !== 0;

  }

  function ceilPowerOfTwo( value ) {

  	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

  }

  function floorPowerOfTwo( value ) {

  	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

  }

  function setQuaternionFromProperEuler( q, a, b, c, order ) {

  	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

  	// rotations are applied to the axes in the order specified by 'order'
  	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
  	// angles are in radians

  	const cos = Math.cos;
  	const sin = Math.sin;

  	const c2 = cos( b / 2 );
  	const s2 = sin( b / 2 );

  	const c13 = cos( ( a + c ) / 2 );
  	const s13 = sin( ( a + c ) / 2 );

  	const c1_3 = cos( ( a - c ) / 2 );
  	const s1_3 = sin( ( a - c ) / 2 );

  	const c3_1 = cos( ( c - a ) / 2 );
  	const s3_1 = sin( ( c - a ) / 2 );

  	switch ( order ) {

  		case 'XYX':
  			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
  			break;

  		case 'YZY':
  			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
  			break;

  		case 'ZXZ':
  			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
  			break;

  		case 'XZX':
  			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
  			break;

  		case 'YXY':
  			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
  			break;

  		case 'ZYZ':
  			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
  			break;

  		default:
  			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

  	}

  }

  var MathUtils = /*#__PURE__*/Object.freeze({
  	__proto__: null,
  	DEG2RAD: DEG2RAD,
  	RAD2DEG: RAD2DEG,
  	generateUUID: generateUUID,
  	clamp: clamp,
  	euclideanModulo: euclideanModulo,
  	mapLinear: mapLinear,
  	inverseLerp: inverseLerp,
  	lerp: lerp,
  	damp: damp,
  	pingpong: pingpong,
  	smoothstep: smoothstep,
  	smootherstep: smootherstep,
  	randInt: randInt,
  	randFloat: randFloat,
  	randFloatSpread: randFloatSpread,
  	seededRandom: seededRandom,
  	degToRad: degToRad,
  	radToDeg: radToDeg,
  	isPowerOfTwo: isPowerOfTwo,
  	ceilPowerOfTwo: ceilPowerOfTwo,
  	floorPowerOfTwo: floorPowerOfTwo,
  	setQuaternionFromProperEuler: setQuaternionFromProperEuler
  });

  class Vector2 {

  	constructor( x = 0, y = 0 ) {

  		this.x = x;
  		this.y = y;

  	}

  	get width() {

  		return this.x;

  	}

  	set width( value ) {

  		this.x = value;

  	}

  	get height() {

  		return this.y;

  	}

  	set height( value ) {

  		this.y = value;

  	}

  	set( x, y ) {

  		this.x = x;
  		this.y = y;

  		return this;

  	}

  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;

  		return this;

  	}

  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	clone() {

  		return new this.constructor( this.x, this.y );

  	}

  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;

  		return this;

  	}

  	add( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;

  		return this;

  	}

  	addScalar( s ) {

  		this.x += s;
  		this.y += s;

  		return this;

  	}

  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;

  		return this;

  	}

  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;

  		return this;

  	}

  	sub( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;

  		return this;

  	}

  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;

  		return this;

  	}

  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;

  		return this;

  	}

  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;

  		return this;

  	}

  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;

  		return this;

  	}

  	divide( v ) {

  		this.x /= v.x;
  		this.y /= v.y;

  		return this;

  	}

  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	applyMatrix3( m ) {

  		const x = this.x, y = this.y;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

  		return this;

  	}

  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );

  		return this;

  	}

  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );

  		return this;

  	}

  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

  		return this;

  	}

  	clampScalar( minVal, maxVal ) {

  		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
  		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

  		return this;

  	}

  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	}

  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );

  		return this;

  	}

  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );

  		return this;

  	}

  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );

  		return this;

  	}

  	roundToZero() {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

  		return this;

  	}

  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;

  		return this;

  	}

  	dot( v ) {

  		return this.x * v.x + this.y * v.y;

  	}

  	cross( v ) {

  		return this.x * v.y - this.y * v.x;

  	}

  	lengthSq() {

  		return this.x * this.x + this.y * this.y;

  	}

  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y );

  	}

  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y );

  	}

  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	angle() {

  		// computes the angle in radians with respect to the positive x-axis

  		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

  		return angle;

  	}

  	distanceTo( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	}

  	distanceToSquared( v ) {

  		const dx = this.x - v.x, dy = this.y - v.y;
  		return dx * dx + dy * dy;

  	}

  	manhattanDistanceTo( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

  	}

  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;

  		return this;

  	}

  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;

  		return this;

  	}

  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) );

  	}

  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;

  		return array;

  	}

  	fromBufferAttribute( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );

  		return this;

  	}

  	rotateAround( center, angle ) {

  		const c = Math.cos( angle ), s = Math.sin( angle );

  		const x = this.x - center.x;
  		const y = this.y - center.y;

  		this.x = x * c - y * s + center.x;
  		this.y = x * s + y * c + center.y;

  		return this;

  	}

  	random() {

  		this.x = Math.random();
  		this.y = Math.random();

  		return this;

  	}

  }

  Vector2.prototype.isVector2 = true;

  class Matrix3 {

  	constructor() {

  		this.elements = [

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		];

  		if ( arguments.length > 0 ) {

  			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

  		}

  	}

  	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		const te = this.elements;

  		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
  		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
  		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

  		return this;

  	}

  	identity() {

  		this.set(

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	copy( m ) {

  		const te = this.elements;
  		const me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
  		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
  		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

  		return this;

  	}

  	extractBasis( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrix3Column( this, 0 );
  		yAxis.setFromMatrix3Column( this, 1 );
  		zAxis.setFromMatrix3Column( this, 2 );

  		return this;

  	}

  	setFromMatrix4( m ) {

  		const me = m.elements;

  		this.set(

  			me[ 0 ], me[ 4 ], me[ 8 ],
  			me[ 1 ], me[ 5 ], me[ 9 ],
  			me[ 2 ], me[ 6 ], me[ 10 ]

  		);

  		return this;

  	}

  	multiply( m ) {

  		return this.multiplyMatrices( this, m );

  	}

  	premultiply( m ) {

  		return this.multiplyMatrices( m, this );

  	}

  	multiplyMatrices( a, b ) {

  		const ae = a.elements;
  		const be = b.elements;
  		const te = this.elements;

  		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
  		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
  		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

  		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
  		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
  		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
  		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
  		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
  		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
  		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
  		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
  		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

  		return this;

  	}

  	multiplyScalar( s ) {

  		const te = this.elements;

  		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
  		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
  		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

  		return this;

  	}

  	determinant() {

  		const te = this.elements;

  		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
  			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
  			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

  		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  	}

  	invert() {

  		const te = this.elements,

  			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
  			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
  			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

  			t11 = n33 * n22 - n32 * n23,
  			t12 = n32 * n13 - n33 * n12,
  			t13 = n23 * n12 - n22 * n13,

  			det = n11 * t11 + n21 * t12 + n31 * t13;

  		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

  		const detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
  		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

  		te[ 3 ] = t12 * detInv;
  		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
  		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

  		te[ 6 ] = t13 * detInv;
  		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
  		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

  		return this;

  	}

  	transpose() {

  		let tmp;
  		const m = this.elements;

  		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
  		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
  		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

  		return this;

  	}

  	getNormalMatrix( matrix4 ) {

  		return this.setFromMatrix4( matrix4 ).invert().transpose();

  	}

  	transposeIntoArray( r ) {

  		const m = this.elements;

  		r[ 0 ] = m[ 0 ];
  		r[ 1 ] = m[ 3 ];
  		r[ 2 ] = m[ 6 ];
  		r[ 3 ] = m[ 1 ];
  		r[ 4 ] = m[ 4 ];
  		r[ 5 ] = m[ 7 ];
  		r[ 6 ] = m[ 2 ];
  		r[ 7 ] = m[ 5 ];
  		r[ 8 ] = m[ 8 ];

  		return this;

  	}

  	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

  		const c = Math.cos( rotation );
  		const s = Math.sin( rotation );

  		this.set(
  			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
  			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
  			0, 0, 1
  		);

  		return this;

  	}

  	scale( sx, sy ) {

  		const te = this.elements;

  		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
  		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

  		return this;

  	}

  	rotate( theta ) {

  		const c = Math.cos( theta );
  		const s = Math.sin( theta );

  		const te = this.elements;

  		const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
  		const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

  		te[ 0 ] = c * a11 + s * a21;
  		te[ 3 ] = c * a12 + s * a22;
  		te[ 6 ] = c * a13 + s * a23;

  		te[ 1 ] = - s * a11 + c * a21;
  		te[ 4 ] = - s * a12 + c * a22;
  		te[ 7 ] = - s * a13 + c * a23;

  		return this;

  	}

  	translate( tx, ty ) {

  		const te = this.elements;

  		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
  		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

  		return this;

  	}

  	equals( matrix ) {

  		const te = this.elements;
  		const me = matrix.elements;

  		for ( let i = 0; i < 9; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) return false;

  		}

  		return true;

  	}

  	fromArray( array, offset = 0 ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		const te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];

  		array[ offset + 3 ] = te[ 3 ];
  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];

  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];
  		array[ offset + 8 ] = te[ 8 ];

  		return array;

  	}

  	clone() {

  		return new this.constructor().fromArray( this.elements );

  	}

  }

  Matrix3.prototype.isMatrix3 = true;

  let _canvas;

  class ImageUtils {

  	static getDataURL( image ) {

  		if ( /^data:/i.test( image.src ) ) {

  			return image.src;

  		}

  		if ( typeof HTMLCanvasElement == 'undefined' ) {

  			return image.src;

  		}

  		let canvas;

  		if ( image instanceof HTMLCanvasElement ) {

  			canvas = image;

  		} else {

  			if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

  			_canvas.width = image.width;
  			_canvas.height = image.height;

  			const context = _canvas.getContext( '2d' );

  			if ( image instanceof ImageData ) {

  				context.putImageData( image, 0, 0 );

  			} else {

  				context.drawImage( image, 0, 0, image.width, image.height );

  			}

  			canvas = _canvas;

  		}

  		if ( canvas.width > 2048 || canvas.height > 2048 ) {

  			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

  			return canvas.toDataURL( 'image/jpeg', 0.6 );

  		} else {

  			return canvas.toDataURL( 'image/png' );

  		}

  	}

  }

  let textureId = 0;

  class Texture extends EventDispatcher {

  	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

  		super();

  		Object.defineProperty( this, 'id', { value: textureId ++ } );

  		this.uuid = generateUUID();

  		this.name = '';

  		this.image = image;
  		this.mipmaps = [];

  		this.mapping = mapping;

  		this.wrapS = wrapS;
  		this.wrapT = wrapT;

  		this.magFilter = magFilter;
  		this.minFilter = minFilter;

  		this.anisotropy = anisotropy;

  		this.format = format;
  		this.internalFormat = null;
  		this.type = type;

  		this.offset = new Vector2( 0, 0 );
  		this.repeat = new Vector2( 1, 1 );
  		this.center = new Vector2( 0, 0 );
  		this.rotation = 0;

  		this.matrixAutoUpdate = true;
  		this.matrix = new Matrix3();

  		this.generateMipmaps = true;
  		this.premultiplyAlpha = false;
  		this.flipY = true;
  		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  		//
  		// Also changing the encoding after already used by a Material will not automatically make the Material
  		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
  		this.encoding = encoding;

  		this.version = 0;
  		this.onUpdate = null;

  	}

  	updateMatrix() {

  		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		this.name = source.name;

  		this.image = source.image;
  		this.mipmaps = source.mipmaps.slice( 0 );

  		this.mapping = source.mapping;

  		this.wrapS = source.wrapS;
  		this.wrapT = source.wrapT;

  		this.magFilter = source.magFilter;
  		this.minFilter = source.minFilter;

  		this.anisotropy = source.anisotropy;

  		this.format = source.format;
  		this.internalFormat = source.internalFormat;
  		this.type = source.type;

  		this.offset.copy( source.offset );
  		this.repeat.copy( source.repeat );
  		this.center.copy( source.center );
  		this.rotation = source.rotation;

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrix.copy( source.matrix );

  		this.generateMipmaps = source.generateMipmaps;
  		this.premultiplyAlpha = source.premultiplyAlpha;
  		this.flipY = source.flipY;
  		this.unpackAlignment = source.unpackAlignment;
  		this.encoding = source.encoding;

  		return this;

  	}

  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

  			return meta.textures[ this.uuid ];

  		}

  		const output = {

  			metadata: {
  				version: 4.5,
  				type: 'Texture',
  				generator: 'Texture.toJSON'
  			},

  			uuid: this.uuid,
  			name: this.name,

  			mapping: this.mapping,

  			repeat: [ this.repeat.x, this.repeat.y ],
  			offset: [ this.offset.x, this.offset.y ],
  			center: [ this.center.x, this.center.y ],
  			rotation: this.rotation,

  			wrap: [ this.wrapS, this.wrapT ],

  			format: this.format,
  			type: this.type,
  			encoding: this.encoding,

  			minFilter: this.minFilter,
  			magFilter: this.magFilter,
  			anisotropy: this.anisotropy,

  			flipY: this.flipY,

  			premultiplyAlpha: this.premultiplyAlpha,
  			unpackAlignment: this.unpackAlignment

  		};

  		if ( this.image !== undefined ) {

  			// TODO: Move to THREE.Image

  			const image = this.image;

  			if ( image.uuid === undefined ) {

  				image.uuid = generateUUID(); // UGH

  			}

  			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

  				let url;

  				if ( Array.isArray( image ) ) {

  					// process array of images e.g. CubeTexture

  					url = [];

  					for ( let i = 0, l = image.length; i < l; i ++ ) {

  						// check cube texture with data textures

  						if ( image[ i ].isDataTexture ) {

  							url.push( serializeImage( image[ i ].image ) );

  						} else {

  							url.push( serializeImage( image[ i ] ) );

  						}

  					}

  				} else {

  					// process single image

  					url = serializeImage( image );

  				}

  				meta.images[ image.uuid ] = {
  					uuid: image.uuid,
  					url: url
  				};

  			}

  			output.image = image.uuid;

  		}

  		if ( ! isRootObject ) {

  			meta.textures[ this.uuid ] = output;

  		}

  		return output;

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	transformUv( uv ) {

  		if ( this.mapping !== UVMapping ) return uv;

  		uv.applyMatrix3( this.matrix );

  		if ( uv.x < 0 || uv.x > 1 ) {

  			switch ( this.wrapS ) {

  				case RepeatWrapping:

  					uv.x = uv.x - Math.floor( uv.x );
  					break;

  				case ClampToEdgeWrapping:

  					uv.x = uv.x < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

  						uv.x = Math.ceil( uv.x ) - uv.x;

  					} else {

  						uv.x = uv.x - Math.floor( uv.x );

  					}

  					break;

  			}

  		}

  		if ( uv.y < 0 || uv.y > 1 ) {

  			switch ( this.wrapT ) {

  				case RepeatWrapping:

  					uv.y = uv.y - Math.floor( uv.y );
  					break;

  				case ClampToEdgeWrapping:

  					uv.y = uv.y < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

  						uv.y = Math.ceil( uv.y ) - uv.y;

  					} else {

  						uv.y = uv.y - Math.floor( uv.y );

  					}

  					break;

  			}

  		}

  		if ( this.flipY ) {

  			uv.y = 1 - uv.y;

  		}

  		return uv;

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  }

  Texture.DEFAULT_IMAGE = undefined;
  Texture.DEFAULT_MAPPING = UVMapping;

  Texture.prototype.isTexture = true;

  function serializeImage( image ) {

  	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

  		// default images

  		return ImageUtils.getDataURL( image );

  	} else {

  		if ( image.data ) {

  			// images of DataTexture

  			return {
  				data: Array.prototype.slice.call( image.data ),
  				width: image.width,
  				height: image.height,
  				type: image.data.constructor.name
  			};

  		} else {

  			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
  			return {};

  		}

  	}

  }

  class Vector4$1 {

  	constructor( x = 0, y = 0, z = 0, w = 1 ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;
  		this.w = w;

  	}

  	get width() {

  		return this.z;

  	}

  	set width( value ) {

  		this.z = value;

  	}

  	get height() {

  		return this.w;

  	}

  	set height( value ) {

  		this.w = value;

  	}

  	set( x, y, z, w ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;
  		this.w = w;

  		return this;

  	}

  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;
  		this.w = scalar;

  		return this;

  	}

  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	setZ( z ) {

  		this.z = z;

  		return this;

  	}

  	setW( w ) {

  		this.w = w;

  		return this;

  	}

  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			case 3: this.w = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			case 3: return this.w;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	clone() {

  		return new this.constructor( this.x, this.y, this.z, this.w );

  	}

  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;
  		this.w = ( v.w !== undefined ) ? v.w : 1;

  		return this;

  	}

  	add( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;
  		this.w += v.w;

  		return this;

  	}

  	addScalar( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;
  		this.w += s;

  		return this;

  	}

  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;
  		this.w = a.w + b.w;

  		return this;

  	}

  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;
  		this.w += v.w * s;

  		return this;

  	}

  	sub( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;
  		this.w -= v.w;

  		return this;

  	}

  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;
  		this.w -= s;

  		return this;

  	}

  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;
  		this.w = a.w - b.w;

  		return this;

  	}

  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;
  		this.w *= v.w;

  		return this;

  	}

  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;
  		this.w *= scalar;

  		return this;

  	}

  	applyMatrix4( m ) {

  		const x = this.x, y = this.y, z = this.z, w = this.w;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
  		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

  		return this;

  	}

  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	setAxisAngleFromQuaternion( q ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

  		// q is assumed to be normalized

  		this.w = 2 * Math.acos( q.w );

  		const s = Math.sqrt( 1 - q.w * q.w );

  		if ( s < 0.0001 ) {

  			this.x = 1;
  			this.y = 0;
  			this.z = 0;

  		} else {

  			this.x = q.x / s;
  			this.y = q.y / s;
  			this.z = q.z / s;

  		}

  		return this;

  	}

  	setAxisAngleFromRotationMatrix( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		let angle, x, y, z; // variables for result
  		const epsilon = 0.01,		// margin to allow for rounding errors
  			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

  			te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
  		     ( Math.abs( m13 - m31 ) < epsilon ) &&
  		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

  			// singularity found
  			// first check for identity matrix which must have +1 for all terms
  			// in leading diagonal and zero in other terms

  			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
  			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
  			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
  			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

  				// this singularity is identity matrix so angle = 0

  				this.set( 1, 0, 0, 0 );

  				return this; // zero angle, arbitrary axis

  			}

  			// otherwise this singularity is angle = 180

  			angle = Math.PI;

  			const xx = ( m11 + 1 ) / 2;
  			const yy = ( m22 + 1 ) / 2;
  			const zz = ( m33 + 1 ) / 2;
  			const xy = ( m12 + m21 ) / 4;
  			const xz = ( m13 + m31 ) / 4;
  			const yz = ( m23 + m32 ) / 4;

  			if ( ( xx > yy ) && ( xx > zz ) ) {

  				// m11 is the largest diagonal term

  				if ( xx < epsilon ) {

  					x = 0;
  					y = 0.707106781;
  					z = 0.707106781;

  				} else {

  					x = Math.sqrt( xx );
  					y = xy / x;
  					z = xz / x;

  				}

  			} else if ( yy > zz ) {

  				// m22 is the largest diagonal term

  				if ( yy < epsilon ) {

  					x = 0.707106781;
  					y = 0;
  					z = 0.707106781;

  				} else {

  					y = Math.sqrt( yy );
  					x = xy / y;
  					z = yz / y;

  				}

  			} else {

  				// m33 is the largest diagonal term so base result on this

  				if ( zz < epsilon ) {

  					x = 0.707106781;
  					y = 0.707106781;
  					z = 0;

  				} else {

  					z = Math.sqrt( zz );
  					x = xz / z;
  					y = yz / z;

  				}

  			}

  			this.set( x, y, z, angle );

  			return this; // return 180 deg rotation

  		}

  		// as we have reached here there are no singularities so we can handle normally

  		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
  			( m13 - m31 ) * ( m13 - m31 ) +
  			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

  		if ( Math.abs( s ) < 0.001 ) s = 1;

  		// prevent divide by zero, should not happen if matrix is orthogonal and should be
  		// caught by singularity test above, but I've left it in just in case

  		this.x = ( m32 - m23 ) / s;
  		this.y = ( m13 - m31 ) / s;
  		this.z = ( m21 - m12 ) / s;
  		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

  		return this;

  	}

  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );
  		this.w = Math.min( this.w, v.w );

  		return this;

  	}

  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );
  		this.w = Math.max( this.w, v.w );

  		return this;

  	}

  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
  		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

  		return this;

  	}

  	clampScalar( minVal, maxVal ) {

  		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
  		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
  		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
  		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

  		return this;

  	}

  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	}

  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );
  		this.w = Math.floor( this.w );

  		return this;

  	}

  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );
  		this.w = Math.ceil( this.w );

  		return this;

  	}

  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );
  		this.w = Math.round( this.w );

  		return this;

  	}

  	roundToZero() {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
  		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
  		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

  		return this;

  	}

  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;
  		this.w = - this.w;

  		return this;

  	}

  	dot( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  	}

  	lengthSq() {

  		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  	}

  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  	}

  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  	}

  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;
  		this.w += ( v.w - this.w ) * alpha;

  		return this;

  	}

  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;
  		this.z = v1.z + ( v2.z - v1.z ) * alpha;
  		this.w = v1.w + ( v2.w - v1.w ) * alpha;

  		return this;

  	}

  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  	}

  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];
  		this.w = array[ offset + 3 ];

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;
  		array[ offset + 3 ] = this.w;

  		return array;

  	}

  	fromBufferAttribute( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );
  		this.w = attribute.getW( index );

  		return this;

  	}

  	random() {

  		this.x = Math.random();
  		this.y = Math.random();
  		this.z = Math.random();
  		this.w = Math.random();

  		return this;

  	}

  }

  Vector4$1.prototype.isVector4 = true;

  /*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */
  class WebGLRenderTarget extends EventDispatcher {

  	constructor( width, height, options ) {

  		super();

  		this.width = width;
  		this.height = height;
  		this.depth = 1;

  		this.scissor = new Vector4$1( 0, 0, width, height );
  		this.scissorTest = false;

  		this.viewport = new Vector4$1( 0, 0, width, height );

  		options = options || {};

  		this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

  		this.texture.image = {};
  		this.texture.image.width = width;
  		this.texture.image.height = height;
  		this.texture.image.depth = 1;

  		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
  		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

  		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
  		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

  	}

  	setTexture( texture ) {

  		texture.image = {
  			width: this.width,
  			height: this.height,
  			depth: this.depth
  		};

  		this.texture = texture;

  	}

  	setSize( width, height, depth = 1 ) {

  		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

  			this.width = width;
  			this.height = height;
  			this.depth = depth;

  			this.texture.image.width = width;
  			this.texture.image.height = height;
  			this.texture.image.depth = depth;

  			this.dispose();

  		}

  		this.viewport.set( 0, 0, width, height );
  		this.scissor.set( 0, 0, width, height );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		this.width = source.width;
  		this.height = source.height;
  		this.depth = source.depth;

  		this.viewport.copy( source.viewport );

  		this.texture = source.texture.clone();
  		this.texture.image = { ...this.texture.image }; // See #20328.

  		this.depthBuffer = source.depthBuffer;
  		this.stencilBuffer = source.stencilBuffer;
  		this.depthTexture = source.depthTexture;

  		return this;

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  }

  WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

  class WebGLMultipleRenderTargets extends WebGLRenderTarget {

  	constructor( width, height, count ) {

  		super( width, height );

  		const texture = this.texture;

  		this.texture = [];

  		for ( let i = 0; i < count; i ++ ) {

  			this.texture[ i ] = texture.clone();

  		}

  	}

  	setSize( width, height, depth = 1 ) {

  		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

  			this.width = width;
  			this.height = height;
  			this.depth = depth;

  			for ( let i = 0, il = this.texture.length; i < il; i ++ ) {

  				this.texture[ i ].image.width = width;
  				this.texture[ i ].image.height = height;
  				this.texture[ i ].image.depth = depth;

  			}

  			this.dispose();

  		}

  		this.viewport.set( 0, 0, width, height );
  		this.scissor.set( 0, 0, width, height );

  		return this;

  	}

  	copy( source ) {

  		this.dispose();

  		this.width = source.width;
  		this.height = source.height;
  		this.depth = source.depth;

  		this.viewport.set( 0, 0, this.width, this.height );
  		this.scissor.set( 0, 0, this.width, this.height );

  		this.depthBuffer = source.depthBuffer;
  		this.stencilBuffer = source.stencilBuffer;
  		this.depthTexture = source.depthTexture;

  		this.texture.length = 0;

  		for ( let i = 0, il = source.texture.length; i < il; i ++ ) {

  			this.texture[ i ] = source.texture[ i ].clone();

  		}

  		return this;

  	}

  }

  WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;

  class WebGLMultisampleRenderTarget extends WebGLRenderTarget {

  	constructor( width, height, options ) {

  		super( width, height, options );

  		this.samples = 4;

  	}

  	copy( source ) {

  		super.copy.call( this, source );

  		this.samples = source.samples;

  		return this;

  	}

  }

  WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;

  class Quaternion {

  	constructor( x = 0, y = 0, z = 0, w = 1 ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  	}

  	static slerp( qa, qb, qm, t ) {

  		console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
  		return qm.slerpQuaternions( qa, qb, t );

  	}

  	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

  		// fuzz-free, array-based Quaternion SLERP operation

  		let x0 = src0[ srcOffset0 + 0 ],
  			y0 = src0[ srcOffset0 + 1 ],
  			z0 = src0[ srcOffset0 + 2 ],
  			w0 = src0[ srcOffset0 + 3 ];

  		const x1 = src1[ srcOffset1 + 0 ],
  			y1 = src1[ srcOffset1 + 1 ],
  			z1 = src1[ srcOffset1 + 2 ],
  			w1 = src1[ srcOffset1 + 3 ];

  		if ( t === 0 ) {

  			dst[ dstOffset + 0 ] = x0;
  			dst[ dstOffset + 1 ] = y0;
  			dst[ dstOffset + 2 ] = z0;
  			dst[ dstOffset + 3 ] = w0;
  			return;

  		}

  		if ( t === 1 ) {

  			dst[ dstOffset + 0 ] = x1;
  			dst[ dstOffset + 1 ] = y1;
  			dst[ dstOffset + 2 ] = z1;
  			dst[ dstOffset + 3 ] = w1;
  			return;

  		}

  		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

  			let s = 1 - t;
  			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
  				dir = ( cos >= 0 ? 1 : - 1 ),
  				sqrSin = 1 - cos * cos;

  			// Skip the Slerp for tiny steps to avoid numeric problems:
  			if ( sqrSin > Number.EPSILON ) {

  				const sin = Math.sqrt( sqrSin ),
  					len = Math.atan2( sin, cos * dir );

  				s = Math.sin( s * len ) / sin;
  				t = Math.sin( t * len ) / sin;

  			}

  			const tDir = t * dir;

  			x0 = x0 * s + x1 * tDir;
  			y0 = y0 * s + y1 * tDir;
  			z0 = z0 * s + z1 * tDir;
  			w0 = w0 * s + w1 * tDir;

  			// Normalize in case we just did a lerp:
  			if ( s === 1 - t ) {

  				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

  				x0 *= f;
  				y0 *= f;
  				z0 *= f;
  				w0 *= f;

  			}

  		}

  		dst[ dstOffset ] = x0;
  		dst[ dstOffset + 1 ] = y0;
  		dst[ dstOffset + 2 ] = z0;
  		dst[ dstOffset + 3 ] = w0;

  	}

  	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

  		const x0 = src0[ srcOffset0 ];
  		const y0 = src0[ srcOffset0 + 1 ];
  		const z0 = src0[ srcOffset0 + 2 ];
  		const w0 = src0[ srcOffset0 + 3 ];

  		const x1 = src1[ srcOffset1 ];
  		const y1 = src1[ srcOffset1 + 1 ];
  		const z1 = src1[ srcOffset1 + 2 ];
  		const w1 = src1[ srcOffset1 + 3 ];

  		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
  		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
  		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
  		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

  		return dst;

  	}

  	get x() {

  		return this._x;

  	}

  	set x( value ) {

  		this._x = value;
  		this._onChangeCallback();

  	}

  	get y() {

  		return this._y;

  	}

  	set y( value ) {

  		this._y = value;
  		this._onChangeCallback();

  	}

  	get z() {

  		return this._z;

  	}

  	set z( value ) {

  		this._z = value;
  		this._onChangeCallback();

  	}

  	get w() {

  		return this._w;

  	}

  	set w( value ) {

  		this._w = value;
  		this._onChangeCallback();

  	}

  	set( x, y, z, w ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  		this._onChangeCallback();

  		return this;

  	}

  	clone() {

  		return new this.constructor( this._x, this._y, this._z, this._w );

  	}

  	copy( quaternion ) {

  		this._x = quaternion.x;
  		this._y = quaternion.y;
  		this._z = quaternion.z;
  		this._w = quaternion.w;

  		this._onChangeCallback();

  		return this;

  	}

  	setFromEuler( euler, update ) {

  		if ( ! ( euler && euler.isEuler ) ) {

  			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

  		}

  		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

  		// http://www.mathworks.com/matlabcentral/fileexchange/
  		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  		//	content/SpinCalc.m

  		const cos = Math.cos;
  		const sin = Math.sin;

  		const c1 = cos( x / 2 );
  		const c2 = cos( y / 2 );
  		const c3 = cos( z / 2 );

  		const s1 = sin( x / 2 );
  		const s2 = sin( y / 2 );
  		const s3 = sin( z / 2 );

  		switch ( order ) {

  			case 'XYZ':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'YXZ':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			case 'ZXY':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'ZYX':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			case 'YZX':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'XZY':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			default:
  				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

  		}

  		if ( update !== false ) this._onChangeCallback();

  		return this;

  	}

  	setFromAxisAngle( axis, angle ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

  		// assumes axis is normalized

  		const halfAngle = angle / 2, s = Math.sin( halfAngle );

  		this._x = axis.x * s;
  		this._y = axis.y * s;
  		this._z = axis.z * s;
  		this._w = Math.cos( halfAngle );

  		this._onChangeCallback();

  		return this;

  	}

  	setFromRotationMatrix( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		const te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

  			trace = m11 + m22 + m33;

  		if ( trace > 0 ) {

  			const s = 0.5 / Math.sqrt( trace + 1.0 );

  			this._w = 0.25 / s;
  			this._x = ( m32 - m23 ) * s;
  			this._y = ( m13 - m31 ) * s;
  			this._z = ( m21 - m12 ) * s;

  		} else if ( m11 > m22 && m11 > m33 ) {

  			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

  			this._w = ( m32 - m23 ) / s;
  			this._x = 0.25 * s;
  			this._y = ( m12 + m21 ) / s;
  			this._z = ( m13 + m31 ) / s;

  		} else if ( m22 > m33 ) {

  			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

  			this._w = ( m13 - m31 ) / s;
  			this._x = ( m12 + m21 ) / s;
  			this._y = 0.25 * s;
  			this._z = ( m23 + m32 ) / s;

  		} else {

  			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

  			this._w = ( m21 - m12 ) / s;
  			this._x = ( m13 + m31 ) / s;
  			this._y = ( m23 + m32 ) / s;
  			this._z = 0.25 * s;

  		}

  		this._onChangeCallback();

  		return this;

  	}

  	setFromUnitVectors( vFrom, vTo ) {

  		// assumes direction vectors vFrom and vTo are normalized

  		let r = vFrom.dot( vTo ) + 1;

  		if ( r < Number.EPSILON ) {

  			// vFrom and vTo point in opposite directions

  			r = 0;

  			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

  				this._x = - vFrom.y;
  				this._y = vFrom.x;
  				this._z = 0;
  				this._w = r;

  			} else {

  				this._x = 0;
  				this._y = - vFrom.z;
  				this._z = vFrom.y;
  				this._w = r;

  			}

  		} else {

  			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

  			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
  			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
  			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
  			this._w = r;

  		}

  		return this.normalize();

  	}

  	angleTo( q ) {

  		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

  	}

  	rotateTowards( q, step ) {

  		const angle = this.angleTo( q );

  		if ( angle === 0 ) return this;

  		const t = Math.min( 1, step / angle );

  		this.slerp( q, t );

  		return this;

  	}

  	identity() {

  		return this.set( 0, 0, 0, 1 );

  	}

  	invert() {

  		// quaternion is assumed to have unit length

  		return this.conjugate();

  	}

  	conjugate() {

  		this._x *= - 1;
  		this._y *= - 1;
  		this._z *= - 1;

  		this._onChangeCallback();

  		return this;

  	}

  	dot( v ) {

  		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  	}

  	lengthSq() {

  		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  	}

  	length() {

  		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  	}

  	normalize() {

  		let l = this.length();

  		if ( l === 0 ) {

  			this._x = 0;
  			this._y = 0;
  			this._z = 0;
  			this._w = 1;

  		} else {

  			l = 1 / l;

  			this._x = this._x * l;
  			this._y = this._y * l;
  			this._z = this._z * l;
  			this._w = this._w * l;

  		}

  		this._onChangeCallback();

  		return this;

  	}

  	multiply( q, p ) {

  		if ( p !== undefined ) {

  			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
  			return this.multiplyQuaternions( q, p );

  		}

  		return this.multiplyQuaternions( this, q );

  	}

  	premultiply( q ) {

  		return this.multiplyQuaternions( q, this );

  	}

  	multiplyQuaternions( a, b ) {

  		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

  		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
  		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

  		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
  		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
  		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
  		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

  		this._onChangeCallback();

  		return this;

  	}

  	slerp( qb, t ) {

  		if ( t === 0 ) return this;
  		if ( t === 1 ) return this.copy( qb );

  		const x = this._x, y = this._y, z = this._z, w = this._w;

  		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

  		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

  		if ( cosHalfTheta < 0 ) {

  			this._w = - qb._w;
  			this._x = - qb._x;
  			this._y = - qb._y;
  			this._z = - qb._z;

  			cosHalfTheta = - cosHalfTheta;

  		} else {

  			this.copy( qb );

  		}

  		if ( cosHalfTheta >= 1.0 ) {

  			this._w = w;
  			this._x = x;
  			this._y = y;
  			this._z = z;

  			return this;

  		}

  		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

  		if ( sqrSinHalfTheta <= Number.EPSILON ) {

  			const s = 1 - t;
  			this._w = s * w + t * this._w;
  			this._x = s * x + t * this._x;
  			this._y = s * y + t * this._y;
  			this._z = s * z + t * this._z;

  			this.normalize();
  			this._onChangeCallback();

  			return this;

  		}

  		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
  		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
  		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
  			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

  		this._w = ( w * ratioA + this._w * ratioB );
  		this._x = ( x * ratioA + this._x * ratioB );
  		this._y = ( y * ratioA + this._y * ratioB );
  		this._z = ( z * ratioA + this._z * ratioB );

  		this._onChangeCallback();

  		return this;

  	}

  	slerpQuaternions( qa, qb, t ) {

  		this.copy( qa ).slerp( qb, t );

  	}

  	equals( quaternion ) {

  		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  	}

  	fromArray( array, offset = 0 ) {

  		this._x = array[ offset ];
  		this._y = array[ offset + 1 ];
  		this._z = array[ offset + 2 ];
  		this._w = array[ offset + 3 ];

  		this._onChangeCallback();

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._w;

  		return array;

  	}

  	fromBufferAttribute( attribute, index ) {

  		this._x = attribute.getX( index );
  		this._y = attribute.getY( index );
  		this._z = attribute.getZ( index );
  		this._w = attribute.getW( index );

  		return this;

  	}

  	_onChange( callback ) {

  		this._onChangeCallback = callback;

  		return this;

  	}

  	_onChangeCallback() {}

  }

  Quaternion.prototype.isQuaternion = true;

  class Vector3 {

  	constructor( x = 0, y = 0, z = 0 ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;

  	}

  	set( x, y, z ) {

  		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

  		this.x = x;
  		this.y = y;
  		this.z = z;

  		return this;

  	}

  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;

  		return this;

  	}

  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	setZ( z ) {

  		this.z = z;

  		return this;

  	}

  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	clone() {

  		return new this.constructor( this.x, this.y, this.z );

  	}

  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;

  		return this;

  	}

  	add( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;

  		return this;

  	}

  	addScalar( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;

  		return this;

  	}

  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;

  		return this;

  	}

  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;

  		return this;

  	}

  	sub( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;

  		return this;

  	}

  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;

  		return this;

  	}

  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;

  		return this;

  	}

  	multiply( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
  			return this.multiplyVectors( v, w );

  		}

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;

  		return this;

  	}

  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;

  		return this;

  	}

  	multiplyVectors( a, b ) {

  		this.x = a.x * b.x;
  		this.y = a.y * b.y;
  		this.z = a.z * b.z;

  		return this;

  	}

  	applyEuler( euler ) {

  		if ( ! ( euler && euler.isEuler ) ) {

  			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

  		}

  		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

  	}

  	applyAxisAngle( axis, angle ) {

  		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

  	}

  	applyMatrix3( m ) {

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
  		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

  		return this;

  	}

  	applyNormalMatrix( m ) {

  		return this.applyMatrix3( m ).normalize();

  	}

  	applyMatrix4( m ) {

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

  		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
  		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
  		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

  		return this;

  	}

  	applyQuaternion( q ) {

  		const x = this.x, y = this.y, z = this.z;
  		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

  		// calculate quat * vector

  		const ix = qw * x + qy * z - qz * y;
  		const iy = qw * y + qz * x - qx * z;
  		const iz = qw * z + qx * y - qy * x;
  		const iw = - qx * x - qy * y - qz * z;

  		// calculate result * inverse quat

  		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
  		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
  		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

  		return this;

  	}

  	project( camera ) {

  		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

  	}

  	unproject( camera ) {

  		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

  	}

  	transformDirection( m ) {

  		// input: THREE.Matrix4 affine matrix
  		// vector interpreted as a direction

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

  		return this.normalize();

  	}

  	divide( v ) {

  		this.x /= v.x;
  		this.y /= v.y;
  		this.z /= v.z;

  		return this;

  	}

  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );

  		return this;

  	}

  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );

  		return this;

  	}

  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

  		return this;

  	}

  	clampScalar( minVal, maxVal ) {

  		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
  		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
  		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

  		return this;

  	}

  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	}

  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );

  		return this;

  	}

  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );

  		return this;

  	}

  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );

  		return this;

  	}

  	roundToZero() {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
  		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

  		return this;

  	}

  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;

  		return this;

  	}

  	dot( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z;

  	}

  	// TODO lengthSquared?

  	lengthSq() {

  		return this.x * this.x + this.y * this.y + this.z * this.z;

  	}

  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  	}

  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  	}

  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;

  		return this;

  	}

  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;
  		this.z = v1.z + ( v2.z - v1.z ) * alpha;

  		return this;

  	}

  	cross( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
  			return this.crossVectors( v, w );

  		}

  		return this.crossVectors( this, v );

  	}

  	crossVectors( a, b ) {

  		const ax = a.x, ay = a.y, az = a.z;
  		const bx = b.x, by = b.y, bz = b.z;

  		this.x = ay * bz - az * by;
  		this.y = az * bx - ax * bz;
  		this.z = ax * by - ay * bx;

  		return this;

  	}

  	projectOnVector( v ) {

  		const denominator = v.lengthSq();

  		if ( denominator === 0 ) return this.set( 0, 0, 0 );

  		const scalar = v.dot( this ) / denominator;

  		return this.copy( v ).multiplyScalar( scalar );

  	}

  	projectOnPlane( planeNormal ) {

  		_vector$c.copy( this ).projectOnVector( planeNormal );

  		return this.sub( _vector$c );

  	}

  	reflect( normal ) {

  		// reflect incident vector off plane orthogonal to normal
  		// normal is assumed to have unit length

  		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

  	}

  	angleTo( v ) {

  		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

  		if ( denominator === 0 ) return Math.PI / 2;

  		const theta = this.dot( v ) / denominator;

  		// clamp, to handle numerical problems

  		return Math.acos( clamp( theta, - 1, 1 ) );

  	}

  	distanceTo( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	}

  	distanceToSquared( v ) {

  		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

  		return dx * dx + dy * dy + dz * dz;

  	}

  	manhattanDistanceTo( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

  	}

  	setFromSpherical( s ) {

  		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

  	}

  	setFromSphericalCoords( radius, phi, theta ) {

  		const sinPhiRadius = Math.sin( phi ) * radius;

  		this.x = sinPhiRadius * Math.sin( theta );
  		this.y = Math.cos( phi ) * radius;
  		this.z = sinPhiRadius * Math.cos( theta );

  		return this;

  	}

  	setFromCylindrical( c ) {

  		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

  	}

  	setFromCylindricalCoords( radius, theta, y ) {

  		this.x = radius * Math.sin( theta );
  		this.y = y;
  		this.z = radius * Math.cos( theta );

  		return this;

  	}

  	setFromMatrixPosition( m ) {

  		const e = m.elements;

  		this.x = e[ 12 ];
  		this.y = e[ 13 ];
  		this.z = e[ 14 ];

  		return this;

  	}

  	setFromMatrixScale( m ) {

  		const sx = this.setFromMatrixColumn( m, 0 ).length();
  		const sy = this.setFromMatrixColumn( m, 1 ).length();
  		const sz = this.setFromMatrixColumn( m, 2 ).length();

  		this.x = sx;
  		this.y = sy;
  		this.z = sz;

  		return this;

  	}

  	setFromMatrixColumn( m, index ) {

  		return this.fromArray( m.elements, index * 4 );

  	}

  	setFromMatrix3Column( m, index ) {

  		return this.fromArray( m.elements, index * 3 );

  	}

  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  	}

  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;

  		return array;

  	}

  	fromBufferAttribute( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );

  		return this;

  	}

  	random() {

  		this.x = Math.random();
  		this.y = Math.random();
  		this.z = Math.random();

  		return this;

  	}

  }

  Vector3.prototype.isVector3 = true;

  const _vector$c = /*@__PURE__*/ new Vector3();
  const _quaternion$4 = /*@__PURE__*/ new Quaternion();

  class Box3 {

  	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

  		this.min = min;
  		this.max = max;

  	}

  	set( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	}

  	setFromArray( array ) {

  		let minX = + Infinity;
  		let minY = + Infinity;
  		let minZ = + Infinity;

  		let maxX = - Infinity;
  		let maxY = - Infinity;
  		let maxZ = - Infinity;

  		for ( let i = 0, l = array.length; i < l; i += 3 ) {

  			const x = array[ i ];
  			const y = array[ i + 1 ];
  			const z = array[ i + 2 ];

  			if ( x < minX ) minX = x;
  			if ( y < minY ) minY = y;
  			if ( z < minZ ) minZ = z;

  			if ( x > maxX ) maxX = x;
  			if ( y > maxY ) maxY = y;
  			if ( z > maxZ ) maxZ = z;

  		}

  		this.min.set( minX, minY, minZ );
  		this.max.set( maxX, maxY, maxZ );

  		return this;

  	}

  	setFromBufferAttribute( attribute ) {

  		let minX = + Infinity;
  		let minY = + Infinity;
  		let minZ = + Infinity;

  		let maxX = - Infinity;
  		let maxY = - Infinity;
  		let maxZ = - Infinity;

  		for ( let i = 0, l = attribute.count; i < l; i ++ ) {

  			const x = attribute.getX( i );
  			const y = attribute.getY( i );
  			const z = attribute.getZ( i );

  			if ( x < minX ) minX = x;
  			if ( y < minY ) minY = y;
  			if ( z < minZ ) minZ = z;

  			if ( x > maxX ) maxX = x;
  			if ( y > maxY ) maxY = y;
  			if ( z > maxZ ) maxZ = z;

  		}

  		this.min.set( minX, minY, minZ );
  		this.max.set( maxX, maxY, maxZ );

  		return this;

  	}

  	setFromPoints( points ) {

  		this.makeEmpty();

  		for ( let i = 0, il = points.length; i < il; i ++ ) {

  			this.expandByPoint( points[ i ] );

  		}

  		return this;

  	}

  	setFromCenterAndSize( center, size ) {

  		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

  		this.min.copy( center ).sub( halfSize );
  		this.max.copy( center ).add( halfSize );

  		return this;

  	}

  	setFromObject( object ) {

  		this.makeEmpty();

  		return this.expandByObject( object );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	}

  	makeEmpty() {

  		this.min.x = this.min.y = this.min.z = + Infinity;
  		this.max.x = this.max.y = this.max.z = - Infinity;

  		return this;

  	}

  	isEmpty() {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  	}

  	getCenter( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Box3: .getCenter() target is now required' );
  			target = new Vector3();

  		}

  		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	}

  	getSize( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Box3: .getSize() target is now required' );
  			target = new Vector3();

  		}

  		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

  	}

  	expandByPoint( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	}

  	expandByVector( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	}

  	expandByScalar( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	}

  	expandByObject( object ) {

  		// Computes the world-axis-aligned bounding box of an object (including its children),
  		// accounting for both the object's, and children's, world transforms

  		object.updateWorldMatrix( false, false );

  		const geometry = object.geometry;

  		if ( geometry !== undefined ) {

  			if ( geometry.boundingBox === null ) {

  				geometry.computeBoundingBox();

  			}

  			_box$3.copy( geometry.boundingBox );
  			_box$3.applyMatrix4( object.matrixWorld );

  			this.union( _box$3 );

  		}

  		const children = object.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			this.expandByObject( children[ i ] );

  		}

  		return this;

  	}

  	containsPoint( point ) {

  		return point.x < this.min.x || point.x > this.max.x ||
  			point.y < this.min.y || point.y > this.max.y ||
  			point.z < this.min.z || point.z > this.max.z ? false : true;

  	}

  	containsBox( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y &&
  			this.min.z <= box.min.z && box.max.z <= this.max.z;

  	}

  	getParameter( point, target ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		if ( target === undefined ) {

  			console.warn( 'THREE.Box3: .getParameter() target is now required' );
  			target = new Vector3();

  		}

  		return target.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
  			( point.z - this.min.z ) / ( this.max.z - this.min.z )
  		);

  	}

  	intersectsBox( box ) {

  		// using 6 splitting planes to rule out intersections.
  		return box.max.x < this.min.x || box.min.x > this.max.x ||
  			box.max.y < this.min.y || box.min.y > this.max.y ||
  			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

  	}

  	intersectsSphere( sphere ) {

  		// Find the point on the AABB closest to the sphere center.
  		this.clampPoint( sphere.center, _vector$b );

  		// If that point is inside the sphere, the AABB and sphere intersect.
  		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

  	}

  	intersectsPlane( plane ) {

  		// We compute the minimum and maximum dot product values. If those values
  		// are on the same side (back or front) of the plane, then there is no intersection.

  		let min, max;

  		if ( plane.normal.x > 0 ) {

  			min = plane.normal.x * this.min.x;
  			max = plane.normal.x * this.max.x;

  		} else {

  			min = plane.normal.x * this.max.x;
  			max = plane.normal.x * this.min.x;

  		}

  		if ( plane.normal.y > 0 ) {

  			min += plane.normal.y * this.min.y;
  			max += plane.normal.y * this.max.y;

  		} else {

  			min += plane.normal.y * this.max.y;
  			max += plane.normal.y * this.min.y;

  		}

  		if ( plane.normal.z > 0 ) {

  			min += plane.normal.z * this.min.z;
  			max += plane.normal.z * this.max.z;

  		} else {

  			min += plane.normal.z * this.max.z;
  			max += plane.normal.z * this.min.z;

  		}

  		return ( min <= - plane.constant && max >= - plane.constant );

  	}

  	intersectsTriangle( triangle ) {

  		if ( this.isEmpty() ) {

  			return false;

  		}

  		// compute box center and extents
  		this.getCenter( _center );
  		_extents.subVectors( this.max, _center );

  		// translate triangle to aabb origin
  		_v0$2.subVectors( triangle.a, _center );
  		_v1$7.subVectors( triangle.b, _center );
  		_v2$3.subVectors( triangle.c, _center );

  		// compute edge vectors for triangle
  		_f0.subVectors( _v1$7, _v0$2 );
  		_f1.subVectors( _v2$3, _v1$7 );
  		_f2.subVectors( _v0$2, _v2$3 );

  		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
  		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
  		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
  		let axes = [
  			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
  			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
  			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
  		];
  		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

  			return false;

  		}

  		// test 3 face normals from the aabb
  		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
  		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

  			return false;

  		}

  		// finally testing the face normal of the triangle
  		// use already existing triangle edge vectors here
  		_triangleNormal.crossVectors( _f0, _f1 );
  		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

  		return satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents );

  	}

  	clampPoint( point, target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Box3: .clampPoint() target is now required' );
  			target = new Vector3();

  		}

  		return target.copy( point ).clamp( this.min, this.max );

  	}

  	distanceToPoint( point ) {

  		const clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );

  		return clampedPoint.sub( point ).length();

  	}

  	getBoundingSphere( target ) {

  		if ( target === undefined ) {

  			console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
  			//target = new Sphere(); // removed to avoid cyclic dependency

  		}

  		this.getCenter( target.center );

  		target.radius = this.getSize( _vector$b ).length() * 0.5;

  		return target;

  	}

  	intersect( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  		if ( this.isEmpty() ) this.makeEmpty();

  		return this;

  	}

  	union( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	}

  	applyMatrix4( matrix ) {

  		// transform of empty box is an empty box.
  		if ( this.isEmpty() ) return this;

  		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
  		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
  		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
  		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
  		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
  		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
  		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
  		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

  		this.setFromPoints( _points );

  		return this;

  	}

  	translate( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	}

  	equals( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  }

  Box3.prototype.isBox3 = true;

  const _points = [
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3()
  ];

  const _vector$b = /*@__PURE__*/ new Vector3();

  const _box$3 = /*@__PURE__*/ new Box3();

  // triangle centered vertices

  const _v0$2 = /*@__PURE__*/ new Vector3();
  const _v1$7 = /*@__PURE__*/ new Vector3();
  const _v2$3 = /*@__PURE__*/ new Vector3();

  // triangle edge vectors

  const _f0 = /*@__PURE__*/ new Vector3();
  const _f1 = /*@__PURE__*/ new Vector3();
  const _f2 = /*@__PURE__*/ new Vector3();

  const _center = /*@__PURE__*/ new Vector3();
  const _extents = /*@__PURE__*/ new Vector3();
  const _triangleNormal = /*@__PURE__*/ new Vector3();
  const _testAxis = /*@__PURE__*/ new Vector3();

  function satForAxes( axes, v0, v1, v2, extents ) {

  	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

  		_testAxis.fromArray( axes, i );
  		// project the aabb onto the seperating axis
  		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
  		// project all 3 vertices of the triangle onto the seperating axis
  		const p0 = v0.dot( _testAxis );
  		const p1 = v1.dot( _testAxis );
  		const p2 = v2.dot( _testAxis );
  		// actual test, basically see if either of the most extreme of the triangle points intersects r
  		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

  			// points of the projected triangle are outside the projected half-length of the aabb
  			// the axis is seperating and we can exit
  			return false;

  		}

  	}

  	return true;

  }

  const _box$2 = /*@__PURE__*/ new Box3();
  const _v1$6 = /*@__PURE__*/ new Vector3();
  const _toFarthestPoint = /*@__PURE__*/ new Vector3();
  const _toPoint = /*@__PURE__*/ new Vector3();

  class Sphere {

  	constructor( center = new Vector3(), radius = - 1 ) {

  		this.center = center;
  		this.radius = radius;

  	}

  	set( center, radius ) {

  		this.center.copy( center );
  		this.radius = radius;

  		return this;

  	}

  	setFromPoints( points, optionalCenter ) {

  		const center = this.center;

  		if ( optionalCenter !== undefined ) {

  			center.copy( optionalCenter );

  		} else {

  			_box$2.setFromPoints( points ).getCenter( center );

  		}

  		let maxRadiusSq = 0;

  		for ( let i = 0, il = points.length; i < il; i ++ ) {

  			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

  		}

  		this.radius = Math.sqrt( maxRadiusSq );

  		return this;

  	}

  	copy( sphere ) {

  		this.center.copy( sphere.center );
  		this.radius = sphere.radius;

  		return this;

  	}

  	isEmpty() {

  		return ( this.radius < 0 );

  	}

  	makeEmpty() {

  		this.center.set( 0, 0, 0 );
  		this.radius = - 1;

  		return this;

  	}

  	containsPoint( point ) {

  		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  	}

  	distanceToPoint( point ) {

  		return ( point.distanceTo( this.center ) - this.radius );

  	}

  	intersectsSphere( sphere ) {

  		const radiusSum = this.radius + sphere.radius;

  		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  	}

  	intersectsBox( box ) {

  		return box.intersectsSphere( this );

  	}

  	intersectsPlane( plane ) {

  		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

  	}

  	clampPoint( point, target ) {

  		const deltaLengthSq = this.center.distanceToSquared( point );

  		if ( target === undefined ) {

  			console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
  			target = new Vector3();

  		}

  		target.copy( point );

  		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

  			target.sub( this.center ).normalize();
  			target.multiplyScalar( this.radius ).add( this.center );

  		}

  		return target;

  	}

  	getBoundingBox( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
  			target = new Box3();

  		}

  		if ( this.isEmpty() ) {

  			// Empty sphere produces empty bounding box
  			target.makeEmpty();
  			return target;

  		}

  		target.set( this.center, this.center );
  		target.expandByScalar( this.radius );

  		return target;

  	}

  	applyMatrix4( matrix ) {

  		this.center.applyMatrix4( matrix );
  		this.radius = this.radius * matrix.getMaxScaleOnAxis();

  		return this;

  	}

  	translate( offset ) {

  		this.center.add( offset );

  		return this;

  	}

  	expandByPoint( point ) {

  		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

  		_toPoint.subVectors( point, this.center );

  		const lengthSq = _toPoint.lengthSq();

  		if ( lengthSq > ( this.radius * this.radius ) ) {

  			const length = Math.sqrt( lengthSq );
  			const missingRadiusHalf = ( length - this.radius ) * 0.5;

  			// Nudge this sphere towards the target point. Add half the missing distance to radius,
  			// and the other half to position. This gives a tighter enclosure, instead of if
  			// the whole missing distance were just added to radius.

  			this.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );
  			this.radius += missingRadiusHalf;

  		}

  		return this;

  	}

  	union( sphere ) {

  		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

  		// To enclose another sphere into this sphere, we only need to enclose two points:
  		// 1) Enclose the farthest point on the other sphere into this sphere.
  		// 2) Enclose the opposite point of the farthest point into this sphere.

  		_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );

  		this.expandByPoint( _v1$6.copy( sphere.center ).add( _toFarthestPoint ) );
  		this.expandByPoint( _v1$6.copy( sphere.center ).sub( _toFarthestPoint ) );

  		return this;

  	}

  	equals( sphere ) {

  		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _vector$a = /*@__PURE__*/ new Vector3();
  const _segCenter = /*@__PURE__*/ new Vector3();
  const _segDir = /*@__PURE__*/ new Vector3();
  const _diff = /*@__PURE__*/ new Vector3();

  const _edge1 = /*@__PURE__*/ new Vector3();
  const _edge2 = /*@__PURE__*/ new Vector3();
  const _normal$1 = /*@__PURE__*/ new Vector3();

  class Ray {

  	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

  		this.origin = origin;
  		this.direction = direction;

  	}

  	set( origin, direction ) {

  		this.origin.copy( origin );
  		this.direction.copy( direction );

  		return this;

  	}

  	copy( ray ) {

  		this.origin.copy( ray.origin );
  		this.direction.copy( ray.direction );

  		return this;

  	}

  	at( t, target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Ray: .at() target is now required' );
  			target = new Vector3();

  		}

  		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

  	}

  	lookAt( v ) {

  		this.direction.copy( v ).sub( this.origin ).normalize();

  		return this;

  	}

  	recast( t ) {

  		this.origin.copy( this.at( t, _vector$a ) );

  		return this;

  	}

  	closestPointToPoint( point, target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
  			target = new Vector3();

  		}

  		target.subVectors( point, this.origin );

  		const directionDistance = target.dot( this.direction );

  		if ( directionDistance < 0 ) {

  			return target.copy( this.origin );

  		}

  		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  	}

  	distanceToPoint( point ) {

  		return Math.sqrt( this.distanceSqToPoint( point ) );

  	}

  	distanceSqToPoint( point ) {

  		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

  		// point behind the ray

  		if ( directionDistance < 0 ) {

  			return this.origin.distanceToSquared( point );

  		}

  		_vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  		return _vector$a.distanceToSquared( point );

  	}

  	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

  		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
  		// It returns the min distance between the ray and the segment
  		// defined by v0 and v1
  		// It can also set two optional targets :
  		// - The closest point on the ray
  		// - The closest point on the segment

  		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
  		_segDir.copy( v1 ).sub( v0 ).normalize();
  		_diff.copy( this.origin ).sub( _segCenter );

  		const segExtent = v0.distanceTo( v1 ) * 0.5;
  		const a01 = - this.direction.dot( _segDir );
  		const b0 = _diff.dot( this.direction );
  		const b1 = - _diff.dot( _segDir );
  		const c = _diff.lengthSq();
  		const det = Math.abs( 1 - a01 * a01 );
  		let s0, s1, sqrDist, extDet;

  		if ( det > 0 ) {

  			// The ray and segment are not parallel.

  			s0 = a01 * b1 - b0;
  			s1 = a01 * b0 - b1;
  			extDet = segExtent * det;

  			if ( s0 >= 0 ) {

  				if ( s1 >= - extDet ) {

  					if ( s1 <= extDet ) {

  						// region 0
  						// Minimum at interior points of ray and segment.

  						const invDet = 1 / det;
  						s0 *= invDet;
  						s1 *= invDet;
  						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

  					} else {

  						// region 1

  						s1 = segExtent;
  						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				} else {

  					// region 5

  					s1 = - segExtent;
  					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				}

  			} else {

  				if ( s1 <= - extDet ) {

  					// region 4

  					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
  					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				} else if ( s1 <= extDet ) {

  					// region 3

  					s0 = 0;
  					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

  				} else {

  					// region 2

  					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
  					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				}

  			}

  		} else {

  			// Ray and segment are parallel.

  			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
  			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  		}

  		if ( optionalPointOnRay ) {

  			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

  		}

  		if ( optionalPointOnSegment ) {

  			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

  		}

  		return sqrDist;

  	}

  	intersectSphere( sphere, target ) {

  		_vector$a.subVectors( sphere.center, this.origin );
  		const tca = _vector$a.dot( this.direction );
  		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
  		const radius2 = sphere.radius * sphere.radius;

  		if ( d2 > radius2 ) return null;

  		const thc = Math.sqrt( radius2 - d2 );

  		// t0 = first intersect point - entrance on front of sphere
  		const t0 = tca - thc;

  		// t1 = second intersect point - exit point on back of sphere
  		const t1 = tca + thc;

  		// test to see if both t0 and t1 are behind the ray - if so, return null
  		if ( t0 < 0 && t1 < 0 ) return null;

  		// test to see if t0 is behind the ray:
  		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  		// in order to always return an intersect point that is in front of the ray.
  		if ( t0 < 0 ) return this.at( t1, target );

  		// else t0 is in front of the ray, so return the first collision point scaled by t0
  		return this.at( t0, target );

  	}

  	intersectsSphere( sphere ) {

  		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

  	}

  	distanceToPlane( plane ) {

  		const denominator = plane.normal.dot( this.direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( plane.distanceToPoint( this.origin ) === 0 ) {

  				return 0;

  			}

  			// Null is preferable to undefined since undefined means.... it is undefined

  			return null;

  		}

  		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

  		// Return if the ray never intersects the plane

  		return t >= 0 ? t : null;

  	}

  	intersectPlane( plane, target ) {

  		const t = this.distanceToPlane( plane );

  		if ( t === null ) {

  			return null;

  		}

  		return this.at( t, target );

  	}

  	intersectsPlane( plane ) {

  		// check if the ray lies on the plane first

  		const distToPoint = plane.distanceToPoint( this.origin );

  		if ( distToPoint === 0 ) {

  			return true;

  		}

  		const denominator = plane.normal.dot( this.direction );

  		if ( denominator * distToPoint < 0 ) {

  			return true;

  		}

  		// ray origin is behind the plane (and is pointing behind it)

  		return false;

  	}

  	intersectBox( box, target ) {

  		let tmin, tmax, tymin, tymax, tzmin, tzmax;

  		const invdirx = 1 / this.direction.x,
  			invdiry = 1 / this.direction.y,
  			invdirz = 1 / this.direction.z;

  		const origin = this.origin;

  		if ( invdirx >= 0 ) {

  			tmin = ( box.min.x - origin.x ) * invdirx;
  			tmax = ( box.max.x - origin.x ) * invdirx;

  		} else {

  			tmin = ( box.max.x - origin.x ) * invdirx;
  			tmax = ( box.min.x - origin.x ) * invdirx;

  		}

  		if ( invdiry >= 0 ) {

  			tymin = ( box.min.y - origin.y ) * invdiry;
  			tymax = ( box.max.y - origin.y ) * invdiry;

  		} else {

  			tymin = ( box.max.y - origin.y ) * invdiry;
  			tymax = ( box.min.y - origin.y ) * invdiry;

  		}

  		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

  		// These lines also handle the case where tmin or tmax is NaN
  		// (result of 0 * Infinity). x !== x returns true if x is NaN

  		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

  		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

  		if ( invdirz >= 0 ) {

  			tzmin = ( box.min.z - origin.z ) * invdirz;
  			tzmax = ( box.max.z - origin.z ) * invdirz;

  		} else {

  			tzmin = ( box.max.z - origin.z ) * invdirz;
  			tzmax = ( box.min.z - origin.z ) * invdirz;

  		}

  		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

  		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

  		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

  		//return point closest to the ray (positive side)

  		if ( tmax < 0 ) return null;

  		return this.at( tmin >= 0 ? tmin : tmax, target );

  	}

  	intersectsBox( box ) {

  		return this.intersectBox( box, _vector$a ) !== null;

  	}

  	intersectTriangle( a, b, c, backfaceCulling, target ) {

  		// Compute the offset origin, edges, and normal.

  		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

  		_edge1.subVectors( b, a );
  		_edge2.subVectors( c, a );
  		_normal$1.crossVectors( _edge1, _edge2 );

  		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  		let DdN = this.direction.dot( _normal$1 );
  		let sign;

  		if ( DdN > 0 ) {

  			if ( backfaceCulling ) return null;
  			sign = 1;

  		} else if ( DdN < 0 ) {

  			sign = - 1;
  			DdN = - DdN;

  		} else {

  			return null;

  		}

  		_diff.subVectors( this.origin, a );
  		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

  		// b1 < 0, no intersection
  		if ( DdQxE2 < 0 ) {

  			return null;

  		}

  		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

  		// b2 < 0, no intersection
  		if ( DdE1xQ < 0 ) {

  			return null;

  		}

  		// b1+b2 > 1, no intersection
  		if ( DdQxE2 + DdE1xQ > DdN ) {

  			return null;

  		}

  		// Line intersects triangle, check if ray does.
  		const QdN = - sign * _diff.dot( _normal$1 );

  		// t < 0, no intersection
  		if ( QdN < 0 ) {

  			return null;

  		}

  		// Ray intersects triangle.
  		return this.at( QdN / DdN, target );

  	}

  	applyMatrix4( matrix4 ) {

  		this.origin.applyMatrix4( matrix4 );
  		this.direction.transformDirection( matrix4 );

  		return this;

  	}

  	equals( ray ) {

  		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  class Matrix4 {

  	constructor() {

  		this.elements = [

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		];

  		if ( arguments.length > 0 ) {

  			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

  		}

  	}

  	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		const te = this.elements;

  		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
  		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
  		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
  		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

  		return this;

  	}

  	identity() {

  		this.set(

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	clone() {

  		return new Matrix4().fromArray( this.elements );

  	}

  	copy( m ) {

  		const te = this.elements;
  		const me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
  		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
  		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
  		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

  		return this;

  	}

  	copyPosition( m ) {

  		const te = this.elements, me = m.elements;

  		te[ 12 ] = me[ 12 ];
  		te[ 13 ] = me[ 13 ];
  		te[ 14 ] = me[ 14 ];

  		return this;

  	}

  	setFromMatrix3( m ) {

  		const me = m.elements;

  		this.set(

  			me[ 0 ], me[ 3 ], me[ 6 ], 0,
  			me[ 1 ], me[ 4 ], me[ 7 ], 0,
  			me[ 2 ], me[ 5 ], me[ 8 ], 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	extractBasis( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrixColumn( this, 0 );
  		yAxis.setFromMatrixColumn( this, 1 );
  		zAxis.setFromMatrixColumn( this, 2 );

  		return this;

  	}

  	makeBasis( xAxis, yAxis, zAxis ) {

  		this.set(
  			xAxis.x, yAxis.x, zAxis.x, 0,
  			xAxis.y, yAxis.y, zAxis.y, 0,
  			xAxis.z, yAxis.z, zAxis.z, 0,
  			0, 0, 0, 1
  		);

  		return this;

  	}

  	extractRotation( m ) {

  		// this method does not support reflection matrices

  		const te = this.elements;
  		const me = m.elements;

  		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
  		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
  		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

  		te[ 0 ] = me[ 0 ] * scaleX;
  		te[ 1 ] = me[ 1 ] * scaleX;
  		te[ 2 ] = me[ 2 ] * scaleX;
  		te[ 3 ] = 0;

  		te[ 4 ] = me[ 4 ] * scaleY;
  		te[ 5 ] = me[ 5 ] * scaleY;
  		te[ 6 ] = me[ 6 ] * scaleY;
  		te[ 7 ] = 0;

  		te[ 8 ] = me[ 8 ] * scaleZ;
  		te[ 9 ] = me[ 9 ] * scaleZ;
  		te[ 10 ] = me[ 10 ] * scaleZ;
  		te[ 11 ] = 0;

  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	}

  	makeRotationFromEuler( euler ) {

  		if ( ! ( euler && euler.isEuler ) ) {

  			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

  		}

  		const te = this.elements;

  		const x = euler.x, y = euler.y, z = euler.z;
  		const a = Math.cos( x ), b = Math.sin( x );
  		const c = Math.cos( y ), d = Math.sin( y );
  		const e = Math.cos( z ), f = Math.sin( z );

  		if ( euler.order === 'XYZ' ) {

  			const ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - c * f;
  			te[ 8 ] = d;

  			te[ 1 ] = af + be * d;
  			te[ 5 ] = ae - bf * d;
  			te[ 9 ] = - b * c;

  			te[ 2 ] = bf - ae * d;
  			te[ 6 ] = be + af * d;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YXZ' ) {

  			const ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce + df * b;
  			te[ 4 ] = de * b - cf;
  			te[ 8 ] = a * d;

  			te[ 1 ] = a * f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b;

  			te[ 2 ] = cf * b - de;
  			te[ 6 ] = df + ce * b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZXY' ) {

  			const ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce - df * b;
  			te[ 4 ] = - a * f;
  			te[ 8 ] = de + cf * b;

  			te[ 1 ] = cf + de * b;
  			te[ 5 ] = a * e;
  			te[ 9 ] = df - ce * b;

  			te[ 2 ] = - a * d;
  			te[ 6 ] = b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZYX' ) {

  			const ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = be * d - af;
  			te[ 8 ] = ae * d + bf;

  			te[ 1 ] = c * f;
  			te[ 5 ] = bf * d + ae;
  			te[ 9 ] = af * d - be;

  			te[ 2 ] = - d;
  			te[ 6 ] = b * c;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YZX' ) {

  			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = bd - ac * f;
  			te[ 8 ] = bc * f + ad;

  			te[ 1 ] = f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b * e;

  			te[ 2 ] = - d * e;
  			te[ 6 ] = ad * f + bc;
  			te[ 10 ] = ac - bd * f;

  		} else if ( euler.order === 'XZY' ) {

  			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - f;
  			te[ 8 ] = d * e;

  			te[ 1 ] = ac * f + bd;
  			te[ 5 ] = a * e;
  			te[ 9 ] = ad * f - bc;

  			te[ 2 ] = bc * f - ad;
  			te[ 6 ] = b * e;
  			te[ 10 ] = bd * f + ac;

  		}

  		// bottom row
  		te[ 3 ] = 0;
  		te[ 7 ] = 0;
  		te[ 11 ] = 0;

  		// last column
  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	}

  	makeRotationFromQuaternion( q ) {

  		return this.compose( _zero, q, _one );

  	}

  	lookAt( eye, target, up ) {

  		const te = this.elements;

  		_z.subVectors( eye, target );

  		if ( _z.lengthSq() === 0 ) {

  			// eye and target are in the same position

  			_z.z = 1;

  		}

  		_z.normalize();
  		_x.crossVectors( up, _z );

  		if ( _x.lengthSq() === 0 ) {

  			// up and z are parallel

  			if ( Math.abs( up.z ) === 1 ) {

  				_z.x += 0.0001;

  			} else {

  				_z.z += 0.0001;

  			}

  			_z.normalize();
  			_x.crossVectors( up, _z );

  		}

  		_x.normalize();
  		_y.crossVectors( _z, _x );

  		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
  		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
  		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

  		return this;

  	}

  	multiply( m, n ) {

  		if ( n !== undefined ) {

  			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
  			return this.multiplyMatrices( m, n );

  		}

  		return this.multiplyMatrices( this, m );

  	}

  	premultiply( m ) {

  		return this.multiplyMatrices( m, this );

  	}

  	multiplyMatrices( a, b ) {

  		const ae = a.elements;
  		const be = b.elements;
  		const te = this.elements;

  		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
  		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
  		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
  		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

  		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
  		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
  		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
  		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

  		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

  		return this;

  	}

  	multiplyScalar( s ) {

  		const te = this.elements;

  		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
  		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
  		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
  		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

  		return this;

  	}

  	determinant() {

  		const te = this.elements;

  		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
  		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
  		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
  		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

  		//TODO: make this more efficient
  		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

  		return (
  			n41 * (
  				+ n14 * n23 * n32
  				 - n13 * n24 * n32
  				 - n14 * n22 * n33
  				 + n12 * n24 * n33
  				 + n13 * n22 * n34
  				 - n12 * n23 * n34
  			) +
  			n42 * (
  				+ n11 * n23 * n34
  				 - n11 * n24 * n33
  				 + n14 * n21 * n33
  				 - n13 * n21 * n34
  				 + n13 * n24 * n31
  				 - n14 * n23 * n31
  			) +
  			n43 * (
  				+ n11 * n24 * n32
  				 - n11 * n22 * n34
  				 - n14 * n21 * n32
  				 + n12 * n21 * n34
  				 + n14 * n22 * n31
  				 - n12 * n24 * n31
  			) +
  			n44 * (
  				- n13 * n22 * n31
  				 - n11 * n23 * n32
  				 + n11 * n22 * n33
  				 + n13 * n21 * n32
  				 - n12 * n21 * n33
  				 + n12 * n23 * n31
  			)

  		);

  	}

  	transpose() {

  		const te = this.elements;
  		let tmp;

  		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
  		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
  		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

  		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
  		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
  		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

  		return this;

  	}

  	setPosition( x, y, z ) {

  		const te = this.elements;

  		if ( x.isVector3 ) {

  			te[ 12 ] = x.x;
  			te[ 13 ] = x.y;
  			te[ 14 ] = x.z;

  		} else {

  			te[ 12 ] = x;
  			te[ 13 ] = y;
  			te[ 14 ] = z;

  		}

  		return this;

  	}

  	invert() {

  		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  		const te = this.elements,

  			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
  			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
  			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
  			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

  			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
  			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
  			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
  			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

  		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

  		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

  		const detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
  		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
  		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

  		te[ 4 ] = t12 * detInv;
  		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
  		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
  		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

  		te[ 8 ] = t13 * detInv;
  		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
  		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
  		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

  		te[ 12 ] = t14 * detInv;
  		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
  		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
  		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

  		return this;

  	}

  	scale( v ) {

  		const te = this.elements;
  		const x = v.x, y = v.y, z = v.z;

  		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
  		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
  		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
  		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

  		return this;

  	}

  	getMaxScaleOnAxis() {

  		const te = this.elements;

  		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
  		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
  		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

  		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

  	}

  	makeTranslation( x, y, z ) {

  		this.set(

  			1, 0, 0, x,
  			0, 1, 0, y,
  			0, 0, 1, z,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeRotationX( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			1, 0, 0, 0,
  			0, c, - s, 0,
  			0, s, c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeRotationY( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			 c, 0, s, 0,
  			 0, 1, 0, 0,
  			- s, 0, c, 0,
  			 0, 0, 0, 1

  		);

  		return this;

  	}

  	makeRotationZ( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			c, - s, 0, 0,
  			s, c, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeRotationAxis( axis, angle ) {

  		// Based on http://www.gamedev.net/reference/articles/article1199.asp

  		const c = Math.cos( angle );
  		const s = Math.sin( angle );
  		const t = 1 - c;
  		const x = axis.x, y = axis.y, z = axis.z;
  		const tx = t * x, ty = t * y;

  		this.set(

  			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
  			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
  			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeScale( x, y, z ) {

  		this.set(

  			x, 0, 0, 0,
  			0, y, 0, 0,
  			0, 0, z, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeShear( xy, xz, yx, yz, zx, zy ) {

  		this.set(

  			1, yx, zx, 0,
  			xy, 1, zy, 0,
  			xz, yz, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	compose( position, quaternion, scale ) {

  		const te = this.elements;

  		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
  		const x2 = x + x,	y2 = y + y, z2 = z + z;
  		const xx = x * x2, xy = x * y2, xz = x * z2;
  		const yy = y * y2, yz = y * z2, zz = z * z2;
  		const wx = w * x2, wy = w * y2, wz = w * z2;

  		const sx = scale.x, sy = scale.y, sz = scale.z;

  		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
  		te[ 1 ] = ( xy + wz ) * sx;
  		te[ 2 ] = ( xz - wy ) * sx;
  		te[ 3 ] = 0;

  		te[ 4 ] = ( xy - wz ) * sy;
  		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
  		te[ 6 ] = ( yz + wx ) * sy;
  		te[ 7 ] = 0;

  		te[ 8 ] = ( xz + wy ) * sz;
  		te[ 9 ] = ( yz - wx ) * sz;
  		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
  		te[ 11 ] = 0;

  		te[ 12 ] = position.x;
  		te[ 13 ] = position.y;
  		te[ 14 ] = position.z;
  		te[ 15 ] = 1;

  		return this;

  	}

  	decompose( position, quaternion, scale ) {

  		const te = this.elements;

  		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
  		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
  		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

  		// if determine is negative, we need to invert one scale
  		const det = this.determinant();
  		if ( det < 0 ) sx = - sx;

  		position.x = te[ 12 ];
  		position.y = te[ 13 ];
  		position.z = te[ 14 ];

  		// scale the rotation part
  		_m1$2.copy( this );

  		const invSX = 1 / sx;
  		const invSY = 1 / sy;
  		const invSZ = 1 / sz;

  		_m1$2.elements[ 0 ] *= invSX;
  		_m1$2.elements[ 1 ] *= invSX;
  		_m1$2.elements[ 2 ] *= invSX;

  		_m1$2.elements[ 4 ] *= invSY;
  		_m1$2.elements[ 5 ] *= invSY;
  		_m1$2.elements[ 6 ] *= invSY;

  		_m1$2.elements[ 8 ] *= invSZ;
  		_m1$2.elements[ 9 ] *= invSZ;
  		_m1$2.elements[ 10 ] *= invSZ;

  		quaternion.setFromRotationMatrix( _m1$2 );

  		scale.x = sx;
  		scale.y = sy;
  		scale.z = sz;

  		return this;

  	}

  	makePerspective( left, right, top, bottom, near, far ) {

  		if ( far === undefined ) {

  			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

  		}

  		const te = this.elements;
  		const x = 2 * near / ( right - left );
  		const y = 2 * near / ( top - bottom );

  		const a = ( right + left ) / ( right - left );
  		const b = ( top + bottom ) / ( top - bottom );
  		const c = - ( far + near ) / ( far - near );
  		const d = - 2 * far * near / ( far - near );

  		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
  		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

  		return this;

  	}

  	makeOrthographic( left, right, top, bottom, near, far ) {

  		const te = this.elements;
  		const w = 1.0 / ( right - left );
  		const h = 1.0 / ( top - bottom );
  		const p = 1.0 / ( far - near );

  		const x = ( right + left ) * w;
  		const y = ( top + bottom ) * h;
  		const z = ( far + near ) * p;

  		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
  		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

  		return this;

  	}

  	equals( matrix ) {

  		const te = this.elements;
  		const me = matrix.elements;

  		for ( let i = 0; i < 16; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) return false;

  		}

  		return true;

  	}

  	fromArray( array, offset = 0 ) {

  		for ( let i = 0; i < 16; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		const te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];
  		array[ offset + 3 ] = te[ 3 ];

  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];
  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];

  		array[ offset + 8 ] = te[ 8 ];
  		array[ offset + 9 ] = te[ 9 ];
  		array[ offset + 10 ] = te[ 10 ];
  		array[ offset + 11 ] = te[ 11 ];

  		array[ offset + 12 ] = te[ 12 ];
  		array[ offset + 13 ] = te[ 13 ];
  		array[ offset + 14 ] = te[ 14 ];
  		array[ offset + 15 ] = te[ 15 ];

  		return array;

  	}

  }

  Matrix4.prototype.isMatrix4 = true;

  const _v1$5 = /*@__PURE__*/ new Vector3();
  const _m1$2 = /*@__PURE__*/ new Matrix4();
  const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
  const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
  const _x = /*@__PURE__*/ new Vector3();
  const _y = /*@__PURE__*/ new Vector3();
  const _z = /*@__PURE__*/ new Vector3();

  const _matrix$1 = /*@__PURE__*/ new Matrix4();
  const _quaternion$3 = /*@__PURE__*/ new Quaternion();

  class Euler {

  	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order;

  	}

  	get x() {

  		return this._x;

  	}

  	set x( value ) {

  		this._x = value;
  		this._onChangeCallback();

  	}

  	get y() {

  		return this._y;

  	}

  	set y( value ) {

  		this._y = value;
  		this._onChangeCallback();

  	}

  	get z() {

  		return this._z;

  	}

  	set z( value ) {

  		this._z = value;
  		this._onChangeCallback();

  	}

  	get order() {

  		return this._order;

  	}

  	set order( value ) {

  		this._order = value;
  		this._onChangeCallback();

  	}

  	set( x, y, z, order ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order || this._order;

  		this._onChangeCallback();

  		return this;

  	}

  	clone() {

  		return new this.constructor( this._x, this._y, this._z, this._order );

  	}

  	copy( euler ) {

  		this._x = euler._x;
  		this._y = euler._y;
  		this._z = euler._z;
  		this._order = euler._order;

  		this._onChangeCallback();

  		return this;

  	}

  	setFromRotationMatrix( m, order, update ) {

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		const te = m.elements;
  		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
  		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
  		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		order = order || this._order;

  		switch ( order ) {

  			case 'XYZ':

  				this._y = Math.asin( clamp( m13, - 1, 1 ) );

  				if ( Math.abs( m13 ) < 0.9999999 ) {

  					this._x = Math.atan2( - m23, m33 );
  					this._z = Math.atan2( - m12, m11 );

  				} else {

  					this._x = Math.atan2( m32, m22 );
  					this._z = 0;

  				}

  				break;

  			case 'YXZ':

  				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

  				if ( Math.abs( m23 ) < 0.9999999 ) {

  					this._y = Math.atan2( m13, m33 );
  					this._z = Math.atan2( m21, m22 );

  				} else {

  					this._y = Math.atan2( - m31, m11 );
  					this._z = 0;

  				}

  				break;

  			case 'ZXY':

  				this._x = Math.asin( clamp( m32, - 1, 1 ) );

  				if ( Math.abs( m32 ) < 0.9999999 ) {

  					this._y = Math.atan2( - m31, m33 );
  					this._z = Math.atan2( - m12, m22 );

  				} else {

  					this._y = 0;
  					this._z = Math.atan2( m21, m11 );

  				}

  				break;

  			case 'ZYX':

  				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

  				if ( Math.abs( m31 ) < 0.9999999 ) {

  					this._x = Math.atan2( m32, m33 );
  					this._z = Math.atan2( m21, m11 );

  				} else {

  					this._x = 0;
  					this._z = Math.atan2( - m12, m22 );

  				}

  				break;

  			case 'YZX':

  				this._z = Math.asin( clamp( m21, - 1, 1 ) );

  				if ( Math.abs( m21 ) < 0.9999999 ) {

  					this._x = Math.atan2( - m23, m22 );
  					this._y = Math.atan2( - m31, m11 );

  				} else {

  					this._x = 0;
  					this._y = Math.atan2( m13, m33 );

  				}

  				break;

  			case 'XZY':

  				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

  				if ( Math.abs( m12 ) < 0.9999999 ) {

  					this._x = Math.atan2( m32, m22 );
  					this._y = Math.atan2( m13, m11 );

  				} else {

  					this._x = Math.atan2( - m23, m33 );
  					this._y = 0;

  				}

  				break;

  			default:

  				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

  		}

  		this._order = order;

  		if ( update !== false ) this._onChangeCallback();

  		return this;

  	}

  	setFromQuaternion( q, order, update ) {

  		_matrix$1.makeRotationFromQuaternion( q );

  		return this.setFromRotationMatrix( _matrix$1, order, update );

  	}

  	setFromVector3( v, order ) {

  		return this.set( v.x, v.y, v.z, order || this._order );

  	}

  	reorder( newOrder ) {

  		// WARNING: this discards revolution information -bhouston

  		_quaternion$3.setFromEuler( this );

  		return this.setFromQuaternion( _quaternion$3, newOrder );

  	}

  	equals( euler ) {

  		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  	}

  	fromArray( array ) {

  		this._x = array[ 0 ];
  		this._y = array[ 1 ];
  		this._z = array[ 2 ];
  		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

  		this._onChangeCallback();

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._order;

  		return array;

  	}

  	toVector3( optionalResult ) {

  		if ( optionalResult ) {

  			return optionalResult.set( this._x, this._y, this._z );

  		} else {

  			return new Vector3( this._x, this._y, this._z );

  		}

  	}

  	_onChange( callback ) {

  		this._onChangeCallback = callback;

  		return this;

  	}

  	_onChangeCallback() {}

  }

  Euler.prototype.isEuler = true;

  Euler.DefaultOrder = 'XYZ';
  Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

  class Layers {

  	constructor() {

  		this.mask = 1 | 0;

  	}

  	set( channel ) {

  		this.mask = 1 << channel | 0;

  	}

  	enable( channel ) {

  		this.mask |= 1 << channel | 0;

  	}

  	enableAll() {

  		this.mask = 0xffffffff | 0;

  	}

  	toggle( channel ) {

  		this.mask ^= 1 << channel | 0;

  	}

  	disable( channel ) {

  		this.mask &= ~ ( 1 << channel | 0 );

  	}

  	disableAll() {

  		this.mask = 0;

  	}

  	test( layers ) {

  		return ( this.mask & layers.mask ) !== 0;

  	}

  }

  let _object3DId = 0;

  const _v1$4 = /*@__PURE__*/ new Vector3();
  const _q1 = /*@__PURE__*/ new Quaternion();
  const _m1$1 = /*@__PURE__*/ new Matrix4();
  const _target = /*@__PURE__*/ new Vector3();

  const _position$3 = /*@__PURE__*/ new Vector3();
  const _scale$2 = /*@__PURE__*/ new Vector3();
  const _quaternion$2 = /*@__PURE__*/ new Quaternion();

  const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
  const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
  const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

  const _addedEvent = { type: 'added' };
  const _removedEvent = { type: 'removed' };

  class Object3D extends EventDispatcher {

  	constructor() {

  		super();

  		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

  		this.uuid = generateUUID();

  		this.name = '';
  		this.type = 'Object3D';

  		this.parent = null;
  		this.children = [];

  		this.up = Object3D.DefaultUp.clone();

  		const position = new Vector3();
  		const rotation = new Euler();
  		const quaternion = new Quaternion();
  		const scale = new Vector3( 1, 1, 1 );

  		function onRotationChange() {

  			quaternion.setFromEuler( rotation, false );

  		}

  		function onQuaternionChange() {

  			rotation.setFromQuaternion( quaternion, undefined, false );

  		}

  		rotation._onChange( onRotationChange );
  		quaternion._onChange( onQuaternionChange );

  		Object.defineProperties( this, {
  			position: {
  				configurable: true,
  				enumerable: true,
  				value: position
  			},
  			rotation: {
  				configurable: true,
  				enumerable: true,
  				value: rotation
  			},
  			quaternion: {
  				configurable: true,
  				enumerable: true,
  				value: quaternion
  			},
  			scale: {
  				configurable: true,
  				enumerable: true,
  				value: scale
  			},
  			modelViewMatrix: {
  				value: new Matrix4()
  			},
  			normalMatrix: {
  				value: new Matrix3()
  			}
  		} );

  		this.matrix = new Matrix4();
  		this.matrixWorld = new Matrix4();

  		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  		this.matrixWorldNeedsUpdate = false;

  		this.layers = new Layers();
  		this.visible = true;

  		this.castShadow = false;
  		this.receiveShadow = false;

  		this.frustumCulled = true;
  		this.renderOrder = 0;

  		this.animations = [];

  		this.userData = {};

  	}

  	onBeforeRender() {}
  	onAfterRender() {}

  	applyMatrix4( matrix ) {

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		this.matrix.premultiply( matrix );

  		this.matrix.decompose( this.position, this.quaternion, this.scale );

  	}

  	applyQuaternion( q ) {

  		this.quaternion.premultiply( q );

  		return this;

  	}

  	setRotationFromAxisAngle( axis, angle ) {

  		// assumes axis is normalized

  		this.quaternion.setFromAxisAngle( axis, angle );

  	}

  	setRotationFromEuler( euler ) {

  		this.quaternion.setFromEuler( euler, true );

  	}

  	setRotationFromMatrix( m ) {

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		this.quaternion.setFromRotationMatrix( m );

  	}

  	setRotationFromQuaternion( q ) {

  		// assumes q is normalized

  		this.quaternion.copy( q );

  	}

  	rotateOnAxis( axis, angle ) {

  		// rotate object on axis in object space
  		// axis is assumed to be normalized

  		_q1.setFromAxisAngle( axis, angle );

  		this.quaternion.multiply( _q1 );

  		return this;

  	}

  	rotateOnWorldAxis( axis, angle ) {

  		// rotate object on axis in world space
  		// axis is assumed to be normalized
  		// method assumes no rotated parent

  		_q1.setFromAxisAngle( axis, angle );

  		this.quaternion.premultiply( _q1 );

  		return this;

  	}

  	rotateX( angle ) {

  		return this.rotateOnAxis( _xAxis, angle );

  	}

  	rotateY( angle ) {

  		return this.rotateOnAxis( _yAxis, angle );

  	}

  	rotateZ( angle ) {

  		return this.rotateOnAxis( _zAxis, angle );

  	}

  	translateOnAxis( axis, distance ) {

  		// translate object by distance along axis in object space
  		// axis is assumed to be normalized

  		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

  		this.position.add( _v1$4.multiplyScalar( distance ) );

  		return this;

  	}

  	translateX( distance ) {

  		return this.translateOnAxis( _xAxis, distance );

  	}

  	translateY( distance ) {

  		return this.translateOnAxis( _yAxis, distance );

  	}

  	translateZ( distance ) {

  		return this.translateOnAxis( _zAxis, distance );

  	}

  	localToWorld( vector ) {

  		return vector.applyMatrix4( this.matrixWorld );

  	}

  	worldToLocal( vector ) {

  		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

  	}

  	lookAt( x, y, z ) {

  		// This method does not support objects having non-uniformly-scaled parent(s)

  		if ( x.isVector3 ) {

  			_target.copy( x );

  		} else {

  			_target.set( x, y, z );

  		}

  		const parent = this.parent;

  		this.updateWorldMatrix( true, false );

  		_position$3.setFromMatrixPosition( this.matrixWorld );

  		if ( this.isCamera || this.isLight ) {

  			_m1$1.lookAt( _position$3, _target, this.up );

  		} else {

  			_m1$1.lookAt( _target, _position$3, this.up );

  		}

  		this.quaternion.setFromRotationMatrix( _m1$1 );

  		if ( parent ) {

  			_m1$1.extractRotation( parent.matrixWorld );
  			_q1.setFromRotationMatrix( _m1$1 );
  			this.quaternion.premultiply( _q1.invert() );

  		}

  	}

  	add( object ) {

  		if ( arguments.length > 1 ) {

  			for ( let i = 0; i < arguments.length; i ++ ) {

  				this.add( arguments[ i ] );

  			}

  			return this;

  		}

  		if ( object === this ) {

  			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
  			return this;

  		}

  		if ( object && object.isObject3D ) {

  			if ( object.parent !== null ) {

  				object.parent.remove( object );

  			}

  			object.parent = this;
  			this.children.push( object );

  			object.dispatchEvent( _addedEvent );

  		} else {

  			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

  		}

  		return this;

  	}

  	remove( object ) {

  		if ( arguments.length > 1 ) {

  			for ( let i = 0; i < arguments.length; i ++ ) {

  				this.remove( arguments[ i ] );

  			}

  			return this;

  		}

  		const index = this.children.indexOf( object );

  		if ( index !== - 1 ) {

  			object.parent = null;
  			this.children.splice( index, 1 );

  			object.dispatchEvent( _removedEvent );

  		}

  		return this;

  	}

  	removeFromParent() {

  		const parent = this.parent;

  		if ( parent !== null ) {

  			parent.remove( this );

  		}

  		return this;

  	}

  	clear() {

  		for ( let i = 0; i < this.children.length; i ++ ) {

  			const object = this.children[ i ];

  			object.parent = null;

  			object.dispatchEvent( _removedEvent );

  		}

  		this.children.length = 0;

  		return this;


  	}

  	attach( object ) {

  		// adds object as a child of this, while maintaining the object's world transform

  		this.updateWorldMatrix( true, false );

  		_m1$1.copy( this.matrixWorld ).invert();

  		if ( object.parent !== null ) {

  			object.parent.updateWorldMatrix( true, false );

  			_m1$1.multiply( object.parent.matrixWorld );

  		}

  		object.applyMatrix4( _m1$1 );

  		this.add( object );

  		object.updateWorldMatrix( false, true );

  		return this;

  	}

  	getObjectById( id ) {

  		return this.getObjectByProperty( 'id', id );

  	}

  	getObjectByName( name ) {

  		return this.getObjectByProperty( 'name', name );

  	}

  	getObjectByProperty( name, value ) {

  		if ( this[ name ] === value ) return this;

  		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

  			const child = this.children[ i ];
  			const object = child.getObjectByProperty( name, value );

  			if ( object !== undefined ) {

  				return object;

  			}

  		}

  		return undefined;

  	}

  	getWorldPosition( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
  			target = new Vector3();

  		}

  		this.updateWorldMatrix( true, false );

  		return target.setFromMatrixPosition( this.matrixWorld );

  	}

  	getWorldQuaternion( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
  			target = new Quaternion();

  		}

  		this.updateWorldMatrix( true, false );

  		this.matrixWorld.decompose( _position$3, target, _scale$2 );

  		return target;

  	}

  	getWorldScale( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
  			target = new Vector3();

  		}

  		this.updateWorldMatrix( true, false );

  		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

  		return target;

  	}

  	getWorldDirection( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
  			target = new Vector3();

  		}

  		this.updateWorldMatrix( true, false );

  		const e = this.matrixWorld.elements;

  		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

  	}

  	raycast() {}

  	traverse( callback ) {

  		callback( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverse( callback );

  		}

  	}

  	traverseVisible( callback ) {

  		if ( this.visible === false ) return;

  		callback( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverseVisible( callback );

  		}

  	}

  	traverseAncestors( callback ) {

  		const parent = this.parent;

  		if ( parent !== null ) {

  			callback( parent );

  			parent.traverseAncestors( callback );

  		}

  	}

  	updateMatrix() {

  		this.matrix.compose( this.position, this.quaternion, this.scale );

  		this.matrixWorldNeedsUpdate = true;

  	}

  	updateMatrixWorld( force ) {

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		if ( this.matrixWorldNeedsUpdate || force ) {

  			if ( this.parent === null ) {

  				this.matrixWorld.copy( this.matrix );

  			} else {

  				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  			}

  			this.matrixWorldNeedsUpdate = false;

  			force = true;

  		}

  		// update children

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].updateMatrixWorld( force );

  		}

  	}

  	updateWorldMatrix( updateParents, updateChildren ) {

  		const parent = this.parent;

  		if ( updateParents === true && parent !== null ) {

  			parent.updateWorldMatrix( true, false );

  		}

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		if ( this.parent === null ) {

  			this.matrixWorld.copy( this.matrix );

  		} else {

  			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  		}

  		// update children

  		if ( updateChildren === true ) {

  			const children = this.children;

  			for ( let i = 0, l = children.length; i < l; i ++ ) {

  				children[ i ].updateWorldMatrix( false, true );

  			}

  		}

  	}

  	toJSON( meta ) {

  		// meta is a string when called from JSON.stringify
  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		const output = {};

  		// meta is a hash used to collect geometries, materials.
  		// not providing it implies that this is the root object
  		// being serialized.
  		if ( isRootObject ) {

  			// initialize meta obj
  			meta = {
  				geometries: {},
  				materials: {},
  				textures: {},
  				images: {},
  				shapes: {},
  				skeletons: {},
  				animations: {}
  			};

  			output.metadata = {
  				version: 4.5,
  				type: 'Object',
  				generator: 'Object3D.toJSON'
  			};

  		}

  		// standard Object3D serialization

  		const object = {};

  		object.uuid = this.uuid;
  		object.type = this.type;

  		if ( this.name !== '' ) object.name = this.name;
  		if ( this.castShadow === true ) object.castShadow = true;
  		if ( this.receiveShadow === true ) object.receiveShadow = true;
  		if ( this.visible === false ) object.visible = false;
  		if ( this.frustumCulled === false ) object.frustumCulled = false;
  		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
  		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

  		object.layers = this.layers.mask;
  		object.matrix = this.matrix.toArray();

  		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

  		// object specific properties

  		if ( this.isInstancedMesh ) {

  			object.type = 'InstancedMesh';
  			object.count = this.count;
  			object.instanceMatrix = this.instanceMatrix.toJSON();
  			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

  		}

  		//

  		function serialize( library, element ) {

  			if ( library[ element.uuid ] === undefined ) {

  				library[ element.uuid ] = element.toJSON( meta );

  			}

  			return element.uuid;

  		}

  		if ( this.isMesh || this.isLine || this.isPoints ) {

  			object.geometry = serialize( meta.geometries, this.geometry );

  			const parameters = this.geometry.parameters;

  			if ( parameters !== undefined && parameters.shapes !== undefined ) {

  				const shapes = parameters.shapes;

  				if ( Array.isArray( shapes ) ) {

  					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

  						const shape = shapes[ i ];

  						serialize( meta.shapes, shape );

  					}

  				} else {

  					serialize( meta.shapes, shapes );

  				}

  			}

  		}

  		if ( this.isSkinnedMesh ) {

  			object.bindMode = this.bindMode;
  			object.bindMatrix = this.bindMatrix.toArray();

  			if ( this.skeleton !== undefined ) {

  				serialize( meta.skeletons, this.skeleton );

  				object.skeleton = this.skeleton.uuid;

  			}

  		}

  		if ( this.material !== undefined ) {

  			if ( Array.isArray( this.material ) ) {

  				const uuids = [];

  				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

  					uuids.push( serialize( meta.materials, this.material[ i ] ) );

  				}

  				object.material = uuids;

  			} else {

  				object.material = serialize( meta.materials, this.material );

  			}

  		}

  		//

  		if ( this.children.length > 0 ) {

  			object.children = [];

  			for ( let i = 0; i < this.children.length; i ++ ) {

  				object.children.push( this.children[ i ].toJSON( meta ).object );

  			}

  		}

  		//

  		if ( this.animations.length > 0 ) {

  			object.animations = [];

  			for ( let i = 0; i < this.animations.length; i ++ ) {

  				const animation = this.animations[ i ];

  				object.animations.push( serialize( meta.animations, animation ) );

  			}

  		}

  		if ( isRootObject ) {

  			const geometries = extractFromCache( meta.geometries );
  			const materials = extractFromCache( meta.materials );
  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );
  			const shapes = extractFromCache( meta.shapes );
  			const skeletons = extractFromCache( meta.skeletons );
  			const animations = extractFromCache( meta.animations );

  			if ( geometries.length > 0 ) output.geometries = geometries;
  			if ( materials.length > 0 ) output.materials = materials;
  			if ( textures.length > 0 ) output.textures = textures;
  			if ( images.length > 0 ) output.images = images;
  			if ( shapes.length > 0 ) output.shapes = shapes;
  			if ( skeletons.length > 0 ) output.skeletons = skeletons;
  			if ( animations.length > 0 ) output.animations = animations;

  		}

  		output.object = object;

  		return output;

  		// extract data from the cache hash
  		// remove metadata on each item
  		// and return as array
  		function extractFromCache( cache ) {

  			const values = [];
  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  	}

  	clone( recursive ) {

  		return new this.constructor().copy( this, recursive );

  	}

  	copy( source, recursive = true ) {

  		this.name = source.name;

  		this.up.copy( source.up );

  		this.position.copy( source.position );
  		this.rotation.order = source.rotation.order;
  		this.quaternion.copy( source.quaternion );
  		this.scale.copy( source.scale );

  		this.matrix.copy( source.matrix );
  		this.matrixWorld.copy( source.matrixWorld );

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

  		this.layers.mask = source.layers.mask;
  		this.visible = source.visible;

  		this.castShadow = source.castShadow;
  		this.receiveShadow = source.receiveShadow;

  		this.frustumCulled = source.frustumCulled;
  		this.renderOrder = source.renderOrder;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		if ( recursive === true ) {

  			for ( let i = 0; i < source.children.length; i ++ ) {

  				const child = source.children[ i ];
  				this.add( child.clone() );

  			}

  		}

  		return this;

  	}

  }

  Object3D.DefaultUp = new Vector3( 0, 1, 0 );
  Object3D.DefaultMatrixAutoUpdate = true;

  Object3D.prototype.isObject3D = true;

  const _vector1 = /*@__PURE__*/ new Vector3();
  const _vector2$1 = /*@__PURE__*/ new Vector3();
  const _normalMatrix = /*@__PURE__*/ new Matrix3();

  class Plane {

  	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

  		// normal is assumed to be normalized

  		this.normal = normal;
  		this.constant = constant;

  	}

  	set( normal, constant ) {

  		this.normal.copy( normal );
  		this.constant = constant;

  		return this;

  	}

  	setComponents( x, y, z, w ) {

  		this.normal.set( x, y, z );
  		this.constant = w;

  		return this;

  	}

  	setFromNormalAndCoplanarPoint( normal, point ) {

  		this.normal.copy( normal );
  		this.constant = - point.dot( this.normal );

  		return this;

  	}

  	setFromCoplanarPoints( a, b, c ) {

  		const normal = _vector1.subVectors( c, b ).cross( _vector2$1.subVectors( a, b ) ).normalize();

  		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

  		this.setFromNormalAndCoplanarPoint( normal, a );

  		return this;

  	}

  	copy( plane ) {

  		this.normal.copy( plane.normal );
  		this.constant = plane.constant;

  		return this;

  	}

  	normalize() {

  		// Note: will lead to a divide by zero if the plane is invalid.

  		const inverseNormalLength = 1.0 / this.normal.length();
  		this.normal.multiplyScalar( inverseNormalLength );
  		this.constant *= inverseNormalLength;

  		return this;

  	}

  	negate() {

  		this.constant *= - 1;
  		this.normal.negate();

  		return this;

  	}

  	distanceToPoint( point ) {

  		return this.normal.dot( point ) + this.constant;

  	}

  	distanceToSphere( sphere ) {

  		return this.distanceToPoint( sphere.center ) - sphere.radius;

  	}

  	projectPoint( point, target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Plane: .projectPoint() target is now required' );
  			target = new Vector3();

  		}

  		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

  	}

  	intersectLine( line, target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Plane: .intersectLine() target is now required' );
  			target = new Vector3();

  		}

  		const direction = line.delta( _vector1 );

  		const denominator = this.normal.dot( direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( this.distanceToPoint( line.start ) === 0 ) {

  				return target.copy( line.start );

  			}

  			// Unsure if this is the correct method to handle this case.
  			return null;

  		}

  		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

  		if ( t < 0 || t > 1 ) {

  			return null;

  		}

  		return target.copy( direction ).multiplyScalar( t ).add( line.start );

  	}

  	intersectsLine( line ) {

  		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

  		const startSign = this.distanceToPoint( line.start );
  		const endSign = this.distanceToPoint( line.end );

  		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  	}

  	intersectsBox( box ) {

  		return box.intersectsPlane( this );

  	}

  	intersectsSphere( sphere ) {

  		return sphere.intersectsPlane( this );

  	}

  	coplanarPoint( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
  			target = new Vector3();

  		}

  		return target.copy( this.normal ).multiplyScalar( - this.constant );

  	}

  	applyMatrix4( matrix, optionalNormalMatrix ) {

  		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

  		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

  		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

  		this.constant = - referencePoint.dot( normal );

  		return this;

  	}

  	translate( offset ) {

  		this.constant -= offset.dot( this.normal );

  		return this;

  	}

  	equals( plane ) {

  		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  Plane.prototype.isPlane = true;

  const _v0$1 = /*@__PURE__*/ new Vector3();
  const _v1$3 = /*@__PURE__*/ new Vector3();
  const _v2$2 = /*@__PURE__*/ new Vector3();
  const _v3$1 = /*@__PURE__*/ new Vector3();

  const _vab = /*@__PURE__*/ new Vector3();
  const _vac = /*@__PURE__*/ new Vector3();
  const _vbc = /*@__PURE__*/ new Vector3();
  const _vap = /*@__PURE__*/ new Vector3();
  const _vbp = /*@__PURE__*/ new Vector3();
  const _vcp = /*@__PURE__*/ new Vector3();

  class Triangle {

  	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

  		this.a = a;
  		this.b = b;
  		this.c = c;

  	}

  	static getNormal( a, b, c, target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Triangle: .getNormal() target is now required' );
  			target = new Vector3();

  		}

  		target.subVectors( c, b );
  		_v0$1.subVectors( a, b );
  		target.cross( _v0$1 );

  		const targetLengthSq = target.lengthSq();
  		if ( targetLengthSq > 0 ) {

  			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

  		}

  		return target.set( 0, 0, 0 );

  	}

  	// static/instance method to calculate barycentric coordinates
  	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  	static getBarycoord( point, a, b, c, target ) {

  		_v0$1.subVectors( c, a );
  		_v1$3.subVectors( b, a );
  		_v2$2.subVectors( point, a );

  		const dot00 = _v0$1.dot( _v0$1 );
  		const dot01 = _v0$1.dot( _v1$3 );
  		const dot02 = _v0$1.dot( _v2$2 );
  		const dot11 = _v1$3.dot( _v1$3 );
  		const dot12 = _v1$3.dot( _v2$2 );

  		const denom = ( dot00 * dot11 - dot01 * dot01 );

  		if ( target === undefined ) {

  			console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
  			target = new Vector3();

  		}

  		// collinear or singular triangle
  		if ( denom === 0 ) {

  			// arbitrary location outside of triangle?
  			// not sure if this is the best idea, maybe should be returning undefined
  			return target.set( - 2, - 1, - 1 );

  		}

  		const invDenom = 1 / denom;
  		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
  		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

  		// barycentric coordinates must always sum to 1
  		return target.set( 1 - u - v, v, u );

  	}

  	static containsPoint( point, a, b, c ) {

  		this.getBarycoord( point, a, b, c, _v3$1 );

  		return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

  	}

  	static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

  		this.getBarycoord( point, p1, p2, p3, _v3$1 );

  		target.set( 0, 0 );
  		target.addScaledVector( uv1, _v3$1.x );
  		target.addScaledVector( uv2, _v3$1.y );
  		target.addScaledVector( uv3, _v3$1.z );

  		return target;

  	}

  	static isFrontFacing( a, b, c, direction ) {

  		_v0$1.subVectors( c, b );
  		_v1$3.subVectors( a, b );

  		// strictly front facing
  		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

  	}

  	set( a, b, c ) {

  		this.a.copy( a );
  		this.b.copy( b );
  		this.c.copy( c );

  		return this;

  	}

  	setFromPointsAndIndices( points, i0, i1, i2 ) {

  		this.a.copy( points[ i0 ] );
  		this.b.copy( points[ i1 ] );
  		this.c.copy( points[ i2 ] );

  		return this;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( triangle ) {

  		this.a.copy( triangle.a );
  		this.b.copy( triangle.b );
  		this.c.copy( triangle.c );

  		return this;

  	}

  	getArea() {

  		_v0$1.subVectors( this.c, this.b );
  		_v1$3.subVectors( this.a, this.b );

  		return _v0$1.cross( _v1$3 ).length() * 0.5;

  	}

  	getMidpoint( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
  			target = new Vector3();

  		}

  		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  	}

  	getNormal( target ) {

  		return Triangle.getNormal( this.a, this.b, this.c, target );

  	}

  	getPlane( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Triangle: .getPlane() target is now required' );
  			target = new Plane();

  		}

  		return target.setFromCoplanarPoints( this.a, this.b, this.c );

  	}

  	getBarycoord( point, target ) {

  		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

  	}

  	getUV( point, uv1, uv2, uv3, target ) {

  		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

  	}

  	containsPoint( point ) {

  		return Triangle.containsPoint( point, this.a, this.b, this.c );

  	}

  	isFrontFacing( direction ) {

  		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

  	}

  	intersectsBox( box ) {

  		return box.intersectsTriangle( this );

  	}

  	closestPointToPoint( p, target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
  			target = new Vector3();

  		}

  		const a = this.a, b = this.b, c = this.c;
  		let v, w;

  		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
  		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
  		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
  		// basically, we're distinguishing which of the voronoi regions of the triangle
  		// the point lies in with the minimum amount of redundant computation.

  		_vab.subVectors( b, a );
  		_vac.subVectors( c, a );
  		_vap.subVectors( p, a );
  		const d1 = _vab.dot( _vap );
  		const d2 = _vac.dot( _vap );
  		if ( d1 <= 0 && d2 <= 0 ) {

  			// vertex region of A; barycentric coords (1, 0, 0)
  			return target.copy( a );

  		}

  		_vbp.subVectors( p, b );
  		const d3 = _vab.dot( _vbp );
  		const d4 = _vac.dot( _vbp );
  		if ( d3 >= 0 && d4 <= d3 ) {

  			// vertex region of B; barycentric coords (0, 1, 0)
  			return target.copy( b );

  		}

  		const vc = d1 * d4 - d3 * d2;
  		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

  			v = d1 / ( d1 - d3 );
  			// edge region of AB; barycentric coords (1-v, v, 0)
  			return target.copy( a ).addScaledVector( _vab, v );

  		}

  		_vcp.subVectors( p, c );
  		const d5 = _vab.dot( _vcp );
  		const d6 = _vac.dot( _vcp );
  		if ( d6 >= 0 && d5 <= d6 ) {

  			// vertex region of C; barycentric coords (0, 0, 1)
  			return target.copy( c );

  		}

  		const vb = d5 * d2 - d1 * d6;
  		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

  			w = d2 / ( d2 - d6 );
  			// edge region of AC; barycentric coords (1-w, 0, w)
  			return target.copy( a ).addScaledVector( _vac, w );

  		}

  		const va = d3 * d6 - d5 * d4;
  		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

  			_vbc.subVectors( c, b );
  			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
  			// edge region of BC; barycentric coords (0, 1-w, w)
  			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

  		}

  		// face region
  		const denom = 1 / ( va + vb + vc );
  		// u = va * denom
  		v = vb * denom;
  		w = vc * denom;

  		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

  	}

  	equals( triangle ) {

  		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  	}

  }

  let materialId = 0;

  class Material extends EventDispatcher {

  	constructor() {

  		super();

  		Object.defineProperty( this, 'id', { value: materialId ++ } );

  		this.uuid = generateUUID();

  		this.name = '';
  		this.type = 'Material';

  		this.fog = true;

  		this.blending = NormalBlending;
  		this.side = FrontSide;
  		this.vertexColors = false;

  		this.opacity = 1;
  		this.transparent = false;

  		this.blendSrc = SrcAlphaFactor;
  		this.blendDst = OneMinusSrcAlphaFactor;
  		this.blendEquation = AddEquation;
  		this.blendSrcAlpha = null;
  		this.blendDstAlpha = null;
  		this.blendEquationAlpha = null;

  		this.depthFunc = LessEqualDepth;
  		this.depthTest = true;
  		this.depthWrite = true;

  		this.stencilWriteMask = 0xff;
  		this.stencilFunc = AlwaysStencilFunc;
  		this.stencilRef = 0;
  		this.stencilFuncMask = 0xff;
  		this.stencilFail = KeepStencilOp;
  		this.stencilZFail = KeepStencilOp;
  		this.stencilZPass = KeepStencilOp;
  		this.stencilWrite = false;

  		this.clippingPlanes = null;
  		this.clipIntersection = false;
  		this.clipShadows = false;

  		this.shadowSide = null;

  		this.colorWrite = true;

  		this.precision = null; // override the renderer's default precision for this material

  		this.polygonOffset = false;
  		this.polygonOffsetFactor = 0;
  		this.polygonOffsetUnits = 0;

  		this.dithering = false;

  		this.alphaTest = 0;
  		this.alphaToCoverage = false;
  		this.premultipliedAlpha = false;

  		this.visible = true;

  		this.toneMapped = true;

  		this.userData = {};

  		this.version = 0;

  	}

  	onBuild( /* shaderobject, renderer */ ) {}

  	onBeforeCompile( /* shaderobject, renderer */ ) {}

  	customProgramCacheKey() {

  		return this.onBeforeCompile.toString();

  	}

  	setValues( values ) {

  		if ( values === undefined ) return;

  		for ( const key in values ) {

  			const newValue = values[ key ];

  			if ( newValue === undefined ) {

  				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
  				continue;

  			}

  			// for backward compatability if shading is set in the constructor
  			if ( key === 'shading' ) {

  				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
  				this.flatShading = ( newValue === FlatShading ) ? true : false;
  				continue;

  			}

  			const currentValue = this[ key ];

  			if ( currentValue === undefined ) {

  				console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
  				continue;

  			}

  			if ( currentValue && currentValue.isColor ) {

  				currentValue.set( newValue );

  			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

  				currentValue.copy( newValue );

  			} else {

  				this[ key ] = newValue;

  			}

  		}

  	}

  	toJSON( meta ) {

  		const isRoot = ( meta === undefined || typeof meta === 'string' );

  		if ( isRoot ) {

  			meta = {
  				textures: {},
  				images: {}
  			};

  		}

  		const data = {
  			metadata: {
  				version: 4.5,
  				type: 'Material',
  				generator: 'Material.toJSON'
  			}
  		};

  		// standard Material serialization
  		data.uuid = this.uuid;
  		data.type = this.type;

  		if ( this.name !== '' ) data.name = this.name;

  		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

  		if ( this.roughness !== undefined ) data.roughness = this.roughness;
  		if ( this.metalness !== undefined ) data.metalness = this.metalness;

  		if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
  		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
  		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

  		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
  		if ( this.shininess !== undefined ) data.shininess = this.shininess;
  		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
  		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

  		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

  			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

  		}

  		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

  			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

  		}

  		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

  			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
  			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

  		}

  		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
  		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
  		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

  		if ( this.lightMap && this.lightMap.isTexture ) {

  			data.lightMap = this.lightMap.toJSON( meta ).uuid;
  			data.lightMapIntensity = this.lightMapIntensity;

  		}

  		if ( this.aoMap && this.aoMap.isTexture ) {

  			data.aoMap = this.aoMap.toJSON( meta ).uuid;
  			data.aoMapIntensity = this.aoMapIntensity;

  		}

  		if ( this.bumpMap && this.bumpMap.isTexture ) {

  			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
  			data.bumpScale = this.bumpScale;

  		}

  		if ( this.normalMap && this.normalMap.isTexture ) {

  			data.normalMap = this.normalMap.toJSON( meta ).uuid;
  			data.normalMapType = this.normalMapType;
  			data.normalScale = this.normalScale.toArray();

  		}

  		if ( this.displacementMap && this.displacementMap.isTexture ) {

  			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
  			data.displacementScale = this.displacementScale;
  			data.displacementBias = this.displacementBias;

  		}

  		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
  		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

  		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
  		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

  		if ( this.envMap && this.envMap.isTexture ) {

  			data.envMap = this.envMap.toJSON( meta ).uuid;

  			if ( this.combine !== undefined ) data.combine = this.combine;

  		}

  		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
  		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
  		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

  		if ( this.gradientMap && this.gradientMap.isTexture ) {

  			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

  		}

  		if ( this.transmission !== undefined ) data.transmission = this.transmission;
  		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
  		if ( this.thickness !== undefined ) data.thickness = this.thickness;
  		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
  		if ( this.attenuationDistance !== undefined ) data.attenuationDistance = this.attenuationDistance;
  		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

  		if ( this.size !== undefined ) data.size = this.size;
  		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
  		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

  		if ( this.blending !== NormalBlending ) data.blending = this.blending;
  		if ( this.side !== FrontSide ) data.side = this.side;
  		if ( this.vertexColors ) data.vertexColors = true;

  		if ( this.opacity < 1 ) data.opacity = this.opacity;
  		if ( this.transparent === true ) data.transparent = this.transparent;

  		data.depthFunc = this.depthFunc;
  		data.depthTest = this.depthTest;
  		data.depthWrite = this.depthWrite;
  		data.colorWrite = this.colorWrite;

  		data.stencilWrite = this.stencilWrite;
  		data.stencilWriteMask = this.stencilWriteMask;
  		data.stencilFunc = this.stencilFunc;
  		data.stencilRef = this.stencilRef;
  		data.stencilFuncMask = this.stencilFuncMask;
  		data.stencilFail = this.stencilFail;
  		data.stencilZFail = this.stencilZFail;
  		data.stencilZPass = this.stencilZPass;

  		// rotation (SpriteMaterial)
  		if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

  		if ( this.polygonOffset === true ) data.polygonOffset = true;
  		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
  		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

  		if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
  		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
  		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
  		if ( this.scale !== undefined ) data.scale = this.scale;

  		if ( this.dithering === true ) data.dithering = true;

  		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
  		if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
  		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

  		if ( this.wireframe === true ) data.wireframe = this.wireframe;
  		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
  		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
  		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

  		if ( this.morphTargets === true ) data.morphTargets = true;
  		if ( this.morphNormals === true ) data.morphNormals = true;

  		if ( this.flatShading === true ) data.flatShading = this.flatShading;

  		if ( this.visible === false ) data.visible = false;

  		if ( this.toneMapped === false ) data.toneMapped = false;

  		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			const values = [];

  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRoot ) {

  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );

  			if ( textures.length > 0 ) data.textures = textures;
  			if ( images.length > 0 ) data.images = images;

  		}

  		return data;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		this.name = source.name;

  		this.fog = source.fog;

  		this.blending = source.blending;
  		this.side = source.side;
  		this.vertexColors = source.vertexColors;

  		this.opacity = source.opacity;
  		this.transparent = source.transparent;

  		this.blendSrc = source.blendSrc;
  		this.blendDst = source.blendDst;
  		this.blendEquation = source.blendEquation;
  		this.blendSrcAlpha = source.blendSrcAlpha;
  		this.blendDstAlpha = source.blendDstAlpha;
  		this.blendEquationAlpha = source.blendEquationAlpha;

  		this.depthFunc = source.depthFunc;
  		this.depthTest = source.depthTest;
  		this.depthWrite = source.depthWrite;

  		this.stencilWriteMask = source.stencilWriteMask;
  		this.stencilFunc = source.stencilFunc;
  		this.stencilRef = source.stencilRef;
  		this.stencilFuncMask = source.stencilFuncMask;
  		this.stencilFail = source.stencilFail;
  		this.stencilZFail = source.stencilZFail;
  		this.stencilZPass = source.stencilZPass;
  		this.stencilWrite = source.stencilWrite;

  		const srcPlanes = source.clippingPlanes;
  		let dstPlanes = null;

  		if ( srcPlanes !== null ) {

  			const n = srcPlanes.length;
  			dstPlanes = new Array( n );

  			for ( let i = 0; i !== n; ++ i ) {

  				dstPlanes[ i ] = srcPlanes[ i ].clone();

  			}

  		}

  		this.clippingPlanes = dstPlanes;
  		this.clipIntersection = source.clipIntersection;
  		this.clipShadows = source.clipShadows;

  		this.shadowSide = source.shadowSide;

  		this.colorWrite = source.colorWrite;

  		this.precision = source.precision;

  		this.polygonOffset = source.polygonOffset;
  		this.polygonOffsetFactor = source.polygonOffsetFactor;
  		this.polygonOffsetUnits = source.polygonOffsetUnits;

  		this.dithering = source.dithering;

  		this.alphaTest = source.alphaTest;
  		this.alphaToCoverage = source.alphaToCoverage;
  		this.premultipliedAlpha = source.premultipliedAlpha;

  		this.visible = source.visible;

  		this.toneMapped = source.toneMapped;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		return this;

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  }

  Material.prototype.isMaterial = true;

  const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
  	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
  	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
  	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
  	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
  	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
  	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
  	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
  	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
  	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
  	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
  	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
  	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
  	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
  	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
  	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
  	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
  	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
  	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
  	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
  	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
  	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
  	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
  	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

  const _hslA = { h: 0, s: 0, l: 0 };
  const _hslB = { h: 0, s: 0, l: 0 };

  function hue2rgb( p, q, t ) {

  	if ( t < 0 ) t += 1;
  	if ( t > 1 ) t -= 1;
  	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
  	if ( t < 1 / 2 ) return q;
  	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
  	return p;

  }

  function SRGBToLinear( c ) {

  	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

  }

  function LinearToSRGB( c ) {

  	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

  }

  class Color {

  	constructor( r, g, b ) {

  		if ( g === undefined && b === undefined ) {

  			// r is THREE.Color, hex or string
  			return this.set( r );

  		}

  		return this.setRGB( r, g, b );

  	}

  	set( value ) {

  		if ( value && value.isColor ) {

  			this.copy( value );

  		} else if ( typeof value === 'number' ) {

  			this.setHex( value );

  		} else if ( typeof value === 'string' ) {

  			this.setStyle( value );

  		}

  		return this;

  	}

  	setScalar( scalar ) {

  		this.r = scalar;
  		this.g = scalar;
  		this.b = scalar;

  		return this;

  	}

  	setHex( hex ) {

  		hex = Math.floor( hex );

  		this.r = ( hex >> 16 & 255 ) / 255;
  		this.g = ( hex >> 8 & 255 ) / 255;
  		this.b = ( hex & 255 ) / 255;

  		return this;

  	}

  	setRGB( r, g, b ) {

  		this.r = r;
  		this.g = g;
  		this.b = b;

  		return this;

  	}

  	setHSL( h, s, l ) {

  		// h,s,l ranges are in 0.0 - 1.0
  		h = euclideanModulo( h, 1 );
  		s = clamp( s, 0, 1 );
  		l = clamp( l, 0, 1 );

  		if ( s === 0 ) {

  			this.r = this.g = this.b = l;

  		} else {

  			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
  			const q = ( 2 * l ) - p;

  			this.r = hue2rgb( q, p, h + 1 / 3 );
  			this.g = hue2rgb( q, p, h );
  			this.b = hue2rgb( q, p, h - 1 / 3 );

  		}

  		return this;

  	}

  	setStyle( style ) {

  		function handleAlpha( string ) {

  			if ( string === undefined ) return;

  			if ( parseFloat( string ) < 1 ) {

  				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

  			}

  		}


  		let m;

  		if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

  			// rgb / hsl

  			let color;
  			const name = m[ 1 ];
  			const components = m[ 2 ];

  			switch ( name ) {

  				case 'rgb':
  				case 'rgba':

  					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// rgb(255,0,0) rgba(255,0,0,0.5)
  						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
  						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
  						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

  						handleAlpha( color[ 4 ] );

  						return this;

  					}

  					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
  						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
  						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
  						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

  						handleAlpha( color[ 4 ] );

  						return this;

  					}

  					break;

  				case 'hsl':
  				case 'hsla':

  					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
  						const h = parseFloat( color[ 1 ] ) / 360;
  						const s = parseInt( color[ 2 ], 10 ) / 100;
  						const l = parseInt( color[ 3 ], 10 ) / 100;

  						handleAlpha( color[ 4 ] );

  						return this.setHSL( h, s, l );

  					}

  					break;

  			}

  		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

  			// hex color

  			const hex = m[ 1 ];
  			const size = hex.length;

  			if ( size === 3 ) {

  				// #ff0
  				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
  				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
  				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

  				return this;

  			} else if ( size === 6 ) {

  				// #ff0000
  				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
  				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
  				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

  				return this;

  			}

  		}

  		if ( style && style.length > 0 ) {

  			return this.setColorName( style );

  		}

  		return this;

  	}

  	setColorName( style ) {

  		// color keywords
  		const hex = _colorKeywords[ style.toLowerCase() ];

  		if ( hex !== undefined ) {

  			// red
  			this.setHex( hex );

  		} else {

  			// unknown color
  			console.warn( 'THREE.Color: Unknown color ' + style );

  		}

  		return this;

  	}

  	clone() {

  		return new this.constructor( this.r, this.g, this.b );

  	}

  	copy( color ) {

  		this.r = color.r;
  		this.g = color.g;
  		this.b = color.b;

  		return this;

  	}

  	copyGammaToLinear( color, gammaFactor = 2.0 ) {

  		this.r = Math.pow( color.r, gammaFactor );
  		this.g = Math.pow( color.g, gammaFactor );
  		this.b = Math.pow( color.b, gammaFactor );

  		return this;

  	}

  	copyLinearToGamma( color, gammaFactor = 2.0 ) {

  		const safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

  		this.r = Math.pow( color.r, safeInverse );
  		this.g = Math.pow( color.g, safeInverse );
  		this.b = Math.pow( color.b, safeInverse );

  		return this;

  	}

  	convertGammaToLinear( gammaFactor ) {

  		this.copyGammaToLinear( this, gammaFactor );

  		return this;

  	}

  	convertLinearToGamma( gammaFactor ) {

  		this.copyLinearToGamma( this, gammaFactor );

  		return this;

  	}

  	copySRGBToLinear( color ) {

  		this.r = SRGBToLinear( color.r );
  		this.g = SRGBToLinear( color.g );
  		this.b = SRGBToLinear( color.b );

  		return this;

  	}

  	copyLinearToSRGB( color ) {

  		this.r = LinearToSRGB( color.r );
  		this.g = LinearToSRGB( color.g );
  		this.b = LinearToSRGB( color.b );

  		return this;

  	}

  	convertSRGBToLinear() {

  		this.copySRGBToLinear( this );

  		return this;

  	}

  	convertLinearToSRGB() {

  		this.copyLinearToSRGB( this );

  		return this;

  	}

  	getHex() {

  		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

  	}

  	getHexString() {

  		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

  	}

  	getHSL( target ) {

  		// h,s,l ranges are in 0.0 - 1.0

  		if ( target === undefined ) {

  			console.warn( 'THREE.Color: .getHSL() target is now required' );
  			target = { h: 0, s: 0, l: 0 };

  		}

  		const r = this.r, g = this.g, b = this.b;

  		const max = Math.max( r, g, b );
  		const min = Math.min( r, g, b );

  		let hue, saturation;
  		const lightness = ( min + max ) / 2.0;

  		if ( min === max ) {

  			hue = 0;
  			saturation = 0;

  		} else {

  			const delta = max - min;

  			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

  			switch ( max ) {

  				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
  				case g: hue = ( b - r ) / delta + 2; break;
  				case b: hue = ( r - g ) / delta + 4; break;

  			}

  			hue /= 6;

  		}

  		target.h = hue;
  		target.s = saturation;
  		target.l = lightness;

  		return target;

  	}

  	getStyle() {

  		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

  	}

  	offsetHSL( h, s, l ) {

  		this.getHSL( _hslA );

  		_hslA.h += h; _hslA.s += s; _hslA.l += l;

  		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

  		return this;

  	}

  	add( color ) {

  		this.r += color.r;
  		this.g += color.g;
  		this.b += color.b;

  		return this;

  	}

  	addColors( color1, color2 ) {

  		this.r = color1.r + color2.r;
  		this.g = color1.g + color2.g;
  		this.b = color1.b + color2.b;

  		return this;

  	}

  	addScalar( s ) {

  		this.r += s;
  		this.g += s;
  		this.b += s;

  		return this;

  	}

  	sub( color ) {

  		this.r = Math.max( 0, this.r - color.r );
  		this.g = Math.max( 0, this.g - color.g );
  		this.b = Math.max( 0, this.b - color.b );

  		return this;

  	}

  	multiply( color ) {

  		this.r *= color.r;
  		this.g *= color.g;
  		this.b *= color.b;

  		return this;

  	}

  	multiplyScalar( s ) {

  		this.r *= s;
  		this.g *= s;
  		this.b *= s;

  		return this;

  	}

  	lerp( color, alpha ) {

  		this.r += ( color.r - this.r ) * alpha;
  		this.g += ( color.g - this.g ) * alpha;
  		this.b += ( color.b - this.b ) * alpha;

  		return this;

  	}

  	lerpColors( color1, color2, alpha ) {

  		this.r = color1.r + ( color2.r - color1.r ) * alpha;
  		this.g = color1.g + ( color2.g - color1.g ) * alpha;
  		this.b = color1.b + ( color2.b - color1.b ) * alpha;

  		return this;

  	}

  	lerpHSL( color, alpha ) {

  		this.getHSL( _hslA );
  		color.getHSL( _hslB );

  		const h = lerp( _hslA.h, _hslB.h, alpha );
  		const s = lerp( _hslA.s, _hslB.s, alpha );
  		const l = lerp( _hslA.l, _hslB.l, alpha );

  		this.setHSL( h, s, l );

  		return this;

  	}

  	equals( c ) {

  		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  	}

  	fromArray( array, offset = 0 ) {

  		this.r = array[ offset ];
  		this.g = array[ offset + 1 ];
  		this.b = array[ offset + 2 ];

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.r;
  		array[ offset + 1 ] = this.g;
  		array[ offset + 2 ] = this.b;

  		return array;

  	}

  	fromBufferAttribute( attribute, index ) {

  		this.r = attribute.getX( index );
  		this.g = attribute.getY( index );
  		this.b = attribute.getZ( index );

  		if ( attribute.normalized === true ) {

  			// assuming Uint8Array

  			this.r /= 255;
  			this.g /= 255;
  			this.b /= 255;

  		}

  		return this;

  	}

  	toJSON() {

  		return this.getHex();

  	}

  }

  Color.NAMES = _colorKeywords;

  Color.prototype.isColor = true;
  Color.prototype.r = 1;
  Color.prototype.g = 1;
  Color.prototype.b = 1;

  /**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  depthTest: <bool>,
   *  depthWrite: <bool>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  morphTargets: <bool>
   * }
   */

  class MeshBasicMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.type = 'MeshBasicMaterial';

  		this.color = new Color( 0xffffff ); // emissive

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.specularMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.combine = MultiplyOperation;
  		this.reflectivity = 1;
  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.morphTargets = false;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.morphTargets = source.morphTargets;

  		return this;

  	}

  }

  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

  const _vector$9 = /*@__PURE__*/ new Vector3();
  const _vector2 = /*@__PURE__*/ new Vector2();

  class BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  		}

  		this.name = '';

  		this.array = array;
  		this.itemSize = itemSize;
  		this.count = array !== undefined ? array.length / itemSize : 0;
  		this.normalized = normalized === true;

  		this.usage = StaticDrawUsage;
  		this.updateRange = { offset: 0, count: - 1 };

  		this.version = 0;

  	}

  	onUploadCallback() {}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	setUsage( value ) {

  		this.usage = value;

  		return this;

  	}

  	copy( source ) {

  		this.name = source.name;
  		this.array = new source.array.constructor( source.array );
  		this.itemSize = source.itemSize;
  		this.count = source.count;
  		this.normalized = source.normalized;

  		this.usage = source.usage;

  		return this;

  	}

  	copyAt( index1, attribute, index2 ) {

  		index1 *= this.itemSize;
  		index2 *= attribute.itemSize;

  		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

  			this.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	}

  	copyArray( array ) {

  		this.array.set( array );

  		return this;

  	}

  	copyColorsArray( colors ) {

  		const array = this.array;
  		let offset = 0;

  		for ( let i = 0, l = colors.length; i < l; i ++ ) {

  			let color = colors[ i ];

  			if ( color === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
  				color = new Color();

  			}

  			array[ offset ++ ] = color.r;
  			array[ offset ++ ] = color.g;
  			array[ offset ++ ] = color.b;

  		}

  		return this;

  	}

  	copyVector2sArray( vectors ) {

  		const array = this.array;
  		let offset = 0;

  		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

  			let vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
  				vector = new Vector2();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;

  		}

  		return this;

  	}

  	copyVector3sArray( vectors ) {

  		const array = this.array;
  		let offset = 0;

  		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

  			let vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
  				vector = new Vector3();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;
  			array[ offset ++ ] = vector.z;

  		}

  		return this;

  	}

  	copyVector4sArray( vectors ) {

  		const array = this.array;
  		let offset = 0;

  		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

  			let vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
  				vector = new Vector4$1();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;
  			array[ offset ++ ] = vector.z;
  			array[ offset ++ ] = vector.w;

  		}

  		return this;

  	}

  	applyMatrix3( m ) {

  		if ( this.itemSize === 2 ) {

  			for ( let i = 0, l = this.count; i < l; i ++ ) {

  				_vector2.fromBufferAttribute( this, i );
  				_vector2.applyMatrix3( m );

  				this.setXY( i, _vector2.x, _vector2.y );

  			}

  		} else if ( this.itemSize === 3 ) {

  			for ( let i = 0, l = this.count; i < l; i ++ ) {

  				_vector$9.fromBufferAttribute( this, i );
  				_vector$9.applyMatrix3( m );

  				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  			}

  		}

  		return this;

  	}

  	applyMatrix4( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.x = this.getX( i );
  			_vector$9.y = this.getY( i );
  			_vector$9.z = this.getZ( i );

  			_vector$9.applyMatrix4( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	applyNormalMatrix( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.x = this.getX( i );
  			_vector$9.y = this.getY( i );
  			_vector$9.z = this.getZ( i );

  			_vector$9.applyNormalMatrix( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	transformDirection( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.x = this.getX( i );
  			_vector$9.y = this.getY( i );
  			_vector$9.z = this.getZ( i );

  			_vector$9.transformDirection( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	set( value, offset = 0 ) {

  		this.array.set( value, offset );

  		return this;

  	}

  	getX( index ) {

  		return this.array[ index * this.itemSize ];

  	}

  	setX( index, x ) {

  		this.array[ index * this.itemSize ] = x;

  		return this;

  	}

  	getY( index ) {

  		return this.array[ index * this.itemSize + 1 ];

  	}

  	setY( index, y ) {

  		this.array[ index * this.itemSize + 1 ] = y;

  		return this;

  	}

  	getZ( index ) {

  		return this.array[ index * this.itemSize + 2 ];

  	}

  	setZ( index, z ) {

  		this.array[ index * this.itemSize + 2 ] = z;

  		return this;

  	}

  	getW( index ) {

  		return this.array[ index * this.itemSize + 3 ];

  	}

  	setW( index, w ) {

  		this.array[ index * this.itemSize + 3 ] = w;

  		return this;

  	}

  	setXY( index, x, y ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;

  		return this;

  	}

  	setXYZ( index, x, y, z ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;

  		return this;

  	}

  	setXYZW( index, x, y, z, w ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;
  		this.array[ index + 3 ] = w;

  		return this;

  	}

  	onUpload( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  	clone() {

  		return new this.constructor( this.array, this.itemSize ).copy( this );

  	}

  	toJSON() {

  		const data = {
  			itemSize: this.itemSize,
  			type: this.array.constructor.name,
  			array: Array.prototype.slice.call( this.array ),
  			normalized: this.normalized
  		};

  		if ( this.name !== '' ) data.name = this.name;
  		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
  		if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

  		return data;

  	}

  }

  BufferAttribute.prototype.isBufferAttribute = true;

  //

  class Int8BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Int8Array( array ), itemSize, normalized );

  	}

  }

  class Uint8BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Uint8Array( array ), itemSize, normalized );

  	}

  }

  class Uint8ClampedBufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Uint8ClampedArray( array ), itemSize, normalized );

  	}

  }

  class Int16BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Int16Array( array ), itemSize, normalized );

  	}

  }

  class Uint16BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Uint16Array( array ), itemSize, normalized );

  	}

  }

  class Int32BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Int32Array( array ), itemSize, normalized );

  	}

  }

  class Uint32BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Uint32Array( array ), itemSize, normalized );

  	}

  }

  class Float16BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Uint16Array( array ), itemSize, normalized );

  	}

  }

  Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

  class Float32BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Float32Array( array ), itemSize, normalized );

  	}

  }

  class Float64BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Float64Array( array ), itemSize, normalized );

  	}

  }

  function arrayMax( array ) {

  	if ( array.length === 0 ) return - Infinity;

  	let max = array[ 0 ];

  	for ( let i = 1, l = array.length; i < l; ++ i ) {

  		if ( array[ i ] > max ) max = array[ i ];

  	}

  	return max;

  }

  const TYPED_ARRAYS = {
  	Int8Array: Int8Array,
  	Uint8Array: Uint8Array,
  	Uint8ClampedArray: Uint8ClampedArray,
  	Int16Array: Int16Array,
  	Uint16Array: Uint16Array,
  	Int32Array: Int32Array,
  	Uint32Array: Uint32Array,
  	Float32Array: Float32Array,
  	Float64Array: Float64Array
  };

  function getTypedArray( type, buffer ) {

  	return new TYPED_ARRAYS[ type ]( buffer );

  }

  let _id = 0;

  const _m1 = /*@__PURE__*/ new Matrix4();
  const _obj = /*@__PURE__*/ new Object3D();
  const _offset = /*@__PURE__*/ new Vector3();
  const _box$1 = /*@__PURE__*/ new Box3();
  const _boxMorphTargets = /*@__PURE__*/ new Box3();
  const _vector$8 = /*@__PURE__*/ new Vector3();

  class BufferGeometry extends EventDispatcher {

  	constructor() {

  		super();

  		Object.defineProperty( this, 'id', { value: _id ++ } );

  		this.uuid = generateUUID();

  		this.name = '';
  		this.type = 'BufferGeometry';

  		this.index = null;
  		this.attributes = {};

  		this.morphAttributes = {};
  		this.morphTargetsRelative = false;

  		this.groups = [];

  		this.boundingBox = null;
  		this.boundingSphere = null;

  		this.drawRange = { start: 0, count: Infinity };

  		this.userData = {};

  	}

  	getIndex() {

  		return this.index;

  	}

  	setIndex( index ) {

  		if ( Array.isArray( index ) ) {

  			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

  		} else {

  			this.index = index;

  		}

  		return this;

  	}

  	getAttribute( name ) {

  		return this.attributes[ name ];

  	}

  	setAttribute( name, attribute ) {

  		this.attributes[ name ] = attribute;

  		return this;

  	}

  	deleteAttribute( name ) {

  		delete this.attributes[ name ];

  		return this;

  	}

  	hasAttribute( name ) {

  		return this.attributes[ name ] !== undefined;

  	}

  	addGroup( start, count, materialIndex = 0 ) {

  		this.groups.push( {

  			start: start,
  			count: count,
  			materialIndex: materialIndex

  		} );

  	}

  	clearGroups() {

  		this.groups = [];

  	}

  	setDrawRange( start, count ) {

  		this.drawRange.start = start;
  		this.drawRange.count = count;

  	}

  	applyMatrix4( matrix ) {

  		const position = this.attributes.position;

  		if ( position !== undefined ) {

  			position.applyMatrix4( matrix );

  			position.needsUpdate = true;

  		}

  		const normal = this.attributes.normal;

  		if ( normal !== undefined ) {

  			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

  			normal.applyNormalMatrix( normalMatrix );

  			normal.needsUpdate = true;

  		}

  		const tangent = this.attributes.tangent;

  		if ( tangent !== undefined ) {

  			tangent.transformDirection( matrix );

  			tangent.needsUpdate = true;

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		return this;

  	}

  	applyQuaternion( q ) {

  		_m1.makeRotationFromQuaternion( q );

  		this.applyMatrix4( _m1 );

  		return this;

  	}

  	rotateX( angle ) {

  		// rotate geometry around world x-axis

  		_m1.makeRotationX( angle );

  		this.applyMatrix4( _m1 );

  		return this;

  	}

  	rotateY( angle ) {

  		// rotate geometry around world y-axis

  		_m1.makeRotationY( angle );

  		this.applyMatrix4( _m1 );

  		return this;

  	}

  	rotateZ( angle ) {

  		// rotate geometry around world z-axis

  		_m1.makeRotationZ( angle );

  		this.applyMatrix4( _m1 );

  		return this;

  	}

  	translate( x, y, z ) {

  		// translate geometry

  		_m1.makeTranslation( x, y, z );

  		this.applyMatrix4( _m1 );

  		return this;

  	}

  	scale( x, y, z ) {

  		// scale geometry

  		_m1.makeScale( x, y, z );

  		this.applyMatrix4( _m1 );

  		return this;

  	}

  	lookAt( vector ) {

  		_obj.lookAt( vector );

  		_obj.updateMatrix();

  		this.applyMatrix4( _obj.matrix );

  		return this;

  	}

  	center() {

  		this.computeBoundingBox();

  		this.boundingBox.getCenter( _offset ).negate();

  		this.translate( _offset.x, _offset.y, _offset.z );

  		return this;

  	}

  	setFromPoints( points ) {

  		const position = [];

  		for ( let i = 0, l = points.length; i < l; i ++ ) {

  			const point = points[ i ];
  			position.push( point.x, point.y, point.z || 0 );

  		}

  		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

  		return this;

  	}

  	computeBoundingBox() {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		const position = this.attributes.position;
  		const morphAttributesPosition = this.morphAttributes.position;

  		if ( position && position.isGLBufferAttribute ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

  			this.boundingBox.set(
  				new Vector3( - Infinity, - Infinity, - Infinity ),
  				new Vector3( + Infinity, + Infinity, + Infinity )
  			);

  			return;

  		}

  		if ( position !== undefined ) {

  			this.boundingBox.setFromBufferAttribute( position );

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					_box$1.setFromBufferAttribute( morphAttribute );

  					if ( this.morphTargetsRelative ) {

  						_vector$8.addVectors( this.boundingBox.min, _box$1.min );
  						this.boundingBox.expandByPoint( _vector$8 );

  						_vector$8.addVectors( this.boundingBox.max, _box$1.max );
  						this.boundingBox.expandByPoint( _vector$8 );

  					} else {

  						this.boundingBox.expandByPoint( _box$1.min );
  						this.boundingBox.expandByPoint( _box$1.max );

  					}

  				}

  			}

  		} else {

  			this.boundingBox.makeEmpty();

  		}

  		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

  		}

  	}

  	computeBoundingSphere() {

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere();

  		}

  		const position = this.attributes.position;
  		const morphAttributesPosition = this.morphAttributes.position;

  		if ( position && position.isGLBufferAttribute ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

  			this.boundingSphere.set( new Vector3(), Infinity );

  			return;

  		}

  		if ( position ) {

  			// first, find the center of the bounding sphere

  			const center = this.boundingSphere.center;

  			_box$1.setFromBufferAttribute( position );

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

  					if ( this.morphTargetsRelative ) {

  						_vector$8.addVectors( _box$1.min, _boxMorphTargets.min );
  						_box$1.expandByPoint( _vector$8 );

  						_vector$8.addVectors( _box$1.max, _boxMorphTargets.max );
  						_box$1.expandByPoint( _vector$8 );

  					} else {

  						_box$1.expandByPoint( _boxMorphTargets.min );
  						_box$1.expandByPoint( _boxMorphTargets.max );

  					}

  				}

  			}

  			_box$1.getCenter( center );

  			// second, try to find a boundingSphere with a radius smaller than the
  			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

  			let maxRadiusSq = 0;

  			for ( let i = 0, il = position.count; i < il; i ++ ) {

  				_vector$8.fromBufferAttribute( position, i );

  				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

  			}

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					const morphTargetsRelative = this.morphTargetsRelative;

  					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

  						_vector$8.fromBufferAttribute( morphAttribute, j );

  						if ( morphTargetsRelative ) {

  							_offset.fromBufferAttribute( position, j );
  							_vector$8.add( _offset );

  						}

  						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

  					}

  				}

  			}

  			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

  			if ( isNaN( this.boundingSphere.radius ) ) {

  				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

  			}

  		}

  	}

  	computeFaceNormals() {

  		// backwards compatibility

  	}

  	computeTangents() {

  		const index = this.index;
  		const attributes = this.attributes;

  		// based on http://www.terathon.com/code/tangent.html
  		// (per vertex tangents)

  		if ( index === null ||
  			 attributes.position === undefined ||
  			 attributes.normal === undefined ||
  			 attributes.uv === undefined ) {

  			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
  			return;

  		}

  		const indices = index.array;
  		const positions = attributes.position.array;
  		const normals = attributes.normal.array;
  		const uvs = attributes.uv.array;

  		const nVertices = positions.length / 3;

  		if ( attributes.tangent === undefined ) {

  			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

  		}

  		const tangents = attributes.tangent.array;

  		const tan1 = [], tan2 = [];

  		for ( let i = 0; i < nVertices; i ++ ) {

  			tan1[ i ] = new Vector3();
  			tan2[ i ] = new Vector3();

  		}

  		const vA = new Vector3(),
  			vB = new Vector3(),
  			vC = new Vector3(),

  			uvA = new Vector2(),
  			uvB = new Vector2(),
  			uvC = new Vector2(),

  			sdir = new Vector3(),
  			tdir = new Vector3();

  		function handleTriangle( a, b, c ) {

  			vA.fromArray( positions, a * 3 );
  			vB.fromArray( positions, b * 3 );
  			vC.fromArray( positions, c * 3 );

  			uvA.fromArray( uvs, a * 2 );
  			uvB.fromArray( uvs, b * 2 );
  			uvC.fromArray( uvs, c * 2 );

  			vB.sub( vA );
  			vC.sub( vA );

  			uvB.sub( uvA );
  			uvC.sub( uvA );

  			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

  			// silently ignore degenerate uv triangles having coincident or colinear vertices

  			if ( ! isFinite( r ) ) return;

  			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
  			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

  			tan1[ a ].add( sdir );
  			tan1[ b ].add( sdir );
  			tan1[ c ].add( sdir );

  			tan2[ a ].add( tdir );
  			tan2[ b ].add( tdir );
  			tan2[ c ].add( tdir );

  		}

  		let groups = this.groups;

  		if ( groups.length === 0 ) {

  			groups = [ {
  				start: 0,
  				count: indices.length
  			} ];

  		}

  		for ( let i = 0, il = groups.length; i < il; ++ i ) {

  			const group = groups[ i ];

  			const start = group.start;
  			const count = group.count;

  			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

  				handleTriangle(
  					indices[ j + 0 ],
  					indices[ j + 1 ],
  					indices[ j + 2 ]
  				);

  			}

  		}

  		const tmp = new Vector3(), tmp2 = new Vector3();
  		const n = new Vector3(), n2 = new Vector3();

  		function handleVertex( v ) {

  			n.fromArray( normals, v * 3 );
  			n2.copy( n );

  			const t = tan1[ v ];

  			// Gram-Schmidt orthogonalize

  			tmp.copy( t );
  			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

  			// Calculate handedness

  			tmp2.crossVectors( n2, t );
  			const test = tmp2.dot( tan2[ v ] );
  			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

  			tangents[ v * 4 ] = tmp.x;
  			tangents[ v * 4 + 1 ] = tmp.y;
  			tangents[ v * 4 + 2 ] = tmp.z;
  			tangents[ v * 4 + 3 ] = w;

  		}

  		for ( let i = 0, il = groups.length; i < il; ++ i ) {

  			const group = groups[ i ];

  			const start = group.start;
  			const count = group.count;

  			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

  				handleVertex( indices[ j + 0 ] );
  				handleVertex( indices[ j + 1 ] );
  				handleVertex( indices[ j + 2 ] );

  			}

  		}

  	}

  	computeVertexNormals() {

  		const index = this.index;
  		const positionAttribute = this.getAttribute( 'position' );

  		if ( positionAttribute !== undefined ) {

  			let normalAttribute = this.getAttribute( 'normal' );

  			if ( normalAttribute === undefined ) {

  				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
  				this.setAttribute( 'normal', normalAttribute );

  			} else {

  				// reset existing normals to zero

  				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

  					normalAttribute.setXYZ( i, 0, 0, 0 );

  				}

  			}

  			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
  			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
  			const cb = new Vector3(), ab = new Vector3();

  			// indexed elements

  			if ( index ) {

  				for ( let i = 0, il = index.count; i < il; i += 3 ) {

  					const vA = index.getX( i + 0 );
  					const vB = index.getX( i + 1 );
  					const vC = index.getX( i + 2 );

  					pA.fromBufferAttribute( positionAttribute, vA );
  					pB.fromBufferAttribute( positionAttribute, vB );
  					pC.fromBufferAttribute( positionAttribute, vC );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					nA.fromBufferAttribute( normalAttribute, vA );
  					nB.fromBufferAttribute( normalAttribute, vB );
  					nC.fromBufferAttribute( normalAttribute, vC );

  					nA.add( cb );
  					nB.add( cb );
  					nC.add( cb );

  					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
  					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
  					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

  				}

  			} else {

  				// non-indexed elements (unconnected triangle soup)

  				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

  					pA.fromBufferAttribute( positionAttribute, i + 0 );
  					pB.fromBufferAttribute( positionAttribute, i + 1 );
  					pC.fromBufferAttribute( positionAttribute, i + 2 );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
  					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
  					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

  				}

  			}

  			this.normalizeNormals();

  			normalAttribute.needsUpdate = true;

  		}

  	}

  	merge( geometry, offset ) {

  		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

  			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
  			return;

  		}

  		if ( offset === undefined ) {

  			offset = 0;

  			console.warn(
  				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
  				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
  			);

  		}

  		const attributes = this.attributes;

  		for ( const key in attributes ) {

  			if ( geometry.attributes[ key ] === undefined ) continue;

  			const attribute1 = attributes[ key ];
  			const attributeArray1 = attribute1.array;

  			const attribute2 = geometry.attributes[ key ];
  			const attributeArray2 = attribute2.array;

  			const attributeOffset = attribute2.itemSize * offset;
  			const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

  			for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

  				attributeArray1[ j ] = attributeArray2[ i ];

  			}

  		}

  		return this;

  	}

  	normalizeNormals() {

  		const normals = this.attributes.normal;

  		for ( let i = 0, il = normals.count; i < il; i ++ ) {

  			_vector$8.fromBufferAttribute( normals, i );

  			_vector$8.normalize();

  			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

  		}

  	}

  	toNonIndexed() {

  		function convertBufferAttribute( attribute, indices ) {

  			const array = attribute.array;
  			const itemSize = attribute.itemSize;
  			const normalized = attribute.normalized;

  			const array2 = new array.constructor( indices.length * itemSize );

  			let index = 0, index2 = 0;

  			for ( let i = 0, l = indices.length; i < l; i ++ ) {

  				index = indices[ i ] * itemSize;

  				for ( let j = 0; j < itemSize; j ++ ) {

  					array2[ index2 ++ ] = array[ index ++ ];

  				}

  			}

  			return new BufferAttribute( array2, itemSize, normalized );

  		}

  		//

  		if ( this.index === null ) {

  			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
  			return this;

  		}

  		const geometry2 = new BufferGeometry();

  		const indices = this.index.array;
  		const attributes = this.attributes;

  		// attributes

  		for ( const name in attributes ) {

  			const attribute = attributes[ name ];

  			const newAttribute = convertBufferAttribute( attribute, indices );

  			geometry2.setAttribute( name, newAttribute );

  		}

  		// morph attributes

  		const morphAttributes = this.morphAttributes;

  		for ( const name in morphAttributes ) {

  			const morphArray = [];
  			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

  				const attribute = morphAttribute[ i ];

  				const newAttribute = convertBufferAttribute( attribute, indices );

  				morphArray.push( newAttribute );

  			}

  			geometry2.morphAttributes[ name ] = morphArray;

  		}

  		geometry2.morphTargetsRelative = this.morphTargetsRelative;

  		// groups

  		const groups = this.groups;

  		for ( let i = 0, l = groups.length; i < l; i ++ ) {

  			const group = groups[ i ];
  			geometry2.addGroup( group.start, group.count, group.materialIndex );

  		}

  		return geometry2;

  	}

  	toJSON() {

  		const data = {
  			metadata: {
  				version: 4.5,
  				type: 'BufferGeometry',
  				generator: 'BufferGeometry.toJSON'
  			}
  		};

  		// standard BufferGeometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) data.name = this.name;
  		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

  		if ( this.parameters !== undefined ) {

  			const parameters = this.parameters;

  			for ( const key in parameters ) {

  				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

  			}

  			return data;

  		}

  		// for simplicity the code assumes attributes are not shared across geometries, see #15811

  		data.data = { attributes: {} };

  		const index = this.index;

  		if ( index !== null ) {

  			data.data.index = {
  				type: index.array.constructor.name,
  				array: Array.prototype.slice.call( index.array )
  			};

  		}

  		const attributes = this.attributes;

  		for ( const key in attributes ) {

  			const attribute = attributes[ key ];

  			data.data.attributes[ key ] = attribute.toJSON( data.data );

  		}

  		const morphAttributes = {};
  		let hasMorphAttributes = false;

  		for ( const key in this.morphAttributes ) {

  			const attributeArray = this.morphAttributes[ key ];

  			const array = [];

  			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

  				const attribute = attributeArray[ i ];

  				array.push( attribute.toJSON( data.data ) );

  			}

  			if ( array.length > 0 ) {

  				morphAttributes[ key ] = array;

  				hasMorphAttributes = true;

  			}

  		}

  		if ( hasMorphAttributes ) {

  			data.data.morphAttributes = morphAttributes;
  			data.data.morphTargetsRelative = this.morphTargetsRelative;

  		}

  		const groups = this.groups;

  		if ( groups.length > 0 ) {

  			data.data.groups = JSON.parse( JSON.stringify( groups ) );

  		}

  		const boundingSphere = this.boundingSphere;

  		if ( boundingSphere !== null ) {

  			data.data.boundingSphere = {
  				center: boundingSphere.center.toArray(),
  				radius: boundingSphere.radius
  			};

  		}

  		return data;

  	}

  	clone() {

  		/*
  		 // Handle primitives

  		 const parameters = this.parameters;

  		 if ( parameters !== undefined ) {

  		 const values = [];

  		 for ( const key in parameters ) {

  		 values.push( parameters[ key ] );

  		 }

  		 const geometry = Object.create( this.constructor.prototype );
  		 this.constructor.apply( geometry, values );
  		 return geometry;

  		 }

  		 return new this.constructor().copy( this );
  		 */

  		return new BufferGeometry().copy( this );

  	}

  	copy( source ) {

  		// reset

  		this.index = null;
  		this.attributes = {};
  		this.morphAttributes = {};
  		this.groups = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// used for storing cloned, shared data

  		const data = {};

  		// name

  		this.name = source.name;

  		// index

  		const index = source.index;

  		if ( index !== null ) {

  			this.setIndex( index.clone( data ) );

  		}

  		// attributes

  		const attributes = source.attributes;

  		for ( const name in attributes ) {

  			const attribute = attributes[ name ];
  			this.setAttribute( name, attribute.clone( data ) );

  		}

  		// morph attributes

  		const morphAttributes = source.morphAttributes;

  		for ( const name in morphAttributes ) {

  			const array = [];
  			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

  				array.push( morphAttribute[ i ].clone( data ) );

  			}

  			this.morphAttributes[ name ] = array;

  		}

  		this.morphTargetsRelative = source.morphTargetsRelative;

  		// groups

  		const groups = source.groups;

  		for ( let i = 0, l = groups.length; i < l; i ++ ) {

  			const group = groups[ i ];
  			this.addGroup( group.start, group.count, group.materialIndex );

  		}

  		// bounding box

  		const boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		const boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// draw range

  		this.drawRange.start = source.drawRange.start;
  		this.drawRange.count = source.drawRange.count;

  		// user data

  		this.userData = source.userData;

  		return this;

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  }

  BufferGeometry.prototype.isBufferGeometry = true;

  const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
  const _ray$2 = /*@__PURE__*/ new Ray();
  const _sphere$3 = /*@__PURE__*/ new Sphere();

  const _vA$1 = /*@__PURE__*/ new Vector3();
  const _vB$1 = /*@__PURE__*/ new Vector3();
  const _vC$1 = /*@__PURE__*/ new Vector3();

  const _tempA = /*@__PURE__*/ new Vector3();
  const _tempB = /*@__PURE__*/ new Vector3();
  const _tempC = /*@__PURE__*/ new Vector3();

  const _morphA = /*@__PURE__*/ new Vector3();
  const _morphB = /*@__PURE__*/ new Vector3();
  const _morphC = /*@__PURE__*/ new Vector3();

  const _uvA$1 = /*@__PURE__*/ new Vector2();
  const _uvB$1 = /*@__PURE__*/ new Vector2();
  const _uvC$1 = /*@__PURE__*/ new Vector2();

  const _intersectionPoint = /*@__PURE__*/ new Vector3();
  const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

  class Mesh extends Object3D {

  	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

  		super();

  		this.type = 'Mesh';

  		this.geometry = geometry;
  		this.material = material;

  		this.updateMorphTargets();

  	}

  	copy( source ) {

  		super.copy( source );

  		if ( source.morphTargetInfluences !== undefined ) {

  			this.morphTargetInfluences = source.morphTargetInfluences.slice();

  		}

  		if ( source.morphTargetDictionary !== undefined ) {

  			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

  		}

  		this.material = source.material;
  		this.geometry = source.geometry;

  		return this;

  	}

  	updateMorphTargets() {

  		const geometry = this.geometry;

  		if ( geometry.isBufferGeometry ) {

  			const morphAttributes = geometry.morphAttributes;
  			const keys = Object.keys( morphAttributes );

  			if ( keys.length > 0 ) {

  				const morphAttribute = morphAttributes[ keys[ 0 ] ];

  				if ( morphAttribute !== undefined ) {

  					this.morphTargetInfluences = [];
  					this.morphTargetDictionary = {};

  					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  						const name = morphAttribute[ m ].name || String( m );

  						this.morphTargetInfluences.push( 0 );
  						this.morphTargetDictionary[ name ] = m;

  					}

  				}

  			}

  		} else {

  			const morphTargets = geometry.morphTargets;

  			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

  				console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

  			}

  		}

  	}

  	raycast( raycaster, intersects ) {

  		const geometry = this.geometry;
  		const material = this.material;
  		const matrixWorld = this.matrixWorld;

  		if ( material === undefined ) return;

  		// Checking boundingSphere distance to ray

  		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  		_sphere$3.copy( geometry.boundingSphere );
  		_sphere$3.applyMatrix4( matrixWorld );

  		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

  		//

  		_inverseMatrix$2.copy( matrixWorld ).invert();
  		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

  		// Check boundingBox before continuing

  		if ( geometry.boundingBox !== null ) {

  			if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;

  		}

  		let intersection;

  		if ( geometry.isBufferGeometry ) {

  			const index = geometry.index;
  			const position = geometry.attributes.position;
  			const morphPosition = geometry.morphAttributes.position;
  			const morphTargetsRelative = geometry.morphTargetsRelative;
  			const uv = geometry.attributes.uv;
  			const uv2 = geometry.attributes.uv2;
  			const groups = geometry.groups;
  			const drawRange = geometry.drawRange;

  			if ( index !== null ) {

  				// indexed buffer geometry

  				if ( Array.isArray( material ) ) {

  					for ( let i = 0, il = groups.length; i < il; i ++ ) {

  						const group = groups[ i ];
  						const groupMaterial = material[ group.materialIndex ];

  						const start = Math.max( group.start, drawRange.start );
  						const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

  						for ( let j = start, jl = end; j < jl; j += 3 ) {

  							const a = index.getX( j );
  							const b = index.getX( j + 1 );
  							const c = index.getX( j + 2 );

  							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

  							if ( intersection ) {

  								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
  								intersection.face.materialIndex = group.materialIndex;
  								intersects.push( intersection );

  							}

  						}

  					}

  				} else {

  					const start = Math.max( 0, drawRange.start );
  					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  					for ( let i = start, il = end; i < il; i += 3 ) {

  						const a = index.getX( i );
  						const b = index.getX( i + 1 );
  						const c = index.getX( i + 2 );

  						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
  							intersects.push( intersection );

  						}

  					}

  				}

  			} else if ( position !== undefined ) {

  				// non-indexed buffer geometry

  				if ( Array.isArray( material ) ) {

  					for ( let i = 0, il = groups.length; i < il; i ++ ) {

  						const group = groups[ i ];
  						const groupMaterial = material[ group.materialIndex ];

  						const start = Math.max( group.start, drawRange.start );
  						const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

  						for ( let j = start, jl = end; j < jl; j += 3 ) {

  							const a = j;
  							const b = j + 1;
  							const c = j + 2;

  							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

  							if ( intersection ) {

  								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
  								intersection.face.materialIndex = group.materialIndex;
  								intersects.push( intersection );

  							}

  						}

  					}

  				} else {

  					const start = Math.max( 0, drawRange.start );
  					const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

  					for ( let i = start, il = end; i < il; i += 3 ) {

  						const a = i;
  						const b = i + 1;
  						const c = i + 2;

  						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
  							intersects.push( intersection );

  						}

  					}

  				}

  			}

  		} else if ( geometry.isGeometry ) {

  			console.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

  		}

  	}

  }

  Mesh.prototype.isMesh = true;

  function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

  	let intersect;

  	if ( material.side === BackSide ) {

  		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

  	} else {

  		intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

  	}

  	if ( intersect === null ) return null;

  	_intersectionPointWorld.copy( point );
  	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

  	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

  	if ( distance < raycaster.near || distance > raycaster.far ) return null;

  	return {
  		distance: distance,
  		point: _intersectionPointWorld.clone(),
  		object: object
  	};

  }

  function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

  	_vA$1.fromBufferAttribute( position, a );
  	_vB$1.fromBufferAttribute( position, b );
  	_vC$1.fromBufferAttribute( position, c );

  	const morphInfluences = object.morphTargetInfluences;

  	if ( material.morphTargets && morphPosition && morphInfluences ) {

  		_morphA.set( 0, 0, 0 );
  		_morphB.set( 0, 0, 0 );
  		_morphC.set( 0, 0, 0 );

  		for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

  			const influence = morphInfluences[ i ];
  			const morphAttribute = morphPosition[ i ];

  			if ( influence === 0 ) continue;

  			_tempA.fromBufferAttribute( morphAttribute, a );
  			_tempB.fromBufferAttribute( morphAttribute, b );
  			_tempC.fromBufferAttribute( morphAttribute, c );

  			if ( morphTargetsRelative ) {

  				_morphA.addScaledVector( _tempA, influence );
  				_morphB.addScaledVector( _tempB, influence );
  				_morphC.addScaledVector( _tempC, influence );

  			} else {

  				_morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );
  				_morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );
  				_morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );

  			}

  		}

  		_vA$1.add( _morphA );
  		_vB$1.add( _morphB );
  		_vC$1.add( _morphC );

  	}

  	if ( object.isSkinnedMesh ) {

  		object.boneTransform( a, _vA$1 );
  		object.boneTransform( b, _vB$1 );
  		object.boneTransform( c, _vC$1 );

  	}

  	const intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

  	if ( intersection ) {

  		if ( uv ) {

  			_uvA$1.fromBufferAttribute( uv, a );
  			_uvB$1.fromBufferAttribute( uv, b );
  			_uvC$1.fromBufferAttribute( uv, c );

  			intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

  		}

  		if ( uv2 ) {

  			_uvA$1.fromBufferAttribute( uv2, a );
  			_uvB$1.fromBufferAttribute( uv2, b );
  			_uvC$1.fromBufferAttribute( uv2, c );

  			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

  		}

  		const face = {
  			a: a,
  			b: b,
  			c: c,
  			normal: new Vector3(),
  			materialIndex: 0
  		};

  		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

  		intersection.face = face;

  	}

  	return intersection;

  }

  class BoxGeometry extends BufferGeometry {

  	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

  		super();

  		this.type = 'BoxGeometry';

  		this.parameters = {
  			width: width,
  			height: height,
  			depth: depth,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments,
  			depthSegments: depthSegments
  		};

  		const scope = this;

  		// segments

  		widthSegments = Math.floor( widthSegments );
  		heightSegments = Math.floor( heightSegments );
  		depthSegments = Math.floor( depthSegments );

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// helper variables

  		let numberOfVertices = 0;
  		let groupStart = 0;

  		// build each side of the box geometry

  		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
  		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
  		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
  		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
  		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
  		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

  			const segmentWidth = width / gridX;
  			const segmentHeight = height / gridY;

  			const widthHalf = width / 2;
  			const heightHalf = height / 2;
  			const depthHalf = depth / 2;

  			const gridX1 = gridX + 1;
  			const gridY1 = gridY + 1;

  			let vertexCounter = 0;
  			let groupCount = 0;

  			const vector = new Vector3();

  			// generate vertices, normals and uvs

  			for ( let iy = 0; iy < gridY1; iy ++ ) {

  				const y = iy * segmentHeight - heightHalf;

  				for ( let ix = 0; ix < gridX1; ix ++ ) {

  					const x = ix * segmentWidth - widthHalf;

  					// set values to correct vector component

  					vector[ u ] = x * udir;
  					vector[ v ] = y * vdir;
  					vector[ w ] = depthHalf;

  					// now apply vector to vertex buffer

  					vertices.push( vector.x, vector.y, vector.z );

  					// set values to correct vector component

  					vector[ u ] = 0;
  					vector[ v ] = 0;
  					vector[ w ] = depth > 0 ? 1 : - 1;

  					// now apply vector to normal buffer

  					normals.push( vector.x, vector.y, vector.z );

  					// uvs

  					uvs.push( ix / gridX );
  					uvs.push( 1 - ( iy / gridY ) );

  					// counters

  					vertexCounter += 1;

  				}

  			}

  			// indices

  			// 1. you need three indices to draw a single face
  			// 2. a single segment consists of two faces
  			// 3. so we need to generate six (2*3) indices per segment

  			for ( let iy = 0; iy < gridY; iy ++ ) {

  				for ( let ix = 0; ix < gridX; ix ++ ) {

  					const a = numberOfVertices + ix + gridX1 * iy;
  					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
  					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
  					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

  					// faces

  					indices.push( a, b, d );
  					indices.push( b, c, d );

  					// increase counter

  					groupCount += 6;

  				}

  			}

  			// add a group to the geometry. this will ensure multi material support

  			scope.addGroup( groupStart, groupCount, materialIndex );

  			// calculate new start value for groups

  			groupStart += groupCount;

  			// update total number of vertices

  			numberOfVertices += vertexCounter;

  		}

  	}

  }

  /**
   * Uniform Utilities
   */

  function cloneUniforms( src ) {

  	const dst = {};

  	for ( const u in src ) {

  		dst[ u ] = {};

  		for ( const p in src[ u ] ) {

  			const property = src[ u ][ p ];

  			if ( property && ( property.isColor ||
  				property.isMatrix3 || property.isMatrix4 ||
  				property.isVector2 || property.isVector3 || property.isVector4 ||
  				property.isTexture || property.isQuaternion ) ) {

  				dst[ u ][ p ] = property.clone();

  			} else if ( Array.isArray( property ) ) {

  				dst[ u ][ p ] = property.slice();

  			} else {

  				dst[ u ][ p ] = property;

  			}

  		}

  	}

  	return dst;

  }

  function mergeUniforms( uniforms ) {

  	const merged = {};

  	for ( let u = 0; u < uniforms.length; u ++ ) {

  		const tmp = cloneUniforms( uniforms[ u ] );

  		for ( const p in tmp ) {

  			merged[ p ] = tmp[ p ];

  		}

  	}

  	return merged;

  }

  // Legacy

  const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

  var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

  var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

  /**
   * parameters = {
   *  defines: { "label" : "value" },
   *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
   *
   *  fragmentShader: <string>,
   *  vertexShader: <string>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  lights: <bool>,
   *
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  class ShaderMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.type = 'ShaderMaterial';

  		this.defines = {};
  		this.uniforms = {};

  		this.vertexShader = default_vertex;
  		this.fragmentShader = default_fragment;

  		this.linewidth = 1;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;

  		this.fog = false; // set to use scene fog
  		this.lights = false; // set to use scene lights
  		this.clipping = false; // set to use user-defined clipping planes

  		this.morphTargets = false; // set to use morph targets
  		this.morphNormals = false; // set to use morph normals

  		this.extensions = {
  			derivatives: false, // set to use derivatives
  			fragDepth: false, // set to use fragment depth values
  			drawBuffers: false, // set to use draw buffers
  			shaderTextureLOD: false // set to use shader texture LOD
  		};

  		// When rendered geometry doesn't include these attributes but the material does,
  		// use these default values in WebGL. This avoids errors when buffer data is missing.
  		this.defaultAttributeValues = {
  			'color': [ 1, 1, 1 ],
  			'uv': [ 0, 0 ],
  			'uv2': [ 0, 0 ]
  		};

  		this.index0AttributeName = undefined;
  		this.uniformsNeedUpdate = false;

  		this.glslVersion = null;

  		if ( parameters !== undefined ) {

  			if ( parameters.attributes !== undefined ) {

  				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

  			}

  			this.setValues( parameters );

  		}

  	}

  	copy( source ) {

  		super.copy( source );

  		this.fragmentShader = source.fragmentShader;
  		this.vertexShader = source.vertexShader;

  		this.uniforms = cloneUniforms( source.uniforms );

  		this.defines = Object.assign( {}, source.defines );

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		this.lights = source.lights;
  		this.clipping = source.clipping;

  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		this.extensions = Object.assign( {}, source.extensions );

  		this.glslVersion = source.glslVersion;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.glslVersion = this.glslVersion;
  		data.uniforms = {};

  		for ( const name in this.uniforms ) {

  			const uniform = this.uniforms[ name ];
  			const value = uniform.value;

  			if ( value && value.isTexture ) {

  				data.uniforms[ name ] = {
  					type: 't',
  					value: value.toJSON( meta ).uuid
  				};

  			} else if ( value && value.isColor ) {

  				data.uniforms[ name ] = {
  					type: 'c',
  					value: value.getHex()
  				};

  			} else if ( value && value.isVector2 ) {

  				data.uniforms[ name ] = {
  					type: 'v2',
  					value: value.toArray()
  				};

  			} else if ( value && value.isVector3 ) {

  				data.uniforms[ name ] = {
  					type: 'v3',
  					value: value.toArray()
  				};

  			} else if ( value && value.isVector4 ) {

  				data.uniforms[ name ] = {
  					type: 'v4',
  					value: value.toArray()
  				};

  			} else if ( value && value.isMatrix3 ) {

  				data.uniforms[ name ] = {
  					type: 'm3',
  					value: value.toArray()
  				};

  			} else if ( value && value.isMatrix4 ) {

  				data.uniforms[ name ] = {
  					type: 'm4',
  					value: value.toArray()
  				};

  			} else {

  				data.uniforms[ name ] = {
  					value: value
  				};

  				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

  			}

  		}

  		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

  		data.vertexShader = this.vertexShader;
  		data.fragmentShader = this.fragmentShader;

  		const extensions = {};

  		for ( const key in this.extensions ) {

  			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

  		}

  		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

  		return data;

  	}

  }

  ShaderMaterial.prototype.isShaderMaterial = true;

  class Camera extends Object3D {

  	constructor() {

  		super();

  		this.type = 'Camera';

  		this.matrixWorldInverse = new Matrix4();

  		this.projectionMatrix = new Matrix4();
  		this.projectionMatrixInverse = new Matrix4();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.matrixWorldInverse.copy( source.matrixWorldInverse );

  		this.projectionMatrix.copy( source.projectionMatrix );
  		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

  		return this;

  	}

  	getWorldDirection( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
  			target = new Vector3();

  		}

  		this.updateWorldMatrix( true, false );

  		const e = this.matrixWorld.elements;

  		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

  	}

  	updateMatrixWorld( force ) {

  		super.updateMatrixWorld( force );

  		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

  	}

  	updateWorldMatrix( updateParents, updateChildren ) {

  		super.updateWorldMatrix( updateParents, updateChildren );

  		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  Camera.prototype.isCamera = true;

  class PerspectiveCamera extends Camera {

  	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

  		super();

  		this.type = 'PerspectiveCamera';

  		this.fov = fov;
  		this.zoom = 1;

  		this.near = near;
  		this.far = far;
  		this.focus = 10;

  		this.aspect = aspect;
  		this.view = null;

  		this.filmGauge = 35;	// width of the film (default in millimeters)
  		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

  		this.updateProjectionMatrix();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.fov = source.fov;
  		this.zoom = source.zoom;

  		this.near = source.near;
  		this.far = source.far;
  		this.focus = source.focus;

  		this.aspect = source.aspect;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		this.filmGauge = source.filmGauge;
  		this.filmOffset = source.filmOffset;

  		return this;

  	}

  	/**
  	 * Sets the FOV by focal length in respect to the current .filmGauge.
  	 *
  	 * The default film gauge is 35, so that the focal length can be specified for
  	 * a 35mm (full frame) camera.
  	 *
  	 * Values for focal length and film gauge must have the same unit.
  	 */
  	setFocalLength( focalLength ) {

  		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
  		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

  		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Calculates the focal length from the current .fov and .filmGauge.
  	 */
  	getFocalLength() {

  		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

  		return 0.5 * this.getFilmHeight() / vExtentSlope;

  	}

  	getEffectiveFOV() {

  		return RAD2DEG * 2 * Math.atan(
  			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

  	}

  	getFilmWidth() {

  		// film not completely covered in portrait format (aspect < 1)
  		return this.filmGauge * Math.min( this.aspect, 1 );

  	}

  	getFilmHeight() {

  		// film not completely covered in landscape format (aspect > 1)
  		return this.filmGauge / Math.max( this.aspect, 1 );

  	}

  	/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  	 * the monitors are in grid like this
  	 *
  	 *   +---+---+---+
  	 *   | A | B | C |
  	 *   +---+---+---+
  	 *   | D | E | F |
  	 *   +---+---+---+
  	 *
  	 * then for each monitor you would call it like this
  	 *
  	 *   const w = 1920;
  	 *   const h = 1080;
  	 *   const fullWidth = w * 3;
  	 *   const fullHeight = h * 2;
  	 *
  	 *   --A--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  	 *   --B--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  	 *   --C--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  	 *   --D--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  	 *   --E--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  	 *   --F--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  	 *
  	 *   Note there is no reason monitors have to be the same size or in a grid.
  	 */
  	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

  		this.aspect = fullWidth / fullHeight;

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	}

  	clearViewOffset() {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	}

  	updateProjectionMatrix() {

  		const near = this.near;
  		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
  		let height = 2 * top;
  		let width = this.aspect * height;
  		let left = - 0.5 * width;
  		const view = this.view;

  		if ( this.view !== null && this.view.enabled ) {

  			const fullWidth = view.fullWidth,
  				fullHeight = view.fullHeight;

  			left += view.offsetX * width / fullWidth;
  			top -= view.offsetY * height / fullHeight;
  			width *= view.width / fullWidth;
  			height *= view.height / fullHeight;

  		}

  		const skew = this.filmOffset;
  		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

  		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

  		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.fov = this.fov;
  		data.object.zoom = this.zoom;

  		data.object.near = this.near;
  		data.object.far = this.far;
  		data.object.focus = this.focus;

  		data.object.aspect = this.aspect;

  		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  		data.object.filmGauge = this.filmGauge;
  		data.object.filmOffset = this.filmOffset;

  		return data;

  	}

  }

  PerspectiveCamera.prototype.isPerspectiveCamera = true;

  const fov = 90, aspect = 1;

  class CubeCamera extends Object3D {

  	constructor( near, far, renderTarget ) {

  		super();

  		this.type = 'CubeCamera';

  		if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

  			console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
  			return;

  		}

  		this.renderTarget = renderTarget;

  		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPX.layers = this.layers;
  		cameraPX.up.set( 0, - 1, 0 );
  		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
  		this.add( cameraPX );

  		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNX.layers = this.layers;
  		cameraNX.up.set( 0, - 1, 0 );
  		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
  		this.add( cameraNX );

  		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPY.layers = this.layers;
  		cameraPY.up.set( 0, 0, 1 );
  		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
  		this.add( cameraPY );

  		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNY.layers = this.layers;
  		cameraNY.up.set( 0, 0, - 1 );
  		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
  		this.add( cameraNY );

  		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPZ.layers = this.layers;
  		cameraPZ.up.set( 0, - 1, 0 );
  		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
  		this.add( cameraPZ );

  		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNZ.layers = this.layers;
  		cameraNZ.up.set( 0, - 1, 0 );
  		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
  		this.add( cameraNZ );

  	}

  	update( renderer, scene ) {

  		if ( this.parent === null ) this.updateMatrixWorld();

  		const renderTarget = this.renderTarget;

  		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

  		const currentXrEnabled = renderer.xr.enabled;
  		const currentRenderTarget = renderer.getRenderTarget();

  		renderer.xr.enabled = false;

  		const generateMipmaps = renderTarget.texture.generateMipmaps;

  		renderTarget.texture.generateMipmaps = false;

  		renderer.setRenderTarget( renderTarget, 0 );
  		renderer.render( scene, cameraPX );

  		renderer.setRenderTarget( renderTarget, 1 );
  		renderer.render( scene, cameraNX );

  		renderer.setRenderTarget( renderTarget, 2 );
  		renderer.render( scene, cameraPY );

  		renderer.setRenderTarget( renderTarget, 3 );
  		renderer.render( scene, cameraNY );

  		renderer.setRenderTarget( renderTarget, 4 );
  		renderer.render( scene, cameraPZ );

  		renderTarget.texture.generateMipmaps = generateMipmaps;

  		renderer.setRenderTarget( renderTarget, 5 );
  		renderer.render( scene, cameraNZ );

  		renderer.setRenderTarget( currentRenderTarget );

  		renderer.xr.enabled = currentXrEnabled;

  	}

  }

  class CubeTexture extends Texture {

  	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

  		images = images !== undefined ? images : [];
  		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
  		format = format !== undefined ? format : RGBFormat;

  		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  		// Why CubeTexture._needsFlipEnvMap is necessary:
  		//
  		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
  		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
  		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

  		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
  		// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
  		// when using WebGLCubeRenderTarget.texture as a cube texture.

  		this._needsFlipEnvMap = true;

  		this.flipY = false;

  	}

  	get images() {

  		return this.image;

  	}

  	set images( value ) {

  		this.image = value;

  	}

  }

  CubeTexture.prototype.isCubeTexture = true;

  class WebGLCubeRenderTarget extends WebGLRenderTarget {

  	constructor( size, options, dummy ) {

  		if ( Number.isInteger( options ) ) {

  			console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

  			options = dummy;

  		}

  		super( size, size, options );

  		options = options || {};

  		this.texture = new CubeTexture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

  		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
  		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

  		this.texture._needsFlipEnvMap = false;

  	}

  	fromEquirectangularTexture( renderer, texture ) {

  		this.texture.type = texture.type;
  		this.texture.format = RGBAFormat; // see #18859
  		this.texture.encoding = texture.encoding;

  		this.texture.generateMipmaps = texture.generateMipmaps;
  		this.texture.minFilter = texture.minFilter;
  		this.texture.magFilter = texture.magFilter;

  		const shader = {

  			uniforms: {
  				tEquirect: { value: null },
  			},

  			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

  			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
  		};

  		const geometry = new BoxGeometry( 5, 5, 5 );

  		const material = new ShaderMaterial( {

  			name: 'CubemapFromEquirect',

  			uniforms: cloneUniforms( shader.uniforms ),
  			vertexShader: shader.vertexShader,
  			fragmentShader: shader.fragmentShader,
  			side: BackSide,
  			blending: NoBlending

  		} );

  		material.uniforms.tEquirect.value = texture;

  		const mesh = new Mesh( geometry, material );

  		const currentMinFilter = texture.minFilter;

  		// Avoid blurred poles
  		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

  		const camera = new CubeCamera( 1, 10, this );
  		camera.update( renderer, mesh );

  		texture.minFilter = currentMinFilter;

  		mesh.geometry.dispose();
  		mesh.material.dispose();

  		return this;

  	}

  	clear( renderer, color, depth, stencil ) {

  		const currentRenderTarget = renderer.getRenderTarget();

  		for ( let i = 0; i < 6; i ++ ) {

  			renderer.setRenderTarget( this, i );

  			renderer.clear( color, depth, stencil );

  		}

  		renderer.setRenderTarget( currentRenderTarget );

  	}

  }

  WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

  const _sphere$2 = /*@__PURE__*/ new Sphere();
  const _vector$7 = /*@__PURE__*/ new Vector3();

  class Frustum {

  	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

  		this.planes = [ p0, p1, p2, p3, p4, p5 ];

  	}

  	set( p0, p1, p2, p3, p4, p5 ) {

  		const planes = this.planes;

  		planes[ 0 ].copy( p0 );
  		planes[ 1 ].copy( p1 );
  		planes[ 2 ].copy( p2 );
  		planes[ 3 ].copy( p3 );
  		planes[ 4 ].copy( p4 );
  		planes[ 5 ].copy( p5 );

  		return this;

  	}

  	copy( frustum ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			planes[ i ].copy( frustum.planes[ i ] );

  		}

  		return this;

  	}

  	setFromProjectionMatrix( m ) {

  		const planes = this.planes;
  		const me = m.elements;
  		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
  		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
  		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
  		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

  		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
  		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
  		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
  		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
  		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
  		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

  		return this;

  	}

  	intersectsObject( object ) {

  		const geometry = object.geometry;

  		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  		_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

  		return this.intersectsSphere( _sphere$2 );

  	}

  	intersectsSprite( sprite ) {

  		_sphere$2.center.set( 0, 0, 0 );
  		_sphere$2.radius = 0.7071067811865476;
  		_sphere$2.applyMatrix4( sprite.matrixWorld );

  		return this.intersectsSphere( _sphere$2 );

  	}

  	intersectsSphere( sphere ) {

  		const planes = this.planes;
  		const center = sphere.center;
  		const negRadius = - sphere.radius;

  		for ( let i = 0; i < 6; i ++ ) {

  			const distance = planes[ i ].distanceToPoint( center );

  			if ( distance < negRadius ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	intersectsBox( box ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			const plane = planes[ i ];

  			// corner at max distance

  			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
  			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
  			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

  			if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	containsPoint( point ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  function WebGLAnimation() {

  	let context = null;
  	let isAnimating = false;
  	let animationLoop = null;
  	let requestId = null;

  	function onAnimationFrame( time, frame ) {

  		animationLoop( time, frame );

  		requestId = context.requestAnimationFrame( onAnimationFrame );

  	}

  	return {

  		start: function () {

  			if ( isAnimating === true ) return;
  			if ( animationLoop === null ) return;

  			requestId = context.requestAnimationFrame( onAnimationFrame );

  			isAnimating = true;

  		},

  		stop: function () {

  			context.cancelAnimationFrame( requestId );

  			isAnimating = false;

  		},

  		setAnimationLoop: function ( callback ) {

  			animationLoop = callback;

  		},

  		setContext: function ( value ) {

  			context = value;

  		}

  	};

  }

  function WebGLAttributes( gl, capabilities ) {

  	const isWebGL2 = capabilities.isWebGL2;

  	const buffers = new WeakMap();

  	function createBuffer( attribute, bufferType ) {

  		const array = attribute.array;
  		const usage = attribute.usage;

  		const buffer = gl.createBuffer();

  		gl.bindBuffer( bufferType, buffer );
  		gl.bufferData( bufferType, array, usage );

  		attribute.onUploadCallback();

  		let type = 5126;

  		if ( array instanceof Float32Array ) {

  			type = 5126;

  		} else if ( array instanceof Float64Array ) {

  			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

  		} else if ( array instanceof Uint16Array ) {

  			if ( attribute.isFloat16BufferAttribute ) {

  				if ( isWebGL2 ) {

  					type = 5131;

  				} else {

  					console.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

  				}

  			} else {

  				type = 5123;

  			}

  		} else if ( array instanceof Int16Array ) {

  			type = 5122;

  		} else if ( array instanceof Uint32Array ) {

  			type = 5125;

  		} else if ( array instanceof Int32Array ) {

  			type = 5124;

  		} else if ( array instanceof Int8Array ) {

  			type = 5120;

  		} else if ( array instanceof Uint8Array ) {

  			type = 5121;

  		} else if ( array instanceof Uint8ClampedArray ) {

  			type = 5121;

  		}

  		return {
  			buffer: buffer,
  			type: type,
  			bytesPerElement: array.BYTES_PER_ELEMENT,
  			version: attribute.version
  		};

  	}

  	function updateBuffer( buffer, attribute, bufferType ) {

  		const array = attribute.array;
  		const updateRange = attribute.updateRange;

  		gl.bindBuffer( bufferType, buffer );

  		if ( updateRange.count === - 1 ) {

  			// Not using update ranges

  			gl.bufferSubData( bufferType, 0, array );

  		} else {

  			if ( isWebGL2 ) {

  				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
  					array, updateRange.offset, updateRange.count );

  			} else {

  				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
  					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

  			}

  			updateRange.count = - 1; // reset range

  		}

  	}

  	//

  	function get( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		return buffers.get( attribute );

  	}

  	function remove( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		const data = buffers.get( attribute );

  		if ( data ) {

  			gl.deleteBuffer( data.buffer );

  			buffers.delete( attribute );

  		}

  	}

  	function update( attribute, bufferType ) {

  		if ( attribute.isGLBufferAttribute ) {

  			const cached = buffers.get( attribute );

  			if ( ! cached || cached.version < attribute.version ) {

  				buffers.set( attribute, {
  					buffer: attribute.buffer,
  					type: attribute.type,
  					bytesPerElement: attribute.elementSize,
  					version: attribute.version
  				} );

  			}

  			return;

  		}

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		const data = buffers.get( attribute );

  		if ( data === undefined ) {

  			buffers.set( attribute, createBuffer( attribute, bufferType ) );

  		} else if ( data.version < attribute.version ) {

  			updateBuffer( data.buffer, attribute, bufferType );

  			data.version = attribute.version;

  		}

  	}

  	return {

  		get: get,
  		remove: remove,
  		update: update

  	};

  }

  class PlaneGeometry extends BufferGeometry {

  	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

  		super();
  		this.type = 'PlaneGeometry';

  		this.parameters = {
  			width: width,
  			height: height,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments
  		};

  		const width_half = width / 2;
  		const height_half = height / 2;

  		const gridX = Math.floor( widthSegments );
  		const gridY = Math.floor( heightSegments );

  		const gridX1 = gridX + 1;
  		const gridY1 = gridY + 1;

  		const segment_width = width / gridX;
  		const segment_height = height / gridY;

  		//

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		for ( let iy = 0; iy < gridY1; iy ++ ) {

  			const y = iy * segment_height - height_half;

  			for ( let ix = 0; ix < gridX1; ix ++ ) {

  				const x = ix * segment_width - width_half;

  				vertices.push( x, - y, 0 );

  				normals.push( 0, 0, 1 );

  				uvs.push( ix / gridX );
  				uvs.push( 1 - ( iy / gridY ) );

  			}

  		}

  		for ( let iy = 0; iy < gridY; iy ++ ) {

  			for ( let ix = 0; ix < gridX; ix ++ ) {

  				const a = ix + gridX1 * iy;
  				const b = ix + gridX1 * ( iy + 1 );
  				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
  				const d = ( ix + 1 ) + gridX1 * iy;

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  }

  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

  var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

  var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

  var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

  var begin_vertex = "vec3 transformed = vec3( position );";

  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

  var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

  var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

  var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

  var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

  var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

  var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

  var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

  var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

  var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

  var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

  var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

  var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

  var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

  var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";

  var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

  var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

  var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

  var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

  var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

  var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

  var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

  var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

  var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

  var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

  var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

  var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

  var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

  var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

  var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

  var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

  var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

  var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

  var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

  var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

  var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

  var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

  var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

  var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

  var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

  var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

  var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

  var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

  var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

  var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

  var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

  var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

  var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

  var transmission_fragment = "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );\n\tvec3 f90 = vec3( 1.0 );\n\tvec3 f_transmission = totalTransmission * getIBLVolumeRefraction(\n\t\tnormal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance);\n\tdiffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );\n#endif";

  var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\tfloat NdotV = saturate(dot(n, viewDir));\n\t\tvec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);\n\t\tvec3 specularColor = f0 * brdf.x + f90 * brdf.y;\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif";

  var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

  var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

  var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

  var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

  var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

  var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

  var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

  var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

  var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

  var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

  var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

  var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

  var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

  var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

  var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

  var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

  var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

  var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

  var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

  var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

  var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef USE_TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t\tfloat thicknessFactor = thickness;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\tvec3 rawDiffuseColor = diffuseColor.rgb;\n\t#include <transmission_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}";

  var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

  var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

  var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

  var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

  var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

  var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

  var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

  const ShaderChunk = {
  	alphamap_fragment: alphamap_fragment,
  	alphamap_pars_fragment: alphamap_pars_fragment,
  	alphatest_fragment: alphatest_fragment,
  	aomap_fragment: aomap_fragment,
  	aomap_pars_fragment: aomap_pars_fragment,
  	begin_vertex: begin_vertex,
  	beginnormal_vertex: beginnormal_vertex,
  	bsdfs: bsdfs,
  	bumpmap_pars_fragment: bumpmap_pars_fragment,
  	clipping_planes_fragment: clipping_planes_fragment,
  	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  	clipping_planes_vertex: clipping_planes_vertex,
  	color_fragment: color_fragment,
  	color_pars_fragment: color_pars_fragment,
  	color_pars_vertex: color_pars_vertex,
  	color_vertex: color_vertex,
  	common: common,
  	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  	defaultnormal_vertex: defaultnormal_vertex,
  	displacementmap_pars_vertex: displacementmap_pars_vertex,
  	displacementmap_vertex: displacementmap_vertex,
  	emissivemap_fragment: emissivemap_fragment,
  	emissivemap_pars_fragment: emissivemap_pars_fragment,
  	encodings_fragment: encodings_fragment,
  	encodings_pars_fragment: encodings_pars_fragment,
  	envmap_fragment: envmap_fragment,
  	envmap_common_pars_fragment: envmap_common_pars_fragment,
  	envmap_pars_fragment: envmap_pars_fragment,
  	envmap_pars_vertex: envmap_pars_vertex,
  	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  	envmap_vertex: envmap_vertex,
  	fog_vertex: fog_vertex,
  	fog_pars_vertex: fog_pars_vertex,
  	fog_fragment: fog_fragment,
  	fog_pars_fragment: fog_pars_fragment,
  	gradientmap_pars_fragment: gradientmap_pars_fragment,
  	lightmap_fragment: lightmap_fragment,
  	lightmap_pars_fragment: lightmap_pars_fragment,
  	lights_lambert_vertex: lights_lambert_vertex,
  	lights_pars_begin: lights_pars_begin,
  	lights_toon_fragment: lights_toon_fragment,
  	lights_toon_pars_fragment: lights_toon_pars_fragment,
  	lights_phong_fragment: lights_phong_fragment,
  	lights_phong_pars_fragment: lights_phong_pars_fragment,
  	lights_physical_fragment: lights_physical_fragment,
  	lights_physical_pars_fragment: lights_physical_pars_fragment,
  	lights_fragment_begin: lights_fragment_begin,
  	lights_fragment_maps: lights_fragment_maps,
  	lights_fragment_end: lights_fragment_end,
  	logdepthbuf_fragment: logdepthbuf_fragment,
  	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  	logdepthbuf_vertex: logdepthbuf_vertex,
  	map_fragment: map_fragment,
  	map_pars_fragment: map_pars_fragment,
  	map_particle_fragment: map_particle_fragment,
  	map_particle_pars_fragment: map_particle_pars_fragment,
  	metalnessmap_fragment: metalnessmap_fragment,
  	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  	morphnormal_vertex: morphnormal_vertex,
  	morphtarget_pars_vertex: morphtarget_pars_vertex,
  	morphtarget_vertex: morphtarget_vertex,
  	normal_fragment_begin: normal_fragment_begin,
  	normal_fragment_maps: normal_fragment_maps,
  	normalmap_pars_fragment: normalmap_pars_fragment,
  	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
  	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
  	clearcoat_pars_fragment: clearcoat_pars_fragment,
  	packing: packing,
  	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  	project_vertex: project_vertex,
  	dithering_fragment: dithering_fragment,
  	dithering_pars_fragment: dithering_pars_fragment,
  	roughnessmap_fragment: roughnessmap_fragment,
  	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  	shadowmap_pars_fragment: shadowmap_pars_fragment,
  	shadowmap_pars_vertex: shadowmap_pars_vertex,
  	shadowmap_vertex: shadowmap_vertex,
  	shadowmask_pars_fragment: shadowmask_pars_fragment,
  	skinbase_vertex: skinbase_vertex,
  	skinning_pars_vertex: skinning_pars_vertex,
  	skinning_vertex: skinning_vertex,
  	skinnormal_vertex: skinnormal_vertex,
  	specularmap_fragment: specularmap_fragment,
  	specularmap_pars_fragment: specularmap_pars_fragment,
  	tonemapping_fragment: tonemapping_fragment,
  	tonemapping_pars_fragment: tonemapping_pars_fragment,
  	transmission_fragment: transmission_fragment,
  	transmission_pars_fragment: transmission_pars_fragment,
  	uv_pars_fragment: uv_pars_fragment,
  	uv_pars_vertex: uv_pars_vertex,
  	uv_vertex: uv_vertex,
  	uv2_pars_fragment: uv2_pars_fragment,
  	uv2_pars_vertex: uv2_pars_vertex,
  	uv2_vertex: uv2_vertex,
  	worldpos_vertex: worldpos_vertex,

  	background_frag: background_frag,
  	background_vert: background_vert,
  	cube_frag: cube_frag,
  	cube_vert: cube_vert,
  	depth_frag: depth_frag,
  	depth_vert: depth_vert,
  	distanceRGBA_frag: distanceRGBA_frag,
  	distanceRGBA_vert: distanceRGBA_vert,
  	equirect_frag: equirect_frag,
  	equirect_vert: equirect_vert,
  	linedashed_frag: linedashed_frag,
  	linedashed_vert: linedashed_vert,
  	meshbasic_frag: meshbasic_frag,
  	meshbasic_vert: meshbasic_vert,
  	meshlambert_frag: meshlambert_frag,
  	meshlambert_vert: meshlambert_vert,
  	meshmatcap_frag: meshmatcap_frag,
  	meshmatcap_vert: meshmatcap_vert,
  	meshtoon_frag: meshtoon_frag,
  	meshtoon_vert: meshtoon_vert,
  	meshphong_frag: meshphong_frag,
  	meshphong_vert: meshphong_vert,
  	meshphysical_frag: meshphysical_frag,
  	meshphysical_vert: meshphysical_vert,
  	normal_frag: normal_frag,
  	normal_vert: normal_vert,
  	points_frag: points_frag,
  	points_vert: points_vert,
  	shadow_frag: shadow_frag,
  	shadow_vert: shadow_vert,
  	sprite_frag: sprite_frag,
  	sprite_vert: sprite_vert
  };

  /**
   * Uniforms library for shared webgl shaders
   */

  const UniformsLib = {

  	common: {

  		diffuse: { value: new Color( 0xffffff ) },
  		opacity: { value: 1.0 },

  		map: { value: null },
  		uvTransform: { value: new Matrix3() },
  		uv2Transform: { value: new Matrix3() },

  		alphaMap: { value: null },

  	},

  	specularmap: {

  		specularMap: { value: null },

  	},

  	envmap: {

  		envMap: { value: null },
  		flipEnvMap: { value: - 1 },
  		reflectivity: { value: 1.0 },
  		refractionRatio: { value: 0.98 },
  		maxMipLevel: { value: 0 }

  	},

  	aomap: {

  		aoMap: { value: null },
  		aoMapIntensity: { value: 1 }

  	},

  	lightmap: {

  		lightMap: { value: null },
  		lightMapIntensity: { value: 1 }

  	},

  	emissivemap: {

  		emissiveMap: { value: null }

  	},

  	bumpmap: {

  		bumpMap: { value: null },
  		bumpScale: { value: 1 }

  	},

  	normalmap: {

  		normalMap: { value: null },
  		normalScale: { value: new Vector2( 1, 1 ) }

  	},

  	displacementmap: {

  		displacementMap: { value: null },
  		displacementScale: { value: 1 },
  		displacementBias: { value: 0 }

  	},

  	roughnessmap: {

  		roughnessMap: { value: null }

  	},

  	metalnessmap: {

  		metalnessMap: { value: null }

  	},

  	gradientmap: {

  		gradientMap: { value: null }

  	},

  	fog: {

  		fogDensity: { value: 0.00025 },
  		fogNear: { value: 1 },
  		fogFar: { value: 2000 },
  		fogColor: { value: new Color( 0xffffff ) }

  	},

  	lights: {

  		ambientLightColor: { value: [] },

  		lightProbe: { value: [] },

  		directionalLights: { value: [], properties: {
  			direction: {},
  			color: {}
  		} },

  		directionalLightShadows: { value: [], properties: {
  			shadowBias: {},
  			shadowNormalBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		directionalShadowMap: { value: [] },
  		directionalShadowMatrix: { value: [] },

  		spotLights: { value: [], properties: {
  			color: {},
  			position: {},
  			direction: {},
  			distance: {},
  			coneCos: {},
  			penumbraCos: {},
  			decay: {}
  		} },

  		spotLightShadows: { value: [], properties: {
  			shadowBias: {},
  			shadowNormalBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		spotShadowMap: { value: [] },
  		spotShadowMatrix: { value: [] },

  		pointLights: { value: [], properties: {
  			color: {},
  			position: {},
  			decay: {},
  			distance: {}
  		} },

  		pointLightShadows: { value: [], properties: {
  			shadowBias: {},
  			shadowNormalBias: {},
  			shadowRadius: {},
  			shadowMapSize: {},
  			shadowCameraNear: {},
  			shadowCameraFar: {}
  		} },

  		pointShadowMap: { value: [] },
  		pointShadowMatrix: { value: [] },

  		hemisphereLights: { value: [], properties: {
  			direction: {},
  			skyColor: {},
  			groundColor: {}
  		} },

  		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
  		rectAreaLights: { value: [], properties: {
  			color: {},
  			position: {},
  			width: {},
  			height: {}
  		} },

  		ltc_1: { value: null },
  		ltc_2: { value: null }

  	},

  	points: {

  		diffuse: { value: new Color( 0xffffff ) },
  		opacity: { value: 1.0 },
  		size: { value: 1.0 },
  		scale: { value: 1.0 },
  		map: { value: null },
  		alphaMap: { value: null },
  		uvTransform: { value: new Matrix3() }

  	},

  	sprite: {

  		diffuse: { value: new Color( 0xffffff ) },
  		opacity: { value: 1.0 },
  		center: { value: new Vector2( 0.5, 0.5 ) },
  		rotation: { value: 0.0 },
  		map: { value: null },
  		alphaMap: { value: null },
  		uvTransform: { value: new Matrix3() }

  	}

  };

  const ShaderLib = {

  	basic: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.meshbasic_vert,
  		fragmentShader: ShaderChunk.meshbasic_frag

  	},

  	lambert: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: new Color( 0x000000 ) }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshlambert_vert,
  		fragmentShader: ShaderChunk.meshlambert_frag

  	},

  	phong: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: new Color( 0x000000 ) },
  				specular: { value: new Color( 0x111111 ) },
  				shininess: { value: 30 }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshphong_vert,
  		fragmentShader: ShaderChunk.meshphong_frag

  	},

  	standard: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.roughnessmap,
  			UniformsLib.metalnessmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: new Color( 0x000000 ) },
  				roughness: { value: 1.0 },
  				metalness: { value: 0.0 },
  				envMapIntensity: { value: 1 } // temporary
  			}
  		] ),

  		vertexShader: ShaderChunk.meshphysical_vert,
  		fragmentShader: ShaderChunk.meshphysical_frag

  	},

  	toon: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.gradientmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: new Color( 0x000000 ) }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshtoon_vert,
  		fragmentShader: ShaderChunk.meshtoon_frag

  	},

  	matcap: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.fog,
  			{
  				matcap: { value: null }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshmatcap_vert,
  		fragmentShader: ShaderChunk.meshmatcap_frag

  	},

  	points: {

  		uniforms: mergeUniforms( [
  			UniformsLib.points,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.points_vert,
  		fragmentShader: ShaderChunk.points_frag

  	},

  	dashed: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.fog,
  			{
  				scale: { value: 1 },
  				dashSize: { value: 1 },
  				totalSize: { value: 2 }
  			}
  		] ),

  		vertexShader: ShaderChunk.linedashed_vert,
  		fragmentShader: ShaderChunk.linedashed_frag

  	},

  	depth: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.displacementmap
  		] ),

  		vertexShader: ShaderChunk.depth_vert,
  		fragmentShader: ShaderChunk.depth_frag

  	},

  	normal: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			{
  				opacity: { value: 1.0 }
  			}
  		] ),

  		vertexShader: ShaderChunk.normal_vert,
  		fragmentShader: ShaderChunk.normal_frag

  	},

  	sprite: {

  		uniforms: mergeUniforms( [
  			UniformsLib.sprite,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.sprite_vert,
  		fragmentShader: ShaderChunk.sprite_frag

  	},

  	background: {

  		uniforms: {
  			uvTransform: { value: new Matrix3() },
  			t2D: { value: null },
  		},

  		vertexShader: ShaderChunk.background_vert,
  		fragmentShader: ShaderChunk.background_frag

  	},
  	/* -------------------------------------------------------------------------
  	//	Cube map shader
  	 ------------------------------------------------------------------------- */

  	cube: {

  		uniforms: mergeUniforms( [
  			UniformsLib.envmap,
  			{
  				opacity: { value: 1.0 }
  			}
  		] ),

  		vertexShader: ShaderChunk.cube_vert,
  		fragmentShader: ShaderChunk.cube_frag

  	},

  	equirect: {

  		uniforms: {
  			tEquirect: { value: null },
  		},

  		vertexShader: ShaderChunk.equirect_vert,
  		fragmentShader: ShaderChunk.equirect_frag

  	},

  	distanceRGBA: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.displacementmap,
  			{
  				referencePosition: { value: new Vector3() },
  				nearDistance: { value: 1 },
  				farDistance: { value: 1000 }
  			}
  		] ),

  		vertexShader: ShaderChunk.distanceRGBA_vert,
  		fragmentShader: ShaderChunk.distanceRGBA_frag

  	},

  	shadow: {

  		uniforms: mergeUniforms( [
  			UniformsLib.lights,
  			UniformsLib.fog,
  			{
  				color: { value: new Color( 0x00000 ) },
  				opacity: { value: 1.0 }
  			},
  		] ),

  		vertexShader: ShaderChunk.shadow_vert,
  		fragmentShader: ShaderChunk.shadow_frag

  	}

  };

  ShaderLib.physical = {

  	uniforms: mergeUniforms( [
  		ShaderLib.standard.uniforms,
  		{
  			clearcoat: { value: 0 },
  			clearcoatMap: { value: null },
  			clearcoatRoughness: { value: 0 },
  			clearcoatRoughnessMap: { value: null },
  			clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
  			clearcoatNormalMap: { value: null },
  			sheen: { value: new Color( 0x000000 ) },
  			transmission: { value: 0 },
  			transmissionMap: { value: null },
  			transmissionSamplerSize: { value: new Vector2() },
  			transmissionSamplerMap: { value: null },
  			thickness: { value: 0 },
  			thicknessMap: { value: null },
  			attenuationDistance: { value: 0 },
  			attenuationColor: { value: new Color( 0x000000 ) }
  		}
  	] ),

  	vertexShader: ShaderChunk.meshphysical_vert,
  	fragmentShader: ShaderChunk.meshphysical_frag

  };

  function WebGLBackground( renderer, cubemaps, state, objects, premultipliedAlpha ) {

  	const clearColor = new Color( 0x000000 );
  	let clearAlpha = 0;

  	let planeMesh;
  	let boxMesh;

  	let currentBackground = null;
  	let currentBackgroundVersion = 0;
  	let currentTonemapping = null;

  	function render( renderList, scene ) {

  		let forceClear = false;
  		let background = scene.isScene === true ? scene.background : null;

  		if ( background && background.isTexture ) {

  			background = cubemaps.get( background );

  		}

  		// Ignore background in AR
  		// TODO: Reconsider this.

  		const xr = renderer.xr;
  		const session = xr.getSession && xr.getSession();

  		if ( session && session.environmentBlendMode === 'additive' ) {

  			background = null;

  		}

  		if ( background === null ) {

  			setClear( clearColor, clearAlpha );

  		} else if ( background && background.isColor ) {

  			setClear( background, 1 );
  			forceClear = true;

  		}

  		if ( renderer.autoClear || forceClear ) {

  			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

  		}

  		if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

  			if ( boxMesh === undefined ) {

  				boxMesh = new Mesh(
  					new BoxGeometry( 1, 1, 1 ),
  					new ShaderMaterial( {
  						name: 'BackgroundCubeMaterial',
  						uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
  						vertexShader: ShaderLib.cube.vertexShader,
  						fragmentShader: ShaderLib.cube.fragmentShader,
  						side: BackSide,
  						depthTest: false,
  						depthWrite: false,
  						fog: false
  					} )
  				);

  				boxMesh.geometry.deleteAttribute( 'normal' );
  				boxMesh.geometry.deleteAttribute( 'uv' );

  				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

  					this.matrixWorld.copyPosition( camera.matrixWorld );

  				};

  				// enable code injection for non-built-in material
  				Object.defineProperty( boxMesh.material, 'envMap', {

  					get: function () {

  						return this.uniforms.envMap.value;

  					}

  				} );

  				objects.update( boxMesh );

  			}

  			boxMesh.material.uniforms.envMap.value = background;
  			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background._needsFlipEnvMap ) ? - 1 : 1;

  			if ( currentBackground !== background ||
  				currentBackgroundVersion !== background.version ||
  				currentTonemapping !== renderer.toneMapping ) {

  				boxMesh.material.needsUpdate = true;

  				currentBackground = background;
  				currentBackgroundVersion = background.version;
  				currentTonemapping = renderer.toneMapping;

  			}

  			// push to the pre-sorted opaque render list
  			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

  		} else if ( background && background.isTexture ) {

  			if ( planeMesh === undefined ) {

  				planeMesh = new Mesh(
  					new PlaneGeometry( 2, 2 ),
  					new ShaderMaterial( {
  						name: 'BackgroundMaterial',
  						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
  						vertexShader: ShaderLib.background.vertexShader,
  						fragmentShader: ShaderLib.background.fragmentShader,
  						side: FrontSide,
  						depthTest: false,
  						depthWrite: false,
  						fog: false
  					} )
  				);

  				planeMesh.geometry.deleteAttribute( 'normal' );

  				// enable code injection for non-built-in material
  				Object.defineProperty( planeMesh.material, 'map', {

  					get: function () {

  						return this.uniforms.t2D.value;

  					}

  				} );

  				objects.update( planeMesh );

  			}

  			planeMesh.material.uniforms.t2D.value = background;

  			if ( background.matrixAutoUpdate === true ) {

  				background.updateMatrix();

  			}

  			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

  			if ( currentBackground !== background ||
  				currentBackgroundVersion !== background.version ||
  				currentTonemapping !== renderer.toneMapping ) {

  				planeMesh.material.needsUpdate = true;

  				currentBackground = background;
  				currentBackgroundVersion = background.version;
  				currentTonemapping = renderer.toneMapping;

  			}


  			// push to the pre-sorted opaque render list
  			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

  		}

  	}

  	function setClear( color, alpha ) {

  		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

  	}

  	return {

  		getClearColor: function () {

  			return clearColor;

  		},
  		setClearColor: function ( color, alpha = 1 ) {

  			clearColor.set( color );
  			clearAlpha = alpha;
  			setClear( clearColor, clearAlpha );

  		},
  		getClearAlpha: function () {

  			return clearAlpha;

  		},
  		setClearAlpha: function ( alpha ) {

  			clearAlpha = alpha;
  			setClear( clearColor, clearAlpha );

  		},
  		render: render

  	};

  }

  function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

  	const maxVertexAttributes = gl.getParameter( 34921 );

  	const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
  	const vaoAvailable = capabilities.isWebGL2 || extension !== null;

  	const bindingStates = {};

  	const defaultState = createBindingState( null );
  	let currentState = defaultState;

  	function setup( object, material, program, geometry, index ) {

  		let updateBuffers = false;

  		if ( vaoAvailable ) {

  			const state = getBindingState( geometry, program, material );

  			if ( currentState !== state ) {

  				currentState = state;
  				bindVertexArrayObject( currentState.object );

  			}

  			updateBuffers = needsUpdate( geometry, index );

  			if ( updateBuffers ) saveCache( geometry, index );

  		} else {

  			const wireframe = ( material.wireframe === true );

  			if ( currentState.geometry !== geometry.id ||
  				currentState.program !== program.id ||
  				currentState.wireframe !== wireframe ) {

  				currentState.geometry = geometry.id;
  				currentState.program = program.id;
  				currentState.wireframe = wireframe;

  				updateBuffers = true;

  			}

  		}

  		if ( object.isInstancedMesh === true ) {

  			updateBuffers = true;

  		}

  		if ( index !== null ) {

  			attributes.update( index, 34963 );

  		}

  		if ( updateBuffers ) {

  			setupVertexAttributes( object, material, program, geometry );

  			if ( index !== null ) {

  				gl.bindBuffer( 34963, attributes.get( index ).buffer );

  			}

  		}

  	}

  	function createVertexArrayObject() {

  		if ( capabilities.isWebGL2 ) return gl.createVertexArray();

  		return extension.createVertexArrayOES();

  	}

  	function bindVertexArrayObject( vao ) {

  		if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

  		return extension.bindVertexArrayOES( vao );

  	}

  	function deleteVertexArrayObject( vao ) {

  		if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

  		return extension.deleteVertexArrayOES( vao );

  	}

  	function getBindingState( geometry, program, material ) {

  		const wireframe = ( material.wireframe === true );

  		let programMap = bindingStates[ geometry.id ];

  		if ( programMap === undefined ) {

  			programMap = {};
  			bindingStates[ geometry.id ] = programMap;

  		}

  		let stateMap = programMap[ program.id ];

  		if ( stateMap === undefined ) {

  			stateMap = {};
  			programMap[ program.id ] = stateMap;

  		}

  		let state = stateMap[ wireframe ];

  		if ( state === undefined ) {

  			state = createBindingState( createVertexArrayObject() );
  			stateMap[ wireframe ] = state;

  		}

  		return state;

  	}

  	function createBindingState( vao ) {

  		const newAttributes = [];
  		const enabledAttributes = [];
  		const attributeDivisors = [];

  		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

  			newAttributes[ i ] = 0;
  			enabledAttributes[ i ] = 0;
  			attributeDivisors[ i ] = 0;

  		}

  		return {

  			// for backward compatibility on non-VAO support browser
  			geometry: null,
  			program: null,
  			wireframe: false,

  			newAttributes: newAttributes,
  			enabledAttributes: enabledAttributes,
  			attributeDivisors: attributeDivisors,
  			object: vao,
  			attributes: {},
  			index: null

  		};

  	}

  	function needsUpdate( geometry, index ) {

  		const cachedAttributes = currentState.attributes;
  		const geometryAttributes = geometry.attributes;

  		let attributesNum = 0;

  		for ( const key in geometryAttributes ) {

  			const cachedAttribute = cachedAttributes[ key ];
  			const geometryAttribute = geometryAttributes[ key ];

  			if ( cachedAttribute === undefined ) return true;

  			if ( cachedAttribute.attribute !== geometryAttribute ) return true;

  			if ( cachedAttribute.data !== geometryAttribute.data ) return true;

  			attributesNum ++;

  		}

  		if ( currentState.attributesNum !== attributesNum ) return true;

  		if ( currentState.index !== index ) return true;

  		return false;

  	}

  	function saveCache( geometry, index ) {

  		const cache = {};
  		const attributes = geometry.attributes;
  		let attributesNum = 0;

  		for ( const key in attributes ) {

  			const attribute = attributes[ key ];

  			const data = {};
  			data.attribute = attribute;

  			if ( attribute.data ) {

  				data.data = attribute.data;

  			}

  			cache[ key ] = data;

  			attributesNum ++;

  		}

  		currentState.attributes = cache;
  		currentState.attributesNum = attributesNum;

  		currentState.index = index;

  	}

  	function initAttributes() {

  		const newAttributes = currentState.newAttributes;

  		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

  			newAttributes[ i ] = 0;

  		}

  	}

  	function enableAttribute( attribute ) {

  		enableAttributeAndDivisor( attribute, 0 );

  	}

  	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

  		const newAttributes = currentState.newAttributes;
  		const enabledAttributes = currentState.enabledAttributes;
  		const attributeDivisors = currentState.attributeDivisors;

  		newAttributes[ attribute ] = 1;

  		if ( enabledAttributes[ attribute ] === 0 ) {

  			gl.enableVertexAttribArray( attribute );
  			enabledAttributes[ attribute ] = 1;

  		}

  		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

  			const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

  			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
  			attributeDivisors[ attribute ] = meshPerAttribute;

  		}

  	}

  	function disableUnusedAttributes() {

  		const newAttributes = currentState.newAttributes;
  		const enabledAttributes = currentState.enabledAttributes;

  		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

  			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

  				gl.disableVertexAttribArray( i );
  				enabledAttributes[ i ] = 0;

  			}

  		}

  	}

  	function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

  		if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

  			gl.vertexAttribIPointer( index, size, type, stride, offset );

  		} else {

  			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

  		}

  	}

  	function setupVertexAttributes( object, material, program, geometry ) {

  		if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

  			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

  		}

  		initAttributes();

  		const geometryAttributes = geometry.attributes;

  		const programAttributes = program.getAttributes();

  		const materialDefaultAttributeValues = material.defaultAttributeValues;

  		for ( const name in programAttributes ) {

  			const programAttribute = programAttributes[ name ];

  			if ( programAttribute >= 0 ) {

  				const geometryAttribute = geometryAttributes[ name ];

  				if ( geometryAttribute !== undefined ) {

  					const normalized = geometryAttribute.normalized;
  					const size = geometryAttribute.itemSize;

  					const attribute = attributes.get( geometryAttribute );

  					// TODO Attribute may not be available on context restore

  					if ( attribute === undefined ) continue;

  					const buffer = attribute.buffer;
  					const type = attribute.type;
  					const bytesPerElement = attribute.bytesPerElement;

  					if ( geometryAttribute.isInterleavedBufferAttribute ) {

  						const data = geometryAttribute.data;
  						const stride = data.stride;
  						const offset = geometryAttribute.offset;

  						if ( data && data.isInstancedInterleavedBuffer ) {

  							enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

  							if ( geometry._maxInstanceCount === undefined ) {

  								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

  							}

  						} else {

  							enableAttribute( programAttribute );

  						}

  						gl.bindBuffer( 34962, buffer );
  						vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

  					} else {

  						if ( geometryAttribute.isInstancedBufferAttribute ) {

  							enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

  							if ( geometry._maxInstanceCount === undefined ) {

  								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

  							}

  						} else {

  							enableAttribute( programAttribute );

  						}

  						gl.bindBuffer( 34962, buffer );
  						vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

  					}

  				} else if ( name === 'instanceMatrix' ) {

  					const attribute = attributes.get( object.instanceMatrix );

  					// TODO Attribute may not be available on context restore

  					if ( attribute === undefined ) continue;

  					const buffer = attribute.buffer;
  					const type = attribute.type;

  					enableAttributeAndDivisor( programAttribute + 0, 1 );
  					enableAttributeAndDivisor( programAttribute + 1, 1 );
  					enableAttributeAndDivisor( programAttribute + 2, 1 );
  					enableAttributeAndDivisor( programAttribute + 3, 1 );

  					gl.bindBuffer( 34962, buffer );

  					gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
  					gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
  					gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
  					gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

  				} else if ( name === 'instanceColor' ) {

  					const attribute = attributes.get( object.instanceColor );

  					// TODO Attribute may not be available on context restore

  					if ( attribute === undefined ) continue;

  					const buffer = attribute.buffer;
  					const type = attribute.type;

  					enableAttributeAndDivisor( programAttribute, 1 );

  					gl.bindBuffer( 34962, buffer );

  					gl.vertexAttribPointer( programAttribute, 3, type, false, 12, 0 );

  				} else if ( materialDefaultAttributeValues !== undefined ) {

  					const value = materialDefaultAttributeValues[ name ];

  					if ( value !== undefined ) {

  						switch ( value.length ) {

  							case 2:
  								gl.vertexAttrib2fv( programAttribute, value );
  								break;

  							case 3:
  								gl.vertexAttrib3fv( programAttribute, value );
  								break;

  							case 4:
  								gl.vertexAttrib4fv( programAttribute, value );
  								break;

  							default:
  								gl.vertexAttrib1fv( programAttribute, value );

  						}

  					}

  				}

  			}

  		}

  		disableUnusedAttributes();

  	}

  	function dispose() {

  		reset();

  		for ( const geometryId in bindingStates ) {

  			const programMap = bindingStates[ geometryId ];

  			for ( const programId in programMap ) {

  				const stateMap = programMap[ programId ];

  				for ( const wireframe in stateMap ) {

  					deleteVertexArrayObject( stateMap[ wireframe ].object );

  					delete stateMap[ wireframe ];

  				}

  				delete programMap[ programId ];

  			}

  			delete bindingStates[ geometryId ];

  		}

  	}

  	function releaseStatesOfGeometry( geometry ) {

  		if ( bindingStates[ geometry.id ] === undefined ) return;

  		const programMap = bindingStates[ geometry.id ];

  		for ( const programId in programMap ) {

  			const stateMap = programMap[ programId ];

  			for ( const wireframe in stateMap ) {

  				deleteVertexArrayObject( stateMap[ wireframe ].object );

  				delete stateMap[ wireframe ];

  			}

  			delete programMap[ programId ];

  		}

  		delete bindingStates[ geometry.id ];

  	}

  	function releaseStatesOfProgram( program ) {

  		for ( const geometryId in bindingStates ) {

  			const programMap = bindingStates[ geometryId ];

  			if ( programMap[ program.id ] === undefined ) continue;

  			const stateMap = programMap[ program.id ];

  			for ( const wireframe in stateMap ) {

  				deleteVertexArrayObject( stateMap[ wireframe ].object );

  				delete stateMap[ wireframe ];

  			}

  			delete programMap[ program.id ];

  		}

  	}

  	function reset() {

  		resetDefaultState();

  		if ( currentState === defaultState ) return;

  		currentState = defaultState;
  		bindVertexArrayObject( currentState.object );

  	}

  	// for backward-compatilibity

  	function resetDefaultState() {

  		defaultState.geometry = null;
  		defaultState.program = null;
  		defaultState.wireframe = false;

  	}

  	return {

  		setup: setup,
  		reset: reset,
  		resetDefaultState: resetDefaultState,
  		dispose: dispose,
  		releaseStatesOfGeometry: releaseStatesOfGeometry,
  		releaseStatesOfProgram: releaseStatesOfProgram,

  		initAttributes: initAttributes,
  		enableAttribute: enableAttribute,
  		disableUnusedAttributes: disableUnusedAttributes

  	};

  }

  function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

  	const isWebGL2 = capabilities.isWebGL2;

  	let mode;

  	function setMode( value ) {

  		mode = value;

  	}

  	function render( start, count ) {

  		gl.drawArrays( mode, start, count );

  		info.update( count, mode, 1 );

  	}

  	function renderInstances( start, count, primcount ) {

  		if ( primcount === 0 ) return;

  		let extension, methodName;

  		if ( isWebGL2 ) {

  			extension = gl;
  			methodName = 'drawArraysInstanced';

  		} else {

  			extension = extensions.get( 'ANGLE_instanced_arrays' );
  			methodName = 'drawArraysInstancedANGLE';

  			if ( extension === null ) {

  				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  				return;

  			}

  		}

  		extension[ methodName ]( mode, start, count, primcount );

  		info.update( count, mode, primcount );

  	}

  	//

  	this.setMode = setMode;
  	this.render = render;
  	this.renderInstances = renderInstances;

  }

  function WebGLCapabilities( gl, extensions, parameters ) {

  	let maxAnisotropy;

  	function getMaxAnisotropy() {

  		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

  		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

  			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

  		} else {

  			maxAnisotropy = 0;

  		}

  		return maxAnisotropy;

  	}

  	function getMaxPrecision( precision ) {

  		if ( precision === 'highp' ) {

  			if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
  				gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

  				return 'highp';

  			}

  			precision = 'mediump';

  		}

  		if ( precision === 'mediump' ) {

  			if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
  				gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

  				return 'mediump';

  			}

  		}

  		return 'lowp';

  	}

  	/* eslint-disable no-undef */
  	const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
  		( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
  	/* eslint-enable no-undef */

  	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  	const maxPrecision = getMaxPrecision( precision );

  	if ( maxPrecision !== precision ) {

  		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
  		precision = maxPrecision;

  	}

  	const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );

  	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

  	const maxTextures = gl.getParameter( 34930 );
  	const maxVertexTextures = gl.getParameter( 35660 );
  	const maxTextureSize = gl.getParameter( 3379 );
  	const maxCubemapSize = gl.getParameter( 34076 );

  	const maxAttributes = gl.getParameter( 34921 );
  	const maxVertexUniforms = gl.getParameter( 36347 );
  	const maxVaryings = gl.getParameter( 36348 );
  	const maxFragmentUniforms = gl.getParameter( 36349 );

  	const vertexTextures = maxVertexTextures > 0;
  	const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
  	const floatVertexTextures = vertexTextures && floatFragmentTextures;

  	const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

  	return {

  		isWebGL2: isWebGL2,

  		drawBuffers: drawBuffers,

  		getMaxAnisotropy: getMaxAnisotropy,
  		getMaxPrecision: getMaxPrecision,

  		precision: precision,
  		logarithmicDepthBuffer: logarithmicDepthBuffer,

  		maxTextures: maxTextures,
  		maxVertexTextures: maxVertexTextures,
  		maxTextureSize: maxTextureSize,
  		maxCubemapSize: maxCubemapSize,

  		maxAttributes: maxAttributes,
  		maxVertexUniforms: maxVertexUniforms,
  		maxVaryings: maxVaryings,
  		maxFragmentUniforms: maxFragmentUniforms,

  		vertexTextures: vertexTextures,
  		floatFragmentTextures: floatFragmentTextures,
  		floatVertexTextures: floatVertexTextures,

  		maxSamples: maxSamples

  	};

  }

  function WebGLClipping( properties ) {

  	const scope = this;

  	let globalState = null,
  		numGlobalPlanes = 0,
  		localClippingEnabled = false,
  		renderingShadows = false;

  	const plane = new Plane(),
  		viewNormalMatrix = new Matrix3(),

  		uniform = { value: null, needsUpdate: false };

  	this.uniform = uniform;
  	this.numPlanes = 0;
  	this.numIntersection = 0;

  	this.init = function ( planes, enableLocalClipping, camera ) {

  		const enabled =
  			planes.length !== 0 ||
  			enableLocalClipping ||
  			// enable state of previous frame - the clipping code has to
  			// run another frame in order to reset the state:
  			numGlobalPlanes !== 0 ||
  			localClippingEnabled;

  		localClippingEnabled = enableLocalClipping;

  		globalState = projectPlanes( planes, camera, 0 );
  		numGlobalPlanes = planes.length;

  		return enabled;

  	};

  	this.beginShadows = function () {

  		renderingShadows = true;
  		projectPlanes( null );

  	};

  	this.endShadows = function () {

  		renderingShadows = false;
  		resetGlobalState();

  	};

  	this.setState = function ( material, camera, useCache ) {

  		const planes = material.clippingPlanes,
  			clipIntersection = material.clipIntersection,
  			clipShadows = material.clipShadows;

  		const materialProperties = properties.get( material );

  		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

  			// there's no local clipping

  			if ( renderingShadows ) {

  				// there's no global clipping

  				projectPlanes( null );

  			} else {

  				resetGlobalState();

  			}

  		} else {

  			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
  				lGlobal = nGlobal * 4;

  			let dstArray = materialProperties.clippingState || null;

  			uniform.value = dstArray; // ensure unique state

  			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

  			for ( let i = 0; i !== lGlobal; ++ i ) {

  				dstArray[ i ] = globalState[ i ];

  			}

  			materialProperties.clippingState = dstArray;
  			this.numIntersection = clipIntersection ? this.numPlanes : 0;
  			this.numPlanes += nGlobal;

  		}


  	};

  	function resetGlobalState() {

  		if ( uniform.value !== globalState ) {

  			uniform.value = globalState;
  			uniform.needsUpdate = numGlobalPlanes > 0;

  		}

  		scope.numPlanes = numGlobalPlanes;
  		scope.numIntersection = 0;

  	}

  	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

  		const nPlanes = planes !== null ? planes.length : 0;
  		let dstArray = null;

  		if ( nPlanes !== 0 ) {

  			dstArray = uniform.value;

  			if ( skipTransform !== true || dstArray === null ) {

  				const flatSize = dstOffset + nPlanes * 4,
  					viewMatrix = camera.matrixWorldInverse;

  				viewNormalMatrix.getNormalMatrix( viewMatrix );

  				if ( dstArray === null || dstArray.length < flatSize ) {

  					dstArray = new Float32Array( flatSize );

  				}

  				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

  					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

  					plane.normal.toArray( dstArray, i4 );
  					dstArray[ i4 + 3 ] = plane.constant;

  				}

  			}

  			uniform.value = dstArray;
  			uniform.needsUpdate = true;

  		}

  		scope.numPlanes = nPlanes;
  		scope.numIntersection = 0;

  		return dstArray;

  	}

  }

  function WebGLCubeMaps( renderer ) {

  	let cubemaps = new WeakMap();

  	function mapTextureMapping( texture, mapping ) {

  		if ( mapping === EquirectangularReflectionMapping ) {

  			texture.mapping = CubeReflectionMapping;

  		} else if ( mapping === EquirectangularRefractionMapping ) {

  			texture.mapping = CubeRefractionMapping;

  		}

  		return texture;

  	}

  	function get( texture ) {

  		if ( texture && texture.isTexture ) {

  			const mapping = texture.mapping;

  			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

  				if ( cubemaps.has( texture ) ) {

  					const cubemap = cubemaps.get( texture ).texture;
  					return mapTextureMapping( cubemap, texture.mapping );

  				} else {

  					const image = texture.image;

  					if ( image && image.height > 0 ) {

  						const currentRenderTarget = renderer.getRenderTarget();

  						const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
  						renderTarget.fromEquirectangularTexture( renderer, texture );
  						cubemaps.set( texture, renderTarget );

  						renderer.setRenderTarget( currentRenderTarget );

  						texture.addEventListener( 'dispose', onTextureDispose );

  						return mapTextureMapping( renderTarget.texture, texture.mapping );

  					} else {

  						// image not yet ready. try the conversion next frame

  						return null;

  					}

  				}

  			}

  		}

  		return texture;

  	}

  	function onTextureDispose( event ) {

  		const texture = event.target;

  		texture.removeEventListener( 'dispose', onTextureDispose );

  		const cubemap = cubemaps.get( texture );

  		if ( cubemap !== undefined ) {

  			cubemaps.delete( texture );
  			cubemap.dispose();

  		}

  	}

  	function dispose() {

  		cubemaps = new WeakMap();

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  function WebGLExtensions( gl ) {

  	const extensions = {};

  	function getExtension( name ) {

  		if ( extensions[ name ] !== undefined ) {

  			return extensions[ name ];

  		}

  		let extension;

  		switch ( name ) {

  			case 'WEBGL_depth_texture':
  				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
  				break;

  			case 'EXT_texture_filter_anisotropic':
  				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
  				break;

  			case 'WEBGL_compressed_texture_s3tc':
  				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
  				break;

  			case 'WEBGL_compressed_texture_pvrtc':
  				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
  				break;

  			default:
  				extension = gl.getExtension( name );

  		}

  		extensions[ name ] = extension;

  		return extension;

  	}

  	return {

  		has: function ( name ) {

  			return getExtension( name ) !== null;

  		},

  		init: function ( capabilities ) {

  			if ( capabilities.isWebGL2 ) {

  				getExtension( 'EXT_color_buffer_float' );

  			} else {

  				getExtension( 'WEBGL_depth_texture' );
  				getExtension( 'OES_texture_float' );
  				getExtension( 'OES_texture_half_float' );
  				getExtension( 'OES_texture_half_float_linear' );
  				getExtension( 'OES_standard_derivatives' );
  				getExtension( 'OES_element_index_uint' );
  				getExtension( 'OES_vertex_array_object' );
  				getExtension( 'ANGLE_instanced_arrays' );

  			}

  			getExtension( 'OES_texture_float_linear' );
  			getExtension( 'EXT_color_buffer_half_float' );

  		},

  		get: function ( name ) {

  			const extension = getExtension( name );

  			if ( extension === null ) {

  				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

  			}

  			return extension;

  		}

  	};

  }

  function WebGLGeometries( gl, attributes, info, bindingStates ) {

  	const geometries = {};
  	const wireframeAttributes = new WeakMap();

  	function onGeometryDispose( event ) {

  		const geometry = event.target;

  		if ( geometry.index !== null ) {

  			attributes.remove( geometry.index );

  		}

  		for ( const name in geometry.attributes ) {

  			attributes.remove( geometry.attributes[ name ] );

  		}

  		geometry.removeEventListener( 'dispose', onGeometryDispose );

  		delete geometries[ geometry.id ];

  		const attribute = wireframeAttributes.get( geometry );

  		if ( attribute ) {

  			attributes.remove( attribute );
  			wireframeAttributes.delete( geometry );

  		}

  		bindingStates.releaseStatesOfGeometry( geometry );

  		if ( geometry.isInstancedBufferGeometry === true ) {

  			delete geometry._maxInstanceCount;

  		}

  		//

  		info.memory.geometries --;

  	}

  	function get( object, geometry ) {

  		if ( geometries[ geometry.id ] === true ) return geometry;

  		geometry.addEventListener( 'dispose', onGeometryDispose );

  		geometries[ geometry.id ] = true;

  		info.memory.geometries ++;

  		return geometry;

  	}

  	function update( geometry ) {

  		const geometryAttributes = geometry.attributes;

  		// Updating index buffer in VAO now. See WebGLBindingStates.

  		for ( const name in geometryAttributes ) {

  			attributes.update( geometryAttributes[ name ], 34962 );

  		}

  		// morph targets

  		const morphAttributes = geometry.morphAttributes;

  		for ( const name in morphAttributes ) {

  			const array = morphAttributes[ name ];

  			for ( let i = 0, l = array.length; i < l; i ++ ) {

  				attributes.update( array[ i ], 34962 );

  			}

  		}

  	}

  	function updateWireframeAttribute( geometry ) {

  		const indices = [];

  		const geometryIndex = geometry.index;
  		const geometryPosition = geometry.attributes.position;
  		let version = 0;

  		if ( geometryIndex !== null ) {

  			const array = geometryIndex.array;
  			version = geometryIndex.version;

  			for ( let i = 0, l = array.length; i < l; i += 3 ) {

  				const a = array[ i + 0 ];
  				const b = array[ i + 1 ];
  				const c = array[ i + 2 ];

  				indices.push( a, b, b, c, c, a );

  			}

  		} else {

  			const array = geometryPosition.array;
  			version = geometryPosition.version;

  			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

  				const a = i + 0;
  				const b = i + 1;
  				const c = i + 2;

  				indices.push( a, b, b, c, c, a );

  			}

  		}

  		const attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
  		attribute.version = version;

  		// Updating index buffer in VAO now. See WebGLBindingStates

  		//

  		const previousAttribute = wireframeAttributes.get( geometry );

  		if ( previousAttribute ) attributes.remove( previousAttribute );

  		//

  		wireframeAttributes.set( geometry, attribute );

  	}

  	function getWireframeAttribute( geometry ) {

  		const currentAttribute = wireframeAttributes.get( geometry );

  		if ( currentAttribute ) {

  			const geometryIndex = geometry.index;

  			if ( geometryIndex !== null ) {

  				// if the attribute is obsolete, create a new one

  				if ( currentAttribute.version < geometryIndex.version ) {

  					updateWireframeAttribute( geometry );

  				}

  			}

  		} else {

  			updateWireframeAttribute( geometry );

  		}

  		return wireframeAttributes.get( geometry );

  	}

  	return {

  		get: get,
  		update: update,

  		getWireframeAttribute: getWireframeAttribute

  	};

  }

  function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

  	const isWebGL2 = capabilities.isWebGL2;

  	let mode;

  	function setMode( value ) {

  		mode = value;

  	}

  	let type, bytesPerElement;

  	function setIndex( value ) {

  		type = value.type;
  		bytesPerElement = value.bytesPerElement;

  	}

  	function render( start, count ) {

  		gl.drawElements( mode, count, type, start * bytesPerElement );

  		info.update( count, mode, 1 );

  	}

  	function renderInstances( start, count, primcount ) {

  		if ( primcount === 0 ) return;

  		let extension, methodName;

  		if ( isWebGL2 ) {

  			extension = gl;
  			methodName = 'drawElementsInstanced';

  		} else {

  			extension = extensions.get( 'ANGLE_instanced_arrays' );
  			methodName = 'drawElementsInstancedANGLE';

  			if ( extension === null ) {

  				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  				return;

  			}

  		}

  		extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

  		info.update( count, mode, primcount );

  	}

  	//

  	this.setMode = setMode;
  	this.setIndex = setIndex;
  	this.render = render;
  	this.renderInstances = renderInstances;

  }

  function WebGLInfo( gl ) {

  	const memory = {
  		geometries: 0,
  		textures: 0
  	};

  	const render = {
  		frame: 0,
  		calls: 0,
  		triangles: 0,
  		points: 0,
  		lines: 0
  	};

  	function update( count, mode, instanceCount ) {

  		render.calls ++;

  		switch ( mode ) {

  			case 4:
  				render.triangles += instanceCount * ( count / 3 );
  				break;

  			case 1:
  				render.lines += instanceCount * ( count / 2 );
  				break;

  			case 3:
  				render.lines += instanceCount * ( count - 1 );
  				break;

  			case 2:
  				render.lines += instanceCount * count;
  				break;

  			case 0:
  				render.points += instanceCount * count;
  				break;

  			default:
  				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
  				break;

  		}

  	}

  	function reset() {

  		render.frame ++;
  		render.calls = 0;
  		render.triangles = 0;
  		render.points = 0;
  		render.lines = 0;

  	}

  	return {
  		memory: memory,
  		render: render,
  		programs: null,
  		autoReset: true,
  		reset: reset,
  		update: update
  	};

  }

  function numericalSort( a, b ) {

  	return a[ 0 ] - b[ 0 ];

  }

  function absNumericalSort( a, b ) {

  	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

  }

  function WebGLMorphtargets( gl ) {

  	const influencesList = {};
  	const morphInfluences = new Float32Array( 8 );

  	const workInfluences = [];

  	for ( let i = 0; i < 8; i ++ ) {

  		workInfluences[ i ] = [ i, 0 ];

  	}

  	function update( object, geometry, material, program ) {

  		const objectInfluences = object.morphTargetInfluences;

  		// When object doesn't have morph target influences defined, we treat it as a 0-length array
  		// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

  		const length = objectInfluences === undefined ? 0 : objectInfluences.length;

  		let influences = influencesList[ geometry.id ];

  		if ( influences === undefined ) {

  			// initialise list

  			influences = [];

  			for ( let i = 0; i < length; i ++ ) {

  				influences[ i ] = [ i, 0 ];

  			}

  			influencesList[ geometry.id ] = influences;

  		}

  		// Collect influences

  		for ( let i = 0; i < length; i ++ ) {

  			const influence = influences[ i ];

  			influence[ 0 ] = i;
  			influence[ 1 ] = objectInfluences[ i ];

  		}

  		influences.sort( absNumericalSort );

  		for ( let i = 0; i < 8; i ++ ) {

  			if ( i < length && influences[ i ][ 1 ] ) {

  				workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
  				workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

  			} else {

  				workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
  				workInfluences[ i ][ 1 ] = 0;

  			}

  		}

  		workInfluences.sort( numericalSort );

  		const morphTargets = material.morphTargets && geometry.morphAttributes.position;
  		const morphNormals = material.morphNormals && geometry.morphAttributes.normal;

  		let morphInfluencesSum = 0;

  		for ( let i = 0; i < 8; i ++ ) {

  			const influence = workInfluences[ i ];
  			const index = influence[ 0 ];
  			const value = influence[ 1 ];

  			if ( index !== Number.MAX_SAFE_INTEGER && value ) {

  				if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

  					geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

  				}

  				if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

  					geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

  				}

  				morphInfluences[ i ] = value;
  				morphInfluencesSum += value;

  			} else {

  				if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

  					geometry.deleteAttribute( 'morphTarget' + i );

  				}

  				if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

  					geometry.deleteAttribute( 'morphNormal' + i );

  				}

  				morphInfluences[ i ] = 0;

  			}

  		}

  		// GLSL shader uses formula baseinfluence * base + sum(target * influence)
  		// This allows us to switch between absolute morphs and relative morphs without changing shader code
  		// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
  		const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

  		program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
  		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

  	}

  	return {

  		update: update

  	};

  }

  function WebGLObjects( gl, geometries, attributes, info ) {

  	let updateMap = new WeakMap();

  	function update( object ) {

  		const frame = info.render.frame;

  		const geometry = object.geometry;
  		const buffergeometry = geometries.get( object, geometry );

  		// Update once per frame

  		if ( updateMap.get( buffergeometry ) !== frame ) {

  			geometries.update( buffergeometry );

  			updateMap.set( buffergeometry, frame );

  		}

  		if ( object.isInstancedMesh ) {

  			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

  				object.addEventListener( 'dispose', onInstancedMeshDispose );

  			}

  			attributes.update( object.instanceMatrix, 34962 );

  			if ( object.instanceColor !== null ) {

  				attributes.update( object.instanceColor, 34962 );

  			}

  		}

  		return buffergeometry;

  	}

  	function dispose() {

  		updateMap = new WeakMap();

  	}

  	function onInstancedMeshDispose( event ) {

  		const instancedMesh = event.target;

  		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

  		attributes.remove( instancedMesh.instanceMatrix );

  		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

  	}

  	return {

  		update: update,
  		dispose: dispose

  	};

  }

  class DataTexture2DArray extends Texture {

  	constructor( data = null, width = 1, height = 1, depth = 1 ) {

  		super( null );

  		this.image = { data, width, height, depth };

  		this.magFilter = NearestFilter;
  		this.minFilter = NearestFilter;

  		this.wrapR = ClampToEdgeWrapping;

  		this.generateMipmaps = false;
  		this.flipY = false;
  		this.unpackAlignment = 1;

  		this.needsUpdate = true;

  	}

  }

  DataTexture2DArray.prototype.isDataTexture2DArray = true;

  class DataTexture3D extends Texture {

  	constructor( data = null, width = 1, height = 1, depth = 1 ) {

  		// We're going to add .setXXX() methods for setting properties later.
  		// Users can still set in DataTexture3D directly.
  		//
  		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
  		// 	texture.anisotropy = 16;
  		//
  		// See #14839

  		super( null );

  		this.image = { data, width, height, depth };

  		this.magFilter = NearestFilter;
  		this.minFilter = NearestFilter;

  		this.wrapR = ClampToEdgeWrapping;

  		this.generateMipmaps = false;
  		this.flipY = false;
  		this.unpackAlignment = 1;

  		this.needsUpdate = true;

  	}

  }

  DataTexture3D.prototype.isDataTexture3D = true;

  /**
   * Uniforms of a program.
   * Those form a tree structure with a special top-level container for the root,
   * which you get by calling 'new WebGLUniforms( gl, program )'.
   *
   *
   * Properties of inner nodes including the top-level container:
   *
   * .seq - array of nested uniforms
   * .map - nested uniforms by name
   *
   *
   * Methods of all nodes except the top-level container:
   *
   * .setValue( gl, value, [textures] )
   *
   * 		uploads a uniform value(s)
   *  	the 'textures' parameter is needed for sampler uniforms
   *
   *
   * Static methods of the top-level container (textures factorizations):
   *
   * .upload( gl, seq, values, textures )
   *
   * 		sets uniforms in 'seq' to 'values[id].value'
   *
   * .seqWithValue( seq, values ) : filteredSeq
   *
   * 		filters 'seq' entries with corresponding entry in values
   *
   *
   * Methods of the top-level container (textures factorizations):
   *
   * .setValue( gl, name, value, textures )
   *
   * 		sets uniform with  name 'name' to 'value'
   *
   * .setOptional( gl, obj, prop )
   *
   * 		like .set for an optional property of the object
   *
   */

  const emptyTexture = new Texture();
  const emptyTexture2dArray = new DataTexture2DArray();
  const emptyTexture3d = new DataTexture3D();
  const emptyCubeTexture = new CubeTexture();

  // --- Utilities ---

  // Array Caches (provide typed arrays for temporary by size)

  const arrayCacheF32 = [];
  const arrayCacheI32 = [];

  // Float32Array caches used for uploading Matrix uniforms

  const mat4array = new Float32Array( 16 );
  const mat3array = new Float32Array( 9 );
  const mat2array = new Float32Array( 4 );

  // Flattening for arrays of vectors and matrices

  function flatten( array, nBlocks, blockSize ) {

  	const firstElem = array[ 0 ];

  	if ( firstElem <= 0 || firstElem > 0 ) return array;
  	// unoptimized: ! isNaN( firstElem )
  	// see http://jacksondunstan.com/articles/983

  	const n = nBlocks * blockSize;
  	let r = arrayCacheF32[ n ];

  	if ( r === undefined ) {

  		r = new Float32Array( n );
  		arrayCacheF32[ n ] = r;

  	}

  	if ( nBlocks !== 0 ) {

  		firstElem.toArray( r, 0 );

  		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

  			offset += blockSize;
  			array[ i ].toArray( r, offset );

  		}

  	}

  	return r;

  }

  function arraysEqual( a, b ) {

  	if ( a.length !== b.length ) return false;

  	for ( let i = 0, l = a.length; i < l; i ++ ) {

  		if ( a[ i ] !== b[ i ] ) return false;

  	}

  	return true;

  }

  function copyArray( a, b ) {

  	for ( let i = 0, l = b.length; i < l; i ++ ) {

  		a[ i ] = b[ i ];

  	}

  }

  // Texture unit allocation

  function allocTexUnits( textures, n ) {

  	let r = arrayCacheI32[ n ];

  	if ( r === undefined ) {

  		r = new Int32Array( n );
  		arrayCacheI32[ n ] = r;

  	}

  	for ( let i = 0; i !== n; ++ i ) {

  		r[ i ] = textures.allocateTextureUnit();

  	}

  	return r;

  }

  // --- Setters ---

  // Note: Defining these methods externally, because they come in a bunch
  // and this way their names minify.

  // Single scalar

  function setValueV1f( gl, v ) {

  	const cache = this.cache;

  	if ( cache[ 0 ] === v ) return;

  	gl.uniform1f( this.addr, v );

  	cache[ 0 ] = v;

  }

  // Single float vector (from flat array or THREE.VectorN)

  function setValueV2f( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

  			gl.uniform2f( this.addr, v.x, v.y );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform2fv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV3f( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

  			gl.uniform3f( this.addr, v.x, v.y, v.z );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;

  		}

  	} else if ( v.r !== undefined ) {

  		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

  			gl.uniform3f( this.addr, v.r, v.g, v.b );

  			cache[ 0 ] = v.r;
  			cache[ 1 ] = v.g;
  			cache[ 2 ] = v.b;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform3fv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV4f( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

  			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;
  			cache[ 3 ] = v.w;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform4fv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  // Single matrix (from flat array or THREE.MatrixN)

  function setValueM2( gl, v ) {

  	const cache = this.cache;
  	const elements = v.elements;

  	if ( elements === undefined ) {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniformMatrix2fv( this.addr, false, v );

  		copyArray( cache, v );

  	} else {

  		if ( arraysEqual( cache, elements ) ) return;

  		mat2array.set( elements );

  		gl.uniformMatrix2fv( this.addr, false, mat2array );

  		copyArray( cache, elements );

  	}

  }

  function setValueM3( gl, v ) {

  	const cache = this.cache;
  	const elements = v.elements;

  	if ( elements === undefined ) {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniformMatrix3fv( this.addr, false, v );

  		copyArray( cache, v );

  	} else {

  		if ( arraysEqual( cache, elements ) ) return;

  		mat3array.set( elements );

  		gl.uniformMatrix3fv( this.addr, false, mat3array );

  		copyArray( cache, elements );

  	}

  }

  function setValueM4( gl, v ) {

  	const cache = this.cache;
  	const elements = v.elements;

  	if ( elements === undefined ) {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniformMatrix4fv( this.addr, false, v );

  		copyArray( cache, v );

  	} else {

  		if ( arraysEqual( cache, elements ) ) return;

  		mat4array.set( elements );

  		gl.uniformMatrix4fv( this.addr, false, mat4array );

  		copyArray( cache, elements );

  	}

  }

  // Single integer / boolean

  function setValueV1i( gl, v ) {

  	const cache = this.cache;

  	if ( cache[ 0 ] === v ) return;

  	gl.uniform1i( this.addr, v );

  	cache[ 0 ] = v;

  }

  // Single integer / boolean vector (from flat array)

  function setValueV2i( gl, v ) {

  	const cache = this.cache;

  	if ( arraysEqual( cache, v ) ) return;

  	gl.uniform2iv( this.addr, v );

  	copyArray( cache, v );

  }

  function setValueV3i( gl, v ) {

  	const cache = this.cache;

  	if ( arraysEqual( cache, v ) ) return;

  	gl.uniform3iv( this.addr, v );

  	copyArray( cache, v );

  }

  function setValueV4i( gl, v ) {

  	const cache = this.cache;

  	if ( arraysEqual( cache, v ) ) return;

  	gl.uniform4iv( this.addr, v );

  	copyArray( cache, v );

  }

  // Single unsigned integer

  function setValueV1ui( gl, v ) {

  	const cache = this.cache;

  	if ( cache[ 0 ] === v ) return;

  	gl.uniform1ui( this.addr, v );

  	cache[ 0 ] = v;

  }

  // Single unsigned integer vector (from flat array)

  function setValueV2ui( gl, v ) {

  	const cache = this.cache;

  	if ( arraysEqual( cache, v ) ) return;

  	gl.uniform2uiv( this.addr, v );

  	copyArray( cache, v );

  }

  function setValueV3ui( gl, v ) {

  	const cache = this.cache;

  	if ( arraysEqual( cache, v ) ) return;

  	gl.uniform3uiv( this.addr, v );

  	copyArray( cache, v );

  }

  function setValueV4ui( gl, v ) {

  	const cache = this.cache;

  	if ( arraysEqual( cache, v ) ) return;

  	gl.uniform4uiv( this.addr, v );

  	copyArray( cache, v );

  }


  // Single texture (2D / Cube)

  function setValueT1( gl, v, textures ) {

  	const cache = this.cache;
  	const unit = textures.allocateTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	textures.safeSetTexture2D( v || emptyTexture, unit );

  }

  function setValueT3D1( gl, v, textures ) {

  	const cache = this.cache;
  	const unit = textures.allocateTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	textures.setTexture3D( v || emptyTexture3d, unit );

  }

  function setValueT6( gl, v, textures ) {

  	const cache = this.cache;
  	const unit = textures.allocateTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	textures.safeSetTextureCube( v || emptyCubeTexture, unit );

  }

  function setValueT2DArray1( gl, v, textures ) {

  	const cache = this.cache;
  	const unit = textures.allocateTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	textures.setTexture2DArray( v || emptyTexture2dArray, unit );

  }

  // Helper to pick the right setter for the singular case

  function getSingularSetter( type ) {

  	switch ( type ) {

  		case 0x1406: return setValueV1f; // FLOAT
  		case 0x8b50: return setValueV2f; // _VEC2
  		case 0x8b51: return setValueV3f; // _VEC3
  		case 0x8b52: return setValueV4f; // _VEC4

  		case 0x8b5a: return setValueM2; // _MAT2
  		case 0x8b5b: return setValueM3; // _MAT3
  		case 0x8b5c: return setValueM4; // _MAT4

  		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
  		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
  		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
  		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

  		case 0x1405: return setValueV1ui; // UINT
  		case 0x8dc6: return setValueV2ui; // _VEC2
  		case 0x8dc7: return setValueV3ui; // _VEC3
  		case 0x8dc8: return setValueV4ui; // _VEC4

  		case 0x8b5e: // SAMPLER_2D
  		case 0x8d66: // SAMPLER_EXTERNAL_OES
  		case 0x8dca: // INT_SAMPLER_2D
  		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
  		case 0x8b62: // SAMPLER_2D_SHADOW
  			return setValueT1;

  		case 0x8b5f: // SAMPLER_3D
  		case 0x8dcb: // INT_SAMPLER_3D
  		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
  			return setValueT3D1;

  		case 0x8b60: // SAMPLER_CUBE
  		case 0x8dcc: // INT_SAMPLER_CUBE
  		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
  		case 0x8dc5: // SAMPLER_CUBE_SHADOW
  			return setValueT6;

  		case 0x8dc1: // SAMPLER_2D_ARRAY
  		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
  		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
  		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
  			return setValueT2DArray1;

  	}

  }


  // Array of scalars

  function setValueV1fArray( gl, v ) {

  	gl.uniform1fv( this.addr, v );

  }

  // Array of vectors (from flat array or array of THREE.VectorN)

  function setValueV2fArray( gl, v ) {

  	const data = flatten( v, this.size, 2 );

  	gl.uniform2fv( this.addr, data );

  }

  function setValueV3fArray( gl, v ) {

  	const data = flatten( v, this.size, 3 );

  	gl.uniform3fv( this.addr, data );

  }

  function setValueV4fArray( gl, v ) {

  	const data = flatten( v, this.size, 4 );

  	gl.uniform4fv( this.addr, data );

  }

  // Array of matrices (from flat array or array of THREE.MatrixN)

  function setValueM2Array( gl, v ) {

  	const data = flatten( v, this.size, 4 );

  	gl.uniformMatrix2fv( this.addr, false, data );

  }

  function setValueM3Array( gl, v ) {

  	const data = flatten( v, this.size, 9 );

  	gl.uniformMatrix3fv( this.addr, false, data );

  }

  function setValueM4Array( gl, v ) {

  	const data = flatten( v, this.size, 16 );

  	gl.uniformMatrix4fv( this.addr, false, data );

  }

  // Array of integer / boolean

  function setValueV1iArray( gl, v ) {

  	gl.uniform1iv( this.addr, v );

  }

  // Array of integer / boolean vectors (from flat array)

  function setValueV2iArray( gl, v ) {

  	gl.uniform2iv( this.addr, v );

  }

  function setValueV3iArray( gl, v ) {

  	gl.uniform3iv( this.addr, v );

  }

  function setValueV4iArray( gl, v ) {

  	gl.uniform4iv( this.addr, v );

  }

  // Array of unsigned integer

  function setValueV1uiArray( gl, v ) {

  	gl.uniform1uiv( this.addr, v );

  }

  // Array of unsigned integer vectors (from flat array)

  function setValueV2uiArray( gl, v ) {

  	gl.uniform2uiv( this.addr, v );

  }

  function setValueV3uiArray( gl, v ) {

  	gl.uniform3uiv( this.addr, v );

  }

  function setValueV4uiArray( gl, v ) {

  	gl.uniform4uiv( this.addr, v );

  }


  // Array of textures (2D / Cube)

  function setValueT1Array( gl, v, textures ) {

  	const n = v.length;

  	const units = allocTexUnits( textures, n );

  	gl.uniform1iv( this.addr, units );

  	for ( let i = 0; i !== n; ++ i ) {

  		textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

  	}

  }

  function setValueT6Array( gl, v, textures ) {

  	const n = v.length;

  	const units = allocTexUnits( textures, n );

  	gl.uniform1iv( this.addr, units );

  	for ( let i = 0; i !== n; ++ i ) {

  		textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

  	}

  }

  // Helper to pick the right setter for a pure (bottom-level) array

  function getPureArraySetter( type ) {

  	switch ( type ) {

  		case 0x1406: return setValueV1fArray; // FLOAT
  		case 0x8b50: return setValueV2fArray; // _VEC2
  		case 0x8b51: return setValueV3fArray; // _VEC3
  		case 0x8b52: return setValueV4fArray; // _VEC4

  		case 0x8b5a: return setValueM2Array; // _MAT2
  		case 0x8b5b: return setValueM3Array; // _MAT3
  		case 0x8b5c: return setValueM4Array; // _MAT4

  		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
  		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
  		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
  		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

  		case 0x1405: return setValueV1uiArray; // UINT
  		case 0x8dc6: return setValueV2uiArray; // _VEC2
  		case 0x8dc7: return setValueV3uiArray; // _VEC3
  		case 0x8dc8: return setValueV4uiArray; // _VEC4

  		case 0x8b5e: // SAMPLER_2D
  		case 0x8d66: // SAMPLER_EXTERNAL_OES
  		case 0x8dca: // INT_SAMPLER_2D
  		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
  		case 0x8b62: // SAMPLER_2D_SHADOW
  			return setValueT1Array;

  		case 0x8b60: // SAMPLER_CUBE
  		case 0x8dcc: // INT_SAMPLER_CUBE
  		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
  		case 0x8dc5: // SAMPLER_CUBE_SHADOW
  			return setValueT6Array;

  	}

  }

  // --- Uniform Classes ---

  function SingleUniform( id, activeInfo, addr ) {

  	this.id = id;
  	this.addr = addr;
  	this.cache = [];
  	this.setValue = getSingularSetter( activeInfo.type );

  	// this.path = activeInfo.name; // DEBUG

  }

  function PureArrayUniform( id, activeInfo, addr ) {

  	this.id = id;
  	this.addr = addr;
  	this.cache = [];
  	this.size = activeInfo.size;
  	this.setValue = getPureArraySetter( activeInfo.type );

  	// this.path = activeInfo.name; // DEBUG

  }

  PureArrayUniform.prototype.updateCache = function ( data ) {

  	const cache = this.cache;

  	if ( data instanceof Float32Array && cache.length !== data.length ) {

  		this.cache = new Float32Array( data.length );

  	}

  	copyArray( cache, data );

  };

  function StructuredUniform( id ) {

  	this.id = id;

  	this.seq = [];
  	this.map = {};

  }

  StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

  	const seq = this.seq;

  	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

  		const u = seq[ i ];
  		u.setValue( gl, value[ u.id ], textures );

  	}

  };

  // --- Top-level ---

  // Parser - builds up the property tree from the path strings

  const RePathPart = /(\w+)(\])?(\[|\.)?/g;

  // extracts
  // 	- the identifier (member name or array index)
  //  - followed by an optional right bracket (found when array index)
  //  - followed by an optional left bracket or dot (type of subscript)
  //
  // Note: These portions can be read in a non-overlapping fashion and
  // allow straightforward parsing of the hierarchy that WebGL encodes
  // in the uniform names.

  function addUniform( container, uniformObject ) {

  	container.seq.push( uniformObject );
  	container.map[ uniformObject.id ] = uniformObject;

  }

  function parseUniform( activeInfo, addr, container ) {

  	const path = activeInfo.name,
  		pathLength = path.length;

  	// reset RegExp object, because of the early exit of a previous run
  	RePathPart.lastIndex = 0;

  	while ( true ) {

  		const match = RePathPart.exec( path ),
  			matchEnd = RePathPart.lastIndex;

  		let id = match[ 1 ];
  		const idIsIndex = match[ 2 ] === ']',
  			subscript = match[ 3 ];

  		if ( idIsIndex ) id = id | 0; // convert to integer

  		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

  			// bare name or "pure" bottom-level array "[0]" suffix

  			addUniform( container, subscript === undefined ?
  				new SingleUniform( id, activeInfo, addr ) :
  				new PureArrayUniform( id, activeInfo, addr ) );

  			break;

  		} else {

  			// step into inner node / create it in case it doesn't exist

  			const map = container.map;
  			let next = map[ id ];

  			if ( next === undefined ) {

  				next = new StructuredUniform( id );
  				addUniform( container, next );

  			}

  			container = next;

  		}

  	}

  }

  // Root Container

  function WebGLUniforms( gl, program ) {

  	this.seq = [];
  	this.map = {};

  	const n = gl.getProgramParameter( program, 35718 );

  	for ( let i = 0; i < n; ++ i ) {

  		const info = gl.getActiveUniform( program, i ),
  			addr = gl.getUniformLocation( program, info.name );

  		parseUniform( info, addr, this );

  	}

  }

  WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

  	const u = this.map[ name ];

  	if ( u !== undefined ) u.setValue( gl, value, textures );

  };

  WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

  	const v = object[ name ];

  	if ( v !== undefined ) this.setValue( gl, name, v );

  };


  // Static interface

  WebGLUniforms.upload = function ( gl, seq, values, textures ) {

  	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

  		const u = seq[ i ],
  			v = values[ u.id ];

  		if ( v.needsUpdate !== false ) {

  			// note: always updating when .needsUpdate is undefined
  			u.setValue( gl, v.value, textures );

  		}

  	}

  };

  WebGLUniforms.seqWithValue = function ( seq, values ) {

  	const r = [];

  	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

  		const u = seq[ i ];
  		if ( u.id in values ) r.push( u );

  	}

  	return r;

  };

  function WebGLShader( gl, type, string ) {

  	const shader = gl.createShader( type );

  	gl.shaderSource( shader, string );
  	gl.compileShader( shader );

  	return shader;

  }

  let programIdCount = 0;

  function addLineNumbers( string ) {

  	const lines = string.split( '\n' );

  	for ( let i = 0; i < lines.length; i ++ ) {

  		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

  	}

  	return lines.join( '\n' );

  }

  function getEncodingComponents( encoding ) {

  	switch ( encoding ) {

  		case LinearEncoding:
  			return [ 'Linear', '( value )' ];
  		case sRGBEncoding:
  			return [ 'sRGB', '( value )' ];
  		case RGBEEncoding:
  			return [ 'RGBE', '( value )' ];
  		case RGBM7Encoding:
  			return [ 'RGBM', '( value, 7.0 )' ];
  		case RGBM16Encoding:
  			return [ 'RGBM', '( value, 16.0 )' ];
  		case RGBDEncoding:
  			return [ 'RGBD', '( value, 256.0 )' ];
  		case GammaEncoding:
  			return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
  		case LogLuvEncoding:
  			return [ 'LogLuv', '( value )' ];
  		default:
  			console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
  			return [ 'Linear', '( value )' ];

  	}

  }

  function getShaderErrors( gl, shader, type ) {

  	const status = gl.getShaderParameter( shader, 35713 );
  	const log = gl.getShaderInfoLog( shader ).trim();

  	if ( status && log === '' ) return '';

  	// --enable-privileged-webgl-extension
  	// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  	const source = gl.getShaderSource( shader );

  	return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

  }

  function getTexelDecodingFunction( functionName, encoding ) {

  	const components = getEncodingComponents( encoding );
  	return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

  }

  function getTexelEncodingFunction( functionName, encoding ) {

  	const components = getEncodingComponents( encoding );
  	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

  }

  function getToneMappingFunction( functionName, toneMapping ) {

  	let toneMappingName;

  	switch ( toneMapping ) {

  		case LinearToneMapping:
  			toneMappingName = 'Linear';
  			break;

  		case ReinhardToneMapping:
  			toneMappingName = 'Reinhard';
  			break;

  		case CineonToneMapping:
  			toneMappingName = 'OptimizedCineon';
  			break;

  		case ACESFilmicToneMapping:
  			toneMappingName = 'ACESFilmic';
  			break;

  		case CustomToneMapping:
  			toneMappingName = 'Custom';
  			break;

  		default:
  			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
  			toneMappingName = 'Linear';

  	}

  	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

  }

  function generateExtensions( parameters ) {

  	const chunks = [
  		( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
  		( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
  		( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
  		( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0 ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
  	];

  	return chunks.filter( filterEmptyLine ).join( '\n' );

  }

  function generateDefines( defines ) {

  	const chunks = [];

  	for ( const name in defines ) {

  		const value = defines[ name ];

  		if ( value === false ) continue;

  		chunks.push( '#define ' + name + ' ' + value );

  	}

  	return chunks.join( '\n' );

  }

  function fetchAttributeLocations( gl, program ) {

  	const attributes = {};

  	const n = gl.getProgramParameter( program, 35721 );

  	for ( let i = 0; i < n; i ++ ) {

  		const info = gl.getActiveAttrib( program, i );
  		const name = info.name;

  		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

  		attributes[ name ] = gl.getAttribLocation( program, name );

  	}

  	return attributes;

  }

  function filterEmptyLine( string ) {

  	return string !== '';

  }

  function replaceLightNums( string, parameters ) {

  	return string
  		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
  		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
  		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
  		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
  		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
  		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
  		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
  		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

  }

  function replaceClippingPlaneNums( string, parameters ) {

  	return string
  		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
  		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

  }

  // Resolve Includes

  const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

  function resolveIncludes( string ) {

  	return string.replace( includePattern, includeReplacer );

  }

  function includeReplacer( match, include ) {

  	const string = ShaderChunk[ include ];

  	if ( string === undefined ) {

  		throw new Error( 'Can not resolve #include <' + include + '>' );

  	}

  	return resolveIncludes( string );

  }

  // Unroll Loops

  const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

  function unrollLoops( string ) {

  	return string
  		.replace( unrollLoopPattern, loopReplacer )
  		.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

  }

  function deprecatedLoopReplacer( match, start, end, snippet ) {

  	console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
  	return loopReplacer( match, start, end, snippet );

  }

  function loopReplacer( match, start, end, snippet ) {

  	let string = '';

  	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

  		string += snippet
  			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
  			.replace( /UNROLLED_LOOP_INDEX/g, i );

  	}

  	return string;

  }

  //

  function generatePrecision( parameters ) {

  	let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

  	if ( parameters.precision === 'highp' ) {

  		precisionstring += '\n#define HIGH_PRECISION';

  	} else if ( parameters.precision === 'mediump' ) {

  		precisionstring += '\n#define MEDIUM_PRECISION';

  	} else if ( parameters.precision === 'lowp' ) {

  		precisionstring += '\n#define LOW_PRECISION';

  	}

  	return precisionstring;

  }

  function generateShadowMapTypeDefine( parameters ) {

  	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  	if ( parameters.shadowMapType === PCFShadowMap ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

  	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

  	} else if ( parameters.shadowMapType === VSMShadowMap ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

  	}

  	return shadowMapTypeDefine;

  }

  function generateEnvMapTypeDefine( parameters ) {

  	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

  	if ( parameters.envMap ) {

  		switch ( parameters.envMapMode ) {

  			case CubeReflectionMapping:
  			case CubeRefractionMapping:
  				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  				break;

  			case CubeUVReflectionMapping:
  			case CubeUVRefractionMapping:
  				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
  				break;

  		}

  	}

  	return envMapTypeDefine;

  }

  function generateEnvMapModeDefine( parameters ) {

  	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

  	if ( parameters.envMap ) {

  		switch ( parameters.envMapMode ) {

  			case CubeRefractionMapping:
  			case CubeUVRefractionMapping:

  				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
  				break;

  		}

  	}

  	return envMapModeDefine;

  }

  function generateEnvMapBlendingDefine( parameters ) {

  	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

  	if ( parameters.envMap ) {

  		switch ( parameters.combine ) {

  			case MultiplyOperation:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
  				break;

  			case MixOperation:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
  				break;

  			case AddOperation:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
  				break;

  		}

  	}

  	return envMapBlendingDefine;

  }

  function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

  	const gl = renderer.getContext();

  	const defines = parameters.defines;

  	let vertexShader = parameters.vertexShader;
  	let fragmentShader = parameters.fragmentShader;

  	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
  	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
  	const envMapModeDefine = generateEnvMapModeDefine( parameters );
  	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


  	const gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

  	const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

  	const customDefines = generateDefines( defines );

  	const program = gl.createProgram();

  	let prefixVertex, prefixFragment;
  	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

  	if ( parameters.isRawShaderMaterial ) {

  		prefixVertex = [

  			customDefines

  		].filter( filterEmptyLine ).join( '\n' );

  		if ( prefixVertex.length > 0 ) {

  			prefixVertex += '\n';

  		}

  		prefixFragment = [

  			customExtensions,
  			customDefines

  		].filter( filterEmptyLine ).join( '\n' );

  		if ( prefixFragment.length > 0 ) {

  			prefixFragment += '\n';

  		}

  	} else {

  		prefixVertex = [

  			generatePrecision( parameters ),

  			'#define SHADER_NAME ' + parameters.shaderName,

  			customDefines,

  			parameters.instancing ? '#define USE_INSTANCING' : '',
  			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

  			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

  			'#define GAMMA_FACTOR ' + gammaFactorDefine,

  			'#define MAX_BONES ' + parameters.maxBones,
  			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
  			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

  			parameters.map ? '#define USE_MAP' : '',
  			parameters.envMap ? '#define USE_ENVMAP' : '',
  			parameters.envMap ? '#define ' + envMapModeDefine : '',
  			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  			parameters.aoMap ? '#define USE_AOMAP' : '',
  			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
  			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  			parameters.normalMap ? '#define USE_NORMALMAP' : '',
  			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
  			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

  			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
  			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
  			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
  			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
  			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
  			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
  			parameters.transmission ? '#define USE_TRANSMISSION' : '',
  			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
  			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

  			parameters.vertexTangents ? '#define USE_TANGENT' : '',
  			parameters.vertexColors ? '#define USE_COLOR' : '',
  			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
  			parameters.vertexUvs ? '#define USE_UV' : '',
  			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

  			parameters.flatShading ? '#define FLAT_SHADED' : '',

  			parameters.skinning ? '#define USE_SKINNING' : '',
  			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

  			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
  			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
  			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  			parameters.flipSided ? '#define FLIP_SIDED' : '',

  			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

  			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
  			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

  			'uniform mat4 modelMatrix;',
  			'uniform mat4 modelViewMatrix;',
  			'uniform mat4 projectionMatrix;',
  			'uniform mat4 viewMatrix;',
  			'uniform mat3 normalMatrix;',
  			'uniform vec3 cameraPosition;',
  			'uniform bool isOrthographic;',

  			'#ifdef USE_INSTANCING',

  			'	attribute mat4 instanceMatrix;',

  			'#endif',

  			'#ifdef USE_INSTANCING_COLOR',

  			'	attribute vec3 instanceColor;',

  			'#endif',

  			'attribute vec3 position;',
  			'attribute vec3 normal;',
  			'attribute vec2 uv;',

  			'#ifdef USE_TANGENT',

  			'	attribute vec4 tangent;',

  			'#endif',

  			'#if defined( USE_COLOR_ALPHA )',

  			'	attribute vec4 color;',

  			'#elif defined( USE_COLOR )',

  			'	attribute vec3 color;',

  			'#endif',

  			'#ifdef USE_MORPHTARGETS',

  			'	attribute vec3 morphTarget0;',
  			'	attribute vec3 morphTarget1;',
  			'	attribute vec3 morphTarget2;',
  			'	attribute vec3 morphTarget3;',

  			'	#ifdef USE_MORPHNORMALS',

  			'		attribute vec3 morphNormal0;',
  			'		attribute vec3 morphNormal1;',
  			'		attribute vec3 morphNormal2;',
  			'		attribute vec3 morphNormal3;',

  			'	#else',

  			'		attribute vec3 morphTarget4;',
  			'		attribute vec3 morphTarget5;',
  			'		attribute vec3 morphTarget6;',
  			'		attribute vec3 morphTarget7;',

  			'	#endif',

  			'#endif',

  			'#ifdef USE_SKINNING',

  			'	attribute vec4 skinIndex;',
  			'	attribute vec4 skinWeight;',

  			'#endif',

  			'\n'

  		].filter( filterEmptyLine ).join( '\n' );

  		prefixFragment = [

  			customExtensions,

  			generatePrecision( parameters ),

  			'#define SHADER_NAME ' + parameters.shaderName,

  			customDefines,

  			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

  			'#define GAMMA_FACTOR ' + gammaFactorDefine,

  			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
  			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

  			parameters.map ? '#define USE_MAP' : '',
  			parameters.matcap ? '#define USE_MATCAP' : '',
  			parameters.envMap ? '#define USE_ENVMAP' : '',
  			parameters.envMap ? '#define ' + envMapTypeDefine : '',
  			parameters.envMap ? '#define ' + envMapModeDefine : '',
  			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
  			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  			parameters.aoMap ? '#define USE_AOMAP' : '',
  			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
  			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  			parameters.normalMap ? '#define USE_NORMALMAP' : '',
  			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
  			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
  			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
  			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
  			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
  			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
  			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

  			parameters.sheen ? '#define USE_SHEEN' : '',
  			parameters.transmission ? '#define USE_TRANSMISSION' : '',
  			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
  			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

  			parameters.vertexTangents ? '#define USE_TANGENT' : '',
  			parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
  			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
  			parameters.vertexUvs ? '#define USE_UV' : '',
  			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

  			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

  			parameters.flatShading ? '#define FLAT_SHADED' : '',

  			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  			parameters.flipSided ? '#define FLIP_SIDED' : '',

  			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

  			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

  			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
  			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

  			( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

  			'uniform mat4 viewMatrix;',
  			'uniform vec3 cameraPosition;',
  			'uniform bool isOrthographic;',

  			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
  			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
  			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

  			parameters.dithering ? '#define DITHERING' : '',

  			ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
  			parameters.map ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
  			parameters.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
  			parameters.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
  			parameters.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
  			parameters.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
  			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

  			parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

  			'\n'

  		].filter( filterEmptyLine ).join( '\n' );

  	}

  	vertexShader = resolveIncludes( vertexShader );
  	vertexShader = replaceLightNums( vertexShader, parameters );
  	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

  	fragmentShader = resolveIncludes( fragmentShader );
  	fragmentShader = replaceLightNums( fragmentShader, parameters );
  	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

  	vertexShader = unrollLoops( vertexShader );
  	fragmentShader = unrollLoops( fragmentShader );

  	if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

  		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

  		versionString = '#version 300 es\n';

  		prefixVertex = [
  			'#define attribute in',
  			'#define varying out',
  			'#define texture2D texture'
  		].join( '\n' ) + '\n' + prefixVertex;

  		prefixFragment = [
  			'#define varying in',
  			( parameters.glslVersion === GLSL3 ) ? '' : 'out highp vec4 pc_fragColor;',
  			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
  			'#define gl_FragDepthEXT gl_FragDepth',
  			'#define texture2D texture',
  			'#define textureCube texture',
  			'#define texture2DProj textureProj',
  			'#define texture2DLodEXT textureLod',
  			'#define texture2DProjLodEXT textureProjLod',
  			'#define textureCubeLodEXT textureLod',
  			'#define texture2DGradEXT textureGrad',
  			'#define texture2DProjGradEXT textureProjGrad',
  			'#define textureCubeGradEXT textureGrad'
  		].join( '\n' ) + '\n' + prefixFragment;

  	}

  	const vertexGlsl = versionString + prefixVertex + vertexShader;
  	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

  	// console.log( '*VERTEX*', vertexGlsl );
  	// console.log( '*FRAGMENT*', fragmentGlsl );

  	const glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
  	const glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

  	gl.attachShader( program, glVertexShader );
  	gl.attachShader( program, glFragmentShader );

  	// Force a particular attribute to index 0.

  	if ( parameters.index0AttributeName !== undefined ) {

  		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

  	} else if ( parameters.morphTargets === true ) {

  		// programs with morphTargets displace position out of attribute 0
  		gl.bindAttribLocation( program, 0, 'position' );

  	}

  	gl.linkProgram( program );

  	// check for link errors
  	if ( renderer.debug.checkShaderErrors ) {

  		const programLog = gl.getProgramInfoLog( program ).trim();
  		const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
  		const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

  		let runnable = true;
  		let haveDiagnostics = true;

  		if ( gl.getProgramParameter( program, 35714 ) === false ) {

  			runnable = false;

  			const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
  			const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

  			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

  		} else if ( programLog !== '' ) {

  			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

  		} else if ( vertexLog === '' || fragmentLog === '' ) {

  			haveDiagnostics = false;

  		}

  		if ( haveDiagnostics ) {

  			this.diagnostics = {

  				runnable: runnable,

  				programLog: programLog,

  				vertexShader: {

  					log: vertexLog,
  					prefix: prefixVertex

  				},

  				fragmentShader: {

  					log: fragmentLog,
  					prefix: prefixFragment

  				}

  			};

  		}

  	}

  	// Clean up

  	// Crashes in iOS9 and iOS10. #18402
  	// gl.detachShader( program, glVertexShader );
  	// gl.detachShader( program, glFragmentShader );

  	gl.deleteShader( glVertexShader );
  	gl.deleteShader( glFragmentShader );

  	// set up caching for uniform locations

  	let cachedUniforms;

  	this.getUniforms = function () {

  		if ( cachedUniforms === undefined ) {

  			cachedUniforms = new WebGLUniforms( gl, program );

  		}

  		return cachedUniforms;

  	};

  	// set up caching for attribute locations

  	let cachedAttributes;

  	this.getAttributes = function () {

  		if ( cachedAttributes === undefined ) {

  			cachedAttributes = fetchAttributeLocations( gl, program );

  		}

  		return cachedAttributes;

  	};

  	// free resource

  	this.destroy = function () {

  		bindingStates.releaseStatesOfProgram( this );

  		gl.deleteProgram( program );
  		this.program = undefined;

  	};

  	//

  	this.name = parameters.shaderName;
  	this.id = programIdCount ++;
  	this.cacheKey = cacheKey;
  	this.usedTimes = 1;
  	this.program = program;
  	this.vertexShader = glVertexShader;
  	this.fragmentShader = glFragmentShader;

  	return this;

  }

  function WebGLPrograms( renderer, cubemaps, extensions, capabilities, bindingStates, clipping ) {

  	const programs = [];

  	const isWebGL2 = capabilities.isWebGL2;
  	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  	const floatVertexTextures = capabilities.floatVertexTextures;
  	const maxVertexUniforms = capabilities.maxVertexUniforms;
  	const vertexTextures = capabilities.vertexTextures;

  	let precision = capabilities.precision;

  	const shaderIDs = {
  		MeshDepthMaterial: 'depth',
  		MeshDistanceMaterial: 'distanceRGBA',
  		MeshNormalMaterial: 'normal',
  		MeshBasicMaterial: 'basic',
  		MeshLambertMaterial: 'lambert',
  		MeshPhongMaterial: 'phong',
  		MeshToonMaterial: 'toon',
  		MeshStandardMaterial: 'physical',
  		MeshPhysicalMaterial: 'physical',
  		MeshMatcapMaterial: 'matcap',
  		LineBasicMaterial: 'basic',
  		LineDashedMaterial: 'dashed',
  		PointsMaterial: 'points',
  		ShadowMaterial: 'shadow',
  		SpriteMaterial: 'sprite'
  	};

  	const parameterNames = [
  		'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',
  		'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',
  		'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap',
  		'roughnessMap', 'metalnessMap', 'gradientMap',
  		'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',
  		'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',
  		'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha',
  		'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',
  		'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',
  		'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',
  		'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',
  		'sheen', 'transmission', 'transmissionMap', 'thicknessMap'
  	];

  	function getMaxBones( object ) {

  		const skeleton = object.skeleton;
  		const bones = skeleton.bones;

  		if ( floatVertexTextures ) {

  			return 1024;

  		} else {

  			// default for when object is not specified
  			// ( for example when prebuilding shader to be used with multiple objects )
  			//
  			//  - leave some extra space for other uniforms
  			//  - limit here is ANGLE's 254 max uniform vectors
  			//    (up to 54 should be safe)

  			const nVertexUniforms = maxVertexUniforms;
  			const nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

  			const maxBones = Math.min( nVertexMatrices, bones.length );

  			if ( maxBones < bones.length ) {

  				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
  				return 0;

  			}

  			return maxBones;

  		}

  	}

  	function getTextureEncodingFromMap( map ) {

  		let encoding;

  		if ( map && map.isTexture ) {

  			encoding = map.encoding;

  		} else if ( map && map.isWebGLRenderTarget ) {

  			console.warn( 'THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.' );
  			encoding = map.texture.encoding;

  		} else {

  			encoding = LinearEncoding;

  		}

  		return encoding;

  	}

  	function getParameters( material, lights, shadows, scene, object ) {

  		const fog = scene.fog;
  		const environment = material.isMeshStandardMaterial ? scene.environment : null;

  		const envMap = cubemaps.get( material.envMap || environment );

  		const shaderID = shaderIDs[ material.type ];

  		// heuristics to create shader parameters according to lights in the scene
  		// (not to blow over maxLights budget)

  		const maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

  		if ( material.precision !== null ) {

  			precision = capabilities.getMaxPrecision( material.precision );

  			if ( precision !== material.precision ) {

  				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

  			}

  		}

  		let vertexShader, fragmentShader;

  		if ( shaderID ) {

  			const shader = ShaderLib[ shaderID ];

  			vertexShader = shader.vertexShader;
  			fragmentShader = shader.fragmentShader;

  		} else {

  			vertexShader = material.vertexShader;
  			fragmentShader = material.fragmentShader;

  		}

  		const currentRenderTarget = renderer.getRenderTarget();

  		const parameters = {

  			isWebGL2: isWebGL2,

  			shaderID: shaderID,
  			shaderName: material.type,

  			vertexShader: vertexShader,
  			fragmentShader: fragmentShader,
  			defines: material.defines,

  			isRawShaderMaterial: material.isRawShaderMaterial === true,
  			glslVersion: material.glslVersion,

  			precision: precision,

  			instancing: object.isInstancedMesh === true,
  			instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

  			supportsVertexTextures: vertexTextures,
  			outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
  			map: !! material.map,
  			mapEncoding: getTextureEncodingFromMap( material.map ),
  			matcap: !! material.matcap,
  			matcapEncoding: getTextureEncodingFromMap( material.matcap ),
  			envMap: !! envMap,
  			envMapMode: envMap && envMap.mapping,
  			envMapEncoding: getTextureEncodingFromMap( envMap ),
  			envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
  			lightMap: !! material.lightMap,
  			lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
  			aoMap: !! material.aoMap,
  			emissiveMap: !! material.emissiveMap,
  			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
  			bumpMap: !! material.bumpMap,
  			normalMap: !! material.normalMap,
  			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
  			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
  			clearcoatMap: !! material.clearcoatMap,
  			clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
  			clearcoatNormalMap: !! material.clearcoatNormalMap,
  			displacementMap: !! material.displacementMap,
  			roughnessMap: !! material.roughnessMap,
  			metalnessMap: !! material.metalnessMap,
  			specularMap: !! material.specularMap,
  			alphaMap: !! material.alphaMap,

  			gradientMap: !! material.gradientMap,

  			sheen: !! material.sheen,

  			transmission: !! material.transmission,
  			transmissionMap: !! material.transmissionMap,
  			thicknessMap: !! material.thicknessMap,

  			combine: material.combine,

  			vertexTangents: ( material.normalMap && material.vertexTangents ),
  			vertexColors: material.vertexColors,
  			vertexAlphas: material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
  			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmission || !! material.transmissionMap || !! material.thicknessMap,
  			uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.transmission || !! material.transmissionMap || !! material.thicknessMap ) && !! material.displacementMap,

  			fog: !! fog,
  			useFog: material.fog,
  			fogExp2: ( fog && fog.isFogExp2 ),

  			flatShading: !! material.flatShading,

  			sizeAttenuation: material.sizeAttenuation,
  			logarithmicDepthBuffer: logarithmicDepthBuffer,

  			skinning: object.isSkinnedMesh === true && maxBones > 0,
  			maxBones: maxBones,
  			useVertexTexture: floatVertexTextures,

  			morphTargets: material.morphTargets,
  			morphNormals: material.morphNormals,

  			numDirLights: lights.directional.length,
  			numPointLights: lights.point.length,
  			numSpotLights: lights.spot.length,
  			numRectAreaLights: lights.rectArea.length,
  			numHemiLights: lights.hemi.length,

  			numDirLightShadows: lights.directionalShadowMap.length,
  			numPointLightShadows: lights.pointShadowMap.length,
  			numSpotLightShadows: lights.spotShadowMap.length,

  			numClippingPlanes: clipping.numPlanes,
  			numClipIntersection: clipping.numIntersection,

  			dithering: material.dithering,

  			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
  			shadowMapType: renderer.shadowMap.type,

  			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
  			physicallyCorrectLights: renderer.physicallyCorrectLights,

  			premultipliedAlpha: material.premultipliedAlpha,

  			alphaTest: material.alphaTest,
  			doubleSided: material.side === DoubleSide,
  			flipSided: material.side === BackSide,

  			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

  			index0AttributeName: material.index0AttributeName,

  			extensionDerivatives: material.extensions && material.extensions.derivatives,
  			extensionFragDepth: material.extensions && material.extensions.fragDepth,
  			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
  			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

  			rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
  			rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
  			rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

  			customProgramCacheKey: material.customProgramCacheKey()

  		};

  		return parameters;

  	}

  	function getProgramCacheKey( parameters ) {

  		const array = [];

  		if ( parameters.shaderID ) {

  			array.push( parameters.shaderID );

  		} else {

  			array.push( parameters.fragmentShader );
  			array.push( parameters.vertexShader );

  		}

  		if ( parameters.defines !== undefined ) {

  			for ( const name in parameters.defines ) {

  				array.push( name );
  				array.push( parameters.defines[ name ] );

  			}

  		}

  		if ( parameters.isRawShaderMaterial === false ) {

  			for ( let i = 0; i < parameterNames.length; i ++ ) {

  				array.push( parameters[ parameterNames[ i ] ] );

  			}

  			array.push( renderer.outputEncoding );
  			array.push( renderer.gammaFactor );

  		}

  		array.push( parameters.customProgramCacheKey );

  		return array.join();

  	}

  	function getUniforms( material ) {

  		const shaderID = shaderIDs[ material.type ];
  		let uniforms;

  		if ( shaderID ) {

  			const shader = ShaderLib[ shaderID ];
  			uniforms = UniformsUtils.clone( shader.uniforms );

  		} else {

  			uniforms = material.uniforms;

  		}

  		return uniforms;

  	}

  	function acquireProgram( parameters, cacheKey ) {

  		let program;

  		// Check if code has been already compiled
  		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

  			const preexistingProgram = programs[ p ];

  			if ( preexistingProgram.cacheKey === cacheKey ) {

  				program = preexistingProgram;
  				++ program.usedTimes;

  				break;

  			}

  		}

  		if ( program === undefined ) {

  			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
  			programs.push( program );

  		}

  		return program;

  	}

  	function releaseProgram( program ) {

  		if ( -- program.usedTimes === 0 ) {

  			// Remove from unordered set
  			const i = programs.indexOf( program );
  			programs[ i ] = programs[ programs.length - 1 ];
  			programs.pop();

  			// Free WebGL resources
  			program.destroy();

  		}

  	}

  	return {
  		getParameters: getParameters,
  		getProgramCacheKey: getProgramCacheKey,
  		getUniforms: getUniforms,
  		acquireProgram: acquireProgram,
  		releaseProgram: releaseProgram,
  		// Exposed for resource monitoring & error feedback via renderer.info:
  		programs: programs
  	};

  }

  function WebGLProperties() {

  	let properties = new WeakMap();

  	function get( object ) {

  		let map = properties.get( object );

  		if ( map === undefined ) {

  			map = {};
  			properties.set( object, map );

  		}

  		return map;

  	}

  	function remove( object ) {

  		properties.delete( object );

  	}

  	function update( object, key, value ) {

  		properties.get( object )[ key ] = value;

  	}

  	function dispose() {

  		properties = new WeakMap();

  	}

  	return {
  		get: get,
  		remove: remove,
  		update: update,
  		dispose: dispose
  	};

  }

  function painterSortStable( a, b ) {

  	if ( a.groupOrder !== b.groupOrder ) {

  		return a.groupOrder - b.groupOrder;

  	} else if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.program !== b.program ) {

  		return a.program.id - b.program.id;

  	} else if ( a.material.id !== b.material.id ) {

  		return a.material.id - b.material.id;

  	} else if ( a.z !== b.z ) {

  		return a.z - b.z;

  	} else {

  		return a.id - b.id;

  	}

  }

  function reversePainterSortStable( a, b ) {

  	if ( a.groupOrder !== b.groupOrder ) {

  		return a.groupOrder - b.groupOrder;

  	} else if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.z !== b.z ) {

  		return b.z - a.z;

  	} else {

  		return a.id - b.id;

  	}

  }


  function WebGLRenderList( properties ) {

  	const renderItems = [];
  	let renderItemsIndex = 0;

  	const opaque = [];
  	const transmissive = [];
  	const transparent = [];

  	const defaultProgram = { id: - 1 };

  	function init() {

  		renderItemsIndex = 0;

  		opaque.length = 0;
  		transmissive.length = 0;
  		transparent.length = 0;

  	}

  	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

  		let renderItem = renderItems[ renderItemsIndex ];
  		const materialProperties = properties.get( material );

  		if ( renderItem === undefined ) {

  			renderItem = {
  				id: object.id,
  				object: object,
  				geometry: geometry,
  				material: material,
  				program: materialProperties.program || defaultProgram,
  				groupOrder: groupOrder,
  				renderOrder: object.renderOrder,
  				z: z,
  				group: group
  			};

  			renderItems[ renderItemsIndex ] = renderItem;

  		} else {

  			renderItem.id = object.id;
  			renderItem.object = object;
  			renderItem.geometry = geometry;
  			renderItem.material = material;
  			renderItem.program = materialProperties.program || defaultProgram;
  			renderItem.groupOrder = groupOrder;
  			renderItem.renderOrder = object.renderOrder;
  			renderItem.z = z;
  			renderItem.group = group;

  		}

  		renderItemsIndex ++;

  		return renderItem;

  	}

  	function push( object, geometry, material, groupOrder, z, group ) {

  		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

  		if ( material.transmission > 0.0 ) {

  			transmissive.push( renderItem );

  		} else if ( material.transparent === true ) {

  			transparent.push( renderItem );

  		} else {

  			opaque.push( renderItem );

  		}

  	}

  	function unshift( object, geometry, material, groupOrder, z, group ) {

  		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

  		if ( material.transmission > 0.0 ) {

  			transmissive.unshift( renderItem );

  		} else if ( material.transparent === true ) {

  			transparent.unshift( renderItem );

  		} else {

  			opaque.unshift( renderItem );

  		}

  	}

  	function sort( customOpaqueSort, customTransparentSort ) {

  		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
  		if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
  		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

  	}

  	function finish() {

  		// Clear references from inactive renderItems in the list

  		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

  			const renderItem = renderItems[ i ];

  			if ( renderItem.id === null ) break;

  			renderItem.id = null;
  			renderItem.object = null;
  			renderItem.geometry = null;
  			renderItem.material = null;
  			renderItem.program = null;
  			renderItem.group = null;

  		}

  	}

  	return {

  		opaque: opaque,
  		transmissive: transmissive,
  		transparent: transparent,

  		init: init,
  		push: push,
  		unshift: unshift,
  		finish: finish,

  		sort: sort
  	};

  }

  function WebGLRenderLists( properties ) {

  	let lists = new WeakMap();

  	function get( scene, renderCallDepth ) {

  		let list;

  		if ( lists.has( scene ) === false ) {

  			list = new WebGLRenderList( properties );
  			lists.set( scene, [ list ] );

  		} else {

  			if ( renderCallDepth >= lists.get( scene ).length ) {

  				list = new WebGLRenderList( properties );
  				lists.get( scene ).push( list );

  			} else {

  				list = lists.get( scene )[ renderCallDepth ];

  			}

  		}

  		return list;

  	}

  	function dispose() {

  		lists = new WeakMap();

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  function UniformsCache() {

  	const lights = {};

  	return {

  		get: function ( light ) {

  			if ( lights[ light.id ] !== undefined ) {

  				return lights[ light.id ];

  			}

  			let uniforms;

  			switch ( light.type ) {

  				case 'DirectionalLight':
  					uniforms = {
  						direction: new Vector3(),
  						color: new Color()
  					};
  					break;

  				case 'SpotLight':
  					uniforms = {
  						position: new Vector3(),
  						direction: new Vector3(),
  						color: new Color(),
  						distance: 0,
  						coneCos: 0,
  						penumbraCos: 0,
  						decay: 0
  					};
  					break;

  				case 'PointLight':
  					uniforms = {
  						position: new Vector3(),
  						color: new Color(),
  						distance: 0,
  						decay: 0
  					};
  					break;

  				case 'HemisphereLight':
  					uniforms = {
  						direction: new Vector3(),
  						skyColor: new Color(),
  						groundColor: new Color()
  					};
  					break;

  				case 'RectAreaLight':
  					uniforms = {
  						color: new Color(),
  						position: new Vector3(),
  						halfWidth: new Vector3(),
  						halfHeight: new Vector3()
  					};
  					break;

  			}

  			lights[ light.id ] = uniforms;

  			return uniforms;

  		}

  	};

  }

  function ShadowUniformsCache() {

  	const lights = {};

  	return {

  		get: function ( light ) {

  			if ( lights[ light.id ] !== undefined ) {

  				return lights[ light.id ];

  			}

  			let uniforms;

  			switch ( light.type ) {

  				case 'DirectionalLight':
  					uniforms = {
  						shadowBias: 0,
  						shadowNormalBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2()
  					};
  					break;

  				case 'SpotLight':
  					uniforms = {
  						shadowBias: 0,
  						shadowNormalBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2()
  					};
  					break;

  				case 'PointLight':
  					uniforms = {
  						shadowBias: 0,
  						shadowNormalBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2(),
  						shadowCameraNear: 1,
  						shadowCameraFar: 1000
  					};
  					break;

  				// TODO (abelnation): set RectAreaLight shadow uniforms

  			}

  			lights[ light.id ] = uniforms;

  			return uniforms;

  		}

  	};

  }



  let nextVersion = 0;

  function shadowCastingLightsFirst( lightA, lightB ) {

  	return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

  }

  function WebGLLights( extensions, capabilities ) {

  	const cache = new UniformsCache();

  	const shadowCache = ShadowUniformsCache();

  	const state = {

  		version: 0,

  		hash: {
  			directionalLength: - 1,
  			pointLength: - 1,
  			spotLength: - 1,
  			rectAreaLength: - 1,
  			hemiLength: - 1,

  			numDirectionalShadows: - 1,
  			numPointShadows: - 1,
  			numSpotShadows: - 1
  		},

  		ambient: [ 0, 0, 0 ],
  		probe: [],
  		directional: [],
  		directionalShadow: [],
  		directionalShadowMap: [],
  		directionalShadowMatrix: [],
  		spot: [],
  		spotShadow: [],
  		spotShadowMap: [],
  		spotShadowMatrix: [],
  		rectArea: [],
  		rectAreaLTC1: null,
  		rectAreaLTC2: null,
  		point: [],
  		pointShadow: [],
  		pointShadowMap: [],
  		pointShadowMatrix: [],
  		hemi: []

  	};

  	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

  	const vector3 = new Vector3();
  	const matrix4 = new Matrix4();
  	const matrix42 = new Matrix4();

  	function setup( lights ) {

  		let r = 0, g = 0, b = 0;

  		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

  		let directionalLength = 0;
  		let pointLength = 0;
  		let spotLength = 0;
  		let rectAreaLength = 0;
  		let hemiLength = 0;

  		let numDirectionalShadows = 0;
  		let numPointShadows = 0;
  		let numSpotShadows = 0;

  		lights.sort( shadowCastingLightsFirst );

  		for ( let i = 0, l = lights.length; i < l; i ++ ) {

  			const light = lights[ i ];

  			const color = light.color;
  			const intensity = light.intensity;
  			const distance = light.distance;

  			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

  			if ( light.isAmbientLight ) {

  				r += color.r * intensity;
  				g += color.g * intensity;
  				b += color.b * intensity;

  			} else if ( light.isLightProbe ) {

  				for ( let j = 0; j < 9; j ++ ) {

  					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

  				}

  			} else if ( light.isDirectionalLight ) {

  				const uniforms = cache.get( light );

  				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

  				if ( light.castShadow ) {

  					const shadow = light.shadow;

  					const shadowUniforms = shadowCache.get( light );

  					shadowUniforms.shadowBias = shadow.bias;
  					shadowUniforms.shadowNormalBias = shadow.normalBias;
  					shadowUniforms.shadowRadius = shadow.radius;
  					shadowUniforms.shadowMapSize = shadow.mapSize;

  					state.directionalShadow[ directionalLength ] = shadowUniforms;
  					state.directionalShadowMap[ directionalLength ] = shadowMap;
  					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

  					numDirectionalShadows ++;

  				}

  				state.directional[ directionalLength ] = uniforms;

  				directionalLength ++;

  			} else if ( light.isSpotLight ) {

  				const uniforms = cache.get( light );

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );

  				uniforms.color.copy( color ).multiplyScalar( intensity );
  				uniforms.distance = distance;

  				uniforms.coneCos = Math.cos( light.angle );
  				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
  				uniforms.decay = light.decay;

  				if ( light.castShadow ) {

  					const shadow = light.shadow;

  					const shadowUniforms = shadowCache.get( light );

  					shadowUniforms.shadowBias = shadow.bias;
  					shadowUniforms.shadowNormalBias = shadow.normalBias;
  					shadowUniforms.shadowRadius = shadow.radius;
  					shadowUniforms.shadowMapSize = shadow.mapSize;

  					state.spotShadow[ spotLength ] = shadowUniforms;
  					state.spotShadowMap[ spotLength ] = shadowMap;
  					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

  					numSpotShadows ++;

  				}

  				state.spot[ spotLength ] = uniforms;

  				spotLength ++;

  			} else if ( light.isRectAreaLight ) {

  				const uniforms = cache.get( light );

  				// (a) intensity is the total visible light emitted
  				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

  				// (b) intensity is the brightness of the light
  				uniforms.color.copy( color ).multiplyScalar( intensity );

  				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
  				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

  				state.rectArea[ rectAreaLength ] = uniforms;

  				rectAreaLength ++;

  			} else if ( light.isPointLight ) {

  				const uniforms = cache.get( light );

  				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
  				uniforms.distance = light.distance;
  				uniforms.decay = light.decay;

  				if ( light.castShadow ) {

  					const shadow = light.shadow;

  					const shadowUniforms = shadowCache.get( light );

  					shadowUniforms.shadowBias = shadow.bias;
  					shadowUniforms.shadowNormalBias = shadow.normalBias;
  					shadowUniforms.shadowRadius = shadow.radius;
  					shadowUniforms.shadowMapSize = shadow.mapSize;
  					shadowUniforms.shadowCameraNear = shadow.camera.near;
  					shadowUniforms.shadowCameraFar = shadow.camera.far;

  					state.pointShadow[ pointLength ] = shadowUniforms;
  					state.pointShadowMap[ pointLength ] = shadowMap;
  					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

  					numPointShadows ++;

  				}

  				state.point[ pointLength ] = uniforms;

  				pointLength ++;

  			} else if ( light.isHemisphereLight ) {

  				const uniforms = cache.get( light );

  				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
  				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

  				state.hemi[ hemiLength ] = uniforms;

  				hemiLength ++;

  			}

  		}

  		if ( rectAreaLength > 0 ) {

  			if ( capabilities.isWebGL2 ) {

  				// WebGL 2

  				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
  				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

  			} else {

  				// WebGL 1

  				if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

  					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
  					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

  				} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

  					state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
  					state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

  				} else {

  					console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

  				}

  			}

  		}

  		state.ambient[ 0 ] = r;
  		state.ambient[ 1 ] = g;
  		state.ambient[ 2 ] = b;

  		const hash = state.hash;

  		if ( hash.directionalLength !== directionalLength ||
  			hash.pointLength !== pointLength ||
  			hash.spotLength !== spotLength ||
  			hash.rectAreaLength !== rectAreaLength ||
  			hash.hemiLength !== hemiLength ||
  			hash.numDirectionalShadows !== numDirectionalShadows ||
  			hash.numPointShadows !== numPointShadows ||
  			hash.numSpotShadows !== numSpotShadows ) {

  			state.directional.length = directionalLength;
  			state.spot.length = spotLength;
  			state.rectArea.length = rectAreaLength;
  			state.point.length = pointLength;
  			state.hemi.length = hemiLength;

  			state.directionalShadow.length = numDirectionalShadows;
  			state.directionalShadowMap.length = numDirectionalShadows;
  			state.pointShadow.length = numPointShadows;
  			state.pointShadowMap.length = numPointShadows;
  			state.spotShadow.length = numSpotShadows;
  			state.spotShadowMap.length = numSpotShadows;
  			state.directionalShadowMatrix.length = numDirectionalShadows;
  			state.pointShadowMatrix.length = numPointShadows;
  			state.spotShadowMatrix.length = numSpotShadows;

  			hash.directionalLength = directionalLength;
  			hash.pointLength = pointLength;
  			hash.spotLength = spotLength;
  			hash.rectAreaLength = rectAreaLength;
  			hash.hemiLength = hemiLength;

  			hash.numDirectionalShadows = numDirectionalShadows;
  			hash.numPointShadows = numPointShadows;
  			hash.numSpotShadows = numSpotShadows;

  			state.version = nextVersion ++;

  		}

  	}

  	function setupView( lights, camera ) {

  		let directionalLength = 0;
  		let pointLength = 0;
  		let spotLength = 0;
  		let rectAreaLength = 0;
  		let hemiLength = 0;

  		const viewMatrix = camera.matrixWorldInverse;

  		for ( let i = 0, l = lights.length; i < l; i ++ ) {

  			const light = lights[ i ];

  			if ( light.isDirectionalLight ) {

  				const uniforms = state.directional[ directionalLength ];

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				vector3.setFromMatrixPosition( light.target.matrixWorld );
  				uniforms.direction.sub( vector3 );
  				uniforms.direction.transformDirection( viewMatrix );

  				directionalLength ++;

  			} else if ( light.isSpotLight ) {

  				const uniforms = state.spot[ spotLength ];

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				vector3.setFromMatrixPosition( light.target.matrixWorld );
  				uniforms.direction.sub( vector3 );
  				uniforms.direction.transformDirection( viewMatrix );

  				spotLength ++;

  			} else if ( light.isRectAreaLight ) {

  				const uniforms = state.rectArea[ rectAreaLength ];

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				// extract local rotation of light to derive width/height half vectors
  				matrix42.identity();
  				matrix4.copy( light.matrixWorld );
  				matrix4.premultiply( viewMatrix );
  				matrix42.extractRotation( matrix4 );

  				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
  				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

  				uniforms.halfWidth.applyMatrix4( matrix42 );
  				uniforms.halfHeight.applyMatrix4( matrix42 );

  				rectAreaLength ++;

  			} else if ( light.isPointLight ) {

  				const uniforms = state.point[ pointLength ];

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				pointLength ++;

  			} else if ( light.isHemisphereLight ) {

  				const uniforms = state.hemi[ hemiLength ];

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				uniforms.direction.transformDirection( viewMatrix );
  				uniforms.direction.normalize();

  				hemiLength ++;

  			}

  		}

  	}

  	return {
  		setup: setup,
  		setupView: setupView,
  		state: state
  	};

  }

  function WebGLRenderState( extensions, capabilities ) {

  	const lights = new WebGLLights( extensions, capabilities );

  	const lightsArray = [];
  	const shadowsArray = [];

  	function init() {

  		lightsArray.length = 0;
  		shadowsArray.length = 0;

  	}

  	function pushLight( light ) {

  		lightsArray.push( light );

  	}

  	function pushShadow( shadowLight ) {

  		shadowsArray.push( shadowLight );

  	}

  	function setupLights() {

  		lights.setup( lightsArray );

  	}

  	function setupLightsView( camera ) {

  		lights.setupView( lightsArray, camera );

  	}

  	const state = {
  		lightsArray: lightsArray,
  		shadowsArray: shadowsArray,

  		lights: lights
  	};

  	return {
  		init: init,
  		state: state,
  		setupLights: setupLights,
  		setupLightsView: setupLightsView,

  		pushLight: pushLight,
  		pushShadow: pushShadow
  	};

  }

  function WebGLRenderStates( extensions, capabilities ) {

  	let renderStates = new WeakMap();

  	function get( scene, renderCallDepth = 0 ) {

  		let renderState;

  		if ( renderStates.has( scene ) === false ) {

  			renderState = new WebGLRenderState( extensions, capabilities );
  			renderStates.set( scene, [ renderState ] );

  		} else {

  			if ( renderCallDepth >= renderStates.get( scene ).length ) {

  				renderState = new WebGLRenderState( extensions, capabilities );
  				renderStates.get( scene ).push( renderState );

  			} else {

  				renderState = renderStates.get( scene )[ renderCallDepth ];

  			}

  		}

  		return renderState;

  	}

  	function dispose() {

  		renderStates = new WeakMap();

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  /**
   * parameters = {
   *
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   * }
   */

  class MeshDepthMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.type = 'MeshDepthMaterial';

  		this.depthPacking = BasicDepthPacking;

  		this.morphTargets = false;

  		this.map = null;

  		this.alphaMap = null;

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;

  		this.fog = false;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.depthPacking = source.depthPacking;

  		this.morphTargets = source.morphTargets;

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		return this;

  	}

  }

  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

  /**
   * parameters = {
   *
   *  referencePosition: <float>,
   *  nearDistance: <float>,
   *  farDistance: <float>,
   *
   *  morphTargets: <bool>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>
   *
   * }
   */

  class MeshDistanceMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.type = 'MeshDistanceMaterial';

  		this.referencePosition = new Vector3();
  		this.nearDistance = 1;
  		this.farDistance = 1000;

  		this.morphTargets = false;

  		this.map = null;

  		this.alphaMap = null;

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.fog = false;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.referencePosition.copy( source.referencePosition );
  		this.nearDistance = source.nearDistance;
  		this.farDistance = source.farDistance;

  		this.morphTargets = source.morphTargets;

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		return this;

  	}

  }

  MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

  var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

  var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

  function WebGLShadowMap( _renderer, _objects, _capabilities ) {

  	let _frustum = new Frustum();

  	const _shadowMapSize = new Vector2(),
  		_viewportSize = new Vector2(),

  		_viewport = new Vector4$1(),

  		_depthMaterials = [],
  		_distanceMaterials = [],

  		_materialCache = {},

  		_maxTextureSize = _capabilities.maxTextureSize;

  	const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

  	const shadowMaterialVertical = new ShaderMaterial( {

  		defines: {
  			SAMPLE_RATE: 2.0 / 8.0,
  			HALF_SAMPLE_RATE: 1.0 / 8.0
  		},

  		uniforms: {
  			shadow_pass: { value: null },
  			resolution: { value: new Vector2() },
  			radius: { value: 4.0 }
  		},

  		vertexShader: vsm_vert,

  		fragmentShader: vsm_frag

  	} );

  	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

  	const fullScreenTri = new BufferGeometry();
  	fullScreenTri.setAttribute(
  		'position',
  		new BufferAttribute(
  			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
  			3
  		)
  	);

  	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

  	const scope = this;

  	this.enabled = false;

  	this.autoUpdate = true;
  	this.needsUpdate = false;

  	this.type = PCFShadowMap;

  	this.render = function ( lights, scene, camera ) {

  		if ( scope.enabled === false ) return;
  		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

  		if ( lights.length === 0 ) return;

  		const currentRenderTarget = _renderer.getRenderTarget();
  		const activeCubeFace = _renderer.getActiveCubeFace();
  		const activeMipmapLevel = _renderer.getActiveMipmapLevel();

  		const _state = _renderer.state;

  		// Set GL state for depth map.
  		_state.setBlending( NoBlending );
  		_state.buffers.color.setClear( 1, 1, 1, 1 );
  		_state.buffers.depth.setTest( true );
  		_state.setScissorTest( false );

  		// render depth map

  		for ( let i = 0, il = lights.length; i < il; i ++ ) {

  			const light = lights[ i ];
  			const shadow = light.shadow;

  			if ( shadow === undefined ) {

  				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
  				continue;

  			}

  			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

  			_shadowMapSize.copy( shadow.mapSize );

  			const shadowFrameExtents = shadow.getFrameExtents();

  			_shadowMapSize.multiply( shadowFrameExtents );

  			_viewportSize.copy( shadow.mapSize );

  			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

  				if ( _shadowMapSize.x > _maxTextureSize ) {

  					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
  					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
  					shadow.mapSize.x = _viewportSize.x;

  				}

  				if ( _shadowMapSize.y > _maxTextureSize ) {

  					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
  					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
  					shadow.mapSize.y = _viewportSize.y;

  				}

  			}

  			if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

  				const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

  				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
  				shadow.map.texture.name = light.name + '.shadowMap';

  				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

  				shadow.camera.updateProjectionMatrix();

  			}

  			if ( shadow.map === null ) {

  				const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

  				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
  				shadow.map.texture.name = light.name + '.shadowMap';

  				shadow.camera.updateProjectionMatrix();

  			}

  			_renderer.setRenderTarget( shadow.map );
  			_renderer.clear();

  			const viewportCount = shadow.getViewportCount();

  			for ( let vp = 0; vp < viewportCount; vp ++ ) {

  				const viewport = shadow.getViewport( vp );

  				_viewport.set(
  					_viewportSize.x * viewport.x,
  					_viewportSize.y * viewport.y,
  					_viewportSize.x * viewport.z,
  					_viewportSize.y * viewport.w
  				);

  				_state.viewport( _viewport );

  				shadow.updateMatrices( light, vp );

  				_frustum = shadow.getFrustum();

  				renderObject( scene, camera, shadow.camera, light, this.type );

  			}

  			// do blur pass for VSM

  			if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

  				VSMPass( shadow, camera );

  			}

  			shadow.needsUpdate = false;

  		}

  		scope.needsUpdate = false;

  		_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

  	};

  	function VSMPass( shadow, camera ) {

  		const geometry = _objects.update( fullScreenMesh );

  		// vertical pass

  		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
  		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
  		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
  		_renderer.setRenderTarget( shadow.mapPass );
  		_renderer.clear();
  		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

  		// horizontal pass

  		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
  		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
  		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
  		_renderer.setRenderTarget( shadow.map );
  		_renderer.clear();
  		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

  	}

  	function getDepthMaterialVariant( useMorphing ) {

  		const index = useMorphing << 0;

  		let material = _depthMaterials[ index ];

  		if ( material === undefined ) {

  			material = new MeshDepthMaterial( {

  				depthPacking: RGBADepthPacking,

  				morphTargets: useMorphing

  			} );

  			_depthMaterials[ index ] = material;

  		}

  		return material;

  	}

  	function getDistanceMaterialVariant( useMorphing ) {

  		const index = useMorphing << 0;

  		let material = _distanceMaterials[ index ];

  		if ( material === undefined ) {

  			material = new MeshDistanceMaterial( {

  				morphTargets: useMorphing

  			} );

  			_distanceMaterials[ index ] = material;

  		}

  		return material;

  	}

  	function getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {

  		let result = null;

  		let getMaterialVariant = getDepthMaterialVariant;
  		let customMaterial = object.customDepthMaterial;

  		if ( light.isPointLight === true ) {

  			getMaterialVariant = getDistanceMaterialVariant;
  			customMaterial = object.customDistanceMaterial;

  		}

  		if ( customMaterial === undefined ) {

  			let useMorphing = false;

  			if ( material.morphTargets === true ) {

  				useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

  			}

  			result = getMaterialVariant( useMorphing );

  		} else {

  			result = customMaterial;

  		}

  		if ( _renderer.localClippingEnabled &&
  				material.clipShadows === true &&
  				material.clippingPlanes.length !== 0 ) {

  			// in this case we need a unique material instance reflecting the
  			// appropriate state

  			const keyA = result.uuid, keyB = material.uuid;

  			let materialsForVariant = _materialCache[ keyA ];

  			if ( materialsForVariant === undefined ) {

  				materialsForVariant = {};
  				_materialCache[ keyA ] = materialsForVariant;

  			}

  			let cachedMaterial = materialsForVariant[ keyB ];

  			if ( cachedMaterial === undefined ) {

  				cachedMaterial = result.clone();
  				materialsForVariant[ keyB ] = cachedMaterial;

  			}

  			result = cachedMaterial;

  		}

  		result.visible = material.visible;
  		result.wireframe = material.wireframe;

  		if ( type === VSMShadowMap ) {

  			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

  		} else {

  			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

  		}

  		result.clipShadows = material.clipShadows;
  		result.clippingPlanes = material.clippingPlanes;
  		result.clipIntersection = material.clipIntersection;

  		result.wireframeLinewidth = material.wireframeLinewidth;
  		result.linewidth = material.linewidth;

  		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

  			result.referencePosition.setFromMatrixPosition( light.matrixWorld );
  			result.nearDistance = shadowCameraNear;
  			result.farDistance = shadowCameraFar;

  		}

  		return result;

  	}

  	function renderObject( object, camera, shadowCamera, light, type ) {

  		if ( object.visible === false ) return;

  		const visible = object.layers.test( camera.layers );

  		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

  			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

  				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

  				const geometry = _objects.update( object );
  				const material = object.material;

  				if ( Array.isArray( material ) ) {

  					const groups = geometry.groups;

  					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

  						const group = groups[ k ];
  						const groupMaterial = material[ group.materialIndex ];

  						if ( groupMaterial && groupMaterial.visible ) {

  							const depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

  							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

  						}

  					}

  				} else if ( material.visible ) {

  					const depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );

  					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

  				}

  			}

  		}

  		const children = object.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			renderObject( children[ i ], camera, shadowCamera, light, type );

  		}

  	}

  }

  function WebGLState( gl, extensions, capabilities ) {

  	const isWebGL2 = capabilities.isWebGL2;

  	function ColorBuffer() {

  		let locked = false;

  		const color = new Vector4$1();
  		let currentColorMask = null;
  		const currentColorClear = new Vector4$1( 0, 0, 0, 0 );

  		return {

  			setMask: function ( colorMask ) {

  				if ( currentColorMask !== colorMask && ! locked ) {

  					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
  					currentColorMask = colorMask;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( r, g, b, a, premultipliedAlpha ) {

  				if ( premultipliedAlpha === true ) {

  					r *= a; g *= a; b *= a;

  				}

  				color.set( r, g, b, a );

  				if ( currentColorClear.equals( color ) === false ) {

  					gl.clearColor( r, g, b, a );
  					currentColorClear.copy( color );

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentColorMask = null;
  				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

  			}

  		};

  	}

  	function DepthBuffer() {

  		let locked = false;

  		let currentDepthMask = null;
  		let currentDepthFunc = null;
  		let currentDepthClear = null;

  		return {

  			setTest: function ( depthTest ) {

  				if ( depthTest ) {

  					enable( 2929 );

  				} else {

  					disable( 2929 );

  				}

  			},

  			setMask: function ( depthMask ) {

  				if ( currentDepthMask !== depthMask && ! locked ) {

  					gl.depthMask( depthMask );
  					currentDepthMask = depthMask;

  				}

  			},

  			setFunc: function ( depthFunc ) {

  				if ( currentDepthFunc !== depthFunc ) {

  					if ( depthFunc ) {

  						switch ( depthFunc ) {

  							case NeverDepth:

  								gl.depthFunc( 512 );
  								break;

  							case AlwaysDepth:

  								gl.depthFunc( 519 );
  								break;

  							case LessDepth:

  								gl.depthFunc( 513 );
  								break;

  							case LessEqualDepth:

  								gl.depthFunc( 515 );
  								break;

  							case EqualDepth:

  								gl.depthFunc( 514 );
  								break;

  							case GreaterEqualDepth:

  								gl.depthFunc( 518 );
  								break;

  							case GreaterDepth:

  								gl.depthFunc( 516 );
  								break;

  							case NotEqualDepth:

  								gl.depthFunc( 517 );
  								break;

  							default:

  								gl.depthFunc( 515 );

  						}

  					} else {

  						gl.depthFunc( 515 );

  					}

  					currentDepthFunc = depthFunc;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( depth ) {

  				if ( currentDepthClear !== depth ) {

  					gl.clearDepth( depth );
  					currentDepthClear = depth;

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentDepthMask = null;
  				currentDepthFunc = null;
  				currentDepthClear = null;

  			}

  		};

  	}

  	function StencilBuffer() {

  		let locked = false;

  		let currentStencilMask = null;
  		let currentStencilFunc = null;
  		let currentStencilRef = null;
  		let currentStencilFuncMask = null;
  		let currentStencilFail = null;
  		let currentStencilZFail = null;
  		let currentStencilZPass = null;
  		let currentStencilClear = null;

  		return {

  			setTest: function ( stencilTest ) {

  				if ( ! locked ) {

  					if ( stencilTest ) {

  						enable( 2960 );

  					} else {

  						disable( 2960 );

  					}

  				}

  			},

  			setMask: function ( stencilMask ) {

  				if ( currentStencilMask !== stencilMask && ! locked ) {

  					gl.stencilMask( stencilMask );
  					currentStencilMask = stencilMask;

  				}

  			},

  			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

  				if ( currentStencilFunc !== stencilFunc ||
  				     currentStencilRef !== stencilRef ||
  				     currentStencilFuncMask !== stencilMask ) {

  					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

  					currentStencilFunc = stencilFunc;
  					currentStencilRef = stencilRef;
  					currentStencilFuncMask = stencilMask;

  				}

  			},

  			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

  				if ( currentStencilFail !== stencilFail ||
  				     currentStencilZFail !== stencilZFail ||
  				     currentStencilZPass !== stencilZPass ) {

  					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

  					currentStencilFail = stencilFail;
  					currentStencilZFail = stencilZFail;
  					currentStencilZPass = stencilZPass;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( stencil ) {

  				if ( currentStencilClear !== stencil ) {

  					gl.clearStencil( stencil );
  					currentStencilClear = stencil;

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentStencilMask = null;
  				currentStencilFunc = null;
  				currentStencilRef = null;
  				currentStencilFuncMask = null;
  				currentStencilFail = null;
  				currentStencilZFail = null;
  				currentStencilZPass = null;
  				currentStencilClear = null;

  			}

  		};

  	}

  	//

  	const colorBuffer = new ColorBuffer();
  	const depthBuffer = new DepthBuffer();
  	const stencilBuffer = new StencilBuffer();

  	let enabledCapabilities = {};

  	let xrFramebuffer = null;
  	let currentBoundFramebuffers = {};

  	let currentProgram = null;

  	let currentBlendingEnabled = false;
  	let currentBlending = null;
  	let currentBlendEquation = null;
  	let currentBlendSrc = null;
  	let currentBlendDst = null;
  	let currentBlendEquationAlpha = null;
  	let currentBlendSrcAlpha = null;
  	let currentBlendDstAlpha = null;
  	let currentPremultipledAlpha = false;

  	let currentFlipSided = null;
  	let currentCullFace = null;

  	let currentLineWidth = null;

  	let currentPolygonOffsetFactor = null;
  	let currentPolygonOffsetUnits = null;

  	const maxTextures = gl.getParameter( 35661 );

  	let lineWidthAvailable = false;
  	let version = 0;
  	const glVersion = gl.getParameter( 7938 );

  	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

  		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
  		lineWidthAvailable = ( version >= 1.0 );

  	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

  		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
  		lineWidthAvailable = ( version >= 2.0 );

  	}

  	let currentTextureSlot = null;
  	let currentBoundTextures = {};

  	const scissorParam = gl.getParameter( 3088 );
  	const viewportParam = gl.getParameter( 2978 );

  	const currentScissor = new Vector4$1().fromArray( scissorParam );
  	const currentViewport = new Vector4$1().fromArray( viewportParam );

  	function createTexture( type, target, count ) {

  		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
  		const texture = gl.createTexture();

  		gl.bindTexture( type, texture );
  		gl.texParameteri( type, 10241, 9728 );
  		gl.texParameteri( type, 10240, 9728 );

  		for ( let i = 0; i < count; i ++ ) {

  			gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

  		}

  		return texture;

  	}

  	const emptyTextures = {};
  	emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
  	emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

  	// init

  	colorBuffer.setClear( 0, 0, 0, 1 );
  	depthBuffer.setClear( 1 );
  	stencilBuffer.setClear( 0 );

  	enable( 2929 );
  	depthBuffer.setFunc( LessEqualDepth );

  	setFlipSided( false );
  	setCullFace( CullFaceBack );
  	enable( 2884 );

  	setBlending( NoBlending );

  	//

  	function enable( id ) {

  		if ( enabledCapabilities[ id ] !== true ) {

  			gl.enable( id );
  			enabledCapabilities[ id ] = true;

  		}

  	}

  	function disable( id ) {

  		if ( enabledCapabilities[ id ] !== false ) {

  			gl.disable( id );
  			enabledCapabilities[ id ] = false;

  		}

  	}

  	function bindXRFramebuffer( framebuffer ) {

  		if ( framebuffer !== xrFramebuffer ) {

  			gl.bindFramebuffer( 36160, framebuffer );

  			xrFramebuffer = framebuffer;

  		}

  	}

  	function bindFramebuffer( target, framebuffer ) {

  		if ( framebuffer === null && xrFramebuffer !== null ) framebuffer = xrFramebuffer; // use active XR framebuffer if available

  		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

  			gl.bindFramebuffer( target, framebuffer );

  			currentBoundFramebuffers[ target ] = framebuffer;

  			if ( isWebGL2 ) {

  				// 36009 is equivalent to 36160

  				if ( target === 36009 ) {

  					currentBoundFramebuffers[ 36160 ] = framebuffer;

  				}

  				if ( target === 36160 ) {

  					currentBoundFramebuffers[ 36009 ] = framebuffer;

  				}

  			}

  			return true;

  		}

  		return false;

  	}

  	function useProgram( program ) {

  		if ( currentProgram !== program ) {

  			gl.useProgram( program );

  			currentProgram = program;

  			return true;

  		}

  		return false;

  	}

  	const equationToGL = {
  		[ AddEquation ]: 32774,
  		[ SubtractEquation ]: 32778,
  		[ ReverseSubtractEquation ]: 32779
  	};

  	if ( isWebGL2 ) {

  		equationToGL[ MinEquation ] = 32775;
  		equationToGL[ MaxEquation ] = 32776;

  	} else {

  		const extension = extensions.get( 'EXT_blend_minmax' );

  		if ( extension !== null ) {

  			equationToGL[ MinEquation ] = extension.MIN_EXT;
  			equationToGL[ MaxEquation ] = extension.MAX_EXT;

  		}

  	}

  	const factorToGL = {
  		[ ZeroFactor ]: 0,
  		[ OneFactor ]: 1,
  		[ SrcColorFactor ]: 768,
  		[ SrcAlphaFactor ]: 770,
  		[ SrcAlphaSaturateFactor ]: 776,
  		[ DstColorFactor ]: 774,
  		[ DstAlphaFactor ]: 772,
  		[ OneMinusSrcColorFactor ]: 769,
  		[ OneMinusSrcAlphaFactor ]: 771,
  		[ OneMinusDstColorFactor ]: 775,
  		[ OneMinusDstAlphaFactor ]: 773
  	};

  	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

  		if ( blending === NoBlending ) {

  			if ( currentBlendingEnabled === true ) {

  				disable( 3042 );
  				currentBlendingEnabled = false;

  			}

  			return;

  		}

  		if ( currentBlendingEnabled === false ) {

  			enable( 3042 );
  			currentBlendingEnabled = true;

  		}

  		if ( blending !== CustomBlending ) {

  			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

  				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

  					gl.blendEquation( 32774 );

  					currentBlendEquation = AddEquation;
  					currentBlendEquationAlpha = AddEquation;

  				}

  				if ( premultipliedAlpha ) {

  					switch ( blending ) {

  						case NormalBlending:
  							gl.blendFuncSeparate( 1, 771, 1, 771 );
  							break;

  						case AdditiveBlending:
  							gl.blendFunc( 1, 1 );
  							break;

  						case SubtractiveBlending:
  							gl.blendFuncSeparate( 0, 0, 769, 771 );
  							break;

  						case MultiplyBlending:
  							gl.blendFuncSeparate( 0, 768, 0, 770 );
  							break;

  						default:
  							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
  							break;

  					}

  				} else {

  					switch ( blending ) {

  						case NormalBlending:
  							gl.blendFuncSeparate( 770, 771, 1, 771 );
  							break;

  						case AdditiveBlending:
  							gl.blendFunc( 770, 1 );
  							break;

  						case SubtractiveBlending:
  							gl.blendFunc( 0, 769 );
  							break;

  						case MultiplyBlending:
  							gl.blendFunc( 0, 768 );
  							break;

  						default:
  							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
  							break;

  					}

  				}

  				currentBlendSrc = null;
  				currentBlendDst = null;
  				currentBlendSrcAlpha = null;
  				currentBlendDstAlpha = null;

  				currentBlending = blending;
  				currentPremultipledAlpha = premultipliedAlpha;

  			}

  			return;

  		}

  		// custom blending

  		blendEquationAlpha = blendEquationAlpha || blendEquation;
  		blendSrcAlpha = blendSrcAlpha || blendSrc;
  		blendDstAlpha = blendDstAlpha || blendDst;

  		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

  			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

  			currentBlendEquation = blendEquation;
  			currentBlendEquationAlpha = blendEquationAlpha;

  		}

  		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

  			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

  			currentBlendSrc = blendSrc;
  			currentBlendDst = blendDst;
  			currentBlendSrcAlpha = blendSrcAlpha;
  			currentBlendDstAlpha = blendDstAlpha;

  		}

  		currentBlending = blending;
  		currentPremultipledAlpha = null;

  	}

  	function setMaterial( material, frontFaceCW ) {

  		material.side === DoubleSide
  			? disable( 2884 )
  			: enable( 2884 );

  		let flipSided = ( material.side === BackSide );
  		if ( frontFaceCW ) flipSided = ! flipSided;

  		setFlipSided( flipSided );

  		( material.blending === NormalBlending && material.transparent === false )
  			? setBlending( NoBlending )
  			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

  		depthBuffer.setFunc( material.depthFunc );
  		depthBuffer.setTest( material.depthTest );
  		depthBuffer.setMask( material.depthWrite );
  		colorBuffer.setMask( material.colorWrite );

  		const stencilWrite = material.stencilWrite;
  		stencilBuffer.setTest( stencilWrite );
  		if ( stencilWrite ) {

  			stencilBuffer.setMask( material.stencilWriteMask );
  			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
  			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

  		}

  		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  		material.alphaToCoverage === true
  			? enable( 32926 )
  			: disable( 32926 );

  	}

  	//

  	function setFlipSided( flipSided ) {

  		if ( currentFlipSided !== flipSided ) {

  			if ( flipSided ) {

  				gl.frontFace( 2304 );

  			} else {

  				gl.frontFace( 2305 );

  			}

  			currentFlipSided = flipSided;

  		}

  	}

  	function setCullFace( cullFace ) {

  		if ( cullFace !== CullFaceNone ) {

  			enable( 2884 );

  			if ( cullFace !== currentCullFace ) {

  				if ( cullFace === CullFaceBack ) {

  					gl.cullFace( 1029 );

  				} else if ( cullFace === CullFaceFront ) {

  					gl.cullFace( 1028 );

  				} else {

  					gl.cullFace( 1032 );

  				}

  			}

  		} else {

  			disable( 2884 );

  		}

  		currentCullFace = cullFace;

  	}

  	function setLineWidth( width ) {

  		if ( width !== currentLineWidth ) {

  			if ( lineWidthAvailable ) gl.lineWidth( width );

  			currentLineWidth = width;

  		}

  	}

  	function setPolygonOffset( polygonOffset, factor, units ) {

  		if ( polygonOffset ) {

  			enable( 32823 );

  			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

  				gl.polygonOffset( factor, units );

  				currentPolygonOffsetFactor = factor;
  				currentPolygonOffsetUnits = units;

  			}

  		} else {

  			disable( 32823 );

  		}

  	}

  	function setScissorTest( scissorTest ) {

  		if ( scissorTest ) {

  			enable( 3089 );

  		} else {

  			disable( 3089 );

  		}

  	}

  	// texture

  	function activeTexture( webglSlot ) {

  		if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

  		if ( currentTextureSlot !== webglSlot ) {

  			gl.activeTexture( webglSlot );
  			currentTextureSlot = webglSlot;

  		}

  	}

  	function bindTexture( webglType, webglTexture ) {

  		if ( currentTextureSlot === null ) {

  			activeTexture();

  		}

  		let boundTexture = currentBoundTextures[ currentTextureSlot ];

  		if ( boundTexture === undefined ) {

  			boundTexture = { type: undefined, texture: undefined };
  			currentBoundTextures[ currentTextureSlot ] = boundTexture;

  		}

  		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

  			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

  			boundTexture.type = webglType;
  			boundTexture.texture = webglTexture;

  		}

  	}

  	function unbindTexture() {

  		const boundTexture = currentBoundTextures[ currentTextureSlot ];

  		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

  			gl.bindTexture( boundTexture.type, null );

  			boundTexture.type = undefined;
  			boundTexture.texture = undefined;

  		}

  	}

  	function compressedTexImage2D() {

  		try {

  			gl.compressedTexImage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texImage2D() {

  		try {

  			gl.texImage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texImage3D() {

  		try {

  			gl.texImage3D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	//

  	function scissor( scissor ) {

  		if ( currentScissor.equals( scissor ) === false ) {

  			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
  			currentScissor.copy( scissor );

  		}

  	}

  	function viewport( viewport ) {

  		if ( currentViewport.equals( viewport ) === false ) {

  			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
  			currentViewport.copy( viewport );

  		}

  	}

  	//

  	function reset() {

  		// reset state

  		gl.disable( 3042 );
  		gl.disable( 2884 );
  		gl.disable( 2929 );
  		gl.disable( 32823 );
  		gl.disable( 3089 );
  		gl.disable( 2960 );
  		gl.disable( 32926 );

  		gl.blendEquation( 32774 );
  		gl.blendFunc( 1, 0 );
  		gl.blendFuncSeparate( 1, 0, 1, 0 );

  		gl.colorMask( true, true, true, true );
  		gl.clearColor( 0, 0, 0, 0 );

  		gl.depthMask( true );
  		gl.depthFunc( 513 );
  		gl.clearDepth( 1 );

  		gl.stencilMask( 0xffffffff );
  		gl.stencilFunc( 519, 0, 0xffffffff );
  		gl.stencilOp( 7680, 7680, 7680 );
  		gl.clearStencil( 0 );

  		gl.cullFace( 1029 );
  		gl.frontFace( 2305 );

  		gl.polygonOffset( 0, 0 );

  		gl.activeTexture( 33984 );

  		gl.bindFramebuffer( 36160, null );

  		if ( isWebGL2 === true ) {

  			gl.bindFramebuffer( 36009, null );
  			gl.bindFramebuffer( 36008, null );

  		}

  		gl.useProgram( null );

  		gl.lineWidth( 1 );

  		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
  		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

  		// reset internals

  		enabledCapabilities = {};

  		currentTextureSlot = null;
  		currentBoundTextures = {};

  		xrFramebuffer = null;
  		currentBoundFramebuffers = {};

  		currentProgram = null;

  		currentBlendingEnabled = false;
  		currentBlending = null;
  		currentBlendEquation = null;
  		currentBlendSrc = null;
  		currentBlendDst = null;
  		currentBlendEquationAlpha = null;
  		currentBlendSrcAlpha = null;
  		currentBlendDstAlpha = null;
  		currentPremultipledAlpha = false;

  		currentFlipSided = null;
  		currentCullFace = null;

  		currentLineWidth = null;

  		currentPolygonOffsetFactor = null;
  		currentPolygonOffsetUnits = null;

  		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
  		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

  		colorBuffer.reset();
  		depthBuffer.reset();
  		stencilBuffer.reset();

  	}

  	return {

  		buffers: {
  			color: colorBuffer,
  			depth: depthBuffer,
  			stencil: stencilBuffer
  		},

  		enable: enable,
  		disable: disable,

  		bindFramebuffer: bindFramebuffer,
  		bindXRFramebuffer: bindXRFramebuffer,

  		useProgram: useProgram,

  		setBlending: setBlending,
  		setMaterial: setMaterial,

  		setFlipSided: setFlipSided,
  		setCullFace: setCullFace,

  		setLineWidth: setLineWidth,
  		setPolygonOffset: setPolygonOffset,

  		setScissorTest: setScissorTest,

  		activeTexture: activeTexture,
  		bindTexture: bindTexture,
  		unbindTexture: unbindTexture,
  		compressedTexImage2D: compressedTexImage2D,
  		texImage2D: texImage2D,
  		texImage3D: texImage3D,

  		scissor: scissor,
  		viewport: viewport,

  		reset: reset

  	};

  }

  function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

  	const isWebGL2 = capabilities.isWebGL2;
  	const maxTextures = capabilities.maxTextures;
  	const maxCubemapSize = capabilities.maxCubemapSize;
  	const maxTextureSize = capabilities.maxTextureSize;
  	const maxSamples = capabilities.maxSamples;

  	const _videoTextures = new WeakMap();
  	let _canvas;

  	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
  	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
  	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

  	let useOffscreenCanvas = false;

  	try {

  		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
  			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

  	} catch ( err ) {

  		// Ignore any errors

  	}

  	function createCanvas( width, height ) {

  		// Use OffscreenCanvas when available. Specially needed in web workers

  		return useOffscreenCanvas ?
  			new OffscreenCanvas( width, height ) :
  			document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

  	}

  	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

  		let scale = 1;

  		// handle case if texture exceeds max size

  		if ( image.width > maxSize || image.height > maxSize ) {

  			scale = maxSize / Math.max( image.width, image.height );

  		}

  		// only perform resize if necessary

  		if ( scale < 1 || needsPowerOfTwo === true ) {

  			// only perform resize for certain image types

  			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

  				const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;

  				const width = floor( scale * image.width );
  				const height = floor( scale * image.height );

  				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

  				// cube textures can't reuse the same canvas

  				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

  				canvas.width = width;
  				canvas.height = height;

  				const context = canvas.getContext( '2d' );
  				context.drawImage( image, 0, 0, width, height );

  				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

  				return canvas;

  			} else {

  				if ( 'data' in image ) {

  					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

  				}

  				return image;

  			}

  		}

  		return image;

  	}

  	function isPowerOfTwo$1( image ) {

  		return isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );

  	}

  	function textureNeedsPowerOfTwo( texture ) {

  		if ( isWebGL2 ) return false;

  		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
  			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

  	}

  	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

  		return texture.generateMipmaps && supportsMips &&
  			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

  	}

  	function generateMipmap( target, texture, width, height ) {

  		_gl.generateMipmap( target );

  		const textureProperties = properties.get( texture );

  		textureProperties.__maxMipLevel = Math.log2( Math.max( width, height ) );

  	}

  	function getInternalFormat( internalFormatName, glFormat, glType ) {

  		if ( isWebGL2 === false ) return glFormat;

  		if ( internalFormatName !== null ) {

  			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

  			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

  		}

  		let internalFormat = glFormat;

  		if ( glFormat === 6403 ) {

  			if ( glType === 5126 ) internalFormat = 33326;
  			if ( glType === 5131 ) internalFormat = 33325;
  			if ( glType === 5121 ) internalFormat = 33321;

  		}

  		if ( glFormat === 6407 ) {

  			if ( glType === 5126 ) internalFormat = 34837;
  			if ( glType === 5131 ) internalFormat = 34843;
  			if ( glType === 5121 ) internalFormat = 32849;

  		}

  		if ( glFormat === 6408 ) {

  			if ( glType === 5126 ) internalFormat = 34836;
  			if ( glType === 5131 ) internalFormat = 34842;
  			if ( glType === 5121 ) internalFormat = 32856;

  		}

  		if ( internalFormat === 33325 || internalFormat === 33326 ||
  			internalFormat === 34842 || internalFormat === 34836 ) {

  			extensions.get( 'EXT_color_buffer_float' );

  		}

  		return internalFormat;

  	}

  	// Fallback filters for non-power-of-2 textures

  	function filterFallback( f ) {

  		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

  			return 9728;

  		}

  		return 9729;

  	}

  	//

  	function onTextureDispose( event ) {

  		const texture = event.target;

  		texture.removeEventListener( 'dispose', onTextureDispose );

  		deallocateTexture( texture );

  		if ( texture.isVideoTexture ) {

  			_videoTextures.delete( texture );

  		}

  		info.memory.textures --;

  	}

  	function onRenderTargetDispose( event ) {

  		const renderTarget = event.target;

  		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

  		deallocateRenderTarget( renderTarget );

  	}

  	//

  	function deallocateTexture( texture ) {

  		const textureProperties = properties.get( texture );

  		if ( textureProperties.__webglInit === undefined ) return;

  		_gl.deleteTexture( textureProperties.__webglTexture );

  		properties.remove( texture );

  	}

  	function deallocateRenderTarget( renderTarget ) {

  		const texture = renderTarget.texture;

  		const renderTargetProperties = properties.get( renderTarget );
  		const textureProperties = properties.get( texture );

  		if ( ! renderTarget ) return;

  		if ( textureProperties.__webglTexture !== undefined ) {

  			_gl.deleteTexture( textureProperties.__webglTexture );

  			info.memory.textures --;

  		}

  		if ( renderTarget.depthTexture ) {

  			renderTarget.depthTexture.dispose();

  		}

  		if ( renderTarget.isWebGLCubeRenderTarget ) {

  			for ( let i = 0; i < 6; i ++ ) {

  				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
  				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

  			}

  		} else {

  			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
  			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
  			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
  			if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
  			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

  		}

  		if ( renderTarget.isWebGLMultipleRenderTargets ) {

  			for ( let i = 0, il = texture.length; i < il; i ++ ) {

  				const attachmentProperties = properties.get( texture[ i ] );

  				if ( attachmentProperties.__webglTexture ) {

  					_gl.deleteTexture( attachmentProperties.__webglTexture );

  					info.memory.textures --;

  				}

  				properties.remove( texture[ i ] );

  			}

  		}

  		properties.remove( texture );
  		properties.remove( renderTarget );

  	}

  	//

  	let textureUnits = 0;

  	function resetTextureUnits() {

  		textureUnits = 0;

  	}

  	function allocateTextureUnit() {

  		const textureUnit = textureUnits;

  		if ( textureUnit >= maxTextures ) {

  			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

  		}

  		textureUnits += 1;

  		return textureUnit;

  	}

  	//

  	function setTexture2D( texture, slot ) {

  		const textureProperties = properties.get( texture );

  		if ( texture.isVideoTexture ) updateVideoTexture( texture );

  		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  			const image = texture.image;

  			if ( image === undefined ) {

  				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

  			} else if ( image.complete === false ) {

  				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

  			} else {

  				uploadTexture( textureProperties, texture, slot );
  				return;

  			}

  		}

  		state.activeTexture( 33984 + slot );
  		state.bindTexture( 3553, textureProperties.__webglTexture );

  	}

  	function setTexture2DArray( texture, slot ) {

  		const textureProperties = properties.get( texture );

  		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  			uploadTexture( textureProperties, texture, slot );
  			return;

  		}

  		state.activeTexture( 33984 + slot );
  		state.bindTexture( 35866, textureProperties.__webglTexture );

  	}

  	function setTexture3D( texture, slot ) {

  		const textureProperties = properties.get( texture );

  		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  			uploadTexture( textureProperties, texture, slot );
  			return;

  		}

  		state.activeTexture( 33984 + slot );
  		state.bindTexture( 32879, textureProperties.__webglTexture );

  	}

  	function setTextureCube( texture, slot ) {

  		const textureProperties = properties.get( texture );

  		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  			uploadCubeTexture( textureProperties, texture, slot );
  			return;

  		}

  		state.activeTexture( 33984 + slot );
  		state.bindTexture( 34067, textureProperties.__webglTexture );

  	}

  	const wrappingToGL = {
  		[ RepeatWrapping ]: 10497,
  		[ ClampToEdgeWrapping ]: 33071,
  		[ MirroredRepeatWrapping ]: 33648
  	};

  	const filterToGL = {
  		[ NearestFilter ]: 9728,
  		[ NearestMipmapNearestFilter ]: 9984,
  		[ NearestMipmapLinearFilter ]: 9986,

  		[ LinearFilter ]: 9729,
  		[ LinearMipmapNearestFilter ]: 9985,
  		[ LinearMipmapLinearFilter ]: 9987
  	};

  	function setTextureParameters( textureType, texture, supportsMips ) {

  		if ( supportsMips ) {

  			_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
  			_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

  			if ( textureType === 32879 || textureType === 35866 ) {

  				_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

  			}

  			_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
  			_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

  		} else {

  			_gl.texParameteri( textureType, 10242, 33071 );
  			_gl.texParameteri( textureType, 10243, 33071 );

  			if ( textureType === 32879 || textureType === 35866 ) {

  				_gl.texParameteri( textureType, 32882, 33071 );

  			}

  			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

  				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

  			}

  			_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
  			_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

  			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

  				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

  			}

  		}

  		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

  			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
  			if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

  			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

  				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
  				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

  			}

  		}

  	}

  	function initTexture( textureProperties, texture ) {

  		if ( textureProperties.__webglInit === undefined ) {

  			textureProperties.__webglInit = true;

  			texture.addEventListener( 'dispose', onTextureDispose );

  			textureProperties.__webglTexture = _gl.createTexture();

  			info.memory.textures ++;

  		}

  	}

  	function uploadTexture( textureProperties, texture, slot ) {

  		let textureType = 3553;

  		if ( texture.isDataTexture2DArray ) textureType = 35866;
  		if ( texture.isDataTexture3D ) textureType = 32879;

  		initTexture( textureProperties, texture );

  		state.activeTexture( 33984 + slot );
  		state.bindTexture( textureType, textureProperties.__webglTexture );

  		_gl.pixelStorei( 37440, texture.flipY );
  		_gl.pixelStorei( 37441, texture.premultiplyAlpha );
  		_gl.pixelStorei( 3317, texture.unpackAlignment );
  		_gl.pixelStorei( 37443, 0 );

  		const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
  		const image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

  		const supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
  			glFormat = utils.convert( texture.format );

  		let glType = utils.convert( texture.type ),
  			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

  		setTextureParameters( textureType, texture, supportsMips );

  		let mipmap;
  		const mipmaps = texture.mipmaps;

  		if ( texture.isDepthTexture ) {

  			// populate depth texture with dummy data

  			glInternalFormat = 6402;

  			if ( isWebGL2 ) {

  				if ( texture.type === FloatType ) {

  					glInternalFormat = 36012;

  				} else if ( texture.type === UnsignedIntType ) {

  					glInternalFormat = 33190;

  				} else if ( texture.type === UnsignedInt248Type ) {

  					glInternalFormat = 35056;

  				} else {

  					glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

  				}

  			} else {

  				if ( texture.type === FloatType ) {

  					console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

  				}

  			}

  			// validation checks for WebGL 1

  			if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

  				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
  				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

  					console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

  					texture.type = UnsignedShortType;
  					glType = utils.convert( texture.type );

  				}

  			}

  			if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

  				// Depth stencil textures need the DEPTH_STENCIL internal format
  				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  				glInternalFormat = 34041;

  				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
  				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  				if ( texture.type !== UnsignedInt248Type ) {

  					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

  					texture.type = UnsignedInt248Type;
  					glType = utils.convert( texture.type );

  				}

  			}

  			//

  			state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

  		} else if ( texture.isDataTexture ) {

  			// use manually created mipmaps if available
  			// if there are no manual mipmaps
  			// set 0 level mipmap and then use GL to generate other mipmap levels

  			if ( mipmaps.length > 0 && supportsMips ) {

  				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

  					mipmap = mipmaps[ i ];
  					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  				}

  				texture.generateMipmaps = false;
  				textureProperties.__maxMipLevel = mipmaps.length - 1;

  			} else {

  				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
  				textureProperties.__maxMipLevel = 0;

  			}

  		} else if ( texture.isCompressedTexture ) {

  			for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

  				mipmap = mipmaps[ i ];

  				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

  					if ( glFormat !== null ) {

  						state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  					} else {

  						console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

  					}

  				} else {

  					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  				}

  			}

  			textureProperties.__maxMipLevel = mipmaps.length - 1;

  		} else if ( texture.isDataTexture2DArray ) {

  			state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
  			textureProperties.__maxMipLevel = 0;

  		} else if ( texture.isDataTexture3D ) {

  			state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
  			textureProperties.__maxMipLevel = 0;

  		} else {

  			// regular Texture (image, video, canvas)

  			// use manually created mipmaps if available
  			// if there are no manual mipmaps
  			// set 0 level mipmap and then use GL to generate other mipmap levels

  			if ( mipmaps.length > 0 && supportsMips ) {

  				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

  					mipmap = mipmaps[ i ];
  					state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

  				}

  				texture.generateMipmaps = false;
  				textureProperties.__maxMipLevel = mipmaps.length - 1;

  			} else {

  				state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
  				textureProperties.__maxMipLevel = 0;

  			}

  		}

  		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

  			generateMipmap( textureType, texture, image.width, image.height );

  		}

  		textureProperties.__version = texture.version;

  		if ( texture.onUpdate ) texture.onUpdate( texture );

  	}

  	function uploadCubeTexture( textureProperties, texture, slot ) {

  		if ( texture.image.length !== 6 ) return;

  		initTexture( textureProperties, texture );

  		state.activeTexture( 33984 + slot );
  		state.bindTexture( 34067, textureProperties.__webglTexture );

  		_gl.pixelStorei( 37440, texture.flipY );
  		_gl.pixelStorei( 37441, texture.premultiplyAlpha );
  		_gl.pixelStorei( 3317, texture.unpackAlignment );
  		_gl.pixelStorei( 37443, 0 );

  		const isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
  		const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

  		const cubeImage = [];

  		for ( let i = 0; i < 6; i ++ ) {

  			if ( ! isCompressed && ! isDataTexture ) {

  				cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

  			} else {

  				cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

  			}

  		}

  		const image = cubeImage[ 0 ],
  			supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
  			glFormat = utils.convert( texture.format ),
  			glType = utils.convert( texture.type ),
  			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

  		setTextureParameters( 34067, texture, supportsMips );

  		let mipmaps;

  		if ( isCompressed ) {

  			for ( let i = 0; i < 6; i ++ ) {

  				mipmaps = cubeImage[ i ].mipmaps;

  				for ( let j = 0; j < mipmaps.length; j ++ ) {

  					const mipmap = mipmaps[ j ];

  					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

  						if ( glFormat !== null ) {

  							state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  						} else {

  							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

  						}

  					} else {

  						state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  					}

  				}

  			}

  			textureProperties.__maxMipLevel = mipmaps.length - 1;

  		} else {

  			mipmaps = texture.mipmaps;

  			for ( let i = 0; i < 6; i ++ ) {

  				if ( isDataTexture ) {

  					state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

  					for ( let j = 0; j < mipmaps.length; j ++ ) {

  						const mipmap = mipmaps[ j ];
  						const mipmapImage = mipmap.image[ i ].image;

  						state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

  					}

  				} else {

  					state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

  					for ( let j = 0; j < mipmaps.length; j ++ ) {

  						const mipmap = mipmaps[ j ];

  						state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

  					}

  				}

  			}

  			textureProperties.__maxMipLevel = mipmaps.length;

  		}

  		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

  			// We assume images for cube map have the same size.
  			generateMipmap( 34067, texture, image.width, image.height );

  		}

  		textureProperties.__version = texture.version;

  		if ( texture.onUpdate ) texture.onUpdate( texture );

  	}

  	// Render targets

  	// Setup storage for target texture and bind it to correct framebuffer
  	function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {

  		const glFormat = utils.convert( texture.format );
  		const glType = utils.convert( texture.type );
  		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

  		if ( textureTarget === 32879 || textureTarget === 35866 ) {

  			state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

  		} else {

  			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

  		}

  		state.bindFramebuffer( 36160, framebuffer );
  		_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );
  		state.bindFramebuffer( 36160, null );

  	}

  	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

  		_gl.bindRenderbuffer( 36161, renderbuffer );

  		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

  			let glInternalFormat = 33189;

  			if ( isMultisample ) {

  				const depthTexture = renderTarget.depthTexture;

  				if ( depthTexture && depthTexture.isDepthTexture ) {

  					if ( depthTexture.type === FloatType ) {

  						glInternalFormat = 36012;

  					} else if ( depthTexture.type === UnsignedIntType ) {

  						glInternalFormat = 33190;

  					}

  				}

  				const samples = getRenderTargetSamples( renderTarget );

  				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  			} else {

  				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

  			}

  			_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

  		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

  			if ( isMultisample ) {

  				const samples = getRenderTargetSamples( renderTarget );

  				_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

  			} else {

  				_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

  			}


  			_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

  		} else {

  			// Use the first texture for MRT so far
  			const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[ 0 ] : renderTarget.texture;

  			const glFormat = utils.convert( texture.format );
  			const glType = utils.convert( texture.type );
  			const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

  			if ( isMultisample ) {

  				const samples = getRenderTargetSamples( renderTarget );

  				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  			} else {

  				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

  			}

  		}

  		_gl.bindRenderbuffer( 36161, null );

  	}

  	// Setup resources for a Depth Texture for a FBO (needs an extension)
  	function setupDepthTexture( framebuffer, renderTarget ) {

  		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
  		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

  		state.bindFramebuffer( 36160, framebuffer );

  		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

  			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

  		}

  		// upload an empty depth texture with framebuffer size
  		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
  				renderTarget.depthTexture.image.width !== renderTarget.width ||
  				renderTarget.depthTexture.image.height !== renderTarget.height ) {

  			renderTarget.depthTexture.image.width = renderTarget.width;
  			renderTarget.depthTexture.image.height = renderTarget.height;
  			renderTarget.depthTexture.needsUpdate = true;

  		}

  		setTexture2D( renderTarget.depthTexture, 0 );

  		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

  		if ( renderTarget.depthTexture.format === DepthFormat ) {

  			_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

  		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

  			_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

  		} else {

  			throw new Error( 'Unknown depthTexture format' );

  		}

  	}

  	// Setup GL resources for a non-texture depth buffer
  	function setupDepthRenderbuffer( renderTarget ) {

  		const renderTargetProperties = properties.get( renderTarget );

  		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

  		if ( renderTarget.depthTexture ) {

  			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

  			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

  		} else {

  			if ( isCube ) {

  				renderTargetProperties.__webglDepthbuffer = [];

  				for ( let i = 0; i < 6; i ++ ) {

  					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
  					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
  					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

  				}

  			} else {

  				state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
  				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
  				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

  			}

  		}

  		state.bindFramebuffer( 36160, null );

  	}

  	// Set up GL resources for the render target
  	function setupRenderTarget( renderTarget ) {

  		const texture = renderTarget.texture;

  		const renderTargetProperties = properties.get( renderTarget );
  		const textureProperties = properties.get( texture );

  		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

  		if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {

  			textureProperties.__webglTexture = _gl.createTexture();
  			textureProperties.__version = texture.version;
  			info.memory.textures ++;

  		}

  		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
  		const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );
  		const isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
  		const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
  		const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

  		// Handles WebGL2 RGBFormat fallback - #18858

  		if ( isWebGL2 && texture.format === RGBFormat && ( texture.type === FloatType || texture.type === HalfFloatType ) ) {

  			texture.format = RGBAFormat;

  			console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

  		}

  		// Setup framebuffer

  		if ( isCube ) {

  			renderTargetProperties.__webglFramebuffer = [];

  			for ( let i = 0; i < 6; i ++ ) {

  				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

  			}

  		} else {

  			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

  			if ( isMultipleRenderTargets ) {

  				if ( capabilities.drawBuffers ) {

  					const textures = renderTarget.texture;

  					for ( let i = 0, il = textures.length; i < il; i ++ ) {

  						const attachmentProperties = properties.get( textures[ i ] );

  						if ( attachmentProperties.__webglTexture === undefined ) {

  							attachmentProperties.__webglTexture = _gl.createTexture();

  							info.memory.textures ++;

  						}

  					}

  				} else {

  					console.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );

  				}

  			} else if ( isMultisample ) {

  				if ( isWebGL2 ) {

  					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
  					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

  					_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

  					const glFormat = utils.convert( texture.format );
  					const glType = utils.convert( texture.type );
  					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );
  					const samples = getRenderTargetSamples( renderTarget );
  					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  					state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
  					_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
  					_gl.bindRenderbuffer( 36161, null );

  					if ( renderTarget.depthBuffer ) {

  						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
  						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

  					}

  					state.bindFramebuffer( 36160, null );


  				} else {

  					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

  				}

  			}

  		}

  		// Setup color buffer

  		if ( isCube ) {

  			state.bindTexture( 34067, textureProperties.__webglTexture );
  			setTextureParameters( 34067, texture, supportsMips );

  			for ( let i = 0; i < 6; i ++ ) {

  				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, 36064, 34069 + i );

  			}

  			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

  				generateMipmap( 34067, texture, renderTarget.width, renderTarget.height );

  			}

  			state.bindTexture( 34067, null );

  		} else if ( isMultipleRenderTargets ) {

  			const textures = renderTarget.texture;

  			for ( let i = 0, il = textures.length; i < il; i ++ ) {

  				const attachment = textures[ i ];
  				const attachmentProperties = properties.get( attachment );

  				state.bindTexture( 3553, attachmentProperties.__webglTexture );
  				setTextureParameters( 3553, attachment, supportsMips );
  				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553 );

  				if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {

  					generateMipmap( 3553, attachment, renderTarget.width, renderTarget.height );

  				}

  			}

  			state.bindTexture( 3553, null );

  		} else {

  			let glTextureType = 3553;

  			if ( isRenderTarget3D ) {

  				// Render targets containing layers, i.e: Texture 3D and 2d arrays

  				if ( isWebGL2 ) {

  					const isTexture3D = texture.isDataTexture3D;
  					glTextureType = isTexture3D ? 32879 : 35866;

  				} else {

  					console.warn( 'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.' );

  				}

  			}

  			state.bindTexture( glTextureType, textureProperties.__webglTexture );
  			setTextureParameters( glTextureType, texture, supportsMips );
  			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType );

  			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

  				generateMipmap( 3553, texture, renderTarget.width, renderTarget.height );

  			}

  			state.bindTexture( 3553, null );

  		}

  		// Setup depth and stencil buffers

  		if ( renderTarget.depthBuffer ) {

  			setupDepthRenderbuffer( renderTarget );

  		}

  	}

  	function updateRenderTargetMipmap( renderTarget ) {

  		const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

  		const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

  		for ( let i = 0, il = textures.length; i < il; i ++ ) {

  			const texture = textures[ i ];

  			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

  				const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
  				const webglTexture = properties.get( texture ).__webglTexture;

  				state.bindTexture( target, webglTexture );
  				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
  				state.bindTexture( target, null );

  			}

  		}

  	}

  	function updateMultisampleRenderTarget( renderTarget ) {

  		if ( renderTarget.isWebGLMultisampleRenderTarget ) {

  			if ( isWebGL2 ) {

  				const width = renderTarget.width;
  				const height = renderTarget.height;
  				let mask = 16384;

  				if ( renderTarget.depthBuffer ) mask |= 256;
  				if ( renderTarget.stencilBuffer ) mask |= 1024;

  				const renderTargetProperties = properties.get( renderTarget );

  				state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
  				state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

  				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

  				state.bindFramebuffer( 36008, null );
  				state.bindFramebuffer( 36009, renderTargetProperties.__webglMultisampledFramebuffer );

  			} else {

  				console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

  			}

  		}

  	}

  	function getRenderTargetSamples( renderTarget ) {

  		return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
  			Math.min( maxSamples, renderTarget.samples ) : 0;

  	}

  	function updateVideoTexture( texture ) {

  		const frame = info.render.frame;

  		// Check the last frame we updated the VideoTexture

  		if ( _videoTextures.get( texture ) !== frame ) {

  			_videoTextures.set( texture, frame );
  			texture.update();

  		}

  	}

  	// backwards compatibility

  	let warnedTexture2D = false;
  	let warnedTextureCube = false;

  	function safeSetTexture2D( texture, slot ) {

  		if ( texture && texture.isWebGLRenderTarget ) {

  			if ( warnedTexture2D === false ) {

  				console.warn( 'THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.' );
  				warnedTexture2D = true;

  			}

  			texture = texture.texture;

  		}

  		setTexture2D( texture, slot );

  	}

  	function safeSetTextureCube( texture, slot ) {

  		if ( texture && texture.isWebGLCubeRenderTarget ) {

  			if ( warnedTextureCube === false ) {

  				console.warn( 'THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.' );
  				warnedTextureCube = true;

  			}

  			texture = texture.texture;

  		}


  		setTextureCube( texture, slot );

  	}

  	//

  	this.allocateTextureUnit = allocateTextureUnit;
  	this.resetTextureUnits = resetTextureUnits;

  	this.setTexture2D = setTexture2D;
  	this.setTexture2DArray = setTexture2DArray;
  	this.setTexture3D = setTexture3D;
  	this.setTextureCube = setTextureCube;
  	this.setupRenderTarget = setupRenderTarget;
  	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

  	this.safeSetTexture2D = safeSetTexture2D;
  	this.safeSetTextureCube = safeSetTextureCube;

  }

  function WebGLUtils( gl, extensions, capabilities ) {

  	const isWebGL2 = capabilities.isWebGL2;

  	function convert( p ) {

  		let extension;

  		if ( p === UnsignedByteType ) return 5121;
  		if ( p === UnsignedShort4444Type ) return 32819;
  		if ( p === UnsignedShort5551Type ) return 32820;
  		if ( p === UnsignedShort565Type ) return 33635;

  		if ( p === ByteType ) return 5120;
  		if ( p === ShortType ) return 5122;
  		if ( p === UnsignedShortType ) return 5123;
  		if ( p === IntType ) return 5124;
  		if ( p === UnsignedIntType ) return 5125;
  		if ( p === FloatType ) return 5126;

  		if ( p === HalfFloatType ) {

  			if ( isWebGL2 ) return 5131;

  			extension = extensions.get( 'OES_texture_half_float' );

  			if ( extension !== null ) {

  				return extension.HALF_FLOAT_OES;

  			} else {

  				return null;

  			}

  		}

  		if ( p === AlphaFormat ) return 6406;
  		if ( p === RGBFormat ) return 6407;
  		if ( p === RGBAFormat ) return 6408;
  		if ( p === LuminanceFormat ) return 6409;
  		if ( p === LuminanceAlphaFormat ) return 6410;
  		if ( p === DepthFormat ) return 6402;
  		if ( p === DepthStencilFormat ) return 34041;
  		if ( p === RedFormat ) return 6403;

  		// WebGL2 formats.

  		if ( p === RedIntegerFormat ) return 36244;
  		if ( p === RGFormat ) return 33319;
  		if ( p === RGIntegerFormat ) return 33320;
  		if ( p === RGBIntegerFormat ) return 36248;
  		if ( p === RGBAIntegerFormat ) return 36249;

  		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
  			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

  			if ( extension !== null ) {

  				if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
  				if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
  				if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
  				if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

  			} else {

  				return null;

  			}

  		}

  		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
  			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  			if ( extension !== null ) {

  				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
  				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
  				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
  				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

  			} else {

  				return null;

  			}

  		}

  		if ( p === RGB_ETC1_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

  			if ( extension !== null ) {

  				return extension.COMPRESSED_RGB_ETC1_WEBGL;

  			} else {

  				return null;

  			}

  		}

  		if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

  			if ( extension !== null ) {

  				if ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;
  				if ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

  			}

  		}

  		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
  			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
  			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
  			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
  			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
  			p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
  			p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
  			p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
  			p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
  			p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

  			if ( extension !== null ) {

  				// TODO Complete?

  				return p;

  			} else {

  				return null;

  			}

  		}

  		if ( p === RGBA_BPTC_Format ) {

  			extension = extensions.get( 'EXT_texture_compression_bptc' );

  			if ( extension !== null ) {

  				// TODO Complete?

  				return p;

  			} else {

  				return null;

  			}

  		}

  		if ( p === UnsignedInt248Type ) {

  			if ( isWebGL2 ) return 34042;

  			extension = extensions.get( 'WEBGL_depth_texture' );

  			if ( extension !== null ) {

  				return extension.UNSIGNED_INT_24_8_WEBGL;

  			} else {

  				return null;

  			}

  		}

  	}

  	return { convert: convert };

  }

  class ArrayCamera extends PerspectiveCamera {

  	constructor( array = [] ) {

  		super();

  		this.cameras = array;

  	}

  }

  ArrayCamera.prototype.isArrayCamera = true;

  class Group extends Object3D {

  	constructor() {

  		super();

  		this.type = 'Group';

  	}

  }

  Group.prototype.isGroup = true;

  const _moveEvent = { type: 'move' };

  class WebXRController {

  	constructor() {

  		this._targetRay = null;
  		this._grip = null;
  		this._hand = null;

  	}

  	getHandSpace() {

  		if ( this._hand === null ) {

  			this._hand = new Group();
  			this._hand.matrixAutoUpdate = false;
  			this._hand.visible = false;

  			this._hand.joints = {};
  			this._hand.inputState = { pinching: false };

  		}

  		return this._hand;

  	}

  	getTargetRaySpace() {

  		if ( this._targetRay === null ) {

  			this._targetRay = new Group();
  			this._targetRay.matrixAutoUpdate = false;
  			this._targetRay.visible = false;
  			this._targetRay.hasLinearVelocity = false;
  			this._targetRay.linearVelocity = new Vector3();
  			this._targetRay.hasAngularVelocity = false;
  			this._targetRay.angularVelocity = new Vector3();

  		}

  		return this._targetRay;

  	}

  	getGripSpace() {

  		if ( this._grip === null ) {

  			this._grip = new Group();
  			this._grip.matrixAutoUpdate = false;
  			this._grip.visible = false;
  			this._grip.hasLinearVelocity = false;
  			this._grip.linearVelocity = new Vector3();
  			this._grip.hasAngularVelocity = false;
  			this._grip.angularVelocity = new Vector3();

  		}

  		return this._grip;

  	}

  	dispatchEvent( event ) {

  		if ( this._targetRay !== null ) {

  			this._targetRay.dispatchEvent( event );

  		}

  		if ( this._grip !== null ) {

  			this._grip.dispatchEvent( event );

  		}

  		if ( this._hand !== null ) {

  			this._hand.dispatchEvent( event );

  		}

  		return this;

  	}

  	disconnect( inputSource ) {

  		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

  		if ( this._targetRay !== null ) {

  			this._targetRay.visible = false;

  		}

  		if ( this._grip !== null ) {

  			this._grip.visible = false;

  		}

  		if ( this._hand !== null ) {

  			this._hand.visible = false;

  		}

  		return this;

  	}

  	update( inputSource, frame, referenceSpace ) {

  		let inputPose = null;
  		let gripPose = null;
  		let handPose = null;

  		const targetRay = this._targetRay;
  		const grip = this._grip;
  		const hand = this._hand;

  		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

  			if ( targetRay !== null ) {

  				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

  				if ( inputPose !== null ) {

  					targetRay.matrix.fromArray( inputPose.transform.matrix );
  					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

  					if ( inputPose.linearVelocity ) {

  						targetRay.hasLinearVelocity = true;
  						targetRay.linearVelocity.copy( inputPose.linearVelocity );

  					} else {

  						targetRay.hasLinearVelocity = false;

  					}

  					if ( inputPose.angularVelocity ) {

  						targetRay.hasAngularVelocity = true;
  						targetRay.angularVelocity.copy( inputPose.angularVelocity );

  					} else {

  						targetRay.hasAngularVelocity = false;

  					}

  					this.dispatchEvent( _moveEvent );

  				}

  			}

  			if ( hand && inputSource.hand ) {

  				handPose = true;

  				for ( const inputjoint of inputSource.hand.values() ) {

  					// Update the joints groups with the XRJoint poses
  					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

  					if ( hand.joints[ inputjoint.jointName ] === undefined ) {

  						// The transform of this joint will be updated with the joint pose on each frame
  						const joint = new Group();
  						joint.matrixAutoUpdate = false;
  						joint.visible = false;
  						hand.joints[ inputjoint.jointName ] = joint;
  						// ??
  						hand.add( joint );

  					}

  					const joint = hand.joints[ inputjoint.jointName ];

  					if ( jointPose !== null ) {

  						joint.matrix.fromArray( jointPose.transform.matrix );
  						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
  						joint.jointRadius = jointPose.radius;

  					}

  					joint.visible = jointPose !== null;

  				}

  				// Custom events

  				// Check pinchz
  				const indexTip = hand.joints[ 'index-finger-tip' ];
  				const thumbTip = hand.joints[ 'thumb-tip' ];
  				const distance = indexTip.position.distanceTo( thumbTip.position );

  				const distanceToPinch = 0.02;
  				const threshold = 0.005;

  				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

  					hand.inputState.pinching = false;
  					this.dispatchEvent( {
  						type: 'pinchend',
  						handedness: inputSource.handedness,
  						target: this
  					} );

  				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

  					hand.inputState.pinching = true;
  					this.dispatchEvent( {
  						type: 'pinchstart',
  						handedness: inputSource.handedness,
  						target: this
  					} );

  				}

  			} else {

  				if ( grip !== null && inputSource.gripSpace ) {

  					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

  					if ( gripPose !== null ) {

  						grip.matrix.fromArray( gripPose.transform.matrix );
  						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

  						if ( gripPose.linearVelocity ) {

  							grip.hasLinearVelocity = true;
  							grip.linearVelocity.copy( gripPose.linearVelocity );

  						} else {

  							grip.hasLinearVelocity = false;

  						}

  						if ( gripPose.angularVelocity ) {

  							grip.hasAngularVelocity = true;
  							grip.angularVelocity.copy( gripPose.angularVelocity );

  						} else {

  							grip.hasAngularVelocity = false;

  						}

  					}

  				}

  			}

  		}

  		if ( targetRay !== null ) {

  			targetRay.visible = ( inputPose !== null );

  		}

  		if ( grip !== null ) {

  			grip.visible = ( gripPose !== null );

  		}

  		if ( hand !== null ) {

  			hand.visible = ( handPose !== null );

  		}

  		return this;

  	}

  }

  class WebXRManager extends EventDispatcher {

  	constructor( renderer, gl ) {

  		super();

  		const scope = this;
  		const state = renderer.state;

  		let session = null;

  		let framebufferScaleFactor = 1.0;

  		let referenceSpace = null;
  		let referenceSpaceType = 'local-floor';

  		let pose = null;

  		const controllers = [];
  		const inputSourcesMap = new Map();

  		//

  		const cameraL = new PerspectiveCamera();
  		cameraL.layers.enable( 1 );
  		cameraL.viewport = new Vector4$1();

  		const cameraR = new PerspectiveCamera();
  		cameraR.layers.enable( 2 );
  		cameraR.viewport = new Vector4$1();

  		const cameras = [ cameraL, cameraR ];

  		const cameraVR = new ArrayCamera();
  		cameraVR.layers.enable( 1 );
  		cameraVR.layers.enable( 2 );

  		let _currentDepthNear = null;
  		let _currentDepthFar = null;

  		//

  		this.cameraAutoUpdate = true;
  		this.enabled = false;

  		this.isPresenting = false;

  		this.getController = function ( index ) {

  			let controller = controllers[ index ];

  			if ( controller === undefined ) {

  				controller = new WebXRController();
  				controllers[ index ] = controller;

  			}

  			return controller.getTargetRaySpace();

  		};

  		this.getControllerGrip = function ( index ) {

  			let controller = controllers[ index ];

  			if ( controller === undefined ) {

  				controller = new WebXRController();
  				controllers[ index ] = controller;

  			}

  			return controller.getGripSpace();

  		};

  		this.getHand = function ( index ) {

  			let controller = controllers[ index ];

  			if ( controller === undefined ) {

  				controller = new WebXRController();
  				controllers[ index ] = controller;

  			}

  			return controller.getHandSpace();

  		};

  		//

  		function onSessionEvent( event ) {

  			const controller = inputSourcesMap.get( event.inputSource );

  			if ( controller ) {

  				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

  			}

  		}

  		function onSessionEnd() {

  			inputSourcesMap.forEach( function ( controller, inputSource ) {

  				controller.disconnect( inputSource );

  			} );

  			inputSourcesMap.clear();

  			_currentDepthNear = null;
  			_currentDepthFar = null;

  			// restore framebuffer/rendering state

  			state.bindXRFramebuffer( null );
  			renderer.setRenderTarget( renderer.getRenderTarget() );

  			//

  			animation.stop();

  			scope.isPresenting = false;

  			scope.dispatchEvent( { type: 'sessionend' } );

  		}

  		this.setFramebufferScaleFactor = function ( value ) {

  			framebufferScaleFactor = value;

  			if ( scope.isPresenting === true ) {

  				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

  			}

  		};

  		this.setReferenceSpaceType = function ( value ) {

  			referenceSpaceType = value;

  			if ( scope.isPresenting === true ) {

  				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

  			}

  		};

  		this.getReferenceSpace = function () {

  			return referenceSpace;

  		};

  		this.getSession = function () {

  			return session;

  		};

  		this.setSession = async function ( value ) {

  			session = value;

  			if ( session !== null ) {

  				session.addEventListener( 'select', onSessionEvent );
  				session.addEventListener( 'selectstart', onSessionEvent );
  				session.addEventListener( 'selectend', onSessionEvent );
  				session.addEventListener( 'squeeze', onSessionEvent );
  				session.addEventListener( 'squeezestart', onSessionEvent );
  				session.addEventListener( 'squeezeend', onSessionEvent );
  				session.addEventListener( 'end', onSessionEnd );
  				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

  				const attributes = gl.getContextAttributes();

  				if ( attributes.xrCompatible !== true ) {

  					await gl.makeXRCompatible();

  				}

  				const layerInit = {
  					antialias: attributes.antialias,
  					alpha: attributes.alpha,
  					depth: attributes.depth,
  					stencil: attributes.stencil,
  					framebufferScaleFactor: framebufferScaleFactor
  				};

  				// eslint-disable-next-line no-undef
  				const baseLayer = new XRWebGLLayer( session, gl, layerInit );

  				session.updateRenderState( { baseLayer: baseLayer } );

  				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

  				animation.setContext( session );
  				animation.start();

  				scope.isPresenting = true;

  				scope.dispatchEvent( { type: 'sessionstart' } );

  			}

  		};

  		function onInputSourcesChange( event ) {

  			const inputSources = session.inputSources;

  			// Assign inputSources to available controllers

  			for ( let i = 0; i < controllers.length; i ++ ) {

  				inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

  			}

  			// Notify disconnected

  			for ( let i = 0; i < event.removed.length; i ++ ) {

  				const inputSource = event.removed[ i ];
  				const controller = inputSourcesMap.get( inputSource );

  				if ( controller ) {

  					controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
  					inputSourcesMap.delete( inputSource );

  				}

  			}

  			// Notify connected

  			for ( let i = 0; i < event.added.length; i ++ ) {

  				const inputSource = event.added[ i ];
  				const controller = inputSourcesMap.get( inputSource );

  				if ( controller ) {

  					controller.dispatchEvent( { type: 'connected', data: inputSource } );

  				}

  			}

  		}

  		//

  		const cameraLPos = new Vector3();
  		const cameraRPos = new Vector3();

  		/**
  		 * Assumes 2 cameras that are parallel and share an X-axis, and that
  		 * the cameras' projection and world matrices have already been set.
  		 * And that near and far planes are identical for both cameras.
  		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
  		 */
  		function setProjectionFromUnion( camera, cameraL, cameraR ) {

  			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
  			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

  			const ipd = cameraLPos.distanceTo( cameraRPos );

  			const projL = cameraL.projectionMatrix.elements;
  			const projR = cameraR.projectionMatrix.elements;

  			// VR systems will have identical far and near planes, and
  			// most likely identical top and bottom frustum extents.
  			// Use the left camera for these values.
  			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
  			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
  			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
  			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

  			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
  			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
  			const left = near * leftFov;
  			const right = near * rightFov;

  			// Calculate the new camera's position offset from the
  			// left camera. xOffset should be roughly half `ipd`.
  			const zOffset = ipd / ( - leftFov + rightFov );
  			const xOffset = zOffset * - leftFov;

  			// TODO: Better way to apply this offset?
  			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
  			camera.translateX( xOffset );
  			camera.translateZ( zOffset );
  			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
  			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

  			// Find the union of the frustum values of the cameras and scale
  			// the values so that the near plane's position does not change in world space,
  			// although must now be relative to the new union camera.
  			const near2 = near + zOffset;
  			const far2 = far + zOffset;
  			const left2 = left - xOffset;
  			const right2 = right + ( ipd - xOffset );
  			const top2 = topFov * far / far2 * near2;
  			const bottom2 = bottomFov * far / far2 * near2;

  			camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

  		}

  		function updateCamera( camera, parent ) {

  			if ( parent === null ) {

  				camera.matrixWorld.copy( camera.matrix );

  			} else {

  				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

  			}

  			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

  		}

  		this.updateCamera = function ( camera ) {

  			if ( session === null ) return;

  			cameraVR.near = cameraR.near = cameraL.near = camera.near;
  			cameraVR.far = cameraR.far = cameraL.far = camera.far;

  			if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

  				// Note that the new renderState won't apply until the next frame. See #18320

  				session.updateRenderState( {
  					depthNear: cameraVR.near,
  					depthFar: cameraVR.far
  				} );

  				_currentDepthNear = cameraVR.near;
  				_currentDepthFar = cameraVR.far;

  			}

  			const parent = camera.parent;
  			const cameras = cameraVR.cameras;

  			updateCamera( cameraVR, parent );

  			for ( let i = 0; i < cameras.length; i ++ ) {

  				updateCamera( cameras[ i ], parent );

  			}

  			// update camera and its children

  			camera.matrixWorld.copy( cameraVR.matrixWorld );
  			camera.matrix.copy( cameraVR.matrix );
  			camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );

  			const children = camera.children;

  			for ( let i = 0, l = children.length; i < l; i ++ ) {

  				children[ i ].updateMatrixWorld( true );

  			}

  			// update projection matrix for proper view frustum culling

  			if ( cameras.length === 2 ) {

  				setProjectionFromUnion( cameraVR, cameraL, cameraR );

  			} else {

  				// assume single camera setup (AR)

  				cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

  			}

  		};

  		this.getCamera = function () {

  			return cameraVR;

  		};

  		// Animation Loop

  		let onAnimationFrameCallback = null;

  		function onAnimationFrame( time, frame ) {

  			pose = frame.getViewerPose( referenceSpace );

  			if ( pose !== null ) {

  				const views = pose.views;
  				const baseLayer = session.renderState.baseLayer;

  				state.bindXRFramebuffer( baseLayer.framebuffer );

  				let cameraVRNeedsUpdate = false;

  				// check if it's necessary to rebuild cameraVR's camera list

  				if ( views.length !== cameraVR.cameras.length ) {

  					cameraVR.cameras.length = 0;
  					cameraVRNeedsUpdate = true;

  				}

  				for ( let i = 0; i < views.length; i ++ ) {

  					const view = views[ i ];
  					const viewport = baseLayer.getViewport( view );

  					const camera = cameras[ i ];
  					camera.matrix.fromArray( view.transform.matrix );
  					camera.projectionMatrix.fromArray( view.projectionMatrix );
  					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

  					if ( i === 0 ) {

  						cameraVR.matrix.copy( camera.matrix );

  					}

  					if ( cameraVRNeedsUpdate === true ) {

  						cameraVR.cameras.push( camera );

  					}

  				}

  			}

  			//

  			const inputSources = session.inputSources;

  			for ( let i = 0; i < controllers.length; i ++ ) {

  				const controller = controllers[ i ];
  				const inputSource = inputSources[ i ];

  				controller.update( inputSource, frame, referenceSpace );

  			}

  			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

  		}

  		const animation = new WebGLAnimation();
  		animation.setAnimationLoop( onAnimationFrame );

  		this.setAnimationLoop = function ( callback ) {

  			onAnimationFrameCallback = callback;

  		};

  		this.dispose = function () {};

  	}

  }

  function WebGLMaterials( properties ) {

  	function refreshFogUniforms( uniforms, fog ) {

  		uniforms.fogColor.value.copy( fog.color );

  		if ( fog.isFog ) {

  			uniforms.fogNear.value = fog.near;
  			uniforms.fogFar.value = fog.far;

  		} else if ( fog.isFogExp2 ) {

  			uniforms.fogDensity.value = fog.density;

  		}

  	}

  	function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

  		if ( material.isMeshBasicMaterial ) {

  			refreshUniformsCommon( uniforms, material );

  		} else if ( material.isMeshLambertMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsLambert( uniforms, material );

  		} else if ( material.isMeshToonMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsToon( uniforms, material );

  		} else if ( material.isMeshPhongMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsPhong( uniforms, material );

  		} else if ( material.isMeshStandardMaterial ) {

  			refreshUniformsCommon( uniforms, material );

  			if ( material.isMeshPhysicalMaterial ) {

  				refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

  			} else {

  				refreshUniformsStandard( uniforms, material );

  			}

  		} else if ( material.isMeshMatcapMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsMatcap( uniforms, material );

  		} else if ( material.isMeshDepthMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsDepth( uniforms, material );

  		} else if ( material.isMeshDistanceMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsDistance( uniforms, material );

  		} else if ( material.isMeshNormalMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsNormal( uniforms, material );

  		} else if ( material.isLineBasicMaterial ) {

  			refreshUniformsLine( uniforms, material );

  			if ( material.isLineDashedMaterial ) {

  				refreshUniformsDash( uniforms, material );

  			}

  		} else if ( material.isPointsMaterial ) {

  			refreshUniformsPoints( uniforms, material, pixelRatio, height );

  		} else if ( material.isSpriteMaterial ) {

  			refreshUniformsSprites( uniforms, material );

  		} else if ( material.isShadowMaterial ) {

  			uniforms.color.value.copy( material.color );
  			uniforms.opacity.value = material.opacity;

  		} else if ( material.isShaderMaterial ) {

  			material.uniformsNeedUpdate = false; // #15581

  		}

  	}

  	function refreshUniformsCommon( uniforms, material ) {

  		uniforms.opacity.value = material.opacity;

  		if ( material.color ) {

  			uniforms.diffuse.value.copy( material.color );

  		}

  		if ( material.emissive ) {

  			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

  		}

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  		}

  		if ( material.alphaMap ) {

  			uniforms.alphaMap.value = material.alphaMap;

  		}

  		if ( material.specularMap ) {

  			uniforms.specularMap.value = material.specularMap;

  		}

  		const envMap = properties.get( material ).envMap;

  		if ( envMap ) {

  			uniforms.envMap.value = envMap;

  			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap._needsFlipEnvMap ) ? - 1 : 1;

  			uniforms.reflectivity.value = material.reflectivity;
  			uniforms.refractionRatio.value = material.refractionRatio;

  			const maxMipLevel = properties.get( envMap ).__maxMipLevel;

  			if ( maxMipLevel !== undefined ) {

  				uniforms.maxMipLevel.value = maxMipLevel;

  			}

  		}

  		if ( material.lightMap ) {

  			uniforms.lightMap.value = material.lightMap;
  			uniforms.lightMapIntensity.value = material.lightMapIntensity;

  		}

  		if ( material.aoMap ) {

  			uniforms.aoMap.value = material.aoMap;
  			uniforms.aoMapIntensity.value = material.aoMapIntensity;

  		}

  		// uv repeat and offset setting priorities
  		// 1. color map
  		// 2. specular map
  		// 3. displacementMap map
  		// 4. normal map
  		// 5. bump map
  		// 6. roughnessMap map
  		// 7. metalnessMap map
  		// 8. alphaMap map
  		// 9. emissiveMap map
  		// 10. clearcoat map
  		// 11. clearcoat normal map
  		// 12. clearcoat roughnessMap map

  		let uvScaleMap;

  		if ( material.map ) {

  			uvScaleMap = material.map;

  		} else if ( material.specularMap ) {

  			uvScaleMap = material.specularMap;

  		} else if ( material.displacementMap ) {

  			uvScaleMap = material.displacementMap;

  		} else if ( material.normalMap ) {

  			uvScaleMap = material.normalMap;

  		} else if ( material.bumpMap ) {

  			uvScaleMap = material.bumpMap;

  		} else if ( material.roughnessMap ) {

  			uvScaleMap = material.roughnessMap;

  		} else if ( material.metalnessMap ) {

  			uvScaleMap = material.metalnessMap;

  		} else if ( material.alphaMap ) {

  			uvScaleMap = material.alphaMap;

  		} else if ( material.emissiveMap ) {

  			uvScaleMap = material.emissiveMap;

  		} else if ( material.clearcoatMap ) {

  			uvScaleMap = material.clearcoatMap;

  		} else if ( material.clearcoatNormalMap ) {

  			uvScaleMap = material.clearcoatNormalMap;

  		} else if ( material.clearcoatRoughnessMap ) {

  			uvScaleMap = material.clearcoatRoughnessMap;

  		}

  		if ( uvScaleMap !== undefined ) {

  			// backwards compatibility
  			if ( uvScaleMap.isWebGLRenderTarget ) {

  				uvScaleMap = uvScaleMap.texture;

  			}

  			if ( uvScaleMap.matrixAutoUpdate === true ) {

  				uvScaleMap.updateMatrix();

  			}

  			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

  		}

  		// uv repeat and offset setting priorities for uv2
  		// 1. ao map
  		// 2. light map

  		let uv2ScaleMap;

  		if ( material.aoMap ) {

  			uv2ScaleMap = material.aoMap;

  		} else if ( material.lightMap ) {

  			uv2ScaleMap = material.lightMap;

  		}

  		if ( uv2ScaleMap !== undefined ) {

  			// backwards compatibility
  			if ( uv2ScaleMap.isWebGLRenderTarget ) {

  				uv2ScaleMap = uv2ScaleMap.texture;

  			}

  			if ( uv2ScaleMap.matrixAutoUpdate === true ) {

  				uv2ScaleMap.updateMatrix();

  			}

  			uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

  		}

  	}

  	function refreshUniformsLine( uniforms, material ) {

  		uniforms.diffuse.value.copy( material.color );
  		uniforms.opacity.value = material.opacity;

  	}

  	function refreshUniformsDash( uniforms, material ) {

  		uniforms.dashSize.value = material.dashSize;
  		uniforms.totalSize.value = material.dashSize + material.gapSize;
  		uniforms.scale.value = material.scale;

  	}

  	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

  		uniforms.diffuse.value.copy( material.color );
  		uniforms.opacity.value = material.opacity;
  		uniforms.size.value = material.size * pixelRatio;
  		uniforms.scale.value = height * 0.5;

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  		}

  		if ( material.alphaMap ) {

  			uniforms.alphaMap.value = material.alphaMap;

  		}

  		// uv repeat and offset setting priorities
  		// 1. color map
  		// 2. alpha map

  		let uvScaleMap;

  		if ( material.map ) {

  			uvScaleMap = material.map;

  		} else if ( material.alphaMap ) {

  			uvScaleMap = material.alphaMap;

  		}

  		if ( uvScaleMap !== undefined ) {

  			if ( uvScaleMap.matrixAutoUpdate === true ) {

  				uvScaleMap.updateMatrix();

  			}

  			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

  		}

  	}

  	function refreshUniformsSprites( uniforms, material ) {

  		uniforms.diffuse.value.copy( material.color );
  		uniforms.opacity.value = material.opacity;
  		uniforms.rotation.value = material.rotation;

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  		}

  		if ( material.alphaMap ) {

  			uniforms.alphaMap.value = material.alphaMap;

  		}

  		// uv repeat and offset setting priorities
  		// 1. color map
  		// 2. alpha map

  		let uvScaleMap;

  		if ( material.map ) {

  			uvScaleMap = material.map;

  		} else if ( material.alphaMap ) {

  			uvScaleMap = material.alphaMap;

  		}

  		if ( uvScaleMap !== undefined ) {

  			if ( uvScaleMap.matrixAutoUpdate === true ) {

  				uvScaleMap.updateMatrix();

  			}

  			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

  		}

  	}

  	function refreshUniformsLambert( uniforms, material ) {

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  	}

  	function refreshUniformsPhong( uniforms, material ) {

  		uniforms.specular.value.copy( material.specular );
  		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;
  			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );
  			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	function refreshUniformsToon( uniforms, material ) {

  		if ( material.gradientMap ) {

  			uniforms.gradientMap.value = material.gradientMap;

  		}

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;
  			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );
  			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	function refreshUniformsStandard( uniforms, material ) {

  		uniforms.roughness.value = material.roughness;
  		uniforms.metalness.value = material.metalness;

  		if ( material.roughnessMap ) {

  			uniforms.roughnessMap.value = material.roughnessMap;

  		}

  		if ( material.metalnessMap ) {

  			uniforms.metalnessMap.value = material.metalnessMap;

  		}

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;
  			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );
  			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  		const envMap = properties.get( material ).envMap;

  		if ( envMap ) {

  			//uniforms.envMap.value = material.envMap; // part of uniforms common
  			uniforms.envMapIntensity.value = material.envMapIntensity;

  		}

  	}

  	function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

  		refreshUniformsStandard( uniforms, material );

  		uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

  		uniforms.clearcoat.value = material.clearcoat;
  		uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

  		if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );

  		if ( material.clearcoatMap ) {

  			uniforms.clearcoatMap.value = material.clearcoatMap;

  		}

  		if ( material.clearcoatRoughnessMap ) {

  			uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

  		}

  		if ( material.clearcoatNormalMap ) {

  			uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
  			uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

  			if ( material.side === BackSide ) {

  				uniforms.clearcoatNormalScale.value.negate();

  			}

  		}

  		uniforms.transmission.value = material.transmission;

  		if ( material.transmissionMap ) {

  			uniforms.transmissionMap.value = material.transmissionMap;

  		}

  		if ( material.transmission > 0.0 ) {

  			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
  			uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

  		}

  		uniforms.thickness.value = material.thickness;

  		if ( material.thicknessMap ) {

  			uniforms.thicknessMap.value = material.thicknessMap;

  		}

  		uniforms.attenuationDistance.value = material.attenuationDistance;
  		uniforms.attenuationColor.value.copy( material.attenuationColor );

  	}

  	function refreshUniformsMatcap( uniforms, material ) {

  		if ( material.matcap ) {

  			uniforms.matcap.value = material.matcap;

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;
  			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );
  			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	function refreshUniformsDepth( uniforms, material ) {

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	function refreshUniformsDistance( uniforms, material ) {

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  		uniforms.referencePosition.value.copy( material.referencePosition );
  		uniforms.nearDistance.value = material.nearDistance;
  		uniforms.farDistance.value = material.farDistance;

  	}

  	function refreshUniformsNormal( uniforms, material ) {

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;
  			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );
  			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	return {
  		refreshFogUniforms: refreshFogUniforms,
  		refreshMaterialUniforms: refreshMaterialUniforms
  	};

  }

  function createCanvasElement() {

  	const canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
  	canvas.style.display = 'block';
  	return canvas;

  }

  function WebGLRenderer( parameters ) {

  	parameters = parameters || {};

  	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
  		_context = parameters.context !== undefined ? parameters.context : null,

  		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
  		_depth = parameters.depth !== undefined ? parameters.depth : true,
  		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
  		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
  		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
  		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
  		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
  		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

  	let currentRenderList = null;
  	let currentRenderState = null;

  	// render() can be called from within a callback triggered by another render.
  	// We track this so that the nested render call gets its list and state isolated from the parent render call.

  	const renderListStack = [];
  	const renderStateStack = [];

  	// public properties

  	this.domElement = _canvas;

  	// Debug configuration container
  	this.debug = {

  		/**
  		 * Enables error checking and reporting when shader programs are being compiled
  		 * @type {boolean}
  		 */
  		checkShaderErrors: true
  	};

  	// clearing

  	this.autoClear = true;
  	this.autoClearColor = true;
  	this.autoClearDepth = true;
  	this.autoClearStencil = true;

  	// scene graph

  	this.sortObjects = true;

  	// user-defined clipping

  	this.clippingPlanes = [];
  	this.localClippingEnabled = false;

  	// physically based shading

  	this.gammaFactor = 2.0;	// for backwards compatibility
  	this.outputEncoding = LinearEncoding;

  	// physical lights

  	this.physicallyCorrectLights = false;

  	// tone mapping

  	this.toneMapping = NoToneMapping;
  	this.toneMappingExposure = 1.0;

  	// internal properties

  	const _this = this;

  	let _isContextLost = false;

  	// internal state cache

  	let _currentActiveCubeFace = 0;
  	let _currentActiveMipmapLevel = 0;
  	let _currentRenderTarget = null;
  	let _currentMaterialId = - 1;

  	let _currentCamera = null;

  	const _currentViewport = new Vector4$1();
  	const _currentScissor = new Vector4$1();
  	let _currentScissorTest = null;

  	//

  	let _width = _canvas.width;
  	let _height = _canvas.height;

  	let _pixelRatio = 1;
  	let _opaqueSort = null;
  	let _transparentSort = null;

  	const _viewport = new Vector4$1( 0, 0, _width, _height );
  	const _scissor = new Vector4$1( 0, 0, _width, _height );
  	let _scissorTest = false;

  	//

  	const _currentDrawBuffers = [];

  	// frustum

  	const _frustum = new Frustum();

  	// clipping

  	let _clippingEnabled = false;
  	let _localClippingEnabled = false;

  	// transmission

  	let _transmissionRenderTarget = null;

  	// camera matrices cache

  	const _projScreenMatrix = new Matrix4();

  	const _vector3 = new Vector3();

  	const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

  	function getTargetPixelRatio() {

  		return _currentRenderTarget === null ? _pixelRatio : 1;

  	}

  	// initialize

  	let _gl = _context;

  	function getContext( contextNames, contextAttributes ) {

  		for ( let i = 0; i < contextNames.length; i ++ ) {

  			const contextName = contextNames[ i ];
  			const context = _canvas.getContext( contextName, contextAttributes );
  			if ( context !== null ) return context;

  		}

  		return null;

  	}

  	try {

  		const contextAttributes = {
  			alpha: _alpha,
  			depth: _depth,
  			stencil: _stencil,
  			antialias: _antialias,
  			premultipliedAlpha: _premultipliedAlpha,
  			preserveDrawingBuffer: _preserveDrawingBuffer,
  			powerPreference: _powerPreference,
  			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
  		};

  		// event listeners must be registered before WebGL context is created, see #12753

  		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
  		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

  		if ( _gl === null ) {

  			const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

  			if ( _this.isWebGL1Renderer === true ) {

  				contextNames.shift();

  			}

  			_gl = getContext( contextNames, contextAttributes );

  			if ( _gl === null ) {

  				if ( getContext( contextNames ) ) {

  					throw new Error( 'Error creating WebGL context with your selected attributes.' );

  				} else {

  					throw new Error( 'Error creating WebGL context.' );

  				}

  			}

  		}

  		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

  		if ( _gl.getShaderPrecisionFormat === undefined ) {

  			_gl.getShaderPrecisionFormat = function () {

  				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

  			};

  		}

  	} catch ( error ) {

  		console.error( 'THREE.WebGLRenderer: ' + error.message );
  		throw error;

  	}

  	let extensions, capabilities, state, info;
  	let properties, textures, cubemaps, attributes, geometries, objects;
  	let programCache, materials, renderLists, renderStates, clipping, shadowMap;

  	let background, morphtargets, bufferRenderer, indexedBufferRenderer;

  	let utils, bindingStates;

  	function initGLContext() {

  		extensions = new WebGLExtensions( _gl );

  		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

  		extensions.init( capabilities );

  		utils = new WebGLUtils( _gl, extensions, capabilities );

  		state = new WebGLState( _gl, extensions, capabilities );

  		_currentDrawBuffers[ 0 ] = 1029;

  		info = new WebGLInfo( _gl );
  		properties = new WebGLProperties();
  		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
  		cubemaps = new WebGLCubeMaps( _this );
  		attributes = new WebGLAttributes( _gl, capabilities );
  		bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
  		geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
  		objects = new WebGLObjects( _gl, geometries, attributes, info );
  		morphtargets = new WebGLMorphtargets( _gl );
  		clipping = new WebGLClipping( properties );
  		programCache = new WebGLPrograms( _this, cubemaps, extensions, capabilities, bindingStates, clipping );
  		materials = new WebGLMaterials( properties );
  		renderLists = new WebGLRenderLists( properties );
  		renderStates = new WebGLRenderStates( extensions, capabilities );
  		background = new WebGLBackground( _this, cubemaps, state, objects, _premultipliedAlpha );
  		shadowMap = new WebGLShadowMap( _this, objects, capabilities );

  		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
  		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

  		info.programs = programCache.programs;

  		_this.capabilities = capabilities;
  		_this.extensions = extensions;
  		_this.properties = properties;
  		_this.renderLists = renderLists;
  		_this.shadowMap = shadowMap;
  		_this.state = state;
  		_this.info = info;

  	}

  	initGLContext();

  	// xr

  	const xr = new WebXRManager( _this, _gl );

  	this.xr = xr;

  	// API

  	this.getContext = function () {

  		return _gl;

  	};

  	this.getContextAttributes = function () {

  		return _gl.getContextAttributes();

  	};

  	this.forceContextLoss = function () {

  		const extension = extensions.get( 'WEBGL_lose_context' );
  		if ( extension ) extension.loseContext();

  	};

  	this.forceContextRestore = function () {

  		const extension = extensions.get( 'WEBGL_lose_context' );
  		if ( extension ) extension.restoreContext();

  	};

  	this.getPixelRatio = function () {

  		return _pixelRatio;

  	};

  	this.setPixelRatio = function ( value ) {

  		if ( value === undefined ) return;

  		_pixelRatio = value;

  		this.setSize( _width, _height, false );

  	};

  	this.getSize = function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

  			target = new Vector2();

  		}

  		return target.set( _width, _height );

  	};

  	this.setSize = function ( width, height, updateStyle ) {

  		if ( xr.isPresenting ) {

  			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
  			return;

  		}

  		_width = width;
  		_height = height;

  		_canvas.width = Math.floor( width * _pixelRatio );
  		_canvas.height = Math.floor( height * _pixelRatio );

  		if ( updateStyle !== false ) {

  			_canvas.style.width = width + 'px';
  			_canvas.style.height = height + 'px';

  		}

  		this.setViewport( 0, 0, width, height );

  	};

  	this.getDrawingBufferSize = function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

  			target = new Vector2();

  		}

  		return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

  	};

  	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

  		_width = width;
  		_height = height;

  		_pixelRatio = pixelRatio;

  		_canvas.width = Math.floor( width * pixelRatio );
  		_canvas.height = Math.floor( height * pixelRatio );

  		this.setViewport( 0, 0, width, height );

  	};

  	this.getCurrentViewport = function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

  			target = new Vector4$1();

  		}

  		return target.copy( _currentViewport );

  	};

  	this.getViewport = function ( target ) {

  		return target.copy( _viewport );

  	};

  	this.setViewport = function ( x, y, width, height ) {

  		if ( x.isVector4 ) {

  			_viewport.set( x.x, x.y, x.z, x.w );

  		} else {

  			_viewport.set( x, y, width, height );

  		}

  		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

  	};

  	this.getScissor = function ( target ) {

  		return target.copy( _scissor );

  	};

  	this.setScissor = function ( x, y, width, height ) {

  		if ( x.isVector4 ) {

  			_scissor.set( x.x, x.y, x.z, x.w );

  		} else {

  			_scissor.set( x, y, width, height );

  		}

  		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

  	};

  	this.getScissorTest = function () {

  		return _scissorTest;

  	};

  	this.setScissorTest = function ( boolean ) {

  		state.setScissorTest( _scissorTest = boolean );

  	};

  	this.setOpaqueSort = function ( method ) {

  		_opaqueSort = method;

  	};

  	this.setTransparentSort = function ( method ) {

  		_transparentSort = method;

  	};

  	// Clearing

  	this.getClearColor = function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'WebGLRenderer: .getClearColor() now requires a Color as an argument' );

  			target = new Color();

  		}

  		return target.copy( background.getClearColor() );

  	};

  	this.setClearColor = function () {

  		background.setClearColor.apply( background, arguments );

  	};

  	this.getClearAlpha = function () {

  		return background.getClearAlpha();

  	};

  	this.setClearAlpha = function () {

  		background.setClearAlpha.apply( background, arguments );

  	};

  	this.clear = function ( color, depth, stencil ) {

  		let bits = 0;

  		if ( color === undefined || color ) bits |= 16384;
  		if ( depth === undefined || depth ) bits |= 256;
  		if ( stencil === undefined || stencil ) bits |= 1024;

  		_gl.clear( bits );

  	};

  	this.clearColor = function () {

  		this.clear( true, false, false );

  	};

  	this.clearDepth = function () {

  		this.clear( false, true, false );

  	};

  	this.clearStencil = function () {

  		this.clear( false, false, true );

  	};

  	//

  	this.dispose = function () {

  		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
  		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

  		renderLists.dispose();
  		renderStates.dispose();
  		properties.dispose();
  		cubemaps.dispose();
  		objects.dispose();
  		bindingStates.dispose();

  		xr.dispose();

  		xr.removeEventListener( 'sessionstart', onXRSessionStart );
  		xr.removeEventListener( 'sessionend', onXRSessionEnd );

  		if ( _transmissionRenderTarget ) {

  			_transmissionRenderTarget.dispose();
  			_transmissionRenderTarget = null;

  		}

  		animation.stop();

  	};

  	// Events

  	function onContextLost( event ) {

  		event.preventDefault();

  		console.log( 'THREE.WebGLRenderer: Context Lost.' );

  		_isContextLost = true;

  	}

  	function onContextRestore( /* event */ ) {

  		console.log( 'THREE.WebGLRenderer: Context Restored.' );

  		_isContextLost = false;

  		const infoAutoReset = info.autoReset;
  		const shadowMapEnabled = shadowMap.enabled;
  		const shadowMapAutoUpdate = shadowMap.autoUpdate;
  		const shadowMapNeedsUpdate = shadowMap.needsUpdate;
  		const shadowMapType = shadowMap.type;

  		initGLContext();

  		info.autoReset = infoAutoReset;
  		shadowMap.enabled = shadowMapEnabled;
  		shadowMap.autoUpdate = shadowMapAutoUpdate;
  		shadowMap.needsUpdate = shadowMapNeedsUpdate;
  		shadowMap.type = shadowMapType;

  	}

  	function onMaterialDispose( event ) {

  		const material = event.target;

  		material.removeEventListener( 'dispose', onMaterialDispose );

  		deallocateMaterial( material );

  	}

  	// Buffer deallocation

  	function deallocateMaterial( material ) {

  		releaseMaterialProgramReferences( material );

  		properties.remove( material );

  	}


  	function releaseMaterialProgramReferences( material ) {

  		const programs = properties.get( material ).programs;

  		if ( programs !== undefined ) {

  			programs.forEach( function ( program ) {

  				programCache.releaseProgram( program );

  			} );

  		}

  	}

  	// Buffer rendering

  	function renderObjectImmediate( object, program ) {

  		object.render( function ( object ) {

  			_this.renderBufferImmediate( object, program );

  		} );

  	}

  	this.renderBufferImmediate = function ( object, program ) {

  		bindingStates.initAttributes();

  		const buffers = properties.get( object );

  		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
  		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
  		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
  		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

  		const programAttributes = program.getAttributes();

  		if ( object.hasPositions ) {

  			_gl.bindBuffer( 34962, buffers.position );
  			_gl.bufferData( 34962, object.positionArray, 35048 );

  			bindingStates.enableAttribute( programAttributes.position );
  			_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

  		}

  		if ( object.hasNormals ) {

  			_gl.bindBuffer( 34962, buffers.normal );
  			_gl.bufferData( 34962, object.normalArray, 35048 );

  			bindingStates.enableAttribute( programAttributes.normal );
  			_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

  		}

  		if ( object.hasUvs ) {

  			_gl.bindBuffer( 34962, buffers.uv );
  			_gl.bufferData( 34962, object.uvArray, 35048 );

  			bindingStates.enableAttribute( programAttributes.uv );
  			_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

  		}

  		if ( object.hasColors ) {

  			_gl.bindBuffer( 34962, buffers.color );
  			_gl.bufferData( 34962, object.colorArray, 35048 );

  			bindingStates.enableAttribute( programAttributes.color );
  			_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

  		}

  		bindingStates.disableUnusedAttributes();

  		_gl.drawArrays( 4, 0, object.count );

  		object.count = 0;

  	};

  	this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

  		if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

  		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

  		const program = setProgram( camera, scene, material, object );

  		state.setMaterial( material, frontFaceCW );

  		//

  		let index = geometry.index;
  		const position = geometry.attributes.position;

  		//

  		if ( index === null ) {

  			if ( position === undefined || position.count === 0 ) return;

  		} else if ( index.count === 0 ) {

  			return;

  		}

  		//

  		let rangeFactor = 1;

  		if ( material.wireframe === true ) {

  			index = geometries.getWireframeAttribute( geometry );
  			rangeFactor = 2;

  		}

  		if ( material.morphTargets || material.morphNormals ) {

  			morphtargets.update( object, geometry, material, program );

  		}

  		bindingStates.setup( object, material, program, geometry, index );

  		let attribute;
  		let renderer = bufferRenderer;

  		if ( index !== null ) {

  			attribute = attributes.get( index );

  			renderer = indexedBufferRenderer;
  			renderer.setIndex( attribute );

  		}

  		//

  		const dataCount = ( index !== null ) ? index.count : position.count;

  		const rangeStart = geometry.drawRange.start * rangeFactor;
  		const rangeCount = geometry.drawRange.count * rangeFactor;

  		const groupStart = group !== null ? group.start * rangeFactor : 0;
  		const groupCount = group !== null ? group.count * rangeFactor : Infinity;

  		const drawStart = Math.max( rangeStart, groupStart );
  		const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

  		const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

  		if ( drawCount === 0 ) return;

  		//

  		if ( object.isMesh ) {

  			if ( material.wireframe === true ) {

  				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
  				renderer.setMode( 1 );

  			} else {

  				renderer.setMode( 4 );

  			}

  		} else if ( object.isLine ) {

  			let lineWidth = material.linewidth;

  			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

  			state.setLineWidth( lineWidth * getTargetPixelRatio() );

  			if ( object.isLineSegments ) {

  				renderer.setMode( 1 );

  			} else if ( object.isLineLoop ) {

  				renderer.setMode( 2 );

  			} else {

  				renderer.setMode( 3 );

  			}

  		} else if ( object.isPoints ) {

  			renderer.setMode( 0 );

  		} else if ( object.isSprite ) {

  			renderer.setMode( 4 );

  		}

  		if ( object.isInstancedMesh ) {

  			renderer.renderInstances( drawStart, drawCount, object.count );

  		} else if ( geometry.isInstancedBufferGeometry ) {

  			const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

  			renderer.renderInstances( drawStart, drawCount, instanceCount );

  		} else {

  			renderer.render( drawStart, drawCount );

  		}

  	};

  	// Compile

  	this.compile = function ( scene, camera ) {

  		currentRenderState = renderStates.get( scene );
  		currentRenderState.init();

  		scene.traverseVisible( function ( object ) {

  			if ( object.isLight && object.layers.test( camera.layers ) ) {

  				currentRenderState.pushLight( object );

  				if ( object.castShadow ) {

  					currentRenderState.pushShadow( object );

  				}

  			}

  		} );

  		currentRenderState.setupLights();

  		scene.traverse( function ( object ) {

  			const material = object.material;

  			if ( material ) {

  				if ( Array.isArray( material ) ) {

  					for ( let i = 0; i < material.length; i ++ ) {

  						const material2 = material[ i ];

  						getProgram( material2, scene, object );

  					}

  				} else {

  					getProgram( material, scene, object );

  				}

  			}

  		} );

  	};

  	// Animation Loop

  	let onAnimationFrameCallback = null;

  	function onAnimationFrame( time ) {

  		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

  	}

  	function onXRSessionStart() {

  		animation.stop();

  	}

  	function onXRSessionEnd() {

  		animation.start();

  	}

  	const animation = new WebGLAnimation();
  	animation.setAnimationLoop( onAnimationFrame );

  	if ( typeof window !== 'undefined' ) animation.setContext( window );

  	this.setAnimationLoop = function ( callback ) {

  		onAnimationFrameCallback = callback;
  		xr.setAnimationLoop( callback );

  		( callback === null ) ? animation.stop() : animation.start();

  	};

  	xr.addEventListener( 'sessionstart', onXRSessionStart );
  	xr.addEventListener( 'sessionend', onXRSessionEnd );

  	// Rendering

  	this.render = function ( scene, camera ) {

  		if ( camera !== undefined && camera.isCamera !== true ) {

  			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
  			return;

  		}

  		if ( _isContextLost === true ) return;

  		// update scene graph

  		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

  		// update camera matrices and frustum

  		if ( camera.parent === null ) camera.updateMatrixWorld();

  		if ( xr.enabled === true && xr.isPresenting === true ) {

  			if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

  			camera = xr.getCamera(); // use XR camera for rendering

  		}

  		//
  		if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

  		currentRenderState = renderStates.get( scene, renderStateStack.length );
  		currentRenderState.init();

  		renderStateStack.push( currentRenderState );

  		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  		_frustum.setFromProjectionMatrix( _projScreenMatrix );

  		_localClippingEnabled = this.localClippingEnabled;
  		_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

  		currentRenderList = renderLists.get( scene, renderListStack.length );
  		currentRenderList.init();

  		renderListStack.push( currentRenderList );

  		projectObject( scene, camera, 0, _this.sortObjects );

  		currentRenderList.finish();

  		if ( _this.sortObjects === true ) {

  			currentRenderList.sort( _opaqueSort, _transparentSort );

  		}

  		//

  		if ( _clippingEnabled === true ) clipping.beginShadows();

  		const shadowsArray = currentRenderState.state.shadowsArray;

  		shadowMap.render( shadowsArray, scene, camera );

  		currentRenderState.setupLights();
  		currentRenderState.setupLightsView( camera );

  		if ( _clippingEnabled === true ) clipping.endShadows();

  		//

  		if ( this.info.autoReset === true ) this.info.reset();

  		//

  		background.render( currentRenderList, scene );

  		// render scene

  		const opaqueObjects = currentRenderList.opaque;
  		const transmissiveObjects = currentRenderList.transmissive;
  		const transparentObjects = currentRenderList.transparent;

  		if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
  		if ( transmissiveObjects.length > 0 ) renderTransmissiveObjects( opaqueObjects, transmissiveObjects, scene, camera );
  		if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

  		//

  		if ( _currentRenderTarget !== null ) {

  			// Generate mipmap if we're using any kind of mipmap filtering

  			textures.updateRenderTargetMipmap( _currentRenderTarget );

  			// resolve multisample renderbuffers to a single-sample texture if necessary

  			textures.updateMultisampleRenderTarget( _currentRenderTarget );

  		}

  		//

  		if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

  		// Ensure depth buffer writing is enabled so it can be cleared on next render

  		state.buffers.depth.setTest( true );
  		state.buffers.depth.setMask( true );
  		state.buffers.color.setMask( true );

  		state.setPolygonOffset( false );

  		// _gl.finish();

  		bindingStates.resetDefaultState();
  		_currentMaterialId = - 1;
  		_currentCamera = null;

  		renderStateStack.pop();

  		if ( renderStateStack.length > 0 ) {

  			currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

  		} else {

  			currentRenderState = null;

  		}

  		renderListStack.pop();

  		if ( renderListStack.length > 0 ) {

  			currentRenderList = renderListStack[ renderListStack.length - 1 ];

  		} else {

  			currentRenderList = null;

  		}

  	};

  	function projectObject( object, camera, groupOrder, sortObjects ) {

  		if ( object.visible === false ) return;

  		const visible = object.layers.test( camera.layers );

  		if ( visible ) {

  			if ( object.isGroup ) {

  				groupOrder = object.renderOrder;

  			} else if ( object.isLOD ) {

  				if ( object.autoUpdate === true ) object.update( camera );

  			} else if ( object.isLight ) {

  				currentRenderState.pushLight( object );

  				if ( object.castShadow ) {

  					currentRenderState.pushShadow( object );

  				}

  			} else if ( object.isSprite ) {

  				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

  					if ( sortObjects ) {

  						_vector3.setFromMatrixPosition( object.matrixWorld )
  							.applyMatrix4( _projScreenMatrix );

  					}

  					const geometry = objects.update( object );
  					const material = object.material;

  					if ( material.visible ) {

  						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

  					}

  				}

  			} else if ( object.isImmediateRenderObject ) {

  				if ( sortObjects ) {

  					_vector3.setFromMatrixPosition( object.matrixWorld )
  						.applyMatrix4( _projScreenMatrix );

  				}

  				currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

  			} else if ( object.isMesh || object.isLine || object.isPoints ) {

  				if ( object.isSkinnedMesh ) {

  					// update skeleton only once in a frame

  					if ( object.skeleton.frame !== info.render.frame ) {

  						object.skeleton.update();
  						object.skeleton.frame = info.render.frame;

  					}

  				}

  				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

  					if ( sortObjects ) {

  						_vector3.setFromMatrixPosition( object.matrixWorld )
  							.applyMatrix4( _projScreenMatrix );

  					}

  					const geometry = objects.update( object );
  					const material = object.material;

  					if ( Array.isArray( material ) ) {

  						const groups = geometry.groups;

  						for ( let i = 0, l = groups.length; i < l; i ++ ) {

  							const group = groups[ i ];
  							const groupMaterial = material[ group.materialIndex ];

  							if ( groupMaterial && groupMaterial.visible ) {

  								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

  							}

  						}

  					} else if ( material.visible ) {

  						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

  					}

  				}

  			}

  		}

  		const children = object.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			projectObject( children[ i ], camera, groupOrder, sortObjects );

  		}

  	}

  	function renderTransmissiveObjects( opaqueObjects, transmissiveObjects, scene, camera ) {

  		if ( _transmissionRenderTarget === null ) {

  			_transmissionRenderTarget = new WebGLRenderTarget( 1024, 1024, {
  				generateMipmaps: true,
  				minFilter: LinearMipmapLinearFilter,
  				magFilter: NearestFilter,
  				wrapS: ClampToEdgeWrapping,
  				wrapT: ClampToEdgeWrapping
  			} );

  		}

  		const currentRenderTarget = _this.getRenderTarget();
  		_this.setRenderTarget( _transmissionRenderTarget );
  		_this.clear();

  		renderObjects( opaqueObjects, scene, camera );

  		textures.updateRenderTargetMipmap( _transmissionRenderTarget );

  		_this.setRenderTarget( currentRenderTarget );

  		renderObjects( transmissiveObjects, scene, camera );

  	}

  	function renderObjects( renderList, scene, camera ) {

  		const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

  		for ( let i = 0, l = renderList.length; i < l; i ++ ) {

  			const renderItem = renderList[ i ];

  			const object = renderItem.object;
  			const geometry = renderItem.geometry;
  			const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
  			const group = renderItem.group;

  			if ( camera.isArrayCamera ) {

  				const cameras = camera.cameras;

  				for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

  					const camera2 = cameras[ j ];

  					if ( object.layers.test( camera2.layers ) ) {

  						state.viewport( _currentViewport.copy( camera2.viewport ) );

  						currentRenderState.setupLightsView( camera2 );

  						renderObject( object, scene, camera2, geometry, material, group );

  					}

  				}

  			} else {

  				renderObject( object, scene, camera, geometry, material, group );

  			}

  		}

  	}

  	function renderObject( object, scene, camera, geometry, material, group ) {

  		object.onBeforeRender( _this, scene, camera, geometry, material, group );

  		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
  		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

  		if ( object.isImmediateRenderObject ) {

  			const program = setProgram( camera, scene, material, object );

  			state.setMaterial( material );

  			bindingStates.reset();

  			renderObjectImmediate( object, program );

  		} else {

  			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

  		}

  		object.onAfterRender( _this, scene, camera, geometry, material, group );

  	}

  	function getProgram( material, scene, object ) {

  		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

  		const materialProperties = properties.get( material );

  		const lights = currentRenderState.state.lights;
  		const shadowsArray = currentRenderState.state.shadowsArray;

  		const lightsStateVersion = lights.state.version;

  		const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
  		const programCacheKey = programCache.getProgramCacheKey( parameters );

  		let programs = materialProperties.programs;

  		// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

  		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
  		materialProperties.fog = scene.fog;
  		materialProperties.envMap = cubemaps.get( material.envMap || materialProperties.environment );

  		if ( programs === undefined ) {

  			// new material

  			material.addEventListener( 'dispose', onMaterialDispose );

  			programs = new Map();
  			materialProperties.programs = programs;

  		}

  		let program = programs.get( programCacheKey );

  		if ( program !== undefined ) {

  			// early out if program and light state is identical

  			if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

  				updateCommonMaterialProperties( material, parameters );

  				return program;

  			}

  		} else {

  			parameters.uniforms = programCache.getUniforms( material );

  			material.onBuild( parameters, _this );

  			material.onBeforeCompile( parameters, _this );

  			program = programCache.acquireProgram( parameters, programCacheKey );
  			programs.set( programCacheKey, program );

  			materialProperties.uniforms = parameters.uniforms;

  		}

  		const uniforms = materialProperties.uniforms;

  		if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

  			uniforms.clippingPlanes = clipping.uniform;

  		}

  		updateCommonMaterialProperties( material, parameters );

  		// store the light setup it was created for

  		materialProperties.needsLights = materialNeedsLights( material );
  		materialProperties.lightsStateVersion = lightsStateVersion;

  		if ( materialProperties.needsLights ) {

  			// wire up the material to this renderer's lighting state

  			uniforms.ambientLightColor.value = lights.state.ambient;
  			uniforms.lightProbe.value = lights.state.probe;
  			uniforms.directionalLights.value = lights.state.directional;
  			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
  			uniforms.spotLights.value = lights.state.spot;
  			uniforms.spotLightShadows.value = lights.state.spotShadow;
  			uniforms.rectAreaLights.value = lights.state.rectArea;
  			uniforms.ltc_1.value = lights.state.rectAreaLTC1;
  			uniforms.ltc_2.value = lights.state.rectAreaLTC2;
  			uniforms.pointLights.value = lights.state.point;
  			uniforms.pointLightShadows.value = lights.state.pointShadow;
  			uniforms.hemisphereLights.value = lights.state.hemi;

  			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
  			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
  			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
  			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
  			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
  			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
  			// TODO (abelnation): add area lights shadow info to uniforms

  		}

  		const progUniforms = program.getUniforms();
  		const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

  		materialProperties.currentProgram = program;
  		materialProperties.uniformsList = uniformsList;

  		return program;

  	}

  	function updateCommonMaterialProperties( material, parameters ) {

  		const materialProperties = properties.get( material );

  		materialProperties.outputEncoding = parameters.outputEncoding;
  		materialProperties.instancing = parameters.instancing;
  		materialProperties.skinning = parameters.skinning;
  		materialProperties.numClippingPlanes = parameters.numClippingPlanes;
  		materialProperties.numIntersection = parameters.numClipIntersection;
  		materialProperties.vertexAlphas = parameters.vertexAlphas;

  	}

  	function setProgram( camera, scene, material, object ) {

  		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

  		textures.resetTextureUnits();

  		const fog = scene.fog;
  		const environment = material.isMeshStandardMaterial ? scene.environment : null;
  		const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
  		const envMap = cubemaps.get( material.envMap || environment );
  		const vertexAlphas = material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;

  		const materialProperties = properties.get( material );
  		const lights = currentRenderState.state.lights;

  		if ( _clippingEnabled === true ) {

  			if ( _localClippingEnabled === true || camera !== _currentCamera ) {

  				const useCache =
  					camera === _currentCamera &&
  					material.id === _currentMaterialId;

  				// we might want to call this function with some ClippingGroup
  				// object instead of the material, once it becomes feasible
  				// (#8465, #8379)
  				clipping.setState( material, camera, useCache );

  			}

  		}

  		//

  		let needsProgramChange = false;

  		if ( material.version === materialProperties.__version ) {

  			if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

  				needsProgramChange = true;

  			} else if ( materialProperties.outputEncoding !== encoding ) {

  				needsProgramChange = true;

  			} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

  				needsProgramChange = true;

  			} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

  				needsProgramChange = true;

  			} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

  				needsProgramChange = true;

  			} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

  				needsProgramChange = true;

  			} else if ( materialProperties.envMap !== envMap ) {

  				needsProgramChange = true;

  			} else if ( material.fog && materialProperties.fog !== fog ) {

  				needsProgramChange = true;

  			} else if ( materialProperties.numClippingPlanes !== undefined &&
  				( materialProperties.numClippingPlanes !== clipping.numPlanes ||
  				materialProperties.numIntersection !== clipping.numIntersection ) ) {

  				needsProgramChange = true;

  			} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

  				needsProgramChange = true;

  			}

  		} else {

  			needsProgramChange = true;
  			materialProperties.__version = material.version;

  		}

  		//

  		let program = materialProperties.currentProgram;

  		if ( needsProgramChange === true ) {

  			program = getProgram( material, scene, object );

  		}

  		let refreshProgram = false;
  		let refreshMaterial = false;
  		let refreshLights = false;

  		const p_uniforms = program.getUniforms(),
  			m_uniforms = materialProperties.uniforms;

  		if ( state.useProgram( program.program ) ) {

  			refreshProgram = true;
  			refreshMaterial = true;
  			refreshLights = true;

  		}

  		if ( material.id !== _currentMaterialId ) {

  			_currentMaterialId = material.id;

  			refreshMaterial = true;

  		}

  		if ( refreshProgram || _currentCamera !== camera ) {

  			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

  			if ( capabilities.logarithmicDepthBuffer ) {

  				p_uniforms.setValue( _gl, 'logDepthBufFC',
  					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

  			}

  			if ( _currentCamera !== camera ) {

  				_currentCamera = camera;

  				// lighting uniforms depend on the camera so enforce an update
  				// now, in case this material supports lights - or later, when
  				// the next material that does gets activated:

  				refreshMaterial = true;		// set to true on material change
  				refreshLights = true;		// remains set until update done

  			}

  			// load material specific uniforms
  			// (shader material also gets them for the sake of genericity)

  			if ( material.isShaderMaterial ||
  				material.isMeshPhongMaterial ||
  				material.isMeshToonMaterial ||
  				material.isMeshStandardMaterial ||
  				material.envMap ) {

  				const uCamPos = p_uniforms.map.cameraPosition;

  				if ( uCamPos !== undefined ) {

  					uCamPos.setValue( _gl,
  						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

  				}

  			}

  			if ( material.isMeshPhongMaterial ||
  				material.isMeshToonMaterial ||
  				material.isMeshLambertMaterial ||
  				material.isMeshBasicMaterial ||
  				material.isMeshStandardMaterial ||
  				material.isShaderMaterial ) {

  				p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

  			}

  			if ( material.isMeshPhongMaterial ||
  				material.isMeshToonMaterial ||
  				material.isMeshLambertMaterial ||
  				material.isMeshBasicMaterial ||
  				material.isMeshStandardMaterial ||
  				material.isShaderMaterial ||
  				material.isShadowMaterial ||
  				object.isSkinnedMesh ) {

  				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

  			}

  		}

  		// skinning uniforms must be set even if material didn't change
  		// auto-setting of texture unit for bone texture must go before other textures
  		// otherwise textures used for skinning can take over texture units reserved for other material textures

  		if ( object.isSkinnedMesh ) {

  			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
  			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

  			const skeleton = object.skeleton;

  			if ( skeleton ) {

  				if ( capabilities.floatVertexTextures ) {

  					if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

  					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
  					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

  				} else {

  					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

  				}

  			}

  		}

  		if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

  			materialProperties.receiveShadow = object.receiveShadow;
  			p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

  		}

  		if ( refreshMaterial ) {

  			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

  			if ( materialProperties.needsLights ) {

  				// the current material requires lighting info

  				// note: all lighting uniforms are always set correctly
  				// they simply reference the renderer's state for their
  				// values
  				//
  				// use the current material's .needsUpdate flags to set
  				// the GL state when required

  				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

  			}

  			// refresh uniforms common to several materials

  			if ( fog && material.fog ) {

  				materials.refreshFogUniforms( m_uniforms, fog );

  			}

  			materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );

  			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

  		}

  		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

  			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
  			material.uniformsNeedUpdate = false;

  		}

  		if ( material.isSpriteMaterial ) {

  			p_uniforms.setValue( _gl, 'center', object.center );

  		}

  		// common matrices

  		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
  		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
  		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

  		return program;

  	}

  	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

  	function markUniformsLightsNeedsUpdate( uniforms, value ) {

  		uniforms.ambientLightColor.needsUpdate = value;
  		uniforms.lightProbe.needsUpdate = value;

  		uniforms.directionalLights.needsUpdate = value;
  		uniforms.directionalLightShadows.needsUpdate = value;
  		uniforms.pointLights.needsUpdate = value;
  		uniforms.pointLightShadows.needsUpdate = value;
  		uniforms.spotLights.needsUpdate = value;
  		uniforms.spotLightShadows.needsUpdate = value;
  		uniforms.rectAreaLights.needsUpdate = value;
  		uniforms.hemisphereLights.needsUpdate = value;

  	}

  	function materialNeedsLights( material ) {

  		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
  			material.isMeshStandardMaterial || material.isShadowMaterial ||
  			( material.isShaderMaterial && material.lights === true );

  	}

  	this.getActiveCubeFace = function () {

  		return _currentActiveCubeFace;

  	};

  	this.getActiveMipmapLevel = function () {

  		return _currentActiveMipmapLevel;

  	};

  	this.getRenderTarget = function () {

  		return _currentRenderTarget;

  	};

  	this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

  		_currentRenderTarget = renderTarget;
  		_currentActiveCubeFace = activeCubeFace;
  		_currentActiveMipmapLevel = activeMipmapLevel;

  		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

  			textures.setupRenderTarget( renderTarget );

  		}

  		let framebuffer = null;
  		let isCube = false;
  		let isRenderTarget3D = false;

  		if ( renderTarget ) {

  			const texture = renderTarget.texture;

  			if ( texture.isDataTexture3D || texture.isDataTexture2DArray ) {

  				isRenderTarget3D = true;

  			}

  			const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

  			if ( renderTarget.isWebGLCubeRenderTarget ) {

  				framebuffer = __webglFramebuffer[ activeCubeFace ];
  				isCube = true;

  			} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

  				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

  			} else {

  				framebuffer = __webglFramebuffer;

  			}

  			_currentViewport.copy( renderTarget.viewport );
  			_currentScissor.copy( renderTarget.scissor );
  			_currentScissorTest = renderTarget.scissorTest;

  		} else {

  			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
  			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
  			_currentScissorTest = _scissorTest;

  		}

  		const framebufferBound = state.bindFramebuffer( 36160, framebuffer );

  		if ( framebufferBound && capabilities.drawBuffers ) {

  			let needsUpdate = false;

  			if ( renderTarget ) {

  				if ( renderTarget.isWebGLMultipleRenderTargets ) {

  					const textures = renderTarget.texture;

  					if ( _currentDrawBuffers.length !== textures.length || _currentDrawBuffers[ 0 ] !== 36064 ) {

  						for ( let i = 0, il = textures.length; i < il; i ++ ) {

  							_currentDrawBuffers[ i ] = 36064 + i;

  						}

  						_currentDrawBuffers.length = textures.length;

  						needsUpdate = true;

  					}

  				} else {

  					if ( _currentDrawBuffers.length !== 1 || _currentDrawBuffers[ 0 ] !== 36064 ) {

  						_currentDrawBuffers[ 0 ] = 36064;
  						_currentDrawBuffers.length = 1;

  						needsUpdate = true;

  					}

  				}

  			} else {

  				if ( _currentDrawBuffers.length !== 1 || _currentDrawBuffers[ 0 ] !== 1029 ) {

  					_currentDrawBuffers[ 0 ] = 1029;
  					_currentDrawBuffers.length = 1;

  					needsUpdate = true;

  				}

  			}

  			if ( needsUpdate ) {

  				if ( capabilities.isWebGL2 ) {

  					_gl.drawBuffers( _currentDrawBuffers );

  				} else {

  					extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( _currentDrawBuffers );

  				}

  			}

  		}

  		state.viewport( _currentViewport );
  		state.scissor( _currentScissor );
  		state.setScissorTest( _currentScissorTest );

  		if ( isCube ) {

  			const textureProperties = properties.get( renderTarget.texture );
  			_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

  		} else if ( isRenderTarget3D ) {

  			const textureProperties = properties.get( renderTarget.texture );
  			const layer = activeCubeFace || 0;
  			_gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

  		}

  	};

  	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

  		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

  			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
  			return;

  		}

  		let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

  		if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

  			framebuffer = framebuffer[ activeCubeFaceIndex ];

  		}

  		if ( framebuffer ) {

  			state.bindFramebuffer( 36160, framebuffer );

  			try {

  				const texture = renderTarget.texture;
  				const textureFormat = texture.format;
  				const textureType = texture.type;

  				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

  					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
  					return;

  				}

  				const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

  				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
  					! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
  					! halfFloatSupportedByExt ) {

  					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
  					return;

  				}

  				if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

  					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

  					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

  						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

  					}

  				} else {

  					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

  				}

  			} finally {

  				// restore framebuffer of current render target if necessary

  				const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
  				state.bindFramebuffer( 36160, framebuffer );

  			}

  		}

  	};

  	this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

  		const levelScale = Math.pow( 2, - level );
  		const width = Math.floor( texture.image.width * levelScale );
  		const height = Math.floor( texture.image.height * levelScale );

  		let glFormat = utils.convert( texture.format );

  		if ( capabilities.isWebGL2 ) {

  			// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100

  			if ( glFormat === 6407 ) glFormat = 32849;
  			if ( glFormat === 6408 ) glFormat = 32856;

  		}

  		textures.setTexture2D( texture, 0 );

  		_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );

  		state.unbindTexture();

  	};

  	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

  		const width = srcTexture.image.width;
  		const height = srcTexture.image.height;
  		const glFormat = utils.convert( dstTexture.format );
  		const glType = utils.convert( dstTexture.type );

  		textures.setTexture2D( dstTexture, 0 );

  		// As another texture upload may have changed pixelStorei
  		// parameters, make sure they are correct for the dstTexture
  		_gl.pixelStorei( 37440, dstTexture.flipY );
  		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
  		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

  		if ( srcTexture.isDataTexture ) {

  			_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

  		} else {

  			if ( srcTexture.isCompressedTexture ) {

  				_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

  			} else {

  				_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

  			}

  		}

  		// Generate mipmaps only when copying level 0
  		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

  		state.unbindTexture();

  	};

  	this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

  		if ( _this.isWebGL1Renderer ) {

  			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
  			return;

  		}

  		const { width, height, data } = srcTexture.image;
  		const glFormat = utils.convert( dstTexture.format );
  		const glType = utils.convert( dstTexture.type );
  		let glTarget;

  		if ( dstTexture.isDataTexture3D ) {

  			textures.setTexture3D( dstTexture, 0 );
  			glTarget = 32879;

  		} else if ( dstTexture.isDataTexture2DArray ) {

  			textures.setTexture2DArray( dstTexture, 0 );
  			glTarget = 35866;

  		} else {

  			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
  			return;

  		}

  		_gl.pixelStorei( 37440, dstTexture.flipY );
  		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
  		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

  		const unpackRowLen = _gl.getParameter( 3314 );
  		const unpackImageHeight = _gl.getParameter( 32878 );
  		const unpackSkipPixels = _gl.getParameter( 3316 );
  		const unpackSkipRows = _gl.getParameter( 3315 );
  		const unpackSkipImages = _gl.getParameter( 32877 );

  		_gl.pixelStorei( 3314, width );
  		_gl.pixelStorei( 32878, height );
  		_gl.pixelStorei( 3316, sourceBox.min.x );
  		_gl.pixelStorei( 3315, sourceBox.min.y );
  		_gl.pixelStorei( 32877, sourceBox.min.z );

  		_gl.texSubImage3D(
  			glTarget,
  			level,
  			position.x,
  			position.y,
  			position.z,
  			sourceBox.max.x - sourceBox.min.x + 1,
  			sourceBox.max.y - sourceBox.min.y + 1,
  			sourceBox.max.z - sourceBox.min.z + 1,
  			glFormat,
  			glType,
  			data
  		);

  		_gl.pixelStorei( 3314, unpackRowLen );
  		_gl.pixelStorei( 32878, unpackImageHeight );
  		_gl.pixelStorei( 3316, unpackSkipPixels );
  		_gl.pixelStorei( 3315, unpackSkipRows );
  		_gl.pixelStorei( 32877, unpackSkipImages );

  		// Generate mipmaps only when copying level 0
  		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

  		state.unbindTexture();

  	};

  	this.initTexture = function ( texture ) {

  		textures.setTexture2D( texture, 0 );

  		state.unbindTexture();

  	};

  	this.resetState = function () {

  		_currentActiveCubeFace = 0;
  		_currentActiveMipmapLevel = 0;
  		_currentRenderTarget = null;

  		state.reset();
  		bindingStates.reset();

  	};

  	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

  	}

  }

  class WebGL1Renderer extends WebGLRenderer {}

  WebGL1Renderer.prototype.isWebGL1Renderer = true;

  class FogExp2 {

  	constructor( color, density = 0.00025 ) {

  		this.name = '';

  		this.color = new Color( color );
  		this.density = density;

  	}

  	clone() {

  		return new FogExp2( this.color, this.density );

  	}

  	toJSON( /* meta */ ) {

  		return {
  			type: 'FogExp2',
  			color: this.color.getHex(),
  			density: this.density
  		};

  	}

  }

  FogExp2.prototype.isFogExp2 = true;

  class Fog {

  	constructor( color, near = 1, far = 1000 ) {

  		this.name = '';

  		this.color = new Color( color );

  		this.near = near;
  		this.far = far;

  	}

  	clone() {

  		return new Fog( this.color, this.near, this.far );

  	}

  	toJSON( /* meta */ ) {

  		return {
  			type: 'Fog',
  			color: this.color.getHex(),
  			near: this.near,
  			far: this.far
  		};

  	}

  }

  Fog.prototype.isFog = true;

  class Scene extends Object3D {

  	constructor() {

  		super();

  		this.type = 'Scene';

  		this.background = null;
  		this.environment = null;
  		this.fog = null;

  		this.overrideMaterial = null;

  		this.autoUpdate = true; // checked by the renderer

  		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

  		}

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		if ( source.background !== null ) this.background = source.background.clone();
  		if ( source.environment !== null ) this.environment = source.environment.clone();
  		if ( source.fog !== null ) this.fog = source.fog.clone();

  		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

  		this.autoUpdate = source.autoUpdate;
  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
  		if ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );
  		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

  		return data;

  	}

  }

  Scene.prototype.isScene = true;

  class InterleavedBuffer {

  	constructor( array, stride ) {

  		this.array = array;
  		this.stride = stride;
  		this.count = array !== undefined ? array.length / stride : 0;

  		this.usage = StaticDrawUsage;
  		this.updateRange = { offset: 0, count: - 1 };

  		this.version = 0;

  		this.uuid = generateUUID();

  	}

  	onUploadCallback() {}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	setUsage( value ) {

  		this.usage = value;

  		return this;

  	}

  	copy( source ) {

  		this.array = new source.array.constructor( source.array );
  		this.count = source.count;
  		this.stride = source.stride;
  		this.usage = source.usage;

  		return this;

  	}

  	copyAt( index1, attribute, index2 ) {

  		index1 *= this.stride;
  		index2 *= attribute.stride;

  		for ( let i = 0, l = this.stride; i < l; i ++ ) {

  			this.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	}

  	set( value, offset = 0 ) {

  		this.array.set( value, offset );

  		return this;

  	}

  	clone( data ) {

  		if ( data.arrayBuffers === undefined ) {

  			data.arrayBuffers = {};

  		}

  		if ( this.array.buffer._uuid === undefined ) {

  			this.array.buffer._uuid = generateUUID();

  		}

  		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

  			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

  		}

  		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

  		const ib = new this.constructor( array, this.stride );
  		ib.setUsage( this.usage );

  		return ib;

  	}

  	onUpload( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  	toJSON( data ) {

  		if ( data.arrayBuffers === undefined ) {

  			data.arrayBuffers = {};

  		}

  		// generate UUID for array buffer if necessary

  		if ( this.array.buffer._uuid === undefined ) {

  			this.array.buffer._uuid = generateUUID();

  		}

  		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

  			data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

  		}

  		//

  		return {
  			uuid: this.uuid,
  			buffer: this.array.buffer._uuid,
  			type: this.array.constructor.name,
  			stride: this.stride
  		};

  	}

  }

  InterleavedBuffer.prototype.isInterleavedBuffer = true;

  const _vector$6 = /*@__PURE__*/ new Vector3();

  class InterleavedBufferAttribute {

  	constructor( interleavedBuffer, itemSize, offset, normalized ) {

  		this.name = '';

  		this.data = interleavedBuffer;
  		this.itemSize = itemSize;
  		this.offset = offset;

  		this.normalized = normalized === true;

  	}

  	get count() {

  		return this.data.count;

  	}

  	get array() {

  		return this.data.array;

  	}

  	set needsUpdate( value ) {

  		this.data.needsUpdate = value;

  	}

  	applyMatrix4( m ) {

  		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

  			_vector$6.x = this.getX( i );
  			_vector$6.y = this.getY( i );
  			_vector$6.z = this.getZ( i );

  			_vector$6.applyMatrix4( m );

  			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

  		}

  		return this;

  	}

  	applyNormalMatrix( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$6.x = this.getX( i );
  			_vector$6.y = this.getY( i );
  			_vector$6.z = this.getZ( i );

  			_vector$6.applyNormalMatrix( m );

  			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

  		}

  		return this;

  	}

  	transformDirection( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$6.x = this.getX( i );
  			_vector$6.y = this.getY( i );
  			_vector$6.z = this.getZ( i );

  			_vector$6.transformDirection( m );

  			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

  		}

  		return this;

  	}

  	setX( index, x ) {

  		this.data.array[ index * this.data.stride + this.offset ] = x;

  		return this;

  	}

  	setY( index, y ) {

  		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

  		return this;

  	}

  	setZ( index, z ) {

  		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

  		return this;

  	}

  	setW( index, w ) {

  		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

  		return this;

  	}

  	getX( index ) {

  		return this.data.array[ index * this.data.stride + this.offset ];

  	}

  	getY( index ) {

  		return this.data.array[ index * this.data.stride + this.offset + 1 ];

  	}

  	getZ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset + 2 ];

  	}

  	getW( index ) {

  		return this.data.array[ index * this.data.stride + this.offset + 3 ];

  	}

  	setXY( index, x, y ) {

  		index = index * this.data.stride + this.offset;

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;

  		return this;

  	}

  	setXYZ( index, x, y, z ) {

  		index = index * this.data.stride + this.offset;

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;

  		return this;

  	}

  	setXYZW( index, x, y, z, w ) {

  		index = index * this.data.stride + this.offset;

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;
  		this.data.array[ index + 3 ] = w;

  		return this;

  	}

  	clone( data ) {

  		if ( data === undefined ) {

  			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

  			const array = [];

  			for ( let i = 0; i < this.count; i ++ ) {

  				const index = i * this.data.stride + this.offset;

  				for ( let j = 0; j < this.itemSize; j ++ ) {

  					array.push( this.data.array[ index + j ] );

  				}

  			}

  			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

  		} else {

  			if ( data.interleavedBuffers === undefined ) {

  				data.interleavedBuffers = {};

  			}

  			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

  				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

  			}

  			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

  		}

  	}

  	toJSON( data ) {

  		if ( data === undefined ) {

  			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

  			const array = [];

  			for ( let i = 0; i < this.count; i ++ ) {

  				const index = i * this.data.stride + this.offset;

  				for ( let j = 0; j < this.itemSize; j ++ ) {

  					array.push( this.data.array[ index + j ] );

  				}

  			}

  			// deinterleave data and save it as an ordinary buffer attribute for now

  			return {
  				itemSize: this.itemSize,
  				type: this.array.constructor.name,
  				array: array,
  				normalized: this.normalized
  			};

  		} else {

  			// save as true interlaved attribtue

  			if ( data.interleavedBuffers === undefined ) {

  				data.interleavedBuffers = {};

  			}

  			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

  				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

  			}

  			return {
  				isInterleavedBufferAttribute: true,
  				itemSize: this.itemSize,
  				data: this.data.uuid,
  				offset: this.offset,
  				normalized: this.normalized
  			};

  		}

  	}

  }

  InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;

  /**
   * parameters = {
   *  color: <hex>,
   *  map: new THREE.Texture( <Image> ),
   *  alphaMap: new THREE.Texture( <Image> ),
   *  rotation: <float>,
   *  sizeAttenuation: <bool>
   * }
   */

  class SpriteMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.type = 'SpriteMaterial';

  		this.color = new Color( 0xffffff );

  		this.map = null;

  		this.alphaMap = null;

  		this.rotation = 0;

  		this.sizeAttenuation = true;

  		this.transparent = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.rotation = source.rotation;

  		this.sizeAttenuation = source.sizeAttenuation;

  		return this;

  	}

  }

  SpriteMaterial.prototype.isSpriteMaterial = true;

  let _geometry;

  const _intersectPoint = /*@__PURE__*/ new Vector3();
  const _worldScale = /*@__PURE__*/ new Vector3();
  const _mvPosition = /*@__PURE__*/ new Vector3();

  const _alignedPosition = /*@__PURE__*/ new Vector2();
  const _rotatedPosition = /*@__PURE__*/ new Vector2();
  const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

  const _vA = /*@__PURE__*/ new Vector3();
  const _vB = /*@__PURE__*/ new Vector3();
  const _vC = /*@__PURE__*/ new Vector3();

  const _uvA = /*@__PURE__*/ new Vector2();
  const _uvB = /*@__PURE__*/ new Vector2();
  const _uvC = /*@__PURE__*/ new Vector2();

  class Sprite extends Object3D {

  	constructor( material ) {

  		super();

  		this.type = 'Sprite';

  		if ( _geometry === undefined ) {

  			_geometry = new BufferGeometry();

  			const float32Array = new Float32Array( [
  				- 0.5, - 0.5, 0, 0, 0,
  				0.5, - 0.5, 0, 1, 0,
  				0.5, 0.5, 0, 1, 1,
  				- 0.5, 0.5, 0, 0, 1
  			] );

  			const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

  			_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
  			_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
  			_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

  		}

  		this.geometry = _geometry;
  		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

  		this.center = new Vector2( 0.5, 0.5 );

  	}

  	raycast( raycaster, intersects ) {

  		if ( raycaster.camera === null ) {

  			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

  		}

  		_worldScale.setFromMatrixScale( this.matrixWorld );

  		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
  		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

  		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

  		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

  			_worldScale.multiplyScalar( - _mvPosition.z );

  		}

  		const rotation = this.material.rotation;
  		let sin, cos;

  		if ( rotation !== 0 ) {

  			cos = Math.cos( rotation );
  			sin = Math.sin( rotation );

  		}

  		const center = this.center;

  		transformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
  		transformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
  		transformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

  		_uvA.set( 0, 0 );
  		_uvB.set( 1, 0 );
  		_uvC.set( 1, 1 );

  		// check first triangle
  		let intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );

  		if ( intersect === null ) {

  			// check second triangle
  			transformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
  			_uvB.set( 0, 1 );

  			intersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );
  			if ( intersect === null ) {

  				return;

  			}

  		}

  		const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

  		if ( distance < raycaster.near || distance > raycaster.far ) return;

  		intersects.push( {

  			distance: distance,
  			point: _intersectPoint.clone(),
  			uv: Triangle.getUV( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),
  			face: null,
  			object: this

  		} );

  	}

  	copy( source ) {

  		super.copy( source );

  		if ( source.center !== undefined ) this.center.copy( source.center );

  		this.material = source.material;

  		return this;

  	}

  }

  Sprite.prototype.isSprite = true;

  function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

  	// compute position in camera space
  	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

  	// to check if rotation is not zero
  	if ( sin !== undefined ) {

  		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
  		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

  	} else {

  		_rotatedPosition.copy( _alignedPosition );

  	}


  	vertexPosition.copy( mvPosition );
  	vertexPosition.x += _rotatedPosition.x;
  	vertexPosition.y += _rotatedPosition.y;

  	// transform to world space
  	vertexPosition.applyMatrix4( _viewWorldMatrix );

  }

  const _v1$2 = /*@__PURE__*/ new Vector3();
  const _v2$1 = /*@__PURE__*/ new Vector3();

  class LOD extends Object3D {

  	constructor() {

  		super();

  		this._currentLevel = 0;

  		this.type = 'LOD';

  		Object.defineProperties( this, {
  			levels: {
  				enumerable: true,
  				value: []
  			},
  			isLOD: {
  				value: true,
  			}
  		} );

  		this.autoUpdate = true;

  	}

  	copy( source ) {

  		super.copy( source, false );

  		const levels = source.levels;

  		for ( let i = 0, l = levels.length; i < l; i ++ ) {

  			const level = levels[ i ];

  			this.addLevel( level.object.clone(), level.distance );

  		}

  		this.autoUpdate = source.autoUpdate;

  		return this;

  	}

  	addLevel( object, distance = 0 ) {

  		distance = Math.abs( distance );

  		const levels = this.levels;

  		let l;

  		for ( l = 0; l < levels.length; l ++ ) {

  			if ( distance < levels[ l ].distance ) {

  				break;

  			}

  		}

  		levels.splice( l, 0, { distance: distance, object: object } );

  		this.add( object );

  		return this;

  	}

  	getCurrentLevel() {

  		return this._currentLevel;

  	}

  	getObjectForDistance( distance ) {

  		const levels = this.levels;

  		if ( levels.length > 0 ) {

  			let i, l;

  			for ( i = 1, l = levels.length; i < l; i ++ ) {

  				if ( distance < levels[ i ].distance ) {

  					break;

  				}

  			}

  			return levels[ i - 1 ].object;

  		}

  		return null;

  	}

  	raycast( raycaster, intersects ) {

  		const levels = this.levels;

  		if ( levels.length > 0 ) {

  			_v1$2.setFromMatrixPosition( this.matrixWorld );

  			const distance = raycaster.ray.origin.distanceTo( _v1$2 );

  			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

  		}

  	}

  	update( camera ) {

  		const levels = this.levels;

  		if ( levels.length > 1 ) {

  			_v1$2.setFromMatrixPosition( camera.matrixWorld );
  			_v2$1.setFromMatrixPosition( this.matrixWorld );

  			const distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;

  			levels[ 0 ].object.visible = true;

  			let i, l;

  			for ( i = 1, l = levels.length; i < l; i ++ ) {

  				if ( distance >= levels[ i ].distance ) {

  					levels[ i - 1 ].object.visible = false;
  					levels[ i ].object.visible = true;

  				} else {

  					break;

  				}

  			}

  			this._currentLevel = i - 1;

  			for ( ; i < l; i ++ ) {

  				levels[ i ].object.visible = false;

  			}

  		}

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

  		data.object.levels = [];

  		const levels = this.levels;

  		for ( let i = 0, l = levels.length; i < l; i ++ ) {

  			const level = levels[ i ];

  			data.object.levels.push( {
  				object: level.object.uuid,
  				distance: level.distance
  			} );

  		}

  		return data;

  	}

  }

  const _basePosition = /*@__PURE__*/ new Vector3();

  const _skinIndex = /*@__PURE__*/ new Vector4$1();
  const _skinWeight = /*@__PURE__*/ new Vector4$1();

  const _vector$5 = /*@__PURE__*/ new Vector3();
  const _matrix = /*@__PURE__*/ new Matrix4();

  class SkinnedMesh extends Mesh {

  	constructor( geometry, material ) {

  		super( geometry, material );

  		this.type = 'SkinnedMesh';

  		this.bindMode = 'attached';
  		this.bindMatrix = new Matrix4();
  		this.bindMatrixInverse = new Matrix4();

  	}

  	copy( source ) {

  		super.copy( source );

  		this.bindMode = source.bindMode;
  		this.bindMatrix.copy( source.bindMatrix );
  		this.bindMatrixInverse.copy( source.bindMatrixInverse );

  		this.skeleton = source.skeleton;

  		return this;

  	}

  	bind( skeleton, bindMatrix ) {

  		this.skeleton = skeleton;

  		if ( bindMatrix === undefined ) {

  			this.updateMatrixWorld( true );

  			this.skeleton.calculateInverses();

  			bindMatrix = this.matrixWorld;

  		}

  		this.bindMatrix.copy( bindMatrix );
  		this.bindMatrixInverse.copy( bindMatrix ).invert();

  	}

  	pose() {

  		this.skeleton.pose();

  	}

  	normalizeSkinWeights() {

  		const vector = new Vector4$1();

  		const skinWeight = this.geometry.attributes.skinWeight;

  		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

  			vector.x = skinWeight.getX( i );
  			vector.y = skinWeight.getY( i );
  			vector.z = skinWeight.getZ( i );
  			vector.w = skinWeight.getW( i );

  			const scale = 1.0 / vector.manhattanLength();

  			if ( scale !== Infinity ) {

  				vector.multiplyScalar( scale );

  			} else {

  				vector.set( 1, 0, 0, 0 ); // do something reasonable

  			}

  			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

  		}

  	}

  	updateMatrixWorld( force ) {

  		super.updateMatrixWorld( force );

  		if ( this.bindMode === 'attached' ) {

  			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

  		} else if ( this.bindMode === 'detached' ) {

  			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

  		} else {

  			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

  		}

  	}

  	boneTransform( index, target ) {

  		const skeleton = this.skeleton;
  		const geometry = this.geometry;

  		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
  		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

  		_basePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );

  		target.set( 0, 0, 0 );

  		for ( let i = 0; i < 4; i ++ ) {

  			const weight = _skinWeight.getComponent( i );

  			if ( weight !== 0 ) {

  				const boneIndex = _skinIndex.getComponent( i );

  				_matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

  				target.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix ), weight );

  			}

  		}

  		return target.applyMatrix4( this.bindMatrixInverse );

  	}

  }

  SkinnedMesh.prototype.isSkinnedMesh = true;

  class Bone extends Object3D {

  	constructor() {

  		super();

  		this.type = 'Bone';

  	}

  }

  Bone.prototype.isBone = true;

  class DataTexture extends Texture {

  	constructor( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

  		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  		this.image = { data: data || null, width: width || 1, height: height || 1 };

  		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

  		this.generateMipmaps = false;
  		this.flipY = false;
  		this.unpackAlignment = 1;

  		this.needsUpdate = true;

  	}

  }

  DataTexture.prototype.isDataTexture = true;

  const _offsetMatrix = /*@__PURE__*/ new Matrix4();
  const _identityMatrix = /*@__PURE__*/ new Matrix4();

  class Skeleton {

  	constructor( bones = [], boneInverses = [] ) {

  		this.uuid = generateUUID();

  		this.bones = bones.slice( 0 );
  		this.boneInverses = boneInverses;
  		this.boneMatrices = null;

  		this.boneTexture = null;
  		this.boneTextureSize = 0;

  		this.frame = - 1;

  		this.init();

  	}

  	init() {

  		const bones = this.bones;
  		const boneInverses = this.boneInverses;

  		this.boneMatrices = new Float32Array( bones.length * 16 );

  		// calculate inverse bone matrices if necessary

  		if ( boneInverses.length === 0 ) {

  			this.calculateInverses();

  		} else {

  			// handle special case

  			if ( bones.length !== boneInverses.length ) {

  				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

  				this.boneInverses = [];

  				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  					this.boneInverses.push( new Matrix4() );

  				}

  			}

  		}

  	}

  	calculateInverses() {

  		this.boneInverses.length = 0;

  		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  			const inverse = new Matrix4();

  			if ( this.bones[ i ] ) {

  				inverse.copy( this.bones[ i ].matrixWorld ).invert();

  			}

  			this.boneInverses.push( inverse );

  		}

  	}

  	pose() {

  		// recover the bind-time world matrices

  		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  			const bone = this.bones[ i ];

  			if ( bone ) {

  				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

  			}

  		}

  		// compute the local matrices, positions, rotations and scales

  		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  			const bone = this.bones[ i ];

  			if ( bone ) {

  				if ( bone.parent && bone.parent.isBone ) {

  					bone.matrix.copy( bone.parent.matrixWorld ).invert();
  					bone.matrix.multiply( bone.matrixWorld );

  				} else {

  					bone.matrix.copy( bone.matrixWorld );

  				}

  				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

  			}

  		}

  	}

  	update() {

  		const bones = this.bones;
  		const boneInverses = this.boneInverses;
  		const boneMatrices = this.boneMatrices;
  		const boneTexture = this.boneTexture;

  		// flatten bone matrices to array

  		for ( let i = 0, il = bones.length; i < il; i ++ ) {

  			// compute the offset between the current and the original transform

  			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

  			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
  			_offsetMatrix.toArray( boneMatrices, i * 16 );

  		}

  		if ( boneTexture !== null ) {

  			boneTexture.needsUpdate = true;

  		}

  	}

  	clone() {

  		return new Skeleton( this.bones, this.boneInverses );

  	}

  	computeBoneTexture() {

  		// layout (1 matrix = 4 pixels)
  		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
  		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
  		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
  		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
  		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

  		let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
  		size = ceilPowerOfTwo( size );
  		size = Math.max( size, 4 );

  		const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
  		boneMatrices.set( this.boneMatrices ); // copy current values

  		const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

  		this.boneMatrices = boneMatrices;
  		this.boneTexture = boneTexture;
  		this.boneTextureSize = size;

  		return this;

  	}

  	getBoneByName( name ) {

  		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  			const bone = this.bones[ i ];

  			if ( bone.name === name ) {

  				return bone;

  			}

  		}

  		return undefined;

  	}

  	dispose( ) {

  		if ( this.boneTexture !== null ) {

  			this.boneTexture.dispose();

  			this.boneTexture = null;

  		}

  	}

  	fromJSON( json, bones ) {

  		this.uuid = json.uuid;

  		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

  			const uuid = json.bones[ i ];
  			let bone = bones[ uuid ];

  			if ( bone === undefined ) {

  				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
  				bone = new Bone();

  			}

  			this.bones.push( bone );
  			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

  		}

  		this.init();

  		return this;

  	}

  	toJSON() {

  		const data = {
  			metadata: {
  				version: 4.5,
  				type: 'Skeleton',
  				generator: 'Skeleton.toJSON'
  			},
  			bones: [],
  			boneInverses: []
  		};

  		data.uuid = this.uuid;

  		const bones = this.bones;
  		const boneInverses = this.boneInverses;

  		for ( let i = 0, l = bones.length; i < l; i ++ ) {

  			const bone = bones[ i ];
  			data.bones.push( bone.uuid );

  			const boneInverse = boneInverses[ i ];
  			data.boneInverses.push( boneInverse.toArray() );

  		}

  		return data;

  	}

  }

  const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
  const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

  const _instanceIntersects = [];

  const _mesh = /*@__PURE__*/ new Mesh();

  class InstancedMesh extends Mesh {

  	constructor( geometry, material, count ) {

  		super( geometry, material );

  		this.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );
  		this.instanceColor = null;

  		this.count = count;

  		this.frustumCulled = false;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.instanceMatrix.copy( source.instanceMatrix );

  		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

  		this.count = source.count;

  		return this;

  	}

  	getColorAt( index, color ) {

  		color.fromArray( this.instanceColor.array, index * 3 );

  	}

  	getMatrixAt( index, matrix ) {

  		matrix.fromArray( this.instanceMatrix.array, index * 16 );

  	}

  	raycast( raycaster, intersects ) {

  		const matrixWorld = this.matrixWorld;
  		const raycastTimes = this.count;

  		_mesh.geometry = this.geometry;
  		_mesh.material = this.material;

  		if ( _mesh.material === undefined ) return;

  		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

  			// calculate the world matrix for each instance

  			this.getMatrixAt( instanceId, _instanceLocalMatrix );

  			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

  			// the mesh represents this single instance

  			_mesh.matrixWorld = _instanceWorldMatrix;

  			_mesh.raycast( raycaster, _instanceIntersects );

  			// process the result of raycast

  			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

  				const intersect = _instanceIntersects[ i ];
  				intersect.instanceId = instanceId;
  				intersect.object = this;
  				intersects.push( intersect );

  			}

  			_instanceIntersects.length = 0;

  		}

  	}

  	setColorAt( index, color ) {

  		if ( this.instanceColor === null ) {

  			this.instanceColor = new BufferAttribute( new Float32Array( this.count * 3 ), 3 );

  		}

  		color.toArray( this.instanceColor.array, index * 3 );

  	}

  	setMatrixAt( index, matrix ) {

  		matrix.toArray( this.instanceMatrix.array, index * 16 );

  	}

  	updateMorphTargets() {

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  }

  InstancedMesh.prototype.isInstancedMesh = true;

  /**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *  linecap: "round",
   *  linejoin: "round"
   * }
   */

  class LineBasicMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.type = 'LineBasicMaterial';

  		this.color = new Color( 0xffffff );

  		this.linewidth = 1;
  		this.linecap = 'round';
  		this.linejoin = 'round';

  		this.morphTargets = false;

  		this.setValues( parameters );

  	}


  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.linewidth = source.linewidth;
  		this.linecap = source.linecap;
  		this.linejoin = source.linejoin;

  		this.morphTargets = source.morphTargets;

  		return this;

  	}

  }

  LineBasicMaterial.prototype.isLineBasicMaterial = true;

  const _start$1 = /*@__PURE__*/ new Vector3();
  const _end$1 = /*@__PURE__*/ new Vector3();
  const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
  const _ray$1 = /*@__PURE__*/ new Ray();
  const _sphere$1 = /*@__PURE__*/ new Sphere();

  class Line extends Object3D {

  	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

  		super();

  		this.type = 'Line';

  		this.geometry = geometry;
  		this.material = material;

  		this.updateMorphTargets();

  	}

  	copy( source ) {

  		super.copy( source );

  		this.material = source.material;
  		this.geometry = source.geometry;

  		return this;

  	}

  	computeLineDistances() {

  		const geometry = this.geometry;

  		if ( geometry.isBufferGeometry ) {

  			// we assume non-indexed geometry

  			if ( geometry.index === null ) {

  				const positionAttribute = geometry.attributes.position;
  				const lineDistances = [ 0 ];

  				for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

  					_start$1.fromBufferAttribute( positionAttribute, i - 1 );
  					_end$1.fromBufferAttribute( positionAttribute, i );

  					lineDistances[ i ] = lineDistances[ i - 1 ];
  					lineDistances[ i ] += _start$1.distanceTo( _end$1 );

  				}

  				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

  			} else {

  				console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

  			}

  		} else if ( geometry.isGeometry ) {

  			console.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

  		}

  		return this;

  	}

  	raycast( raycaster, intersects ) {

  		const geometry = this.geometry;
  		const matrixWorld = this.matrixWorld;
  		const threshold = raycaster.params.Line.threshold;
  		const drawRange = geometry.drawRange;

  		// Checking boundingSphere distance to ray

  		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  		_sphere$1.copy( geometry.boundingSphere );
  		_sphere$1.applyMatrix4( matrixWorld );
  		_sphere$1.radius += threshold;

  		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

  		//

  		_inverseMatrix$1.copy( matrixWorld ).invert();
  		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

  		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  		const localThresholdSq = localThreshold * localThreshold;

  		const vStart = new Vector3();
  		const vEnd = new Vector3();
  		const interSegment = new Vector3();
  		const interRay = new Vector3();
  		const step = this.isLineSegments ? 2 : 1;

  		if ( geometry.isBufferGeometry ) {

  			const index = geometry.index;
  			const attributes = geometry.attributes;
  			const positionAttribute = attributes.position;

  			if ( index !== null ) {

  				const start = Math.max( 0, drawRange.start );
  				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  				for ( let i = start, l = end - 1; i < l; i += step ) {

  					const a = index.getX( i );
  					const b = index.getX( i + 1 );

  					vStart.fromBufferAttribute( positionAttribute, a );
  					vEnd.fromBufferAttribute( positionAttribute, b );

  					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

  					if ( distSq > localThresholdSq ) continue;

  					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

  					const distance = raycaster.ray.origin.distanceTo( interRay );

  					if ( distance < raycaster.near || distance > raycaster.far ) continue;

  					intersects.push( {

  						distance: distance,
  						// What do we want? intersection point on the ray or on the segment??
  						// point: raycaster.ray.at( distance ),
  						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
  						index: i,
  						face: null,
  						faceIndex: null,
  						object: this

  					} );

  				}

  			} else {

  				const start = Math.max( 0, drawRange.start );
  				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

  				for ( let i = start, l = end - 1; i < l; i += step ) {

  					vStart.fromBufferAttribute( positionAttribute, i );
  					vEnd.fromBufferAttribute( positionAttribute, i + 1 );

  					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

  					if ( distSq > localThresholdSq ) continue;

  					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

  					const distance = raycaster.ray.origin.distanceTo( interRay );

  					if ( distance < raycaster.near || distance > raycaster.far ) continue;

  					intersects.push( {

  						distance: distance,
  						// What do we want? intersection point on the ray or on the segment??
  						// point: raycaster.ray.at( distance ),
  						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
  						index: i,
  						face: null,
  						faceIndex: null,
  						object: this

  					} );

  				}

  			}

  		} else if ( geometry.isGeometry ) {

  			console.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

  		}

  	}

  	updateMorphTargets() {

  		const geometry = this.geometry;

  		if ( geometry.isBufferGeometry ) {

  			const morphAttributes = geometry.morphAttributes;
  			const keys = Object.keys( morphAttributes );

  			if ( keys.length > 0 ) {

  				const morphAttribute = morphAttributes[ keys[ 0 ] ];

  				if ( morphAttribute !== undefined ) {

  					this.morphTargetInfluences = [];
  					this.morphTargetDictionary = {};

  					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  						const name = morphAttribute[ m ].name || String( m );

  						this.morphTargetInfluences.push( 0 );
  						this.morphTargetDictionary[ name ] = m;

  					}

  				}

  			}

  		} else {

  			const morphTargets = geometry.morphTargets;

  			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

  				console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

  			}

  		}

  	}

  }

  Line.prototype.isLine = true;

  const _start = /*@__PURE__*/ new Vector3();
  const _end = /*@__PURE__*/ new Vector3();

  class LineSegments extends Line {

  	constructor( geometry, material ) {

  		super( geometry, material );

  		this.type = 'LineSegments';

  	}

  	computeLineDistances() {

  		const geometry = this.geometry;

  		if ( geometry.isBufferGeometry ) {

  			// we assume non-indexed geometry

  			if ( geometry.index === null ) {

  				const positionAttribute = geometry.attributes.position;
  				const lineDistances = [];

  				for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

  					_start.fromBufferAttribute( positionAttribute, i );
  					_end.fromBufferAttribute( positionAttribute, i + 1 );

  					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
  					lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

  				}

  				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

  			} else {

  				console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

  			}

  		} else if ( geometry.isGeometry ) {

  			console.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

  		}

  		return this;

  	}

  }

  LineSegments.prototype.isLineSegments = true;

  class LineLoop extends Line {

  	constructor( geometry, material ) {

  		super( geometry, material );

  		this.type = 'LineLoop';

  	}

  }

  LineLoop.prototype.isLineLoop = true;

  /**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  size: <float>,
   *  sizeAttenuation: <bool>
   *
   *  morphTargets: <bool>
   * }
   */

  class PointsMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.type = 'PointsMaterial';

  		this.color = new Color( 0xffffff );

  		this.map = null;

  		this.alphaMap = null;

  		this.size = 1;
  		this.sizeAttenuation = true;

  		this.morphTargets = false;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.size = source.size;
  		this.sizeAttenuation = source.sizeAttenuation;

  		this.morphTargets = source.morphTargets;

  		return this;

  	}

  }

  PointsMaterial.prototype.isPointsMaterial = true;

  const _inverseMatrix = /*@__PURE__*/ new Matrix4();
  const _ray = /*@__PURE__*/ new Ray();
  const _sphere = /*@__PURE__*/ new Sphere();
  const _position$2 = /*@__PURE__*/ new Vector3();

  class Points extends Object3D {

  	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

  		super();

  		this.type = 'Points';

  		this.geometry = geometry;
  		this.material = material;

  		this.updateMorphTargets();

  	}

  	copy( source ) {

  		super.copy( source );

  		this.material = source.material;
  		this.geometry = source.geometry;

  		return this;

  	}

  	raycast( raycaster, intersects ) {

  		const geometry = this.geometry;
  		const matrixWorld = this.matrixWorld;
  		const threshold = raycaster.params.Points.threshold;
  		const drawRange = geometry.drawRange;

  		// Checking boundingSphere distance to ray

  		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  		_sphere.copy( geometry.boundingSphere );
  		_sphere.applyMatrix4( matrixWorld );
  		_sphere.radius += threshold;

  		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

  		//

  		_inverseMatrix.copy( matrixWorld ).invert();
  		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

  		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  		const localThresholdSq = localThreshold * localThreshold;

  		if ( geometry.isBufferGeometry ) {

  			const index = geometry.index;
  			const attributes = geometry.attributes;
  			const positionAttribute = attributes.position;

  			if ( index !== null ) {

  				const start = Math.max( 0, drawRange.start );
  				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  				for ( let i = start, il = end; i < il; i ++ ) {

  					const a = index.getX( i );

  					_position$2.fromBufferAttribute( positionAttribute, a );

  					testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

  				}

  			} else {

  				const start = Math.max( 0, drawRange.start );
  				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

  				for ( let i = start, l = end; i < l; i ++ ) {

  					_position$2.fromBufferAttribute( positionAttribute, i );

  					testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

  				}

  			}

  		} else {

  			console.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

  		}

  	}

  	updateMorphTargets() {

  		const geometry = this.geometry;

  		if ( geometry.isBufferGeometry ) {

  			const morphAttributes = geometry.morphAttributes;
  			const keys = Object.keys( morphAttributes );

  			if ( keys.length > 0 ) {

  				const morphAttribute = morphAttributes[ keys[ 0 ] ];

  				if ( morphAttribute !== undefined ) {

  					this.morphTargetInfluences = [];
  					this.morphTargetDictionary = {};

  					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  						const name = morphAttribute[ m ].name || String( m );

  						this.morphTargetInfluences.push( 0 );
  						this.morphTargetDictionary[ name ] = m;

  					}

  				}

  			}

  		} else {

  			const morphTargets = geometry.morphTargets;

  			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

  				console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

  			}

  		}

  	}

  }

  Points.prototype.isPoints = true;

  function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

  	const rayPointDistanceSq = _ray.distanceSqToPoint( point );

  	if ( rayPointDistanceSq < localThresholdSq ) {

  		const intersectPoint = new Vector3();

  		_ray.closestPointToPoint( point, intersectPoint );
  		intersectPoint.applyMatrix4( matrixWorld );

  		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

  		if ( distance < raycaster.near || distance > raycaster.far ) return;

  		intersects.push( {

  			distance: distance,
  			distanceToRay: Math.sqrt( rayPointDistanceSq ),
  			point: intersectPoint,
  			index: index,
  			face: null,
  			object: object

  		} );

  	}

  }

  class VideoTexture extends Texture {

  	constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  		super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  		this.format = format !== undefined ? format : RGBFormat;

  		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
  		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

  		this.generateMipmaps = false;

  		const scope = this;

  		function updateVideo() {

  			scope.needsUpdate = true;
  			video.requestVideoFrameCallback( updateVideo );

  		}

  		if ( 'requestVideoFrameCallback' in video ) {

  			video.requestVideoFrameCallback( updateVideo );

  		}

  	}

  	clone() {

  		return new this.constructor( this.image ).copy( this );

  	}

  	update() {

  		const video = this.image;
  		const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

  		if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

  			this.needsUpdate = true;

  		}

  	}

  }

  VideoTexture.prototype.isVideoTexture = true;

  class CompressedTexture extends Texture {

  	constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

  		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  		this.image = { width: width, height: height };
  		this.mipmaps = mipmaps;

  		// no flipping for cube textures
  		// (also flipping doesn't work for compressed textures )

  		this.flipY = false;

  		// can't generate mipmaps for compressed textures
  		// mips must be embedded in DDS files

  		this.generateMipmaps = false;

  	}

  }

  CompressedTexture.prototype.isCompressedTexture = true;

  class CanvasTexture extends Texture {

  	constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  		super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  		this.needsUpdate = true;

  	}

  }

  CanvasTexture.prototype.isCanvasTexture = true;

  class DepthTexture extends Texture {

  	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

  		format = format !== undefined ? format : DepthFormat;

  		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

  			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

  		}

  		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
  		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

  		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  		this.image = { width: width, height: height };

  		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

  		this.flipY = false;
  		this.generateMipmaps	= false;

  	}


  }

  DepthTexture.prototype.isDepthTexture = true;

  class CircleGeometry extends BufferGeometry {

  	constructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {

  		super();

  		this.type = 'CircleGeometry';

  		this.parameters = {
  			radius: radius,
  			segments: segments,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		segments = Math.max( 3, segments );

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// helper variables

  		const vertex = new Vector3();
  		const uv = new Vector2();

  		// center point

  		vertices.push( 0, 0, 0 );
  		normals.push( 0, 0, 1 );
  		uvs.push( 0.5, 0.5 );

  		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

  			const segment = thetaStart + s / segments * thetaLength;

  			// vertex

  			vertex.x = radius * Math.cos( segment );
  			vertex.y = radius * Math.sin( segment );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normals.push( 0, 0, 1 );

  			// uvs

  			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
  			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

  			uvs.push( uv.x, uv.y );

  		}

  		// indices

  		for ( let i = 1; i <= segments; i ++ ) {

  			indices.push( i, i + 1, 0 );

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  }

  class CylinderGeometry extends BufferGeometry {

  	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

  		super();
  		this.type = 'CylinderGeometry';

  		this.parameters = {
  			radiusTop: radiusTop,
  			radiusBottom: radiusBottom,
  			height: height,
  			radialSegments: radialSegments,
  			heightSegments: heightSegments,
  			openEnded: openEnded,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		const scope = this;

  		radialSegments = Math.floor( radialSegments );
  		heightSegments = Math.floor( heightSegments );

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// helper variables

  		let index = 0;
  		const indexArray = [];
  		const halfHeight = height / 2;
  		let groupStart = 0;

  		// generate geometry

  		generateTorso();

  		if ( openEnded === false ) {

  			if ( radiusTop > 0 ) generateCap( true );
  			if ( radiusBottom > 0 ) generateCap( false );

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		function generateTorso() {

  			const normal = new Vector3();
  			const vertex = new Vector3();

  			let groupCount = 0;

  			// this will be used to calculate the normal
  			const slope = ( radiusBottom - radiusTop ) / height;

  			// generate vertices, normals and uvs

  			for ( let y = 0; y <= heightSegments; y ++ ) {

  				const indexRow = [];

  				const v = y / heightSegments;

  				// calculate the radius of the current row

  				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

  				for ( let x = 0; x <= radialSegments; x ++ ) {

  					const u = x / radialSegments;

  					const theta = u * thetaLength + thetaStart;

  					const sinTheta = Math.sin( theta );
  					const cosTheta = Math.cos( theta );

  					// vertex

  					vertex.x = radius * sinTheta;
  					vertex.y = - v * height + halfHeight;
  					vertex.z = radius * cosTheta;
  					vertices.push( vertex.x, vertex.y, vertex.z );

  					// normal

  					normal.set( sinTheta, slope, cosTheta ).normalize();
  					normals.push( normal.x, normal.y, normal.z );

  					// uv

  					uvs.push( u, 1 - v );

  					// save index of vertex in respective row

  					indexRow.push( index ++ );

  				}

  				// now save vertices of the row in our index array

  				indexArray.push( indexRow );

  			}

  			// generate indices

  			for ( let x = 0; x < radialSegments; x ++ ) {

  				for ( let y = 0; y < heightSegments; y ++ ) {

  					// we use the index array to access the correct indices

  					const a = indexArray[ y ][ x ];
  					const b = indexArray[ y + 1 ][ x ];
  					const c = indexArray[ y + 1 ][ x + 1 ];
  					const d = indexArray[ y ][ x + 1 ];

  					// faces

  					indices.push( a, b, d );
  					indices.push( b, c, d );

  					// update group counter

  					groupCount += 6;

  				}

  			}

  			// add a group to the geometry. this will ensure multi material support

  			scope.addGroup( groupStart, groupCount, 0 );

  			// calculate new start value for groups

  			groupStart += groupCount;

  		}

  		function generateCap( top ) {

  			// save the index of the first center vertex
  			const centerIndexStart = index;

  			const uv = new Vector2();
  			const vertex = new Vector3();

  			let groupCount = 0;

  			const radius = ( top === true ) ? radiusTop : radiusBottom;
  			const sign = ( top === true ) ? 1 : - 1;

  			// first we generate the center vertex data of the cap.
  			// because the geometry needs one set of uvs per face,
  			// we must generate a center vertex per face/segment

  			for ( let x = 1; x <= radialSegments; x ++ ) {

  				// vertex

  				vertices.push( 0, halfHeight * sign, 0 );

  				// normal

  				normals.push( 0, sign, 0 );

  				// uv

  				uvs.push( 0.5, 0.5 );

  				// increase index

  				index ++;

  			}

  			// save the index of the last center vertex
  			const centerIndexEnd = index;

  			// now we generate the surrounding vertices, normals and uvs

  			for ( let x = 0; x <= radialSegments; x ++ ) {

  				const u = x / radialSegments;
  				const theta = u * thetaLength + thetaStart;

  				const cosTheta = Math.cos( theta );
  				const sinTheta = Math.sin( theta );

  				// vertex

  				vertex.x = radius * sinTheta;
  				vertex.y = halfHeight * sign;
  				vertex.z = radius * cosTheta;
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normals.push( 0, sign, 0 );

  				// uv

  				uv.x = ( cosTheta * 0.5 ) + 0.5;
  				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
  				uvs.push( uv.x, uv.y );

  				// increase index

  				index ++;

  			}

  			// generate indices

  			for ( let x = 0; x < radialSegments; x ++ ) {

  				const c = centerIndexStart + x;
  				const i = centerIndexEnd + x;

  				if ( top === true ) {

  					// face top

  					indices.push( i, i + 1, c );

  				} else {

  					// face bottom

  					indices.push( i + 1, i, c );

  				}

  				groupCount += 3;

  			}

  			// add a group to the geometry. this will ensure multi material support

  			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

  			// calculate new start value for groups

  			groupStart += groupCount;

  		}

  	}

  }

  class ConeGeometry extends CylinderGeometry {

  	constructor( radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

  		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

  		this.type = 'ConeGeometry';

  		this.parameters = {
  			radius: radius,
  			height: height,
  			radialSegments: radialSegments,
  			heightSegments: heightSegments,
  			openEnded: openEnded,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  	}

  }

  class PolyhedronGeometry extends BufferGeometry {

  	constructor( vertices, indices, radius = 1, detail = 0 ) {

  		super();

  		this.type = 'PolyhedronGeometry';

  		this.parameters = {
  			vertices: vertices,
  			indices: indices,
  			radius: radius,
  			detail: detail
  		};

  		// default buffer data

  		const vertexBuffer = [];
  		const uvBuffer = [];

  		// the subdivision creates the vertex buffer data

  		subdivide( detail );

  		// all vertices should lie on a conceptual sphere with a given radius

  		applyRadius( radius );

  		// finally, create the uv data

  		generateUVs();

  		// build non-indexed geometry

  		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

  		if ( detail === 0 ) {

  			this.computeVertexNormals(); // flat normals

  		} else {

  			this.normalizeNormals(); // smooth normals

  		}

  		// helper functions

  		function subdivide( detail ) {

  			const a = new Vector3();
  			const b = new Vector3();
  			const c = new Vector3();

  			// iterate over all faces and apply a subdivison with the given detail value

  			for ( let i = 0; i < indices.length; i += 3 ) {

  				// get the vertices of the face

  				getVertexByIndex( indices[ i + 0 ], a );
  				getVertexByIndex( indices[ i + 1 ], b );
  				getVertexByIndex( indices[ i + 2 ], c );

  				// perform subdivision

  				subdivideFace( a, b, c, detail );

  			}

  		}

  		function subdivideFace( a, b, c, detail ) {

  			const cols = detail + 1;

  			// we use this multidimensional array as a data structure for creating the subdivision

  			const v = [];

  			// construct all of the vertices for this subdivision

  			for ( let i = 0; i <= cols; i ++ ) {

  				v[ i ] = [];

  				const aj = a.clone().lerp( c, i / cols );
  				const bj = b.clone().lerp( c, i / cols );

  				const rows = cols - i;

  				for ( let j = 0; j <= rows; j ++ ) {

  					if ( j === 0 && i === cols ) {

  						v[ i ][ j ] = aj;

  					} else {

  						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

  					}

  				}

  			}

  			// construct all of the faces

  			for ( let i = 0; i < cols; i ++ ) {

  				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

  					const k = Math.floor( j / 2 );

  					if ( j % 2 === 0 ) {

  						pushVertex( v[ i ][ k + 1 ] );
  						pushVertex( v[ i + 1 ][ k ] );
  						pushVertex( v[ i ][ k ] );

  					} else {

  						pushVertex( v[ i ][ k + 1 ] );
  						pushVertex( v[ i + 1 ][ k + 1 ] );
  						pushVertex( v[ i + 1 ][ k ] );

  					}

  				}

  			}

  		}

  		function applyRadius( radius ) {

  			const vertex = new Vector3();

  			// iterate over the entire buffer and apply the radius to each vertex

  			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

  				vertex.x = vertexBuffer[ i + 0 ];
  				vertex.y = vertexBuffer[ i + 1 ];
  				vertex.z = vertexBuffer[ i + 2 ];

  				vertex.normalize().multiplyScalar( radius );

  				vertexBuffer[ i + 0 ] = vertex.x;
  				vertexBuffer[ i + 1 ] = vertex.y;
  				vertexBuffer[ i + 2 ] = vertex.z;

  			}

  		}

  		function generateUVs() {

  			const vertex = new Vector3();

  			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

  				vertex.x = vertexBuffer[ i + 0 ];
  				vertex.y = vertexBuffer[ i + 1 ];
  				vertex.z = vertexBuffer[ i + 2 ];

  				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
  				const v = inclination( vertex ) / Math.PI + 0.5;
  				uvBuffer.push( u, 1 - v );

  			}

  			correctUVs();

  			correctSeam();

  		}

  		function correctSeam() {

  			// handle case when face straddles the seam, see #3269

  			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

  				// uv data of a single face

  				const x0 = uvBuffer[ i + 0 ];
  				const x1 = uvBuffer[ i + 2 ];
  				const x2 = uvBuffer[ i + 4 ];

  				const max = Math.max( x0, x1, x2 );
  				const min = Math.min( x0, x1, x2 );

  				// 0.9 is somewhat arbitrary

  				if ( max > 0.9 && min < 0.1 ) {

  					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
  					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
  					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

  				}

  			}

  		}

  		function pushVertex( vertex ) {

  			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

  		}

  		function getVertexByIndex( index, vertex ) {

  			const stride = index * 3;

  			vertex.x = vertices[ stride + 0 ];
  			vertex.y = vertices[ stride + 1 ];
  			vertex.z = vertices[ stride + 2 ];

  		}

  		function correctUVs() {

  			const a = new Vector3();
  			const b = new Vector3();
  			const c = new Vector3();

  			const centroid = new Vector3();

  			const uvA = new Vector2();
  			const uvB = new Vector2();
  			const uvC = new Vector2();

  			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

  				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
  				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
  				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

  				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
  				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
  				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

  				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

  				const azi = azimuth( centroid );

  				correctUV( uvA, j + 0, a, azi );
  				correctUV( uvB, j + 2, b, azi );
  				correctUV( uvC, j + 4, c, azi );

  			}

  		}

  		function correctUV( uv, stride, vector, azimuth ) {

  			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

  				uvBuffer[ stride ] = uv.x - 1;

  			}

  			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

  				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

  			}

  		}

  		// Angle around the Y axis, counter-clockwise when looking from above.

  		function azimuth( vector ) {

  			return Math.atan2( vector.z, - vector.x );

  		}


  		// Angle above the XZ plane.

  		function inclination( vector ) {

  			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

  		}

  	}

  }

  class DodecahedronGeometry extends PolyhedronGeometry {

  	constructor( radius = 1, detail = 0 ) {

  		const t = ( 1 + Math.sqrt( 5 ) ) / 2;
  		const r = 1 / t;

  		const vertices = [

  			// (±1, ±1, ±1)
  			- 1, - 1, - 1,	- 1, - 1, 1,
  			- 1, 1, - 1, - 1, 1, 1,
  			1, - 1, - 1, 1, - 1, 1,
  			1, 1, - 1, 1, 1, 1,

  			// (0, ±1/φ, ±φ)
  			0, - r, - t, 0, - r, t,
  			0, r, - t, 0, r, t,

  			// (±1/φ, ±φ, 0)
  			- r, - t, 0, - r, t, 0,
  			r, - t, 0, r, t, 0,

  			// (±φ, 0, ±1/φ)
  			- t, 0, - r, t, 0, - r,
  			- t, 0, r, t, 0, r
  		];

  		const indices = [
  			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
  			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
  			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
  			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
  			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
  			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
  			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
  			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
  			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
  			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
  			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
  			1, 12, 14, 	1, 14, 5, 	1, 5, 9
  		];

  		super( vertices, indices, radius, detail );

  		this.type = 'DodecahedronGeometry';

  		this.parameters = {
  			radius: radius,
  			detail: detail
  		};

  	}

  }

  const _v0 = new Vector3();
  const _v1$1 = new Vector3();
  const _normal = new Vector3();
  const _triangle = new Triangle();

  class EdgesGeometry extends BufferGeometry {

  	constructor( geometry, thresholdAngle ) {

  		super();

  		this.type = 'EdgesGeometry';

  		this.parameters = {
  			thresholdAngle: thresholdAngle
  		};

  		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

  		if ( geometry.isGeometry === true ) {

  			console.error( 'THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
  			return;

  		}

  		const precisionPoints = 4;
  		const precision = Math.pow( 10, precisionPoints );
  		const thresholdDot = Math.cos( DEG2RAD * thresholdAngle );

  		const indexAttr = geometry.getIndex();
  		const positionAttr = geometry.getAttribute( 'position' );
  		const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

  		const indexArr = [ 0, 0, 0 ];
  		const vertKeys = [ 'a', 'b', 'c' ];
  		const hashes = new Array( 3 );

  		const edgeData = {};
  		const vertices = [];
  		for ( let i = 0; i < indexCount; i += 3 ) {

  			if ( indexAttr ) {

  				indexArr[ 0 ] = indexAttr.getX( i );
  				indexArr[ 1 ] = indexAttr.getX( i + 1 );
  				indexArr[ 2 ] = indexAttr.getX( i + 2 );

  			} else {

  				indexArr[ 0 ] = i;
  				indexArr[ 1 ] = i + 1;
  				indexArr[ 2 ] = i + 2;

  			}

  			const { a, b, c } = _triangle;
  			a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
  			b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
  			c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
  			_triangle.getNormal( _normal );

  			// create hashes for the edge from the vertices
  			hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
  			hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
  			hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

  			// skip degenerate triangles
  			if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

  				continue;

  			}

  			// iterate over every edge
  			for ( let j = 0; j < 3; j ++ ) {

  				// get the first and next vertex making up the edge
  				const jNext = ( j + 1 ) % 3;
  				const vecHash0 = hashes[ j ];
  				const vecHash1 = hashes[ jNext ];
  				const v0 = _triangle[ vertKeys[ j ] ];
  				const v1 = _triangle[ vertKeys[ jNext ] ];

  				const hash = `${ vecHash0 }_${ vecHash1 }`;
  				const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

  				if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

  					// if we found a sibling edge add it into the vertex array if
  					// it meets the angle threshold and delete the edge from the map.
  					if ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

  						vertices.push( v0.x, v0.y, v0.z );
  						vertices.push( v1.x, v1.y, v1.z );

  					}

  					edgeData[ reverseHash ] = null;

  				} else if ( ! ( hash in edgeData ) ) {

  					// if we've already got an edge here then skip adding a new one
  					edgeData[ hash ] = {

  						index0: indexArr[ j ],
  						index1: indexArr[ jNext ],
  						normal: _normal.clone(),

  					};

  				}

  			}

  		}

  		// iterate over all remaining, unmatched edges and add them to the vertex array
  		for ( const key in edgeData ) {

  			if ( edgeData[ key ] ) {

  				const { index0, index1 } = edgeData[ key ];
  				_v0.fromBufferAttribute( positionAttr, index0 );
  				_v1$1.fromBufferAttribute( positionAttr, index1 );

  				vertices.push( _v0.x, _v0.y, _v0.z );
  				vertices.push( _v1$1.x, _v1$1.y, _v1$1.z );

  			}

  		}

  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  	}

  }

  /**
   * Port from https://github.com/mapbox/earcut (v2.2.2)
   */

  const Earcut = {

  	triangulate: function ( data, holeIndices, dim ) {

  		dim = dim || 2;

  		const hasHoles = holeIndices && holeIndices.length;
  		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
  		let outerNode = linkedList( data, 0, outerLen, dim, true );
  		const triangles = [];

  		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

  		let minX, minY, maxX, maxY, x, y, invSize;

  		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

  		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
  		if ( data.length > 80 * dim ) {

  			minX = maxX = data[ 0 ];
  			minY = maxY = data[ 1 ];

  			for ( let i = dim; i < outerLen; i += dim ) {

  				x = data[ i ];
  				y = data[ i + 1 ];
  				if ( x < minX ) minX = x;
  				if ( y < minY ) minY = y;
  				if ( x > maxX ) maxX = x;
  				if ( y > maxY ) maxY = y;

  			}

  			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
  			invSize = Math.max( maxX - minX, maxY - minY );
  			invSize = invSize !== 0 ? 1 / invSize : 0;

  		}

  		earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

  		return triangles;

  	}

  };

  // create a circular doubly linked list from polygon points in the specified winding order
  function linkedList( data, start, end, dim, clockwise ) {

  	let i, last;

  	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

  		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

  	} else {

  		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

  	}

  	if ( last && equals( last, last.next ) ) {

  		removeNode( last );
  		last = last.next;

  	}

  	return last;

  }

  // eliminate colinear or duplicate points
  function filterPoints( start, end ) {

  	if ( ! start ) return start;
  	if ( ! end ) end = start;

  	let p = start,
  		again;
  	do {

  		again = false;

  		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

  			removeNode( p );
  			p = end = p.prev;
  			if ( p === p.next ) break;
  			again = true;

  		} else {

  			p = p.next;

  		}

  	} while ( again || p !== end );

  	return end;

  }

  // main ear slicing loop which triangulates a polygon (given as a linked list)
  function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

  	if ( ! ear ) return;

  	// interlink polygon nodes in z-order
  	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

  	let stop = ear,
  		prev, next;

  	// iterate through ears, slicing them one by one
  	while ( ear.prev !== ear.next ) {

  		prev = ear.prev;
  		next = ear.next;

  		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

  			// cut off the triangle
  			triangles.push( prev.i / dim );
  			triangles.push( ear.i / dim );
  			triangles.push( next.i / dim );

  			removeNode( ear );

  			// skipping the next vertex leads to less sliver triangles
  			ear = next.next;
  			stop = next.next;

  			continue;

  		}

  		ear = next;

  		// if we looped through the whole remaining polygon and can't find any more ears
  		if ( ear === stop ) {

  			// try filtering points and slicing again
  			if ( ! pass ) {

  				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

  				// if this didn't work, try curing all small self-intersections locally

  			} else if ( pass === 1 ) {

  				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
  				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

  				// as a last resort, try splitting the remaining polygon into two

  			} else if ( pass === 2 ) {

  				splitEarcut( ear, triangles, dim, minX, minY, invSize );

  			}

  			break;

  		}

  	}

  }

  // check whether a polygon node forms a valid ear with adjacent nodes
  function isEar( ear ) {

  	const a = ear.prev,
  		b = ear,
  		c = ear.next;

  	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

  	// now make sure we don't have other points inside the potential ear
  	let p = ear.next.next;

  	while ( p !== ear.prev ) {

  		if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
  			area( p.prev, p, p.next ) >= 0 ) return false;
  		p = p.next;

  	}

  	return true;

  }

  function isEarHashed( ear, minX, minY, invSize ) {

  	const a = ear.prev,
  		b = ear,
  		c = ear.next;

  	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

  	// triangle bbox; min & max are calculated like this for speed
  	const minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
  		minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
  		maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
  		maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

  	// z-order range for the current triangle bbox;
  	const minZ = zOrder( minTX, minTY, minX, minY, invSize ),
  		maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

  	let p = ear.prevZ,
  		n = ear.nextZ;

  	// look for points inside the triangle in both directions
  	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

  		if ( p !== ear.prev && p !== ear.next &&
  			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
  			area( p.prev, p, p.next ) >= 0 ) return false;
  		p = p.prevZ;

  		if ( n !== ear.prev && n !== ear.next &&
  			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
  			area( n.prev, n, n.next ) >= 0 ) return false;
  		n = n.nextZ;

  	}

  	// look for remaining points in decreasing z-order
  	while ( p && p.z >= minZ ) {

  		if ( p !== ear.prev && p !== ear.next &&
  			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
  			area( p.prev, p, p.next ) >= 0 ) return false;
  		p = p.prevZ;

  	}

  	// look for remaining points in increasing z-order
  	while ( n && n.z <= maxZ ) {

  		if ( n !== ear.prev && n !== ear.next &&
  			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
  			area( n.prev, n, n.next ) >= 0 ) return false;
  		n = n.nextZ;

  	}

  	return true;

  }

  // go through all polygon nodes and cure small local self-intersections
  function cureLocalIntersections( start, triangles, dim ) {

  	let p = start;
  	do {

  		const a = p.prev,
  			b = p.next.next;

  		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

  			triangles.push( a.i / dim );
  			triangles.push( p.i / dim );
  			triangles.push( b.i / dim );

  			// remove two nodes involved
  			removeNode( p );
  			removeNode( p.next );

  			p = start = b;

  		}

  		p = p.next;

  	} while ( p !== start );

  	return filterPoints( p );

  }

  // try splitting polygon into two and triangulate them independently
  function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

  	// look for a valid diagonal that divides the polygon into two
  	let a = start;
  	do {

  		let b = a.next.next;
  		while ( b !== a.prev ) {

  			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

  				// split the polygon in two by the diagonal
  				let c = splitPolygon( a, b );

  				// filter colinear points around the cuts
  				a = filterPoints( a, a.next );
  				c = filterPoints( c, c.next );

  				// run earcut on each half
  				earcutLinked( a, triangles, dim, minX, minY, invSize );
  				earcutLinked( c, triangles, dim, minX, minY, invSize );
  				return;

  			}

  			b = b.next;

  		}

  		a = a.next;

  	} while ( a !== start );

  }

  // link every hole into the outer loop, producing a single-ring polygon without holes
  function eliminateHoles( data, holeIndices, outerNode, dim ) {

  	const queue = [];
  	let i, len, start, end, list;

  	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

  		start = holeIndices[ i ] * dim;
  		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
  		list = linkedList( data, start, end, dim, false );
  		if ( list === list.next ) list.steiner = true;
  		queue.push( getLeftmost( list ) );

  	}

  	queue.sort( compareX );

  	// process holes from left to right
  	for ( i = 0; i < queue.length; i ++ ) {

  		eliminateHole( queue[ i ], outerNode );
  		outerNode = filterPoints( outerNode, outerNode.next );

  	}

  	return outerNode;

  }

  function compareX( a, b ) {

  	return a.x - b.x;

  }

  // find a bridge between vertices that connects hole with an outer ring and and link it
  function eliminateHole( hole, outerNode ) {

  	outerNode = findHoleBridge( hole, outerNode );
  	if ( outerNode ) {

  		const b = splitPolygon( outerNode, hole );

  		// filter collinear points around the cuts
  		filterPoints( outerNode, outerNode.next );
  		filterPoints( b, b.next );

  	}

  }

  // David Eberly's algorithm for finding a bridge between hole and outer polygon
  function findHoleBridge( hole, outerNode ) {

  	let p = outerNode;
  	const hx = hole.x;
  	const hy = hole.y;
  	let qx = - Infinity, m;

  	// find a segment intersected by a ray from the hole's leftmost point to the left;
  	// segment's endpoint with lesser x will be potential connection point
  	do {

  		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

  			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
  			if ( x <= hx && x > qx ) {

  				qx = x;
  				if ( x === hx ) {

  					if ( hy === p.y ) return p;
  					if ( hy === p.next.y ) return p.next;

  				}

  				m = p.x < p.next.x ? p : p.next;

  			}

  		}

  		p = p.next;

  	} while ( p !== outerNode );

  	if ( ! m ) return null;

  	if ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint

  	// look for points inside the triangle of hole point, segment intersection and endpoint;
  	// if there are no points found, we have a valid connection;
  	// otherwise choose the point of the minimum angle with the ray as connection point

  	const stop = m,
  		mx = m.x,
  		my = m.y;
  	let tanMin = Infinity, tan;

  	p = m;

  	do {

  		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
  				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

  			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

  			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

  				m = p;
  				tanMin = tan;

  			}

  		}

  		p = p.next;

  	} while ( p !== stop );

  	return m;

  }

  // whether sector in vertex m contains sector in vertex p in the same coordinates
  function sectorContainsSector( m, p ) {

  	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

  }

  // interlink polygon nodes in z-order
  function indexCurve( start, minX, minY, invSize ) {

  	let p = start;
  	do {

  		if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
  		p.prevZ = p.prev;
  		p.nextZ = p.next;
  		p = p.next;

  	} while ( p !== start );

  	p.prevZ.nextZ = null;
  	p.prevZ = null;

  	sortLinked( p );

  }

  // Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
  function sortLinked( list ) {

  	let i, p, q, e, tail, numMerges, pSize, qSize,
  		inSize = 1;

  	do {

  		p = list;
  		list = null;
  		tail = null;
  		numMerges = 0;

  		while ( p ) {

  			numMerges ++;
  			q = p;
  			pSize = 0;
  			for ( i = 0; i < inSize; i ++ ) {

  				pSize ++;
  				q = q.nextZ;
  				if ( ! q ) break;

  			}

  			qSize = inSize;

  			while ( pSize > 0 || ( qSize > 0 && q ) ) {

  				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

  					e = p;
  					p = p.nextZ;
  					pSize --;

  				} else {

  					e = q;
  					q = q.nextZ;
  					qSize --;

  				}

  				if ( tail ) tail.nextZ = e;
  				else list = e;

  				e.prevZ = tail;
  				tail = e;

  			}

  			p = q;

  		}

  		tail.nextZ = null;
  		inSize *= 2;

  	} while ( numMerges > 1 );

  	return list;

  }

  // z-order of a point given coords and inverse of the longer side of data bbox
  function zOrder( x, y, minX, minY, invSize ) {

  	// coords are transformed into non-negative 15-bit integer range
  	x = 32767 * ( x - minX ) * invSize;
  	y = 32767 * ( y - minY ) * invSize;

  	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
  	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
  	x = ( x | ( x << 2 ) ) & 0x33333333;
  	x = ( x | ( x << 1 ) ) & 0x55555555;

  	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
  	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
  	y = ( y | ( y << 2 ) ) & 0x33333333;
  	y = ( y | ( y << 1 ) ) & 0x55555555;

  	return x | ( y << 1 );

  }

  // find the leftmost node of a polygon ring
  function getLeftmost( start ) {

  	let p = start,
  		leftmost = start;
  	do {

  		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
  		p = p.next;

  	} while ( p !== start );

  	return leftmost;

  }

  // check if a point lies within a convex triangle
  function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

  	return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
  			( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
  			( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

  }

  // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
  function isValidDiagonal( a, b ) {

  	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
  		( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
  		( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
  		equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

  }

  // signed area of a triangle
  function area( p, q, r ) {

  	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

  }

  // check if two points are equal
  function equals( p1, p2 ) {

  	return p1.x === p2.x && p1.y === p2.y;

  }

  // check if two segments intersect
  function intersects( p1, q1, p2, q2 ) {

  	const o1 = sign( area( p1, q1, p2 ) );
  	const o2 = sign( area( p1, q1, q2 ) );
  	const o3 = sign( area( p2, q2, p1 ) );
  	const o4 = sign( area( p2, q2, q1 ) );

  	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

  	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
  	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
  	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
  	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  	return false;

  }

  // for collinear points p, q, r, check if point q lies on segment pr
  function onSegment( p, q, r ) {

  	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

  }

  function sign( num ) {

  	return num > 0 ? 1 : num < 0 ? - 1 : 0;

  }

  // check if a polygon diagonal intersects any polygon segments
  function intersectsPolygon( a, b ) {

  	let p = a;
  	do {

  		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
  				intersects( p, p.next, a, b ) ) return true;
  		p = p.next;

  	} while ( p !== a );

  	return false;

  }

  // check if a polygon diagonal is locally inside the polygon
  function locallyInside( a, b ) {

  	return area( a.prev, a, a.next ) < 0 ?
  		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
  		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

  }

  // check if the middle point of a polygon diagonal is inside the polygon
  function middleInside( a, b ) {

  	let p = a,
  		inside = false;
  	const px = ( a.x + b.x ) / 2,
  		py = ( a.y + b.y ) / 2;
  	do {

  		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
  				( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
  			inside = ! inside;
  		p = p.next;

  	} while ( p !== a );

  	return inside;

  }

  // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring
  function splitPolygon( a, b ) {

  	const a2 = new Node( a.i, a.x, a.y ),
  		b2 = new Node( b.i, b.x, b.y ),
  		an = a.next,
  		bp = b.prev;

  	a.next = b;
  	b.prev = a;

  	a2.next = an;
  	an.prev = a2;

  	b2.next = a2;
  	a2.prev = b2;

  	bp.next = b2;
  	b2.prev = bp;

  	return b2;

  }

  // create a node and optionally link it with previous one (in a circular doubly linked list)
  function insertNode( i, x, y, last ) {

  	const p = new Node( i, x, y );

  	if ( ! last ) {

  		p.prev = p;
  		p.next = p;

  	} else {

  		p.next = last.next;
  		p.prev = last;
  		last.next.prev = p;
  		last.next = p;

  	}

  	return p;

  }

  function removeNode( p ) {

  	p.next.prev = p.prev;
  	p.prev.next = p.next;

  	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
  	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

  }

  function Node( i, x, y ) {

  	// vertex index in coordinates array
  	this.i = i;

  	// vertex coordinates
  	this.x = x;
  	this.y = y;

  	// previous and next vertex nodes in a polygon ring
  	this.prev = null;
  	this.next = null;

  	// z-order curve value
  	this.z = null;

  	// previous and next nodes in z-order
  	this.prevZ = null;
  	this.nextZ = null;

  	// indicates whether this is a steiner point
  	this.steiner = false;

  }

  function signedArea( data, start, end, dim ) {

  	let sum = 0;
  	for ( let i = start, j = end - dim; i < end; i += dim ) {

  		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
  		j = i;

  	}

  	return sum;

  }

  class ShapeUtils {

  	// calculate area of the contour polygon

  	static area( contour ) {

  		const n = contour.length;
  		let a = 0.0;

  		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

  			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

  		}

  		return a * 0.5;

  	}

  	static isClockWise( pts ) {

  		return ShapeUtils.area( pts ) < 0;

  	}

  	static triangulateShape( contour, holes ) {

  		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
  		const holeIndices = []; // array of hole indices
  		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

  		removeDupEndPts( contour );
  		addContour( vertices, contour );

  		//

  		let holeIndex = contour.length;

  		holes.forEach( removeDupEndPts );

  		for ( let i = 0; i < holes.length; i ++ ) {

  			holeIndices.push( holeIndex );
  			holeIndex += holes[ i ].length;
  			addContour( vertices, holes[ i ] );

  		}

  		//

  		const triangles = Earcut.triangulate( vertices, holeIndices );

  		//

  		for ( let i = 0; i < triangles.length; i += 3 ) {

  			faces.push( triangles.slice( i, i + 3 ) );

  		}

  		return faces;

  	}

  }

  function removeDupEndPts( points ) {

  	const l = points.length;

  	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

  		points.pop();

  	}

  }

  function addContour( vertices, contour ) {

  	for ( let i = 0; i < contour.length; i ++ ) {

  		vertices.push( contour[ i ].x );
  		vertices.push( contour[ i ].y );

  	}

  }

  /**
   * Creates extruded geometry from a path shape.
   *
   * parameters = {
   *
   *  curveSegments: <int>, // number of points on the curves
   *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
   *  depth: <float>, // Depth to extrude the shape
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into the original shape bevel goes
   *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
   *  bevelOffset: <float>, // how far from shape outline does bevel start
   *  bevelSegments: <int>, // number of bevel layers
   *
   *  extrudePath: <THREE.Curve> // curve to extrude shape along
   *
   *  UVGenerator: <Object> // object that provides UV generator functions
   *
   * }
   */

  class ExtrudeGeometry extends BufferGeometry {

  	constructor( shapes, options ) {

  		super();

  		this.type = 'ExtrudeGeometry';

  		this.parameters = {
  			shapes: shapes,
  			options: options
  		};

  		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

  		const scope = this;

  		const verticesArray = [];
  		const uvArray = [];

  		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

  			const shape = shapes[ i ];
  			addShape( shape );

  		}

  		// build geometry

  		this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

  		this.computeVertexNormals();

  		// functions

  		function addShape( shape ) {

  			const placeholder = [];

  			// options

  			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
  			const steps = options.steps !== undefined ? options.steps : 1;
  			let depth = options.depth !== undefined ? options.depth : 100;

  			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
  			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
  			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
  			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
  			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

  			const extrudePath = options.extrudePath;

  			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

  			// deprecated options

  			if ( options.amount !== undefined ) {

  				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
  				depth = options.amount;

  			}

  			//

  			let extrudePts, extrudeByPath = false;
  			let splineTube, binormal, normal, position2;

  			if ( extrudePath ) {

  				extrudePts = extrudePath.getSpacedPoints( steps );

  				extrudeByPath = true;
  				bevelEnabled = false; // bevels not supported for path extrusion

  				// SETUP TNB variables

  				// TODO1 - have a .isClosed in spline?

  				splineTube = extrudePath.computeFrenetFrames( steps, false );

  				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

  				binormal = new Vector3();
  				normal = new Vector3();
  				position2 = new Vector3();

  			}

  			// Safeguards if bevels are not enabled

  			if ( ! bevelEnabled ) {

  				bevelSegments = 0;
  				bevelThickness = 0;
  				bevelSize = 0;
  				bevelOffset = 0;

  			}

  			// Variables initialization

  			const shapePoints = shape.extractPoints( curveSegments );

  			let vertices = shapePoints.shape;
  			const holes = shapePoints.holes;

  			const reverse = ! ShapeUtils.isClockWise( vertices );

  			if ( reverse ) {

  				vertices = vertices.reverse();

  				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

  				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

  					const ahole = holes[ h ];

  					if ( ShapeUtils.isClockWise( ahole ) ) {

  						holes[ h ] = ahole.reverse();

  					}

  				}

  			}


  			const faces = ShapeUtils.triangulateShape( vertices, holes );

  			/* Vertices */

  			const contour = vertices; // vertices has all points but contour has only points of circumference

  			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

  				const ahole = holes[ h ];

  				vertices = vertices.concat( ahole );

  			}


  			function scalePt2( pt, vec, size ) {

  				if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

  				return vec.clone().multiplyScalar( size ).add( pt );

  			}

  			const vlen = vertices.length, flen = faces.length;


  			// Find directions for point movement


  			function getBevelVec( inPt, inPrev, inNext ) {

  				// computes for inPt the corresponding point inPt' on a new contour
  				//   shifted by 1 unit (length of normalized vector) to the left
  				// if we walk along contour clockwise, this new contour is outside the old one
  				//
  				// inPt' is the intersection of the two lines parallel to the two
  				//  adjacent edges of inPt at a distance of 1 unit on the left side.

  				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

  				// good reading for geometry algorithms (here: line-line intersection)
  				// http://geomalgorithms.com/a05-_intersect-1.html

  				const v_prev_x = inPt.x - inPrev.x,
  					v_prev_y = inPt.y - inPrev.y;
  				const v_next_x = inNext.x - inPt.x,
  					v_next_y = inNext.y - inPt.y;

  				const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

  				// check for collinear edges
  				const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

  				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

  					// not collinear

  					// length of vectors for normalizing

  					const v_prev_len = Math.sqrt( v_prev_lensq );
  					const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

  					// shift adjacent points by unit vectors to the left

  					const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
  					const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

  					const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
  					const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

  					// scaling factor for v_prev to intersection point

  					const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
  							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
  						( v_prev_x * v_next_y - v_prev_y * v_next_x );

  					// vector from inPt to intersection point

  					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
  					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

  					// Don't normalize!, otherwise sharp corners become ugly
  					//  but prevent crazy spikes
  					const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
  					if ( v_trans_lensq <= 2 ) {

  						return new Vector2( v_trans_x, v_trans_y );

  					} else {

  						shrink_by = Math.sqrt( v_trans_lensq / 2 );

  					}

  				} else {

  					// handle special case of collinear edges

  					let direction_eq = false; // assumes: opposite

  					if ( v_prev_x > Number.EPSILON ) {

  						if ( v_next_x > Number.EPSILON ) {

  							direction_eq = true;

  						}

  					} else {

  						if ( v_prev_x < - Number.EPSILON ) {

  							if ( v_next_x < - Number.EPSILON ) {

  								direction_eq = true;

  							}

  						} else {

  							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

  								direction_eq = true;

  							}

  						}

  					}

  					if ( direction_eq ) {

  						// console.log("Warning: lines are a straight sequence");
  						v_trans_x = - v_prev_y;
  						v_trans_y = v_prev_x;
  						shrink_by = Math.sqrt( v_prev_lensq );

  					} else {

  						// console.log("Warning: lines are a straight spike");
  						v_trans_x = v_prev_x;
  						v_trans_y = v_prev_y;
  						shrink_by = Math.sqrt( v_prev_lensq / 2 );

  					}

  				}

  				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

  			}


  			const contourMovements = [];

  			for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

  				if ( j === il ) j = 0;
  				if ( k === il ) k = 0;

  				//  (j)---(i)---(k)
  				// console.log('i,j,k', i, j , k)

  				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

  			}

  			const holesMovements = [];
  			let oneHoleMovements, verticesMovements = contourMovements.concat();

  			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

  				const ahole = holes[ h ];

  				oneHoleMovements = [];

  				for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

  					if ( j === il ) j = 0;
  					if ( k === il ) k = 0;

  					//  (j)---(i)---(k)
  					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

  				}

  				holesMovements.push( oneHoleMovements );
  				verticesMovements = verticesMovements.concat( oneHoleMovements );

  			}


  			// Loop bevelSegments, 1 for the front, 1 for the back

  			for ( let b = 0; b < bevelSegments; b ++ ) {

  				//for ( b = bevelSegments; b > 0; b -- ) {

  				const t = b / bevelSegments;
  				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
  				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

  				// contract shape

  				for ( let i = 0, il = contour.length; i < il; i ++ ) {

  					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

  					v( vert.x, vert.y, - z );

  				}

  				// expand holes

  				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

  					const ahole = holes[ h ];
  					oneHoleMovements = holesMovements[ h ];

  					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

  						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

  						v( vert.x, vert.y, - z );

  					}

  				}

  			}

  			const bs = bevelSize + bevelOffset;

  			// Back facing vertices

  			for ( let i = 0; i < vlen; i ++ ) {

  				const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

  				if ( ! extrudeByPath ) {

  					v( vert.x, vert.y, 0 );

  				} else {

  					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

  					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
  					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

  					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

  					v( position2.x, position2.y, position2.z );

  				}

  			}

  			// Add stepped vertices...
  			// Including front facing vertices

  			for ( let s = 1; s <= steps; s ++ ) {

  				for ( let i = 0; i < vlen; i ++ ) {

  					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

  					if ( ! extrudeByPath ) {

  						v( vert.x, vert.y, depth / steps * s );

  					} else {

  						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

  						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
  						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

  						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

  						v( position2.x, position2.y, position2.z );

  					}

  				}

  			}


  			// Add bevel segments planes

  			//for ( b = 1; b <= bevelSegments; b ++ ) {
  			for ( let b = bevelSegments - 1; b >= 0; b -- ) {

  				const t = b / bevelSegments;
  				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
  				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

  				// contract shape

  				for ( let i = 0, il = contour.length; i < il; i ++ ) {

  					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
  					v( vert.x, vert.y, depth + z );

  				}

  				// expand holes

  				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

  					const ahole = holes[ h ];
  					oneHoleMovements = holesMovements[ h ];

  					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

  						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

  						if ( ! extrudeByPath ) {

  							v( vert.x, vert.y, depth + z );

  						} else {

  							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

  						}

  					}

  				}

  			}

  			/* Faces */

  			// Top and bottom faces

  			buildLidFaces();

  			// Sides faces

  			buildSideFaces();


  			/////  Internal functions

  			function buildLidFaces() {

  				const start = verticesArray.length / 3;

  				if ( bevelEnabled ) {

  					let layer = 0; // steps + 1
  					let offset = vlen * layer;

  					// Bottom faces

  					for ( let i = 0; i < flen; i ++ ) {

  						const face = faces[ i ];
  						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

  					}

  					layer = steps + bevelSegments * 2;
  					offset = vlen * layer;

  					// Top faces

  					for ( let i = 0; i < flen; i ++ ) {

  						const face = faces[ i ];
  						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

  					}

  				} else {

  					// Bottom faces

  					for ( let i = 0; i < flen; i ++ ) {

  						const face = faces[ i ];
  						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

  					}

  					// Top faces

  					for ( let i = 0; i < flen; i ++ ) {

  						const face = faces[ i ];
  						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

  					}

  				}

  				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

  			}

  			// Create faces for the z-sides of the shape

  			function buildSideFaces() {

  				const start = verticesArray.length / 3;
  				let layeroffset = 0;
  				sidewalls( contour, layeroffset );
  				layeroffset += contour.length;

  				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

  					const ahole = holes[ h ];
  					sidewalls( ahole, layeroffset );

  					//, true
  					layeroffset += ahole.length;

  				}


  				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


  			}

  			function sidewalls( contour, layeroffset ) {

  				let i = contour.length;

  				while ( -- i >= 0 ) {

  					const j = i;
  					let k = i - 1;
  					if ( k < 0 ) k = contour.length - 1;

  					//console.log('b', i,j, i-1, k,vertices.length);

  					for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

  						const slen1 = vlen * s;
  						const slen2 = vlen * ( s + 1 );

  						const a = layeroffset + j + slen1,
  							b = layeroffset + k + slen1,
  							c = layeroffset + k + slen2,
  							d = layeroffset + j + slen2;

  						f4( a, b, c, d );

  					}

  				}

  			}

  			function v( x, y, z ) {

  				placeholder.push( x );
  				placeholder.push( y );
  				placeholder.push( z );

  			}


  			function f3( a, b, c ) {

  				addVertex( a );
  				addVertex( b );
  				addVertex( c );

  				const nextIndex = verticesArray.length / 3;
  				const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

  				addUV( uvs[ 0 ] );
  				addUV( uvs[ 1 ] );
  				addUV( uvs[ 2 ] );

  			}

  			function f4( a, b, c, d ) {

  				addVertex( a );
  				addVertex( b );
  				addVertex( d );

  				addVertex( b );
  				addVertex( c );
  				addVertex( d );


  				const nextIndex = verticesArray.length / 3;
  				const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

  				addUV( uvs[ 0 ] );
  				addUV( uvs[ 1 ] );
  				addUV( uvs[ 3 ] );

  				addUV( uvs[ 1 ] );
  				addUV( uvs[ 2 ] );
  				addUV( uvs[ 3 ] );

  			}

  			function addVertex( index ) {

  				verticesArray.push( placeholder[ index * 3 + 0 ] );
  				verticesArray.push( placeholder[ index * 3 + 1 ] );
  				verticesArray.push( placeholder[ index * 3 + 2 ] );

  			}


  			function addUV( vector2 ) {

  				uvArray.push( vector2.x );
  				uvArray.push( vector2.y );

  			}

  		}

  	}

  	toJSON() {

  		const data = super.toJSON();

  		const shapes = this.parameters.shapes;
  		const options = this.parameters.options;

  		return toJSON$1( shapes, options, data );

  	}

  }

  const WorldUVGenerator = {

  	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

  		const a_x = vertices[ indexA * 3 ];
  		const a_y = vertices[ indexA * 3 + 1 ];
  		const b_x = vertices[ indexB * 3 ];
  		const b_y = vertices[ indexB * 3 + 1 ];
  		const c_x = vertices[ indexC * 3 ];
  		const c_y = vertices[ indexC * 3 + 1 ];

  		return [
  			new Vector2( a_x, a_y ),
  			new Vector2( b_x, b_y ),
  			new Vector2( c_x, c_y )
  		];

  	},

  	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

  		const a_x = vertices[ indexA * 3 ];
  		const a_y = vertices[ indexA * 3 + 1 ];
  		const a_z = vertices[ indexA * 3 + 2 ];
  		const b_x = vertices[ indexB * 3 ];
  		const b_y = vertices[ indexB * 3 + 1 ];
  		const b_z = vertices[ indexB * 3 + 2 ];
  		const c_x = vertices[ indexC * 3 ];
  		const c_y = vertices[ indexC * 3 + 1 ];
  		const c_z = vertices[ indexC * 3 + 2 ];
  		const d_x = vertices[ indexD * 3 ];
  		const d_y = vertices[ indexD * 3 + 1 ];
  		const d_z = vertices[ indexD * 3 + 2 ];

  		if ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {

  			return [
  				new Vector2( a_x, 1 - a_z ),
  				new Vector2( b_x, 1 - b_z ),
  				new Vector2( c_x, 1 - c_z ),
  				new Vector2( d_x, 1 - d_z )
  			];

  		} else {

  			return [
  				new Vector2( a_y, 1 - a_z ),
  				new Vector2( b_y, 1 - b_z ),
  				new Vector2( c_y, 1 - c_z ),
  				new Vector2( d_y, 1 - d_z )
  			];

  		}

  	}

  };

  function toJSON$1( shapes, options, data ) {

  	data.shapes = [];

  	if ( Array.isArray( shapes ) ) {

  		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

  			const shape = shapes[ i ];

  			data.shapes.push( shape.uuid );

  		}

  	} else {

  		data.shapes.push( shapes.uuid );

  	}

  	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

  	return data;

  }

  class IcosahedronGeometry extends PolyhedronGeometry {

  	constructor( radius = 1, detail = 0 ) {

  		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

  		const vertices = [
  			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
  			0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
  			t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
  		];

  		const indices = [
  			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
  			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
  			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
  			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
  		];

  		super( vertices, indices, radius, detail );

  		this.type = 'IcosahedronGeometry';

  		this.parameters = {
  			radius: radius,
  			detail: detail
  		};

  	}

  }

  class LatheGeometry extends BufferGeometry {

  	constructor( points, segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

  		super();

  		this.type = 'LatheGeometry';

  		this.parameters = {
  			points: points,
  			segments: segments,
  			phiStart: phiStart,
  			phiLength: phiLength
  		};

  		segments = Math.floor( segments );

  		// clamp phiLength so it's in range of [ 0, 2PI ]

  		phiLength = clamp( phiLength, 0, Math.PI * 2 );

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const uvs = [];

  		// helper variables

  		const inverseSegments = 1.0 / segments;
  		const vertex = new Vector3();
  		const uv = new Vector2();

  		// generate vertices and uvs

  		for ( let i = 0; i <= segments; i ++ ) {

  			const phi = phiStart + i * inverseSegments * phiLength;

  			const sin = Math.sin( phi );
  			const cos = Math.cos( phi );

  			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

  				// vertex

  				vertex.x = points[ j ].x * sin;
  				vertex.y = points[ j ].y;
  				vertex.z = points[ j ].x * cos;

  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// uv

  				uv.x = i / segments;
  				uv.y = j / ( points.length - 1 );

  				uvs.push( uv.x, uv.y );


  			}

  		}

  		// indices

  		for ( let i = 0; i < segments; i ++ ) {

  			for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

  				const base = j + i * points.length;

  				const a = base;
  				const b = base + points.length;
  				const c = base + points.length + 1;
  				const d = base + 1;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		// generate normals

  		this.computeVertexNormals();

  		// if the geometry is closed, we need to average the normals along the seam.
  		// because the corresponding vertices are identical (but still have different UVs).

  		if ( phiLength === Math.PI * 2 ) {

  			const normals = this.attributes.normal.array;
  			const n1 = new Vector3();
  			const n2 = new Vector3();
  			const n = new Vector3();

  			// this is the buffer offset for the last line of vertices

  			const base = segments * points.length * 3;

  			for ( let i = 0, j = 0; i < points.length; i ++, j += 3 ) {

  				// select the normal of the vertex in the first line

  				n1.x = normals[ j + 0 ];
  				n1.y = normals[ j + 1 ];
  				n1.z = normals[ j + 2 ];

  				// select the normal of the vertex in the last line

  				n2.x = normals[ base + j + 0 ];
  				n2.y = normals[ base + j + 1 ];
  				n2.z = normals[ base + j + 2 ];

  				// average normals

  				n.addVectors( n1, n2 ).normalize();

  				// assign the new values to both normals

  				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
  				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
  				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

  			}

  		}

  	}

  }

  class OctahedronGeometry extends PolyhedronGeometry {

  	constructor( radius = 1, detail = 0 ) {

  		const vertices = [
  			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
  			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
  		];

  		const indices = [
  			0, 2, 4,	0, 4, 3,	0, 3, 5,
  			0, 5, 2,	1, 2, 5,	1, 5, 3,
  			1, 3, 4,	1, 4, 2
  		];

  		super( vertices, indices, radius, detail );

  		this.type = 'OctahedronGeometry';

  		this.parameters = {
  			radius: radius,
  			detail: detail
  		};

  	}

  }

  /**
   * Parametric Surfaces Geometry
   * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
   */

  class ParametricGeometry extends BufferGeometry {

  	constructor( func, slices, stacks ) {

  		super();

  		this.type = 'ParametricGeometry';

  		this.parameters = {
  			func: func,
  			slices: slices,
  			stacks: stacks
  		};

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		const EPS = 0.00001;

  		const normal = new Vector3();

  		const p0 = new Vector3(), p1 = new Vector3();
  		const pu = new Vector3(), pv = new Vector3();

  		if ( func.length < 3 ) {

  			console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

  		}

  		// generate vertices, normals and uvs

  		const sliceCount = slices + 1;

  		for ( let i = 0; i <= stacks; i ++ ) {

  			const v = i / stacks;

  			for ( let j = 0; j <= slices; j ++ ) {

  				const u = j / slices;

  				// vertex

  				func( u, v, p0 );
  				vertices.push( p0.x, p0.y, p0.z );

  				// normal

  				// approximate tangent vectors via finite differences

  				if ( u - EPS >= 0 ) {

  					func( u - EPS, v, p1 );
  					pu.subVectors( p0, p1 );

  				} else {

  					func( u + EPS, v, p1 );
  					pu.subVectors( p1, p0 );

  				}

  				if ( v - EPS >= 0 ) {

  					func( u, v - EPS, p1 );
  					pv.subVectors( p0, p1 );

  				} else {

  					func( u, v + EPS, p1 );
  					pv.subVectors( p1, p0 );

  				}

  				// cross product of tangent vectors returns surface normal

  				normal.crossVectors( pu, pv ).normalize();
  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( u, v );

  			}

  		}

  		// generate indices

  		for ( let i = 0; i < stacks; i ++ ) {

  			for ( let j = 0; j < slices; j ++ ) {

  				const a = i * sliceCount + j;
  				const b = i * sliceCount + j + 1;
  				const c = ( i + 1 ) * sliceCount + j + 1;
  				const d = ( i + 1 ) * sliceCount + j;

  				// faces one and two

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  }

  class RingGeometry extends BufferGeometry {

  	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

  		super();

  		this.type = 'RingGeometry';

  		this.parameters = {
  			innerRadius: innerRadius,
  			outerRadius: outerRadius,
  			thetaSegments: thetaSegments,
  			phiSegments: phiSegments,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		thetaSegments = Math.max( 3, thetaSegments );
  		phiSegments = Math.max( 1, phiSegments );

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// some helper variables

  		let radius = innerRadius;
  		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
  		const vertex = new Vector3();
  		const uv = new Vector2();

  		// generate vertices, normals and uvs

  		for ( let j = 0; j <= phiSegments; j ++ ) {

  			for ( let i = 0; i <= thetaSegments; i ++ ) {

  				// values are generate from the inside of the ring to the outside

  				const segment = thetaStart + i / thetaSegments * thetaLength;

  				// vertex

  				vertex.x = radius * Math.cos( segment );
  				vertex.y = radius * Math.sin( segment );

  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normals.push( 0, 0, 1 );

  				// uv

  				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
  				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

  				uvs.push( uv.x, uv.y );

  			}

  			// increase the radius for next row of vertices

  			radius += radiusStep;

  		}

  		// indices

  		for ( let j = 0; j < phiSegments; j ++ ) {

  			const thetaSegmentLevel = j * ( thetaSegments + 1 );

  			for ( let i = 0; i < thetaSegments; i ++ ) {

  				const segment = i + thetaSegmentLevel;

  				const a = segment;
  				const b = segment + thetaSegments + 1;
  				const c = segment + thetaSegments + 2;
  				const d = segment + 1;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  }

  class ShapeGeometry extends BufferGeometry {

  	constructor( shapes, curveSegments = 12 ) {

  		super();
  		this.type = 'ShapeGeometry';

  		this.parameters = {
  			shapes: shapes,
  			curveSegments: curveSegments
  		};

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// helper variables

  		let groupStart = 0;
  		let groupCount = 0;

  		// allow single and array values for "shapes" parameter

  		if ( Array.isArray( shapes ) === false ) {

  			addShape( shapes );

  		} else {

  			for ( let i = 0; i < shapes.length; i ++ ) {

  				addShape( shapes[ i ] );

  				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

  				groupStart += groupCount;
  				groupCount = 0;

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


  		// helper functions

  		function addShape( shape ) {

  			const indexOffset = vertices.length / 3;
  			const points = shape.extractPoints( curveSegments );

  			let shapeVertices = points.shape;
  			const shapeHoles = points.holes;

  			// check direction of vertices

  			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

  				shapeVertices = shapeVertices.reverse();

  			}

  			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

  				const shapeHole = shapeHoles[ i ];

  				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

  					shapeHoles[ i ] = shapeHole.reverse();

  				}

  			}

  			const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

  			// join vertices of inner and outer paths to a single array

  			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

  				const shapeHole = shapeHoles[ i ];
  				shapeVertices = shapeVertices.concat( shapeHole );

  			}

  			// vertices, normals, uvs

  			for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

  				const vertex = shapeVertices[ i ];

  				vertices.push( vertex.x, vertex.y, 0 );
  				normals.push( 0, 0, 1 );
  				uvs.push( vertex.x, vertex.y ); // world uvs

  			}

  			// incides

  			for ( let i = 0, l = faces.length; i < l; i ++ ) {

  				const face = faces[ i ];

  				const a = face[ 0 ] + indexOffset;
  				const b = face[ 1 ] + indexOffset;
  				const c = face[ 2 ] + indexOffset;

  				indices.push( a, b, c );
  				groupCount += 3;

  			}

  		}

  	}

  	toJSON() {

  		const data = super.toJSON();

  		const shapes = this.parameters.shapes;

  		return toJSON( shapes, data );

  	}

  }

  function toJSON( shapes, data ) {

  	data.shapes = [];

  	if ( Array.isArray( shapes ) ) {

  		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

  			const shape = shapes[ i ];

  			data.shapes.push( shape.uuid );

  		}

  	} else {

  		data.shapes.push( shapes.uuid );

  	}

  	return data;

  }

  class SphereGeometry extends BufferGeometry {

  	constructor( radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

  		super();
  		this.type = 'SphereGeometry';

  		this.parameters = {
  			radius: radius,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments,
  			phiStart: phiStart,
  			phiLength: phiLength,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
  		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

  		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

  		let index = 0;
  		const grid = [];

  		const vertex = new Vector3();
  		const normal = new Vector3();

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// generate vertices, normals and uvs

  		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

  			const verticesRow = [];

  			const v = iy / heightSegments;

  			// special case for the poles

  			let uOffset = 0;

  			if ( iy == 0 && thetaStart == 0 ) {

  				uOffset = 0.5 / widthSegments;

  			} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

  				uOffset = - 0.5 / widthSegments;

  			}

  			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

  				const u = ix / widthSegments;

  				// vertex

  				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
  				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
  				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normal.copy( vertex ).normalize();
  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( u + uOffset, 1 - v );

  				verticesRow.push( index ++ );

  			}

  			grid.push( verticesRow );

  		}

  		// indices

  		for ( let iy = 0; iy < heightSegments; iy ++ ) {

  			for ( let ix = 0; ix < widthSegments; ix ++ ) {

  				const a = grid[ iy ][ ix + 1 ];
  				const b = grid[ iy ][ ix ];
  				const c = grid[ iy + 1 ][ ix ];
  				const d = grid[ iy + 1 ][ ix + 1 ];

  				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
  				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  }

  class TetrahedronGeometry extends PolyhedronGeometry {

  	constructor( radius = 1, detail = 0 ) {

  		const vertices = [
  			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
  		];

  		const indices = [
  			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
  		];

  		super( vertices, indices, radius, detail );

  		this.type = 'TetrahedronGeometry';

  		this.parameters = {
  			radius: radius,
  			detail: detail
  		};

  	}

  }

  /**
   * Text = 3D Text
   *
   * parameters = {
   *  font: <THREE.Font>, // font
   *
   *  size: <float>, // size of the text
   *  height: <float>, // thickness to extrude text
   *  curveSegments: <int>, // number of points on the curves
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into text bevel goes
   *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
   *  bevelOffset: <float> // how far from text outline does bevel start
   * }
   */

  class TextGeometry extends ExtrudeGeometry {

  	constructor( text, parameters = {} ) {

  		const font = parameters.font;

  		if ( ! ( font && font.isFont ) ) {

  			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
  			return new BufferGeometry();

  		}

  		const shapes = font.generateShapes( text, parameters.size );

  		// translate parameters to ExtrudeGeometry API

  		parameters.depth = parameters.height !== undefined ? parameters.height : 50;

  		// defaults

  		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
  		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
  		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

  		super( shapes, parameters );

  		this.type = 'TextGeometry';

  	}

  }

  class TorusGeometry extends BufferGeometry {

  	constructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2 ) {

  		super();
  		this.type = 'TorusGeometry';

  		this.parameters = {
  			radius: radius,
  			tube: tube,
  			radialSegments: radialSegments,
  			tubularSegments: tubularSegments,
  			arc: arc
  		};

  		radialSegments = Math.floor( radialSegments );
  		tubularSegments = Math.floor( tubularSegments );

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// helper variables

  		const center = new Vector3();
  		const vertex = new Vector3();
  		const normal = new Vector3();

  		// generate vertices, normals and uvs

  		for ( let j = 0; j <= radialSegments; j ++ ) {

  			for ( let i = 0; i <= tubularSegments; i ++ ) {

  				const u = i / tubularSegments * arc;
  				const v = j / radialSegments * Math.PI * 2;

  				// vertex

  				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
  				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
  				vertex.z = tube * Math.sin( v );

  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				center.x = radius * Math.cos( u );
  				center.y = radius * Math.sin( u );
  				normal.subVectors( vertex, center ).normalize();

  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( i / tubularSegments );
  				uvs.push( j / radialSegments );

  			}

  		}

  		// generate indices

  		for ( let j = 1; j <= radialSegments; j ++ ) {

  			for ( let i = 1; i <= tubularSegments; i ++ ) {

  				// indices

  				const a = ( tubularSegments + 1 ) * j + i - 1;
  				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
  				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
  				const d = ( tubularSegments + 1 ) * j + i;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  }

  class TorusKnotGeometry extends BufferGeometry {

  	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

  		super();
  		this.type = 'TorusKnotGeometry';

  		this.parameters = {
  			radius: radius,
  			tube: tube,
  			tubularSegments: tubularSegments,
  			radialSegments: radialSegments,
  			p: p,
  			q: q
  		};

  		tubularSegments = Math.floor( tubularSegments );
  		radialSegments = Math.floor( radialSegments );

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// helper variables

  		const vertex = new Vector3();
  		const normal = new Vector3();

  		const P1 = new Vector3();
  		const P2 = new Vector3();

  		const B = new Vector3();
  		const T = new Vector3();
  		const N = new Vector3();

  		// generate vertices, normals and uvs

  		for ( let i = 0; i <= tubularSegments; ++ i ) {

  			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

  			const u = i / tubularSegments * p * Math.PI * 2;

  			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
  			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

  			calculatePositionOnCurve( u, p, q, radius, P1 );
  			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

  			// calculate orthonormal basis

  			T.subVectors( P2, P1 );
  			N.addVectors( P2, P1 );
  			B.crossVectors( T, N );
  			N.crossVectors( B, T );

  			// normalize B, N. T can be ignored, we don't use it

  			B.normalize();
  			N.normalize();

  			for ( let j = 0; j <= radialSegments; ++ j ) {

  				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
  				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

  				const v = j / radialSegments * Math.PI * 2;
  				const cx = - tube * Math.cos( v );
  				const cy = tube * Math.sin( v );

  				// now calculate the final vertex position.
  				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

  				vertex.x = P1.x + ( cx * N.x + cy * B.x );
  				vertex.y = P1.y + ( cx * N.y + cy * B.y );
  				vertex.z = P1.z + ( cx * N.z + cy * B.z );

  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

  				normal.subVectors( vertex, P1 ).normalize();

  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( i / tubularSegments );
  				uvs.push( j / radialSegments );

  			}

  		}

  		// generate indices

  		for ( let j = 1; j <= tubularSegments; j ++ ) {

  			for ( let i = 1; i <= radialSegments; i ++ ) {

  				// indices

  				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
  				const b = ( radialSegments + 1 ) * j + ( i - 1 );
  				const c = ( radialSegments + 1 ) * j + i;
  				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		// this function calculates the current position on the torus curve

  		function calculatePositionOnCurve( u, p, q, radius, position ) {

  			const cu = Math.cos( u );
  			const su = Math.sin( u );
  			const quOverP = q / p * u;
  			const cs = Math.cos( quOverP );

  			position.x = radius * ( 2 + cs ) * 0.5 * cu;
  			position.y = radius * ( 2 + cs ) * su * 0.5;
  			position.z = radius * Math.sin( quOverP ) * 0.5;

  		}

  	}

  }

  class TubeGeometry extends BufferGeometry {

  	constructor( path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

  		super();
  		this.type = 'TubeGeometry';

  		this.parameters = {
  			path: path,
  			tubularSegments: tubularSegments,
  			radius: radius,
  			radialSegments: radialSegments,
  			closed: closed
  		};

  		const frames = path.computeFrenetFrames( tubularSegments, closed );

  		// expose internals

  		this.tangents = frames.tangents;
  		this.normals = frames.normals;
  		this.binormals = frames.binormals;

  		// helper variables

  		const vertex = new Vector3();
  		const normal = new Vector3();
  		const uv = new Vector2();
  		let P = new Vector3();

  		// buffer

  		const vertices = [];
  		const normals = [];
  		const uvs = [];
  		const indices = [];

  		// create buffer data

  		generateBufferData();

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		// functions

  		function generateBufferData() {

  			for ( let i = 0; i < tubularSegments; i ++ ) {

  				generateSegment( i );

  			}

  			// if the geometry is not closed, generate the last row of vertices and normals
  			// at the regular position on the given path
  			//
  			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

  			generateSegment( ( closed === false ) ? tubularSegments : 0 );

  			// uvs are generated in a separate function.
  			// this makes it easy compute correct values for closed geometries

  			generateUVs();

  			// finally create faces

  			generateIndices();

  		}

  		function generateSegment( i ) {

  			// we use getPointAt to sample evenly distributed points from the given path

  			P = path.getPointAt( i / tubularSegments, P );

  			// retrieve corresponding normal and binormal

  			const N = frames.normals[ i ];
  			const B = frames.binormals[ i ];

  			// generate normals and vertices for the current segment

  			for ( let j = 0; j <= radialSegments; j ++ ) {

  				const v = j / radialSegments * Math.PI * 2;

  				const sin = Math.sin( v );
  				const cos = - Math.cos( v );

  				// normal

  				normal.x = ( cos * N.x + sin * B.x );
  				normal.y = ( cos * N.y + sin * B.y );
  				normal.z = ( cos * N.z + sin * B.z );
  				normal.normalize();

  				normals.push( normal.x, normal.y, normal.z );

  				// vertex

  				vertex.x = P.x + radius * normal.x;
  				vertex.y = P.y + radius * normal.y;
  				vertex.z = P.z + radius * normal.z;

  				vertices.push( vertex.x, vertex.y, vertex.z );

  			}

  		}

  		function generateIndices() {

  			for ( let j = 1; j <= tubularSegments; j ++ ) {

  				for ( let i = 1; i <= radialSegments; i ++ ) {

  					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
  					const b = ( radialSegments + 1 ) * j + ( i - 1 );
  					const c = ( radialSegments + 1 ) * j + i;
  					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

  					// faces

  					indices.push( a, b, d );
  					indices.push( b, c, d );

  				}

  			}

  		}

  		function generateUVs() {

  			for ( let i = 0; i <= tubularSegments; i ++ ) {

  				for ( let j = 0; j <= radialSegments; j ++ ) {

  					uv.x = i / tubularSegments;
  					uv.y = j / radialSegments;

  					uvs.push( uv.x, uv.y );

  				}

  			}

  		}

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.path = this.parameters.path.toJSON();

  		return data;

  	}

  }

  class WireframeGeometry extends BufferGeometry {

  	constructor( geometry ) {

  		super();
  		this.type = 'WireframeGeometry';

  		if ( geometry.isGeometry === true ) {

  			console.error( 'THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
  			return;

  		}

  		// buffer

  		const vertices = [];

  		// helper variables

  		const edge = [ 0, 0 ], edges = {};

  		const vertex = new Vector3();

  		if ( geometry.index !== null ) {

  			// indexed BufferGeometry

  			const position = geometry.attributes.position;
  			const indices = geometry.index;
  			let groups = geometry.groups;

  			if ( groups.length === 0 ) {

  				groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

  			}

  			// create a data structure that contains all eges without duplicates

  			for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

  				const group = groups[ o ];

  				const start = group.start;
  				const count = group.count;

  				for ( let i = start, l = ( start + count ); i < l; i += 3 ) {

  					for ( let j = 0; j < 3; j ++ ) {

  						const edge1 = indices.getX( i + j );
  						const edge2 = indices.getX( i + ( j + 1 ) % 3 );
  						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
  						edge[ 1 ] = Math.max( edge1, edge2 );

  						const key = edge[ 0 ] + ',' + edge[ 1 ];

  						if ( edges[ key ] === undefined ) {

  							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

  						}

  					}

  				}

  			}

  			// generate vertices

  			for ( const key in edges ) {

  				const e = edges[ key ];

  				vertex.fromBufferAttribute( position, e.index1 );
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				vertex.fromBufferAttribute( position, e.index2 );
  				vertices.push( vertex.x, vertex.y, vertex.z );

  			}

  		} else {

  			// non-indexed BufferGeometry

  			const position = geometry.attributes.position;

  			for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

  				for ( let j = 0; j < 3; j ++ ) {

  					// three edges per triangle, an edge is represented as (index1, index2)
  					// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

  					const index1 = 3 * i + j;
  					vertex.fromBufferAttribute( position, index1 );
  					vertices.push( vertex.x, vertex.y, vertex.z );

  					const index2 = 3 * i + ( ( j + 1 ) % 3 );
  					vertex.fromBufferAttribute( position, index2 );
  					vertices.push( vertex.x, vertex.y, vertex.z );

  				}

  			}

  		}

  		// build geometry

  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  	}

  }

  var Geometries = /*#__PURE__*/Object.freeze({
  	__proto__: null,
  	BoxGeometry: BoxGeometry,
  	BoxBufferGeometry: BoxGeometry,
  	CircleGeometry: CircleGeometry,
  	CircleBufferGeometry: CircleGeometry,
  	ConeGeometry: ConeGeometry,
  	ConeBufferGeometry: ConeGeometry,
  	CylinderGeometry: CylinderGeometry,
  	CylinderBufferGeometry: CylinderGeometry,
  	DodecahedronGeometry: DodecahedronGeometry,
  	DodecahedronBufferGeometry: DodecahedronGeometry,
  	EdgesGeometry: EdgesGeometry,
  	ExtrudeGeometry: ExtrudeGeometry,
  	ExtrudeBufferGeometry: ExtrudeGeometry,
  	IcosahedronGeometry: IcosahedronGeometry,
  	IcosahedronBufferGeometry: IcosahedronGeometry,
  	LatheGeometry: LatheGeometry,
  	LatheBufferGeometry: LatheGeometry,
  	OctahedronGeometry: OctahedronGeometry,
  	OctahedronBufferGeometry: OctahedronGeometry,
  	ParametricGeometry: ParametricGeometry,
  	ParametricBufferGeometry: ParametricGeometry,
  	PlaneGeometry: PlaneGeometry,
  	PlaneBufferGeometry: PlaneGeometry,
  	PolyhedronGeometry: PolyhedronGeometry,
  	PolyhedronBufferGeometry: PolyhedronGeometry,
  	RingGeometry: RingGeometry,
  	RingBufferGeometry: RingGeometry,
  	ShapeGeometry: ShapeGeometry,
  	ShapeBufferGeometry: ShapeGeometry,
  	SphereGeometry: SphereGeometry,
  	SphereBufferGeometry: SphereGeometry,
  	TetrahedronGeometry: TetrahedronGeometry,
  	TetrahedronBufferGeometry: TetrahedronGeometry,
  	TextGeometry: TextGeometry,
  	TextBufferGeometry: TextGeometry,
  	TorusGeometry: TorusGeometry,
  	TorusBufferGeometry: TorusGeometry,
  	TorusKnotGeometry: TorusKnotGeometry,
  	TorusKnotBufferGeometry: TorusKnotGeometry,
  	TubeGeometry: TubeGeometry,
  	TubeBufferGeometry: TubeGeometry,
  	WireframeGeometry: WireframeGeometry
  });

  /**
   * parameters = {
   *  color: <THREE.Color>
   * }
   */

  class ShadowMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.type = 'ShadowMaterial';

  		this.color = new Color( 0x000000 );
  		this.transparent = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		return this;

  	}

  }

  ShadowMaterial.prototype.isShadowMaterial = true;

  class RawShaderMaterial extends ShaderMaterial {

  	constructor( parameters ) {

  		super( parameters );

  		this.type = 'RawShaderMaterial';

  	}

  }

  RawShaderMaterial.prototype.isRawShaderMaterial = true;

  /**
   * parameters = {
   *  color: <hex>,
   *  roughness: <float>,
   *  metalness: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  roughnessMap: new THREE.Texture( <Image> ),
   *
   *  metalnessMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  envMapIntensity: <float>
   *
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  morphTargets: <bool>,
   *  morphNormals: <bool>,
   *
   *  flatShading: <bool>
   * }
   */

  class MeshStandardMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.defines = { 'STANDARD': '' };

  		this.type = 'MeshStandardMaterial';

  		this.color = new Color( 0xffffff ); // diffuse
  		this.roughness = 1.0;
  		this.metalness = 0.0;

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.roughnessMap = null;

  		this.metalnessMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.envMapIntensity = 1.0;

  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.morphTargets = false;
  		this.morphNormals = false;

  		this.flatShading = false;

  		this.vertexTangents = false;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.defines = { 'STANDARD': '' };

  		this.color.copy( source.color );
  		this.roughness = source.roughness;
  		this.metalness = source.metalness;

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.roughnessMap = source.roughnessMap;

  		this.metalnessMap = source.metalnessMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapIntensity = source.envMapIntensity;

  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		this.flatShading = source.flatShading;

  		this.vertexTangents = source.vertexTangents;

  		return this;

  	}

  }

  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

  /**
   * parameters = {
   *  clearcoat: <float>,
   *  clearcoatMap: new THREE.Texture( <Image> ),
   *  clearcoatRoughness: <float>,
   *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
   *  clearcoatNormalScale: <Vector2>,
   *  clearcoatNormalMap: new THREE.Texture( <Image> ),
   *
   *  reflectivity: <float>,
   *  ior: <float>,
   *
   *  sheen: <Color>,
   *
   *  transmission: <float>,
   *  transmissionMap: new THREE.Texture( <Image> ),
   *
   *  thickness: <float>,
   *  thicknessMap: new THREE.Texture( <Image> ),
   *  attenuationDistance: <float>,
   *  attenuationColor: <Color>
   * }
   */

  class MeshPhysicalMaterial extends MeshStandardMaterial {

  	constructor( parameters ) {

  		super();

  		this.defines = {

  			'STANDARD': '',
  			'PHYSICAL': ''

  		};

  		this.type = 'MeshPhysicalMaterial';

  		this.clearcoat = 0.0;
  		this.clearcoatMap = null;
  		this.clearcoatRoughness = 0.0;
  		this.clearcoatRoughnessMap = null;
  		this.clearcoatNormalScale = new Vector2( 1, 1 );
  		this.clearcoatNormalMap = null;

  		this.reflectivity = 0.5; // maps to F0 = 0.04

  		Object.defineProperty( this, 'ior', {
  			get: function () {

  				return ( 1 + 0.4 * this.reflectivity ) / ( 1 - 0.4 * this.reflectivity );

  			},
  			set: function ( ior ) {

  				this.reflectivity = clamp( 2.5 * ( ior - 1 ) / ( ior + 1 ), 0, 1 );

  			}
  		} );

  		this.sheen = null; // null will disable sheen bsdf

  		this.transmission = 0.0;
  		this.transmissionMap = null;

  		this.thickness = 0.01;
  		this.thicknessMap = null;
  		this.attenuationDistance = 0.0;
  		this.attenuationColor = new Color( 1, 1, 1 );

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.defines = {

  			'STANDARD': '',
  			'PHYSICAL': ''

  		};

  		this.clearcoat = source.clearcoat;
  		this.clearcoatMap = source.clearcoatMap;
  		this.clearcoatRoughness = source.clearcoatRoughness;
  		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  		this.clearcoatNormalMap = source.clearcoatNormalMap;
  		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

  		this.reflectivity = source.reflectivity;

  		if ( source.sheen ) {

  			this.sheen = ( this.sheen || new Color() ).copy( source.sheen );

  		} else {

  			this.sheen = null;

  		}

  		this.transmission = source.transmission;
  		this.transmissionMap = source.transmissionMap;

  		this.thickness = source.thickness;
  		this.thicknessMap = source.thicknessMap;
  		this.attenuationDistance = source.attenuationDistance;
  		this.attenuationColor.copy( source.attenuationColor );

  		return this;

  	}

  }

  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

  /**
   * parameters = {
   *  color: <hex>,
   *  specular: <hex>,
   *  shininess: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.MultiplyOperation,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  morphTargets: <bool>,
   *  morphNormals: <bool>,
   *
   *  flatShading: <bool>
   * }
   */

  class MeshPhongMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.type = 'MeshPhongMaterial';

  		this.color = new Color( 0xffffff ); // diffuse
  		this.specular = new Color( 0x111111 );
  		this.shininess = 30;

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.specularMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.combine = MultiplyOperation;
  		this.reflectivity = 1;
  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.morphTargets = false;
  		this.morphNormals = false;

  		this.flatShading = false;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );
  		this.specular.copy( source.specular );
  		this.shininess = source.shininess;

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		this.flatShading = source.flatShading;

  		return this;

  	}

  }

  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

  /**
   * parameters = {
   *  color: <hex>,
   *
   *  map: new THREE.Texture( <Image> ),
   *  gradientMap: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  class MeshToonMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.defines = { 'TOON': '' };

  		this.type = 'MeshToonMaterial';

  		this.color = new Color( 0xffffff );

  		this.map = null;
  		this.gradientMap = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.alphaMap = null;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.morphTargets = false;
  		this.morphNormals = false;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;
  		this.gradientMap = source.gradientMap;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.alphaMap = source.alphaMap;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		return this;

  	}

  }

  MeshToonMaterial.prototype.isMeshToonMaterial = true;

  /**
   * parameters = {
   *  opacity: <float>,
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   *
   *  morphTargets: <bool>,
   *  morphNormals: <bool>,
   *
   *  flatShading: <bool>
   * }
   */

  class MeshNormalMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.type = 'MeshNormalMaterial';

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;

  		this.fog = false;

  		this.morphTargets = false;
  		this.morphNormals = false;

  		this.flatShading = false;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		this.flatShading = source.flatShading;

  		return this;

  	}

  }

  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

  /**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  class MeshLambertMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.type = 'MeshLambertMaterial';

  		this.color = new Color( 0xffffff ); // diffuse

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.specularMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.combine = MultiplyOperation;
  		this.reflectivity = 1;
  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.morphTargets = false;
  		this.morphNormals = false;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		return this;

  	}

  }

  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

  /**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  matcap: new THREE.Texture( <Image> ),
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   *
   *  flatShading: <bool>
   * }
   */

  class MeshMatcapMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.defines = { 'MATCAP': '' };

  		this.type = 'MeshMatcapMaterial';

  		this.color = new Color( 0xffffff ); // diffuse

  		this.matcap = null;

  		this.map = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.alphaMap = null;

  		this.morphTargets = false;
  		this.morphNormals = false;

  		this.flatShading = false;

  		this.setValues( parameters );

  	}


  	copy( source ) {

  		super.copy( source );

  		this.defines = { 'MATCAP': '' };

  		this.color.copy( source.color );

  		this.matcap = source.matcap;

  		this.map = source.map;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.alphaMap = source.alphaMap;

  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		this.flatShading = source.flatShading;

  		return this;

  	}

  }

  MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

  /**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *
   *  scale: <float>,
   *  dashSize: <float>,
   *  gapSize: <float>
   * }
   */

  class LineDashedMaterial extends LineBasicMaterial {

  	constructor( parameters ) {

  		super();

  		this.type = 'LineDashedMaterial';

  		this.scale = 1;
  		this.dashSize = 3;
  		this.gapSize = 1;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.scale = source.scale;
  		this.dashSize = source.dashSize;
  		this.gapSize = source.gapSize;

  		return this;

  	}

  }

  LineDashedMaterial.prototype.isLineDashedMaterial = true;

  var Materials = /*#__PURE__*/Object.freeze({
  	__proto__: null,
  	ShadowMaterial: ShadowMaterial,
  	SpriteMaterial: SpriteMaterial,
  	RawShaderMaterial: RawShaderMaterial,
  	ShaderMaterial: ShaderMaterial,
  	PointsMaterial: PointsMaterial,
  	MeshPhysicalMaterial: MeshPhysicalMaterial,
  	MeshStandardMaterial: MeshStandardMaterial,
  	MeshPhongMaterial: MeshPhongMaterial,
  	MeshToonMaterial: MeshToonMaterial,
  	MeshNormalMaterial: MeshNormalMaterial,
  	MeshLambertMaterial: MeshLambertMaterial,
  	MeshDepthMaterial: MeshDepthMaterial,
  	MeshDistanceMaterial: MeshDistanceMaterial,
  	MeshBasicMaterial: MeshBasicMaterial,
  	MeshMatcapMaterial: MeshMatcapMaterial,
  	LineDashedMaterial: LineDashedMaterial,
  	LineBasicMaterial: LineBasicMaterial,
  	Material: Material
  });

  const AnimationUtils = {

  	// same as Array.prototype.slice, but also works on typed arrays
  	arraySlice: function ( array, from, to ) {

  		if ( AnimationUtils.isTypedArray( array ) ) {

  			// in ios9 array.subarray(from, undefined) will return empty array
  			// but array.subarray(from) or array.subarray(from, len) is correct
  			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

  		}

  		return array.slice( from, to );

  	},

  	// converts an array to a specific type
  	convertArray: function ( array, type, forceClone ) {

  		if ( ! array || // let 'undefined' and 'null' pass
  			! forceClone && array.constructor === type ) return array;

  		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

  			return new type( array ); // create typed array

  		}

  		return Array.prototype.slice.call( array ); // create Array

  	},

  	isTypedArray: function ( object ) {

  		return ArrayBuffer.isView( object ) &&
  			! ( object instanceof DataView );

  	},

  	// returns an array by which times and values can be sorted
  	getKeyframeOrder: function ( times ) {

  		function compareTime( i, j ) {

  			return times[ i ] - times[ j ];

  		}

  		const n = times.length;
  		const result = new Array( n );
  		for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

  		result.sort( compareTime );

  		return result;

  	},

  	// uses the array previously returned by 'getKeyframeOrder' to sort data
  	sortedArray: function ( values, stride, order ) {

  		const nValues = values.length;
  		const result = new values.constructor( nValues );

  		for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

  			const srcOffset = order[ i ] * stride;

  			for ( let j = 0; j !== stride; ++ j ) {

  				result[ dstOffset ++ ] = values[ srcOffset + j ];

  			}

  		}

  		return result;

  	},

  	// function for parsing AOS keyframe formats
  	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

  		let i = 1, key = jsonKeys[ 0 ];

  		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

  			key = jsonKeys[ i ++ ];

  		}

  		if ( key === undefined ) return; // no data

  		let value = key[ valuePropertyName ];
  		if ( value === undefined ) return; // no data

  		if ( Array.isArray( value ) ) {

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					values.push.apply( values, value ); // push all elements

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		} else if ( value.toArray !== undefined ) {

  			// ...assume THREE.Math-ish

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					value.toArray( values, values.length );

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		} else {

  			// otherwise push as-is

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					values.push( value );

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		}

  	},

  	subclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {

  		const clip = sourceClip.clone();

  		clip.name = name;

  		const tracks = [];

  		for ( let i = 0; i < clip.tracks.length; ++ i ) {

  			const track = clip.tracks[ i ];
  			const valueSize = track.getValueSize();

  			const times = [];
  			const values = [];

  			for ( let j = 0; j < track.times.length; ++ j ) {

  				const frame = track.times[ j ] * fps;

  				if ( frame < startFrame || frame >= endFrame ) continue;

  				times.push( track.times[ j ] );

  				for ( let k = 0; k < valueSize; ++ k ) {

  					values.push( track.values[ j * valueSize + k ] );

  				}

  			}

  			if ( times.length === 0 ) continue;

  			track.times = AnimationUtils.convertArray( times, track.times.constructor );
  			track.values = AnimationUtils.convertArray( values, track.values.constructor );

  			tracks.push( track );

  		}

  		clip.tracks = tracks;

  		// find minimum .times value across all tracks in the trimmed clip

  		let minStartTime = Infinity;

  		for ( let i = 0; i < clip.tracks.length; ++ i ) {

  			if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

  				minStartTime = clip.tracks[ i ].times[ 0 ];

  			}

  		}

  		// shift all tracks such that clip begins at t=0

  		for ( let i = 0; i < clip.tracks.length; ++ i ) {

  			clip.tracks[ i ].shift( - 1 * minStartTime );

  		}

  		clip.resetDuration();

  		return clip;

  	},

  	makeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

  		if ( fps <= 0 ) fps = 30;

  		const numTracks = referenceClip.tracks.length;
  		const referenceTime = referenceFrame / fps;

  		// Make each track's values relative to the values at the reference frame
  		for ( let i = 0; i < numTracks; ++ i ) {

  			const referenceTrack = referenceClip.tracks[ i ];
  			const referenceTrackType = referenceTrack.ValueTypeName;

  			// Skip this track if it's non-numeric
  			if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

  			// Find the track in the target clip whose name and type matches the reference track
  			const targetTrack = targetClip.tracks.find( function ( track ) {

  				return track.name === referenceTrack.name
  					&& track.ValueTypeName === referenceTrackType;

  			} );

  			if ( targetTrack === undefined ) continue;

  			let referenceOffset = 0;
  			const referenceValueSize = referenceTrack.getValueSize();

  			if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

  				referenceOffset = referenceValueSize / 3;

  			}

  			let targetOffset = 0;
  			const targetValueSize = targetTrack.getValueSize();

  			if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

  				targetOffset = targetValueSize / 3;

  			}

  			const lastIndex = referenceTrack.times.length - 1;
  			let referenceValue;

  			// Find the value to subtract out of the track
  			if ( referenceTime <= referenceTrack.times[ 0 ] ) {

  				// Reference frame is earlier than the first keyframe, so just use the first keyframe
  				const startIndex = referenceOffset;
  				const endIndex = referenceValueSize - referenceOffset;
  				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

  			} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

  				// Reference frame is after the last keyframe, so just use the last keyframe
  				const startIndex = lastIndex * referenceValueSize + referenceOffset;
  				const endIndex = startIndex + referenceValueSize - referenceOffset;
  				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

  			} else {

  				// Interpolate to the reference value
  				const interpolant = referenceTrack.createInterpolant();
  				const startIndex = referenceOffset;
  				const endIndex = referenceValueSize - referenceOffset;
  				interpolant.evaluate( referenceTime );
  				referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );

  			}

  			// Conjugate the quaternion
  			if ( referenceTrackType === 'quaternion' ) {

  				const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
  				referenceQuat.toArray( referenceValue );

  			}

  			// Subtract the reference value from all of the track values

  			const numTimes = targetTrack.times.length;
  			for ( let j = 0; j < numTimes; ++ j ) {

  				const valueStart = j * targetValueSize + targetOffset;

  				if ( referenceTrackType === 'quaternion' ) {

  					// Multiply the conjugate for quaternion track types
  					Quaternion.multiplyQuaternionsFlat(
  						targetTrack.values,
  						valueStart,
  						referenceValue,
  						0,
  						targetTrack.values,
  						valueStart
  					);

  				} else {

  					const valueEnd = targetValueSize - targetOffset * 2;

  					// Subtract each value for all other numeric track types
  					for ( let k = 0; k < valueEnd; ++ k ) {

  						targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

  					}

  				}

  			}

  		}

  		targetClip.blendMode = AdditiveAnimationBlendMode;

  		return targetClip;

  	}

  };

  /**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References:
   *
   * 		http://www.oodesign.com/template-method-pattern.html
   *
   */

  class Interpolant {

  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		this.parameterPositions = parameterPositions;
  		this._cachedIndex = 0;

  		this.resultBuffer = resultBuffer !== undefined ?
  			resultBuffer : new sampleValues.constructor( sampleSize );
  		this.sampleValues = sampleValues;
  		this.valueSize = sampleSize;

  		this.settings = null;
  		this.DefaultSettings_ = {};

  	}

  	evaluate( t ) {

  		const pp = this.parameterPositions;
  		let i1 = this._cachedIndex,
  			t1 = pp[ i1 ],
  			t0 = pp[ i1 - 1 ];

  		validate_interval: {

  			seek: {

  				let right;

  				linear_scan: {

  					//- See http://jsperf.com/comparison-to-undefined/3
  					//- slower code:
  					//-
  					//- 				if ( t >= t1 || t1 === undefined ) {
  					forward_scan: if ( ! ( t < t1 ) ) {

  						for ( let giveUpAt = i1 + 2; ; ) {

  							if ( t1 === undefined ) {

  								if ( t < t0 ) break forward_scan;

  								// after end

  								i1 = pp.length;
  								this._cachedIndex = i1;
  								return this.afterEnd_( i1 - 1, t, t0 );

  							}

  							if ( i1 === giveUpAt ) break; // this loop

  							t0 = t1;
  							t1 = pp[ ++ i1 ];

  							if ( t < t1 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the right side of the index
  						right = pp.length;
  						break linear_scan;

  					}

  					//- slower code:
  					//-					if ( t < t0 || t0 === undefined ) {
  					if ( ! ( t >= t0 ) ) {

  						// looping?

  						const t1global = pp[ 1 ];

  						if ( t < t1global ) {

  							i1 = 2; // + 1, using the scan for the details
  							t0 = t1global;

  						}

  						// linear reverse scan

  						for ( let giveUpAt = i1 - 2; ; ) {

  							if ( t0 === undefined ) {

  								// before start

  								this._cachedIndex = 0;
  								return this.beforeStart_( 0, t, t1 );

  							}

  							if ( i1 === giveUpAt ) break; // this loop

  							t1 = t0;
  							t0 = pp[ -- i1 - 1 ];

  							if ( t >= t0 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the left side of the index
  						right = i1;
  						i1 = 0;
  						break linear_scan;

  					}

  					// the interval is valid

  					break validate_interval;

  				} // linear scan

  				// binary search

  				while ( i1 < right ) {

  					const mid = ( i1 + right ) >>> 1;

  					if ( t < pp[ mid ] ) {

  						right = mid;

  					} else {

  						i1 = mid + 1;

  					}

  				}

  				t1 = pp[ i1 ];
  				t0 = pp[ i1 - 1 ];

  				// check boundary cases, again

  				if ( t0 === undefined ) {

  					this._cachedIndex = 0;
  					return this.beforeStart_( 0, t, t1 );

  				}

  				if ( t1 === undefined ) {

  					i1 = pp.length;
  					this._cachedIndex = i1;
  					return this.afterEnd_( i1 - 1, t0, t );

  				}

  			} // seek

  			this._cachedIndex = i1;

  			this.intervalChanged_( i1, t0, t1 );

  		} // validate_interval

  		return this.interpolate_( i1, t0, t, t1 );

  	}

  	getSettings_() {

  		return this.settings || this.DefaultSettings_;

  	}

  	copySampleValue_( index ) {

  		// copies a sample value to the result buffer

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,
  			offset = index * stride;

  		for ( let i = 0; i !== stride; ++ i ) {

  			result[ i ] = values[ offset + i ];

  		}

  		return result;

  	}

  	// Template methods for derived classes:

  	interpolate_( /* i1, t0, t, t1 */ ) {

  		throw new Error( 'call to abstract method' );
  		// implementations shall return this.resultBuffer

  	}

  	intervalChanged_( /* i1, t0, t1 */ ) {

  		// empty

  	}

  }

  // ALIAS DEFINITIONS

  Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
  Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;

  /**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   */

  class CubicInterpolant extends Interpolant {

  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  		this._weightPrev = - 0;
  		this._offsetPrev = - 0;
  		this._weightNext = - 0;
  		this._offsetNext = - 0;

  		this.DefaultSettings_ = {

  			endingStart: ZeroCurvatureEnding,
  			endingEnd: ZeroCurvatureEnding

  		};

  	}

  	intervalChanged_( i1, t0, t1 ) {

  		const pp = this.parameterPositions;
  		let iPrev = i1 - 2,
  			iNext = i1 + 1,

  			tPrev = pp[ iPrev ],
  			tNext = pp[ iNext ];

  		if ( tPrev === undefined ) {

  			switch ( this.getSettings_().endingStart ) {

  				case ZeroSlopeEnding:

  					// f'(t0) = 0
  					iPrev = i1;
  					tPrev = 2 * t0 - t1;

  					break;

  				case WrapAroundEnding:

  					// use the other end of the curve
  					iPrev = pp.length - 2;
  					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(t0) = 0 a.k.a. Natural Spline
  					iPrev = i1;
  					tPrev = t1;

  			}

  		}

  		if ( tNext === undefined ) {

  			switch ( this.getSettings_().endingEnd ) {

  				case ZeroSlopeEnding:

  					// f'(tN) = 0
  					iNext = i1;
  					tNext = 2 * t1 - t0;

  					break;

  				case WrapAroundEnding:

  					// use the other end of the curve
  					iNext = 1;
  					tNext = t1 + pp[ 1 ] - pp[ 0 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(tN) = 0, a.k.a. Natural Spline
  					iNext = i1 - 1;
  					tNext = t0;

  			}

  		}

  		const halfDt = ( t1 - t0 ) * 0.5,
  			stride = this.valueSize;

  		this._weightPrev = halfDt / ( t0 - tPrev );
  		this._weightNext = halfDt / ( tNext - t1 );
  		this._offsetPrev = iPrev * stride;
  		this._offsetNext = iNext * stride;

  	}

  	interpolate_( i1, t0, t, t1 ) {

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			o1 = i1 * stride,		o0 = o1 - stride,
  			oP = this._offsetPrev, 	oN = this._offsetNext,
  			wP = this._weightPrev,	wN = this._weightNext,

  			p = ( t - t0 ) / ( t1 - t0 ),
  			pp = p * p,
  			ppp = pp * p;

  		// evaluate polynomials

  		const sP = - wP * ppp + 2 * wP * pp - wP * p;
  		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
  		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
  		const sN = wN * ppp - wN * pp;

  		// combine data linearly

  		for ( let i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					sP * values[ oP + i ] +
  					s0 * values[ o0 + i ] +
  					s1 * values[ o1 + i ] +
  					sN * values[ oN + i ];

  		}

  		return result;

  	}

  }

  class LinearInterpolant extends Interpolant {

  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	interpolate_( i1, t0, t, t1 ) {

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			offset1 = i1 * stride,
  			offset0 = offset1 - stride,

  			weight1 = ( t - t0 ) / ( t1 - t0 ),
  			weight0 = 1 - weight1;

  		for ( let i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					values[ offset0 + i ] * weight0 +
  					values[ offset1 + i ] * weight1;

  		}

  		return result;

  	}

  }

  /**
   *
   * Interpolant that evaluates to the sample value at the position preceeding
   * the parameter.
   */

  class DiscreteInterpolant extends Interpolant {

  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	interpolate_( i1 /*, t0, t, t1 */ ) {

  		return this.copySampleValue_( i1 - 1 );

  	}

  }

  class KeyframeTrack {

  	constructor( name, times, values, interpolation ) {

  		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
  		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

  		this.name = name;

  		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
  		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

  		this.setInterpolation( interpolation || this.DefaultInterpolation );

  	}

  	// Serialization (in static context, because of constructor invocation
  	// and automatic invocation of .toJSON):

  	static toJSON( track ) {

  		const trackType = track.constructor;

  		let json;

  		// derived classes can define a static toJSON method
  		if ( trackType.toJSON !== this.toJSON ) {

  			json = trackType.toJSON( track );

  		} else {

  			// by default, we assume the data can be serialized as-is
  			json = {

  				'name': track.name,
  				'times': AnimationUtils.convertArray( track.times, Array ),
  				'values': AnimationUtils.convertArray( track.values, Array )

  			};

  			const interpolation = track.getInterpolation();

  			if ( interpolation !== track.DefaultInterpolation ) {

  				json.interpolation = interpolation;

  			}

  		}

  		json.type = track.ValueTypeName; // mandatory

  		return json;

  	}

  	InterpolantFactoryMethodDiscrete( result ) {

  		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

  	}

  	InterpolantFactoryMethodLinear( result ) {

  		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

  	}

  	InterpolantFactoryMethodSmooth( result ) {

  		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

  	}

  	setInterpolation( interpolation ) {

  		let factoryMethod;

  		switch ( interpolation ) {

  			case InterpolateDiscrete:

  				factoryMethod = this.InterpolantFactoryMethodDiscrete;

  				break;

  			case InterpolateLinear:

  				factoryMethod = this.InterpolantFactoryMethodLinear;

  				break;

  			case InterpolateSmooth:

  				factoryMethod = this.InterpolantFactoryMethodSmooth;

  				break;

  		}

  		if ( factoryMethod === undefined ) {

  			const message = 'unsupported interpolation for ' +
  				this.ValueTypeName + ' keyframe track named ' + this.name;

  			if ( this.createInterpolant === undefined ) {

  				// fall back to default, unless the default itself is messed up
  				if ( interpolation !== this.DefaultInterpolation ) {

  					this.setInterpolation( this.DefaultInterpolation );

  				} else {

  					throw new Error( message ); // fatal, in this case

  				}

  			}

  			console.warn( 'THREE.KeyframeTrack:', message );
  			return this;

  		}

  		this.createInterpolant = factoryMethod;

  		return this;

  	}

  	getInterpolation() {

  		switch ( this.createInterpolant ) {

  			case this.InterpolantFactoryMethodDiscrete:

  				return InterpolateDiscrete;

  			case this.InterpolantFactoryMethodLinear:

  				return InterpolateLinear;

  			case this.InterpolantFactoryMethodSmooth:

  				return InterpolateSmooth;

  		}

  	}

  	getValueSize() {

  		return this.values.length / this.times.length;

  	}

  	// move all keyframes either forwards or backwards in time
  	shift( timeOffset ) {

  		if ( timeOffset !== 0.0 ) {

  			const times = this.times;

  			for ( let i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] += timeOffset;

  			}

  		}

  		return this;

  	}

  	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  	scale( timeScale ) {

  		if ( timeScale !== 1.0 ) {

  			const times = this.times;

  			for ( let i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] *= timeScale;

  			}

  		}

  		return this;

  	}

  	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  	trim( startTime, endTime ) {

  		const times = this.times,
  			nKeys = times.length;

  		let from = 0,
  			to = nKeys - 1;

  		while ( from !== nKeys && times[ from ] < startTime ) {

  			++ from;

  		}

  		while ( to !== - 1 && times[ to ] > endTime ) {

  			-- to;

  		}

  		++ to; // inclusive -> exclusive bound

  		if ( from !== 0 || to !== nKeys ) {

  			// empty tracks are forbidden, so keep at least one keyframe
  			if ( from >= to ) {

  				to = Math.max( to, 1 );
  				from = to - 1;

  			}

  			const stride = this.getValueSize();
  			this.times = AnimationUtils.arraySlice( times, from, to );
  			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

  		}

  		return this;

  	}

  	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  	validate() {

  		let valid = true;

  		const valueSize = this.getValueSize();
  		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

  			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
  			valid = false;

  		}

  		const times = this.times,
  			values = this.values,

  			nKeys = times.length;

  		if ( nKeys === 0 ) {

  			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
  			valid = false;

  		}

  		let prevTime = null;

  		for ( let i = 0; i !== nKeys; i ++ ) {

  			const currTime = times[ i ];

  			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

  				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
  				valid = false;
  				break;

  			}

  			if ( prevTime !== null && prevTime > currTime ) {

  				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
  				valid = false;
  				break;

  			}

  			prevTime = currTime;

  		}

  		if ( values !== undefined ) {

  			if ( AnimationUtils.isTypedArray( values ) ) {

  				for ( let i = 0, n = values.length; i !== n; ++ i ) {

  					const value = values[ i ];

  					if ( isNaN( value ) ) {

  						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
  						valid = false;
  						break;

  					}

  				}

  			}

  		}

  		return valid;

  	}

  	// removes equivalent sequential keys as common in morph target sequences
  	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  	optimize() {

  		// times or values may be shared with other tracks, so overwriting is unsafe
  		const times = AnimationUtils.arraySlice( this.times ),
  			values = AnimationUtils.arraySlice( this.values ),
  			stride = this.getValueSize(),

  			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

  			lastIndex = times.length - 1;

  		let writeIndex = 1;

  		for ( let i = 1; i < lastIndex; ++ i ) {

  			let keep = false;

  			const time = times[ i ];
  			const timeNext = times[ i + 1 ];

  			// remove adjacent keyframes scheduled at the same time

  			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

  				if ( ! smoothInterpolation ) {

  					// remove unnecessary keyframes same as their neighbors

  					const offset = i * stride,
  						offsetP = offset - stride,
  						offsetN = offset + stride;

  					for ( let j = 0; j !== stride; ++ j ) {

  						const value = values[ offset + j ];

  						if ( value !== values[ offsetP + j ] ||
  							value !== values[ offsetN + j ] ) {

  							keep = true;
  							break;

  						}

  					}

  				} else {

  					keep = true;

  				}

  			}

  			// in-place compaction

  			if ( keep ) {

  				if ( i !== writeIndex ) {

  					times[ writeIndex ] = times[ i ];

  					const readOffset = i * stride,
  						writeOffset = writeIndex * stride;

  					for ( let j = 0; j !== stride; ++ j ) {

  						values[ writeOffset + j ] = values[ readOffset + j ];

  					}

  				}

  				++ writeIndex;

  			}

  		}

  		// flush last keyframe (compaction looks ahead)

  		if ( lastIndex > 0 ) {

  			times[ writeIndex ] = times[ lastIndex ];

  			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

  				values[ writeOffset + j ] = values[ readOffset + j ];

  			}

  			++ writeIndex;

  		}

  		if ( writeIndex !== times.length ) {

  			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
  			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

  		} else {

  			this.times = times;
  			this.values = values;

  		}

  		return this;

  	}

  	clone() {

  		const times = AnimationUtils.arraySlice( this.times, 0 );
  		const values = AnimationUtils.arraySlice( this.values, 0 );

  		const TypedKeyframeTrack = this.constructor;
  		const track = new TypedKeyframeTrack( this.name, times, values );

  		// Interpolant argument to constructor is not saved, so copy the factory method directly.
  		track.createInterpolant = this.createInterpolant;

  		return track;

  	}

  }

  KeyframeTrack.prototype.TimeBufferType = Float32Array;
  KeyframeTrack.prototype.ValueBufferType = Float32Array;
  KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

  /**
   * A Track of Boolean keyframe values.
   */
  class BooleanKeyframeTrack extends KeyframeTrack {}

  BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
  BooleanKeyframeTrack.prototype.ValueBufferType = Array;
  BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

  /**
   * A Track of keyframe values that represent color.
   */
  class ColorKeyframeTrack extends KeyframeTrack {}

  ColorKeyframeTrack.prototype.ValueTypeName = 'color';

  /**
   * A Track of numeric keyframe values.
   */
  class NumberKeyframeTrack extends KeyframeTrack {}

  NumberKeyframeTrack.prototype.ValueTypeName = 'number';

  /**
   * Spherical linear unit quaternion interpolant.
   */

  class QuaternionLinearInterpolant extends Interpolant {

  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	interpolate_( i1, t0, t, t1 ) {

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			alpha = ( t - t0 ) / ( t1 - t0 );

  		let offset = i1 * stride;

  		for ( let end = offset + stride; offset !== end; offset += 4 ) {

  			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

  		}

  		return result;

  	}

  }

  /**
   * A Track of quaternion keyframe values.
   */
  class QuaternionKeyframeTrack extends KeyframeTrack {

  	InterpolantFactoryMethodLinear( result ) {

  		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

  	}

  }

  QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
  // ValueBufferType is inherited
  QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
  QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

  /**
   * A Track that interpolates Strings
   */
  class StringKeyframeTrack extends KeyframeTrack {}

  StringKeyframeTrack.prototype.ValueTypeName = 'string';
  StringKeyframeTrack.prototype.ValueBufferType = Array;
  StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

  /**
   * A Track of vectored keyframe values.
   */
  class VectorKeyframeTrack extends KeyframeTrack {}

  VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

  class AnimationClip {

  	constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {

  		this.name = name;
  		this.tracks = tracks;
  		this.duration = duration;
  		this.blendMode = blendMode;

  		this.uuid = generateUUID();

  		// this means it should figure out its duration by scanning the tracks
  		if ( this.duration < 0 ) {

  			this.resetDuration();

  		}

  	}


  	static parse( json ) {

  		const tracks = [],
  			jsonTracks = json.tracks,
  			frameTime = 1.0 / ( json.fps || 1.0 );

  		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

  			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

  		}

  		const clip = new this( json.name, json.duration, tracks, json.blendMode );
  		clip.uuid = json.uuid;

  		return clip;

  	}

  	static toJSON( clip ) {

  		const tracks = [],
  			clipTracks = clip.tracks;

  		const json = {

  			'name': clip.name,
  			'duration': clip.duration,
  			'tracks': tracks,
  			'uuid': clip.uuid,
  			'blendMode': clip.blendMode

  		};

  		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

  			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

  		}

  		return json;

  	}

  	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

  		const numMorphTargets = morphTargetSequence.length;
  		const tracks = [];

  		for ( let i = 0; i < numMorphTargets; i ++ ) {

  			let times = [];
  			let values = [];

  			times.push(
  				( i + numMorphTargets - 1 ) % numMorphTargets,
  				i,
  				( i + 1 ) % numMorphTargets );

  			values.push( 0, 1, 0 );

  			const order = AnimationUtils.getKeyframeOrder( times );
  			times = AnimationUtils.sortedArray( times, 1, order );
  			values = AnimationUtils.sortedArray( values, 1, order );

  			// if there is a key at the first frame, duplicate it as the
  			// last frame as well for perfect loop.
  			if ( ! noLoop && times[ 0 ] === 0 ) {

  				times.push( numMorphTargets );
  				values.push( values[ 0 ] );

  			}

  			tracks.push(
  				new NumberKeyframeTrack(
  					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
  					times, values
  				).scale( 1.0 / fps ) );

  		}

  		return new this( name, - 1, tracks );

  	}

  	static findByName( objectOrClipArray, name ) {

  		let clipArray = objectOrClipArray;

  		if ( ! Array.isArray( objectOrClipArray ) ) {

  			const o = objectOrClipArray;
  			clipArray = o.geometry && o.geometry.animations || o.animations;

  		}

  		for ( let i = 0; i < clipArray.length; i ++ ) {

  			if ( clipArray[ i ].name === name ) {

  				return clipArray[ i ];

  			}

  		}

  		return null;

  	}

  	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

  		const animationToMorphTargets = {};

  		// tested with https://regex101.com/ on trick sequences
  		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
  		const pattern = /^([\w-]*?)([\d]+)$/;

  		// sort morph target names into animation groups based
  		// patterns like Walk_001, Walk_002, Run_001, Run_002
  		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

  			const morphTarget = morphTargets[ i ];
  			const parts = morphTarget.name.match( pattern );

  			if ( parts && parts.length > 1 ) {

  				const name = parts[ 1 ];

  				let animationMorphTargets = animationToMorphTargets[ name ];

  				if ( ! animationMorphTargets ) {

  					animationToMorphTargets[ name ] = animationMorphTargets = [];

  				}

  				animationMorphTargets.push( morphTarget );

  			}

  		}

  		const clips = [];

  		for ( const name in animationToMorphTargets ) {

  			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

  		}

  		return clips;

  	}

  	// parse the animation.hierarchy format
  	static parseAnimation( animation, bones ) {

  		if ( ! animation ) {

  			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
  			return null;

  		}

  		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

  			// only return track if there are actually keys.
  			if ( animationKeys.length !== 0 ) {

  				const times = [];
  				const values = [];

  				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

  				// empty keys are filtered out, so check again
  				if ( times.length !== 0 ) {

  					destTracks.push( new trackType( trackName, times, values ) );

  				}

  			}

  		};

  		const tracks = [];

  		const clipName = animation.name || 'default';
  		const fps = animation.fps || 30;
  		const blendMode = animation.blendMode;

  		// automatic length determination in AnimationClip.
  		let duration = animation.length || - 1;

  		const hierarchyTracks = animation.hierarchy || [];

  		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

  			const animationKeys = hierarchyTracks[ h ].keys;

  			// skip empty tracks
  			if ( ! animationKeys || animationKeys.length === 0 ) continue;

  			// process morph targets
  			if ( animationKeys[ 0 ].morphTargets ) {

  				// figure out all morph targets used in this track
  				const morphTargetNames = {};

  				let k;

  				for ( k = 0; k < animationKeys.length; k ++ ) {

  					if ( animationKeys[ k ].morphTargets ) {

  						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

  							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

  						}

  					}

  				}

  				// create a track for each morph target with all zero
  				// morphTargetInfluences except for the keys in which
  				// the morphTarget is named.
  				for ( const morphTargetName in morphTargetNames ) {

  					const times = [];
  					const values = [];

  					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

  						const animationKey = animationKeys[ k ];

  						times.push( animationKey.time );
  						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

  					}

  					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

  				}

  				duration = morphTargetNames.length * ( fps || 1.0 );

  			} else {

  				// ...assume skeletal animation

  				const boneName = '.bones[' + bones[ h ].name + ']';

  				addNonemptyTrack(
  					VectorKeyframeTrack, boneName + '.position',
  					animationKeys, 'pos', tracks );

  				addNonemptyTrack(
  					QuaternionKeyframeTrack, boneName + '.quaternion',
  					animationKeys, 'rot', tracks );

  				addNonemptyTrack(
  					VectorKeyframeTrack, boneName + '.scale',
  					animationKeys, 'scl', tracks );

  			}

  		}

  		if ( tracks.length === 0 ) {

  			return null;

  		}

  		const clip = new this( clipName, duration, tracks, blendMode );

  		return clip;

  	}

  	resetDuration() {

  		const tracks = this.tracks;
  		let duration = 0;

  		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

  			const track = this.tracks[ i ];

  			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

  		}

  		this.duration = duration;

  		return this;

  	}

  	trim() {

  		for ( let i = 0; i < this.tracks.length; i ++ ) {

  			this.tracks[ i ].trim( 0, this.duration );

  		}

  		return this;

  	}

  	validate() {

  		let valid = true;

  		for ( let i = 0; i < this.tracks.length; i ++ ) {

  			valid = valid && this.tracks[ i ].validate();

  		}

  		return valid;

  	}

  	optimize() {

  		for ( let i = 0; i < this.tracks.length; i ++ ) {

  			this.tracks[ i ].optimize();

  		}

  		return this;

  	}

  	clone() {

  		const tracks = [];

  		for ( let i = 0; i < this.tracks.length; i ++ ) {

  			tracks.push( this.tracks[ i ].clone() );

  		}

  		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

  	}

  	toJSON() {

  		return this.constructor.toJSON( this );

  	}

  }

  function getTrackTypeForValueTypeName( typeName ) {

  	switch ( typeName.toLowerCase() ) {

  		case 'scalar':
  		case 'double':
  		case 'float':
  		case 'number':
  		case 'integer':

  			return NumberKeyframeTrack;

  		case 'vector':
  		case 'vector2':
  		case 'vector3':
  		case 'vector4':

  			return VectorKeyframeTrack;

  		case 'color':

  			return ColorKeyframeTrack;

  		case 'quaternion':

  			return QuaternionKeyframeTrack;

  		case 'bool':
  		case 'boolean':

  			return BooleanKeyframeTrack;

  		case 'string':

  			return StringKeyframeTrack;

  	}

  	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

  }

  function parseKeyframeTrack( json ) {

  	if ( json.type === undefined ) {

  		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

  	}

  	const trackType = getTrackTypeForValueTypeName( json.type );

  	if ( json.times === undefined ) {

  		const times = [], values = [];

  		AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

  		json.times = times;
  		json.values = values;

  	}

  	// derived classes can define a static parse method
  	if ( trackType.parse !== undefined ) {

  		return trackType.parse( json );

  	} else {

  		// by default, we assume a constructor compatible with the base
  		return new trackType( json.name, json.times, json.values, json.interpolation );

  	}

  }

  const Cache = {

  	enabled: false,

  	files: {},

  	add: function ( key, file ) {

  		if ( this.enabled === false ) return;

  		// console.log( 'THREE.Cache', 'Adding key:', key );

  		this.files[ key ] = file;

  	},

  	get: function ( key ) {

  		if ( this.enabled === false ) return;

  		// console.log( 'THREE.Cache', 'Checking key:', key );

  		return this.files[ key ];

  	},

  	remove: function ( key ) {

  		delete this.files[ key ];

  	},

  	clear: function () {

  		this.files = {};

  	}

  };

  class LoadingManager {

  	constructor( onLoad, onProgress, onError ) {

  		const scope = this;

  		let isLoading = false;
  		let itemsLoaded = 0;
  		let itemsTotal = 0;
  		let urlModifier = undefined;
  		const handlers = [];

  		// Refer to #5689 for the reason why we don't set .onStart
  		// in the constructor

  		this.onStart = undefined;
  		this.onLoad = onLoad;
  		this.onProgress = onProgress;
  		this.onError = onError;

  		this.itemStart = function ( url ) {

  			itemsTotal ++;

  			if ( isLoading === false ) {

  				if ( scope.onStart !== undefined ) {

  					scope.onStart( url, itemsLoaded, itemsTotal );

  				}

  			}

  			isLoading = true;

  		};

  		this.itemEnd = function ( url ) {

  			itemsLoaded ++;

  			if ( scope.onProgress !== undefined ) {

  				scope.onProgress( url, itemsLoaded, itemsTotal );

  			}

  			if ( itemsLoaded === itemsTotal ) {

  				isLoading = false;

  				if ( scope.onLoad !== undefined ) {

  					scope.onLoad();

  				}

  			}

  		};

  		this.itemError = function ( url ) {

  			if ( scope.onError !== undefined ) {

  				scope.onError( url );

  			}

  		};

  		this.resolveURL = function ( url ) {

  			if ( urlModifier ) {

  				return urlModifier( url );

  			}

  			return url;

  		};

  		this.setURLModifier = function ( transform ) {

  			urlModifier = transform;

  			return this;

  		};

  		this.addHandler = function ( regex, loader ) {

  			handlers.push( regex, loader );

  			return this;

  		};

  		this.removeHandler = function ( regex ) {

  			const index = handlers.indexOf( regex );

  			if ( index !== - 1 ) {

  				handlers.splice( index, 2 );

  			}

  			return this;

  		};

  		this.getHandler = function ( file ) {

  			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

  				const regex = handlers[ i ];
  				const loader = handlers[ i + 1 ];

  				if ( regex.global ) regex.lastIndex = 0; // see #17920

  				if ( regex.test( file ) ) {

  					return loader;

  				}

  			}

  			return null;

  		};

  	}

  }

  const DefaultLoadingManager = new LoadingManager();

  class Loader {

  	constructor( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  		this.crossOrigin = 'anonymous';
  		this.withCredentials = false;
  		this.path = '';
  		this.resourcePath = '';
  		this.requestHeader = {};

  	}

  	load( /* url, onLoad, onProgress, onError */ ) {}

  	loadAsync( url, onProgress ) {

  		const scope = this;

  		return new Promise( function ( resolve, reject ) {

  			scope.load( url, resolve, onProgress, reject );

  		} );

  	}

  	parse( /* data */ ) {}

  	setCrossOrigin( crossOrigin ) {

  		this.crossOrigin = crossOrigin;
  		return this;

  	}

  	setWithCredentials( value ) {

  		this.withCredentials = value;
  		return this;

  	}

  	setPath( path ) {

  		this.path = path;
  		return this;

  	}

  	setResourcePath( resourcePath ) {

  		this.resourcePath = resourcePath;
  		return this;

  	}

  	setRequestHeader( requestHeader ) {

  		this.requestHeader = requestHeader;
  		return this;

  	}

  }

  const loading = {};

  class FileLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		if ( url === undefined ) url = '';

  		if ( this.path !== undefined ) url = this.path + url;

  		url = this.manager.resolveURL( url );

  		const scope = this;

  		const cached = Cache.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) onLoad( cached );

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		// Check if request is duplicate

  		if ( loading[ url ] !== undefined ) {

  			loading[ url ].push( {

  				onLoad: onLoad,
  				onProgress: onProgress,
  				onError: onError

  			} );

  			return;

  		}

  		// Check for data: URI
  		const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
  		const dataUriRegexResult = url.match( dataUriRegex );
  		let request;

  		// Safari can not handle Data URIs through XMLHttpRequest so process manually
  		if ( dataUriRegexResult ) {

  			const mimeType = dataUriRegexResult[ 1 ];
  			const isBase64 = !! dataUriRegexResult[ 2 ];

  			let data = dataUriRegexResult[ 3 ];
  			data = decodeURIComponent( data );

  			if ( isBase64 ) data = atob( data );

  			try {

  				let response;
  				const responseType = ( this.responseType || '' ).toLowerCase();

  				switch ( responseType ) {

  					case 'arraybuffer':
  					case 'blob':

  						const view = new Uint8Array( data.length );

  						for ( let i = 0; i < data.length; i ++ ) {

  							view[ i ] = data.charCodeAt( i );

  						}

  						if ( responseType === 'blob' ) {

  							response = new Blob( [ view.buffer ], { type: mimeType } );

  						} else {

  							response = view.buffer;

  						}

  						break;

  					case 'document':

  						const parser = new DOMParser();
  						response = parser.parseFromString( data, mimeType );

  						break;

  					case 'json':

  						response = JSON.parse( data );

  						break;

  					default: // 'text' or other

  						response = data;

  						break;

  				}

  				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  				setTimeout( function () {

  					if ( onLoad ) onLoad( response );

  					scope.manager.itemEnd( url );

  				}, 0 );

  			} catch ( error ) {

  				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  				setTimeout( function () {

  					if ( onError ) onError( error );

  					scope.manager.itemError( url );
  					scope.manager.itemEnd( url );

  				}, 0 );

  			}

  		} else {

  			// Initialise array for duplicate requests

  			loading[ url ] = [];

  			loading[ url ].push( {

  				onLoad: onLoad,
  				onProgress: onProgress,
  				onError: onError

  			} );

  			request = new XMLHttpRequest();

  			request.open( 'GET', url, true );

  			request.addEventListener( 'load', function ( event ) {

  				const response = this.response;

  				const callbacks = loading[ url ];

  				delete loading[ url ];

  				if ( this.status === 200 || this.status === 0 ) {

  					// Some browsers return HTTP Status 0 when using non-http protocol
  					// e.g. 'file://' or 'data://'. Handle as success.

  					if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

  					// Add to cache only on HTTP success, so that we do not cache
  					// error response bodies as proper responses to requests.
  					Cache.add( url, response );

  					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

  						const callback = callbacks[ i ];
  						if ( callback.onLoad ) callback.onLoad( response );

  					}

  					scope.manager.itemEnd( url );

  				} else {

  					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

  						const callback = callbacks[ i ];
  						if ( callback.onError ) callback.onError( event );

  					}

  					scope.manager.itemError( url );
  					scope.manager.itemEnd( url );

  				}

  			}, false );

  			request.addEventListener( 'progress', function ( event ) {

  				const callbacks = loading[ url ];

  				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

  					const callback = callbacks[ i ];
  					if ( callback.onProgress ) callback.onProgress( event );

  				}

  			}, false );

  			request.addEventListener( 'error', function ( event ) {

  				const callbacks = loading[ url ];

  				delete loading[ url ];

  				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

  					const callback = callbacks[ i ];
  					if ( callback.onError ) callback.onError( event );

  				}

  				scope.manager.itemError( url );
  				scope.manager.itemEnd( url );

  			}, false );

  			request.addEventListener( 'abort', function ( event ) {

  				const callbacks = loading[ url ];

  				delete loading[ url ];

  				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

  					const callback = callbacks[ i ];
  					if ( callback.onError ) callback.onError( event );

  				}

  				scope.manager.itemError( url );
  				scope.manager.itemEnd( url );

  			}, false );

  			if ( this.responseType !== undefined ) request.responseType = this.responseType;
  			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

  			if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

  			for ( const header in this.requestHeader ) {

  				request.setRequestHeader( header, this.requestHeader[ header ] );

  			}

  			request.send( null );

  		}

  		scope.manager.itemStart( url );

  		return request;

  	}

  	setResponseType( value ) {

  		this.responseType = value;
  		return this;

  	}

  	setMimeType( value ) {

  		this.mimeType = value;
  		return this;

  	}

  }

  class AnimationLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const scope = this;

  		const loader = new FileLoader( this.manager );
  		loader.setPath( this.path );
  		loader.setRequestHeader( this.requestHeader );
  		loader.setWithCredentials( this.withCredentials );
  		loader.load( url, function ( text ) {

  			try {

  				onLoad( scope.parse( JSON.parse( text ) ) );

  			} catch ( e ) {

  				if ( onError ) {

  					onError( e );

  				} else {

  					console.error( e );

  				}

  				scope.manager.itemError( url );

  			}

  		}, onProgress, onError );

  	}

  	parse( json ) {

  		const animations = [];

  		for ( let i = 0; i < json.length; i ++ ) {

  			const clip = AnimationClip.parse( json[ i ] );

  			animations.push( clip );

  		}

  		return animations;

  	}

  }

  /**
   * Abstract Base class to block based textures loader (dds, pvr, ...)
   *
   * Sub classes have to implement the parse() method which will be used in load().
   */

  class CompressedTextureLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const scope = this;

  		const images = [];

  		const texture = new CompressedTexture();

  		const loader = new FileLoader( this.manager );
  		loader.setPath( this.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.setRequestHeader( this.requestHeader );
  		loader.setWithCredentials( scope.withCredentials );

  		let loaded = 0;

  		function loadTexture( i ) {

  			loader.load( url[ i ], function ( buffer ) {

  				const texDatas = scope.parse( buffer, true );

  				images[ i ] = {
  					width: texDatas.width,
  					height: texDatas.height,
  					format: texDatas.format,
  					mipmaps: texDatas.mipmaps
  				};

  				loaded += 1;

  				if ( loaded === 6 ) {

  					if ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;

  					texture.image = images;
  					texture.format = texDatas.format;
  					texture.needsUpdate = true;

  					if ( onLoad ) onLoad( texture );

  				}

  			}, onProgress, onError );

  		}

  		if ( Array.isArray( url ) ) {

  			for ( let i = 0, il = url.length; i < il; ++ i ) {

  				loadTexture( i );

  			}

  		} else {

  			// compressed cubemap texture stored in a single DDS file

  			loader.load( url, function ( buffer ) {

  				const texDatas = scope.parse( buffer, true );

  				if ( texDatas.isCubemap ) {

  					const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

  					for ( let f = 0; f < faces; f ++ ) {

  						images[ f ] = { mipmaps: [] };

  						for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

  							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
  							images[ f ].format = texDatas.format;
  							images[ f ].width = texDatas.width;
  							images[ f ].height = texDatas.height;

  						}

  					}

  					texture.image = images;

  				} else {

  					texture.image.width = texDatas.width;
  					texture.image.height = texDatas.height;
  					texture.mipmaps = texDatas.mipmaps;

  				}

  				if ( texDatas.mipmapCount === 1 ) {

  					texture.minFilter = LinearFilter;

  				}

  				texture.format = texDatas.format;
  				texture.needsUpdate = true;

  				if ( onLoad ) onLoad( texture );

  			}, onProgress, onError );

  		}

  		return texture;

  	}

  }

  class ImageLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		if ( this.path !== undefined ) url = this.path + url;

  		url = this.manager.resolveURL( url );

  		const scope = this;

  		const cached = Cache.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) onLoad( cached );

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		const image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

  		function onImageLoad() {

  			image.removeEventListener( 'load', onImageLoad, false );
  			image.removeEventListener( 'error', onImageError, false );

  			Cache.add( url, this );

  			if ( onLoad ) onLoad( this );

  			scope.manager.itemEnd( url );

  		}

  		function onImageError( event ) {

  			image.removeEventListener( 'load', onImageLoad, false );
  			image.removeEventListener( 'error', onImageError, false );

  			if ( onError ) onError( event );

  			scope.manager.itemError( url );
  			scope.manager.itemEnd( url );

  		}

  		image.addEventListener( 'load', onImageLoad, false );
  		image.addEventListener( 'error', onImageError, false );

  		if ( url.substr( 0, 5 ) !== 'data:' ) {

  			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

  		}

  		scope.manager.itemStart( url );

  		image.src = url;

  		return image;

  	}

  }

  class CubeTextureLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( urls, onLoad, onProgress, onError ) {

  		const texture = new CubeTexture();

  		const loader = new ImageLoader( this.manager );
  		loader.setCrossOrigin( this.crossOrigin );
  		loader.setPath( this.path );

  		let loaded = 0;

  		function loadTexture( i ) {

  			loader.load( urls[ i ], function ( image ) {

  				texture.images[ i ] = image;

  				loaded ++;

  				if ( loaded === 6 ) {

  					texture.needsUpdate = true;

  					if ( onLoad ) onLoad( texture );

  				}

  			}, undefined, onError );

  		}

  		for ( let i = 0; i < urls.length; ++ i ) {

  			loadTexture( i );

  		}

  		return texture;

  	}

  }

  /**
   * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
   *
   * Sub classes have to implement the parse() method which will be used in load().
   */

  class DataTextureLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const scope = this;

  		const texture = new DataTexture();

  		const loader = new FileLoader( this.manager );
  		loader.setResponseType( 'arraybuffer' );
  		loader.setRequestHeader( this.requestHeader );
  		loader.setPath( this.path );
  		loader.setWithCredentials( scope.withCredentials );
  		loader.load( url, function ( buffer ) {

  			const texData = scope.parse( buffer );

  			if ( ! texData ) return;

  			if ( texData.image !== undefined ) {

  				texture.image = texData.image;

  			} else if ( texData.data !== undefined ) {

  				texture.image.width = texData.width;
  				texture.image.height = texData.height;
  				texture.image.data = texData.data;

  			}

  			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
  			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

  			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
  			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

  			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

  			if ( texData.encoding !== undefined ) {

  				texture.encoding = texData.encoding;

  			}

  			if ( texData.flipY !== undefined ) {

  				texture.flipY = texData.flipY;

  			}

  			if ( texData.format !== undefined ) {

  				texture.format = texData.format;

  			}

  			if ( texData.type !== undefined ) {

  				texture.type = texData.type;

  			}

  			if ( texData.mipmaps !== undefined ) {

  				texture.mipmaps = texData.mipmaps;
  				texture.minFilter = LinearMipmapLinearFilter; // presumably...

  			}

  			if ( texData.mipmapCount === 1 ) {

  				texture.minFilter = LinearFilter;

  			}

  			if ( texData.generateMipmaps !== undefined ) {

  				texture.generateMipmaps = texData.generateMipmaps;

  			}

  			texture.needsUpdate = true;

  			if ( onLoad ) onLoad( texture, texData );

  		}, onProgress, onError );


  		return texture;

  	}

  }

  class TextureLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const texture = new Texture();

  		const loader = new ImageLoader( this.manager );
  		loader.setCrossOrigin( this.crossOrigin );
  		loader.setPath( this.path );

  		loader.load( url, function ( image ) {

  			texture.image = image;

  			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
  			const isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

  			texture.format = isJPEG ? RGBFormat : RGBAFormat;
  			texture.needsUpdate = true;

  			if ( onLoad !== undefined ) {

  				onLoad( texture );

  			}

  		}, onProgress, onError );

  		return texture;

  	}

  }

  /**
   * Extensible curve object.
   *
   * Some common of curve methods:
   * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
   * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
   * .getPoints(), .getSpacedPoints()
   * .getLength()
   * .updateArcLengths()
   *
   * This following curves inherit from THREE.Curve:
   *
   * -- 2D curves --
   * THREE.ArcCurve
   * THREE.CubicBezierCurve
   * THREE.EllipseCurve
   * THREE.LineCurve
   * THREE.QuadraticBezierCurve
   * THREE.SplineCurve
   *
   * -- 3D curves --
   * THREE.CatmullRomCurve3
   * THREE.CubicBezierCurve3
   * THREE.LineCurve3
   * THREE.QuadraticBezierCurve3
   *
   * A series of curves can be represented as a THREE.CurvePath.
   *
   **/

  class Curve {

  	constructor() {

  		this.type = 'Curve';

  		this.arcLengthDivisions = 200;

  	}

  	// Virtual base class method to overwrite and implement in subclasses
  	//	- t [0 .. 1]

  	getPoint( /* t, optionalTarget */ ) {

  		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
  		return null;

  	}

  	// Get point at relative position in curve according to arc length
  	// - u [0 .. 1]

  	getPointAt( u, optionalTarget ) {

  		const t = this.getUtoTmapping( u );
  		return this.getPoint( t, optionalTarget );

  	}

  	// Get sequence of points using getPoint( t )

  	getPoints( divisions = 5 ) {

  		const points = [];

  		for ( let d = 0; d <= divisions; d ++ ) {

  			points.push( this.getPoint( d / divisions ) );

  		}

  		return points;

  	}

  	// Get sequence of points using getPointAt( u )

  	getSpacedPoints( divisions = 5 ) {

  		const points = [];

  		for ( let d = 0; d <= divisions; d ++ ) {

  			points.push( this.getPointAt( d / divisions ) );

  		}

  		return points;

  	}

  	// Get total curve arc length

  	getLength() {

  		const lengths = this.getLengths();
  		return lengths[ lengths.length - 1 ];

  	}

  	// Get list of cumulative segment lengths

  	getLengths( divisions = this.arcLengthDivisions ) {

  		if ( this.cacheArcLengths &&
  			( this.cacheArcLengths.length === divisions + 1 ) &&
  			! this.needsUpdate ) {

  			return this.cacheArcLengths;

  		}

  		this.needsUpdate = false;

  		const cache = [];
  		let current, last = this.getPoint( 0 );
  		let sum = 0;

  		cache.push( 0 );

  		for ( let p = 1; p <= divisions; p ++ ) {

  			current = this.getPoint( p / divisions );
  			sum += current.distanceTo( last );
  			cache.push( sum );
  			last = current;

  		}

  		this.cacheArcLengths = cache;

  		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

  	}

  	updateArcLengths() {

  		this.needsUpdate = true;
  		this.getLengths();

  	}

  	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

  	getUtoTmapping( u, distance ) {

  		const arcLengths = this.getLengths();

  		let i = 0;
  		const il = arcLengths.length;

  		let targetArcLength; // The targeted u distance value to get

  		if ( distance ) {

  			targetArcLength = distance;

  		} else {

  			targetArcLength = u * arcLengths[ il - 1 ];

  		}

  		// binary search for the index with largest value smaller than target u distance

  		let low = 0, high = il - 1, comparison;

  		while ( low <= high ) {

  			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

  			comparison = arcLengths[ i ] - targetArcLength;

  			if ( comparison < 0 ) {

  				low = i + 1;

  			} else if ( comparison > 0 ) {

  				high = i - 1;

  			} else {

  				high = i;
  				break;

  				// DONE

  			}

  		}

  		i = high;

  		if ( arcLengths[ i ] === targetArcLength ) {

  			return i / ( il - 1 );

  		}

  		// we could get finer grain at lengths, or use simple interpolation between two points

  		const lengthBefore = arcLengths[ i ];
  		const lengthAfter = arcLengths[ i + 1 ];

  		const segmentLength = lengthAfter - lengthBefore;

  		// determine where we are between the 'before' and 'after' points

  		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

  		// add that fractional amount to t

  		const t = ( i + segmentFraction ) / ( il - 1 );

  		return t;

  	}

  	// Returns a unit vector tangent at t
  	// In case any sub curve does not implement its tangent derivation,
  	// 2 points a small delta apart will be used to find its gradient
  	// which seems to give a reasonable approximation

  	getTangent( t, optionalTarget ) {

  		const delta = 0.0001;
  		let t1 = t - delta;
  		let t2 = t + delta;

  		// Capping in case of danger

  		if ( t1 < 0 ) t1 = 0;
  		if ( t2 > 1 ) t2 = 1;

  		const pt1 = this.getPoint( t1 );
  		const pt2 = this.getPoint( t2 );

  		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

  		tangent.copy( pt2 ).sub( pt1 ).normalize();

  		return tangent;

  	}

  	getTangentAt( u, optionalTarget ) {

  		const t = this.getUtoTmapping( u );
  		return this.getTangent( t, optionalTarget );

  	}

  	computeFrenetFrames( segments, closed ) {

  		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

  		const normal = new Vector3();

  		const tangents = [];
  		const normals = [];
  		const binormals = [];

  		const vec = new Vector3();
  		const mat = new Matrix4();

  		// compute the tangent vectors for each segment on the curve

  		for ( let i = 0; i <= segments; i ++ ) {

  			const u = i / segments;

  			tangents[ i ] = this.getTangentAt( u, new Vector3() );
  			tangents[ i ].normalize();

  		}

  		// select an initial normal vector perpendicular to the first tangent vector,
  		// and in the direction of the minimum tangent xyz component

  		normals[ 0 ] = new Vector3();
  		binormals[ 0 ] = new Vector3();
  		let min = Number.MAX_VALUE;
  		const tx = Math.abs( tangents[ 0 ].x );
  		const ty = Math.abs( tangents[ 0 ].y );
  		const tz = Math.abs( tangents[ 0 ].z );

  		if ( tx <= min ) {

  			min = tx;
  			normal.set( 1, 0, 0 );

  		}

  		if ( ty <= min ) {

  			min = ty;
  			normal.set( 0, 1, 0 );

  		}

  		if ( tz <= min ) {

  			normal.set( 0, 0, 1 );

  		}

  		vec.crossVectors( tangents[ 0 ], normal ).normalize();

  		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
  		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


  		// compute the slowly-varying normal and binormal vectors for each segment on the curve

  		for ( let i = 1; i <= segments; i ++ ) {

  			normals[ i ] = normals[ i - 1 ].clone();

  			binormals[ i ] = binormals[ i - 1 ].clone();

  			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

  			if ( vec.length() > Number.EPSILON ) {

  				vec.normalize();

  				const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

  				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

  			}

  			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  		}

  		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

  		if ( closed === true ) {

  			let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
  			theta /= segments;

  			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

  				theta = - theta;

  			}

  			for ( let i = 1; i <= segments; i ++ ) {

  				// twist a little...
  				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
  				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  			}

  		}

  		return {
  			tangents: tangents,
  			normals: normals,
  			binormals: binormals
  		};

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		this.arcLengthDivisions = source.arcLengthDivisions;

  		return this;

  	}

  	toJSON() {

  		const data = {
  			metadata: {
  				version: 4.5,
  				type: 'Curve',
  				generator: 'Curve.toJSON'
  			}
  		};

  		data.arcLengthDivisions = this.arcLengthDivisions;
  		data.type = this.type;

  		return data;

  	}

  	fromJSON( json ) {

  		this.arcLengthDivisions = json.arcLengthDivisions;

  		return this;

  	}

  }

  class EllipseCurve extends Curve {

  	constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

  		super();

  		this.type = 'EllipseCurve';

  		this.aX = aX;
  		this.aY = aY;

  		this.xRadius = xRadius;
  		this.yRadius = yRadius;

  		this.aStartAngle = aStartAngle;
  		this.aEndAngle = aEndAngle;

  		this.aClockwise = aClockwise;

  		this.aRotation = aRotation;

  	}

  	getPoint( t, optionalTarget ) {

  		const point = optionalTarget || new Vector2();

  		const twoPi = Math.PI * 2;
  		let deltaAngle = this.aEndAngle - this.aStartAngle;
  		const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

  		// ensures that deltaAngle is 0 .. 2 PI
  		while ( deltaAngle < 0 ) deltaAngle += twoPi;
  		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

  		if ( deltaAngle < Number.EPSILON ) {

  			if ( samePoints ) {

  				deltaAngle = 0;

  			} else {

  				deltaAngle = twoPi;

  			}

  		}

  		if ( this.aClockwise === true && ! samePoints ) {

  			if ( deltaAngle === twoPi ) {

  				deltaAngle = - twoPi;

  			} else {

  				deltaAngle = deltaAngle - twoPi;

  			}

  		}

  		const angle = this.aStartAngle + t * deltaAngle;
  		let x = this.aX + this.xRadius * Math.cos( angle );
  		let y = this.aY + this.yRadius * Math.sin( angle );

  		if ( this.aRotation !== 0 ) {

  			const cos = Math.cos( this.aRotation );
  			const sin = Math.sin( this.aRotation );

  			const tx = x - this.aX;
  			const ty = y - this.aY;

  			// Rotate the point about the center of the ellipse.
  			x = tx * cos - ty * sin + this.aX;
  			y = tx * sin + ty * cos + this.aY;

  		}

  		return point.set( x, y );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.aX = source.aX;
  		this.aY = source.aY;

  		this.xRadius = source.xRadius;
  		this.yRadius = source.yRadius;

  		this.aStartAngle = source.aStartAngle;
  		this.aEndAngle = source.aEndAngle;

  		this.aClockwise = source.aClockwise;

  		this.aRotation = source.aRotation;

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.aX = this.aX;
  		data.aY = this.aY;

  		data.xRadius = this.xRadius;
  		data.yRadius = this.yRadius;

  		data.aStartAngle = this.aStartAngle;
  		data.aEndAngle = this.aEndAngle;

  		data.aClockwise = this.aClockwise;

  		data.aRotation = this.aRotation;

  		return data;

  	}

  	fromJSON( json ) {

  		super.fromJSON( json );

  		this.aX = json.aX;
  		this.aY = json.aY;

  		this.xRadius = json.xRadius;
  		this.yRadius = json.yRadius;

  		this.aStartAngle = json.aStartAngle;
  		this.aEndAngle = json.aEndAngle;

  		this.aClockwise = json.aClockwise;

  		this.aRotation = json.aRotation;

  		return this;

  	}

  }

  EllipseCurve.prototype.isEllipseCurve = true;

  class ArcCurve extends EllipseCurve {

  	constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  		super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

  		this.type = 'ArcCurve';

  	}

  }

  ArcCurve.prototype.isArcCurve = true;

  /**
   * Centripetal CatmullRom Curve - which is useful for avoiding
   * cusps and self-intersections in non-uniform catmull rom curves.
   * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
   *
   * curve.type accepts centripetal(default), chordal and catmullrom
   * curve.tension is used for catmullrom which defaults to 0.5
   */


  /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM

  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */

  function CubicPoly() {

  	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

  	/*
  	 * Compute coefficients for a cubic polynomial
  	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
  	 * such that
  	 *   p(0) = x0, p(1) = x1
  	 *  and
  	 *   p'(0) = t0, p'(1) = t1.
  	 */
  	function init( x0, x1, t0, t1 ) {

  		c0 = x0;
  		c1 = t0;
  		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
  		c3 = 2 * x0 - 2 * x1 + t0 + t1;

  	}

  	return {

  		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

  			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

  		},

  		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

  			// compute tangents when parameterized in [t1,t2]
  			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
  			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

  			// rescale tangents for parametrization in [0,1]
  			t1 *= dt1;
  			t2 *= dt1;

  			init( x1, x2, t1, t2 );

  		},

  		calc: function ( t ) {

  			const t2 = t * t;
  			const t3 = t2 * t;
  			return c0 + c1 * t + c2 * t2 + c3 * t3;

  		}

  	};

  }

  //

  const tmp = new Vector3();
  const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

  class CatmullRomCurve3 extends Curve {

  	constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

  		super();

  		this.type = 'CatmullRomCurve3';

  		this.points = points;
  		this.closed = closed;
  		this.curveType = curveType;
  		this.tension = tension;

  	}

  	getPoint( t, optionalTarget = new Vector3() ) {

  		const point = optionalTarget;

  		const points = this.points;
  		const l = points.length;

  		const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
  		let intPoint = Math.floor( p );
  		let weight = p - intPoint;

  		if ( this.closed ) {

  			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

  		} else if ( weight === 0 && intPoint === l - 1 ) {

  			intPoint = l - 2;
  			weight = 1;

  		}

  		let p0, p3; // 4 points (p1 & p2 defined below)

  		if ( this.closed || intPoint > 0 ) {

  			p0 = points[ ( intPoint - 1 ) % l ];

  		} else {

  			// extrapolate first point
  			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
  			p0 = tmp;

  		}

  		const p1 = points[ intPoint % l ];
  		const p2 = points[ ( intPoint + 1 ) % l ];

  		if ( this.closed || intPoint + 2 < l ) {

  			p3 = points[ ( intPoint + 2 ) % l ];

  		} else {

  			// extrapolate last point
  			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
  			p3 = tmp;

  		}

  		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

  			// init Centripetal / Chordal Catmull-Rom
  			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
  			let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
  			let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
  			let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

  			// safety check for repeated points
  			if ( dt1 < 1e-4 ) dt1 = 1.0;
  			if ( dt0 < 1e-4 ) dt0 = dt1;
  			if ( dt2 < 1e-4 ) dt2 = dt1;

  			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
  			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
  			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

  		} else if ( this.curveType === 'catmullrom' ) {

  			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
  			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
  			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

  		}

  		point.set(
  			px.calc( weight ),
  			py.calc( weight ),
  			pz.calc( weight )
  		);

  		return point;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.points = [];

  		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

  			const point = source.points[ i ];

  			this.points.push( point.clone() );

  		}

  		this.closed = source.closed;
  		this.curveType = source.curveType;
  		this.tension = source.tension;

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.points = [];

  		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

  			const point = this.points[ i ];
  			data.points.push( point.toArray() );

  		}

  		data.closed = this.closed;
  		data.curveType = this.curveType;
  		data.tension = this.tension;

  		return data;

  	}

  	fromJSON( json ) {

  		super.fromJSON( json );

  		this.points = [];

  		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

  			const point = json.points[ i ];
  			this.points.push( new Vector3().fromArray( point ) );

  		}

  		this.closed = json.closed;
  		this.curveType = json.curveType;
  		this.tension = json.tension;

  		return this;

  	}

  }

  CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

  /**
   * Bezier Curves formulas obtained from
   * http://en.wikipedia.org/wiki/Bézier_curve
   */

  function CatmullRom( t, p0, p1, p2, p3 ) {

  	const v0 = ( p2 - p0 ) * 0.5;
  	const v1 = ( p3 - p1 ) * 0.5;
  	const t2 = t * t;
  	const t3 = t * t2;
  	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

  //

  function QuadraticBezierP0( t, p ) {

  	const k = 1 - t;
  	return k * k * p;

  }

  function QuadraticBezierP1( t, p ) {

  	return 2 * ( 1 - t ) * t * p;

  }

  function QuadraticBezierP2( t, p ) {

  	return t * t * p;

  }

  function QuadraticBezier( t, p0, p1, p2 ) {

  	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
  		QuadraticBezierP2( t, p2 );

  }

  //

  function CubicBezierP0( t, p ) {

  	const k = 1 - t;
  	return k * k * k * p;

  }

  function CubicBezierP1( t, p ) {

  	const k = 1 - t;
  	return 3 * k * k * t * p;

  }

  function CubicBezierP2( t, p ) {

  	return 3 * ( 1 - t ) * t * t * p;

  }

  function CubicBezierP3( t, p ) {

  	return t * t * t * p;

  }

  function CubicBezier( t, p0, p1, p2, p3 ) {

  	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
  		CubicBezierP3( t, p3 );

  }

  class CubicBezierCurve extends Curve {

  	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

  		super();

  		this.type = 'CubicBezierCurve';

  		this.v0 = v0;
  		this.v1 = v1;
  		this.v2 = v2;
  		this.v3 = v3;

  	}

  	getPoint( t, optionalTarget = new Vector2() ) {

  		const point = optionalTarget;

  		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

  		point.set(
  			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
  			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
  		);

  		return point;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.v0.copy( source.v0 );
  		this.v1.copy( source.v1 );
  		this.v2.copy( source.v2 );
  		this.v3.copy( source.v3 );

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.v0 = this.v0.toArray();
  		data.v1 = this.v1.toArray();
  		data.v2 = this.v2.toArray();
  		data.v3 = this.v3.toArray();

  		return data;

  	}

  	fromJSON( json ) {

  		super.fromJSON( json );

  		this.v0.fromArray( json.v0 );
  		this.v1.fromArray( json.v1 );
  		this.v2.fromArray( json.v2 );
  		this.v3.fromArray( json.v3 );

  		return this;

  	}

  }

  CubicBezierCurve.prototype.isCubicBezierCurve = true;

  class CubicBezierCurve3 extends Curve {

  	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

  		super();

  		this.type = 'CubicBezierCurve3';

  		this.v0 = v0;
  		this.v1 = v1;
  		this.v2 = v2;
  		this.v3 = v3;

  	}

  	getPoint( t, optionalTarget = new Vector3() ) {

  		const point = optionalTarget;

  		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

  		point.set(
  			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
  			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
  			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
  		);

  		return point;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.v0.copy( source.v0 );
  		this.v1.copy( source.v1 );
  		this.v2.copy( source.v2 );
  		this.v3.copy( source.v3 );

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.v0 = this.v0.toArray();
  		data.v1 = this.v1.toArray();
  		data.v2 = this.v2.toArray();
  		data.v3 = this.v3.toArray();

  		return data;

  	}

  	fromJSON( json ) {

  		super.fromJSON( json );

  		this.v0.fromArray( json.v0 );
  		this.v1.fromArray( json.v1 );
  		this.v2.fromArray( json.v2 );
  		this.v3.fromArray( json.v3 );

  		return this;

  	}

  }

  CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

  class LineCurve extends Curve {

  	constructor( v1 = new Vector2(), v2 = new Vector2() ) {

  		super();

  		this.type = 'LineCurve';

  		this.v1 = v1;
  		this.v2 = v2;

  	}

  	getPoint( t, optionalTarget = new Vector2() ) {

  		const point = optionalTarget;

  		if ( t === 1 ) {

  			point.copy( this.v2 );

  		} else {

  			point.copy( this.v2 ).sub( this.v1 );
  			point.multiplyScalar( t ).add( this.v1 );

  		}

  		return point;

  	}

  	// Line curve is linear, so we can overwrite default getPointAt
  	getPointAt( u, optionalTarget ) {

  		return this.getPoint( u, optionalTarget );

  	}

  	getTangent( t, optionalTarget ) {

  		const tangent = optionalTarget || new Vector2();

  		tangent.copy( this.v2 ).sub( this.v1 ).normalize();

  		return tangent;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.v1.copy( source.v1 );
  		this.v2.copy( source.v2 );

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.v1 = this.v1.toArray();
  		data.v2 = this.v2.toArray();

  		return data;

  	}

  	fromJSON( json ) {

  		super.fromJSON( json );

  		this.v1.fromArray( json.v1 );
  		this.v2.fromArray( json.v2 );

  		return this;

  	}

  }

  LineCurve.prototype.isLineCurve = true;

  class LineCurve3 extends Curve {

  	constructor( v1 = new Vector3(), v2 = new Vector3() ) {

  		super();

  		this.type = 'LineCurve3';
  		this.isLineCurve3 = true;

  		this.v1 = v1;
  		this.v2 = v2;

  	}
  	getPoint( t, optionalTarget = new Vector3() ) {

  		const point = optionalTarget;

  		if ( t === 1 ) {

  			point.copy( this.v2 );

  		} else {

  			point.copy( this.v2 ).sub( this.v1 );
  			point.multiplyScalar( t ).add( this.v1 );

  		}

  		return point;

  	}
  	// Line curve is linear, so we can overwrite default getPointAt
  	getPointAt( u, optionalTarget ) {

  		return this.getPoint( u, optionalTarget );

  	}
  	copy( source ) {

  		super.copy( source );

  		this.v1.copy( source.v1 );
  		this.v2.copy( source.v2 );

  		return this;

  	}
  	toJSON() {

  		const data = super.toJSON();

  		data.v1 = this.v1.toArray();
  		data.v2 = this.v2.toArray();

  		return data;

  	}
  	fromJSON( json ) {

  		super.fromJSON( json );

  		this.v1.fromArray( json.v1 );
  		this.v2.fromArray( json.v2 );

  		return this;

  	}

  }

  class QuadraticBezierCurve extends Curve {

  	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

  		super();

  		this.type = 'QuadraticBezierCurve';

  		this.v0 = v0;
  		this.v1 = v1;
  		this.v2 = v2;

  	}

  	getPoint( t, optionalTarget = new Vector2() ) {

  		const point = optionalTarget;

  		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

  		point.set(
  			QuadraticBezier( t, v0.x, v1.x, v2.x ),
  			QuadraticBezier( t, v0.y, v1.y, v2.y )
  		);

  		return point;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.v0.copy( source.v0 );
  		this.v1.copy( source.v1 );
  		this.v2.copy( source.v2 );

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.v0 = this.v0.toArray();
  		data.v1 = this.v1.toArray();
  		data.v2 = this.v2.toArray();

  		return data;

  	}

  	fromJSON( json ) {

  		super.fromJSON( json );

  		this.v0.fromArray( json.v0 );
  		this.v1.fromArray( json.v1 );
  		this.v2.fromArray( json.v2 );

  		return this;

  	}

  }

  QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

  class QuadraticBezierCurve3 extends Curve {

  	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

  		super();

  		this.type = 'QuadraticBezierCurve3';

  		this.v0 = v0;
  		this.v1 = v1;
  		this.v2 = v2;

  	}

  	getPoint( t, optionalTarget = new Vector3() ) {

  		const point = optionalTarget;

  		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

  		point.set(
  			QuadraticBezier( t, v0.x, v1.x, v2.x ),
  			QuadraticBezier( t, v0.y, v1.y, v2.y ),
  			QuadraticBezier( t, v0.z, v1.z, v2.z )
  		);

  		return point;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.v0.copy( source.v0 );
  		this.v1.copy( source.v1 );
  		this.v2.copy( source.v2 );

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.v0 = this.v0.toArray();
  		data.v1 = this.v1.toArray();
  		data.v2 = this.v2.toArray();

  		return data;

  	}

  	fromJSON( json ) {

  		super.fromJSON( json );

  		this.v0.fromArray( json.v0 );
  		this.v1.fromArray( json.v1 );
  		this.v2.fromArray( json.v2 );

  		return this;

  	}

  }

  QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

  class SplineCurve extends Curve {

  	constructor( points = [] ) {

  		super();

  		this.type = 'SplineCurve';

  		this.points = points;

  	}

  	getPoint( t, optionalTarget = new Vector2() ) {

  		const point = optionalTarget;

  		const points = this.points;
  		const p = ( points.length - 1 ) * t;

  		const intPoint = Math.floor( p );
  		const weight = p - intPoint;

  		const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
  		const p1 = points[ intPoint ];
  		const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
  		const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

  		point.set(
  			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
  			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
  		);

  		return point;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.points = [];

  		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

  			const point = source.points[ i ];

  			this.points.push( point.clone() );

  		}

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.points = [];

  		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

  			const point = this.points[ i ];
  			data.points.push( point.toArray() );

  		}

  		return data;

  	}

  	fromJSON( json ) {

  		super.fromJSON( json );

  		this.points = [];

  		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

  			const point = json.points[ i ];
  			this.points.push( new Vector2().fromArray( point ) );

  		}

  		return this;

  	}

  }

  SplineCurve.prototype.isSplineCurve = true;

  var Curves = /*#__PURE__*/Object.freeze({
  	__proto__: null,
  	ArcCurve: ArcCurve,
  	CatmullRomCurve3: CatmullRomCurve3,
  	CubicBezierCurve: CubicBezierCurve,
  	CubicBezierCurve3: CubicBezierCurve3,
  	EllipseCurve: EllipseCurve,
  	LineCurve: LineCurve,
  	LineCurve3: LineCurve3,
  	QuadraticBezierCurve: QuadraticBezierCurve,
  	QuadraticBezierCurve3: QuadraticBezierCurve3,
  	SplineCurve: SplineCurve
  });

  /**************************************************************
   *	Curved Path - a curve path is simply a array of connected
   *  curves, but retains the api of a curve
   **************************************************************/

  class CurvePath extends Curve {

  	constructor() {

  		super();

  		this.type = 'CurvePath';

  		this.curves = [];
  		this.autoClose = false; // Automatically closes the path

  	}

  	add( curve ) {

  		this.curves.push( curve );

  	}

  	closePath() {

  		// Add a line curve if start and end of lines are not connected
  		const startPoint = this.curves[ 0 ].getPoint( 0 );
  		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

  		if ( ! startPoint.equals( endPoint ) ) {

  			this.curves.push( new LineCurve( endPoint, startPoint ) );

  		}

  	}

  	// To get accurate point with reference to
  	// entire path distance at time t,
  	// following has to be done:

  	// 1. Length of each sub path have to be known
  	// 2. Locate and identify type of curve
  	// 3. Get t for the curve
  	// 4. Return curve.getPointAt(t')

  	getPoint( t ) {

  		const d = t * this.getLength();
  		const curveLengths = this.getCurveLengths();
  		let i = 0;

  		// To think about boundaries points.

  		while ( i < curveLengths.length ) {

  			if ( curveLengths[ i ] >= d ) {

  				const diff = curveLengths[ i ] - d;
  				const curve = this.curves[ i ];

  				const segmentLength = curve.getLength();
  				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

  				return curve.getPointAt( u );

  			}

  			i ++;

  		}

  		return null;

  		// loop where sum != 0, sum > d , sum+1 <d

  	}

  	// We cannot use the default THREE.Curve getPoint() with getLength() because in
  	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  	// getPoint() depends on getLength

  	getLength() {

  		const lens = this.getCurveLengths();
  		return lens[ lens.length - 1 ];

  	}

  	// cacheLengths must be recalculated.
  	updateArcLengths() {

  		this.needsUpdate = true;
  		this.cacheLengths = null;
  		this.getCurveLengths();

  	}

  	// Compute lengths and cache them
  	// We cannot overwrite getLengths() because UtoT mapping uses it.

  	getCurveLengths() {

  		// We use cache values if curves and cache array are same length

  		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

  			return this.cacheLengths;

  		}

  		// Get length of sub-curve
  		// Push sums into cached array

  		const lengths = [];
  		let sums = 0;

  		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

  			sums += this.curves[ i ].getLength();
  			lengths.push( sums );

  		}

  		this.cacheLengths = lengths;

  		return lengths;

  	}

  	getSpacedPoints( divisions = 40 ) {

  		const points = [];

  		for ( let i = 0; i <= divisions; i ++ ) {

  			points.push( this.getPoint( i / divisions ) );

  		}

  		if ( this.autoClose ) {

  			points.push( points[ 0 ] );

  		}

  		return points;

  	}

  	getPoints( divisions = 12 ) {

  		const points = [];
  		let last;

  		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

  			const curve = curves[ i ];
  			const resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
  				: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
  					: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
  						: divisions;

  			const pts = curve.getPoints( resolution );

  			for ( let j = 0; j < pts.length; j ++ ) {

  				const point = pts[ j ];

  				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

  				points.push( point );
  				last = point;

  			}

  		}

  		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

  			points.push( points[ 0 ] );

  		}

  		return points;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.curves = [];

  		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

  			const curve = source.curves[ i ];

  			this.curves.push( curve.clone() );

  		}

  		this.autoClose = source.autoClose;

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.autoClose = this.autoClose;
  		data.curves = [];

  		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

  			const curve = this.curves[ i ];
  			data.curves.push( curve.toJSON() );

  		}

  		return data;

  	}

  	fromJSON( json ) {

  		super.fromJSON( json );

  		this.autoClose = json.autoClose;
  		this.curves = [];

  		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

  			const curve = json.curves[ i ];
  			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

  		}

  		return this;

  	}

  }

  class Path extends CurvePath {

  	constructor( points ) {

  		super();
  		this.type = 'Path';

  		this.currentPoint = new Vector2();

  		if ( points ) {

  			this.setFromPoints( points );

  		}

  	}

  	setFromPoints( points ) {

  		this.moveTo( points[ 0 ].x, points[ 0 ].y );

  		for ( let i = 1, l = points.length; i < l; i ++ ) {

  			this.lineTo( points[ i ].x, points[ i ].y );

  		}

  		return this;

  	}

  	moveTo( x, y ) {

  		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

  		return this;

  	}

  	lineTo( x, y ) {

  		const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
  		this.curves.push( curve );

  		this.currentPoint.set( x, y );

  		return this;

  	}

  	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

  		const curve = new QuadraticBezierCurve(
  			this.currentPoint.clone(),
  			new Vector2( aCPx, aCPy ),
  			new Vector2( aX, aY )
  		);

  		this.curves.push( curve );

  		this.currentPoint.set( aX, aY );

  		return this;

  	}

  	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

  		const curve = new CubicBezierCurve(
  			this.currentPoint.clone(),
  			new Vector2( aCP1x, aCP1y ),
  			new Vector2( aCP2x, aCP2y ),
  			new Vector2( aX, aY )
  		);

  		this.curves.push( curve );

  		this.currentPoint.set( aX, aY );

  		return this;

  	}

  	splineThru( pts /*Array of Vector*/ ) {

  		const npts = [ this.currentPoint.clone() ].concat( pts );

  		const curve = new SplineCurve( npts );
  		this.curves.push( curve );

  		this.currentPoint.copy( pts[ pts.length - 1 ] );

  		return this;

  	}

  	arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  		const x0 = this.currentPoint.x;
  		const y0 = this.currentPoint.y;

  		this.absarc( aX + x0, aY + y0, aRadius,
  			aStartAngle, aEndAngle, aClockwise );

  		return this;

  	}

  	absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

  		return this;

  	}

  	ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  		const x0 = this.currentPoint.x;
  		const y0 = this.currentPoint.y;

  		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

  		return this;

  	}

  	absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  		const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

  		if ( this.curves.length > 0 ) {

  			// if a previous curve is present, attempt to join
  			const firstPoint = curve.getPoint( 0 );

  			if ( ! firstPoint.equals( this.currentPoint ) ) {

  				this.lineTo( firstPoint.x, firstPoint.y );

  			}

  		}

  		this.curves.push( curve );

  		const lastPoint = curve.getPoint( 1 );
  		this.currentPoint.copy( lastPoint );

  		return this;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.currentPoint.copy( source.currentPoint );

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.currentPoint = this.currentPoint.toArray();

  		return data;

  	}

  	fromJSON( json ) {

  		super.fromJSON( json );

  		this.currentPoint.fromArray( json.currentPoint );

  		return this;

  	}

  }

  class Shape extends Path {

  	constructor( points ) {

  		super( points );

  		this.uuid = generateUUID();

  		this.type = 'Shape';

  		this.holes = [];

  	}

  	getPointsHoles( divisions ) {

  		const holesPts = [];

  		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

  			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

  		}

  		return holesPts;

  	}

  	// get points of shape and holes (keypoints based on segments parameter)

  	extractPoints( divisions ) {

  		return {

  			shape: this.getPoints( divisions ),
  			holes: this.getPointsHoles( divisions )

  		};

  	}

  	copy( source ) {

  		super.copy( source );

  		this.holes = [];

  		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

  			const hole = source.holes[ i ];

  			this.holes.push( hole.clone() );

  		}

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.uuid = this.uuid;
  		data.holes = [];

  		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

  			const hole = this.holes[ i ];
  			data.holes.push( hole.toJSON() );

  		}

  		return data;

  	}

  	fromJSON( json ) {

  		super.fromJSON( json );

  		this.uuid = json.uuid;
  		this.holes = [];

  		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

  			const hole = json.holes[ i ];
  			this.holes.push( new Path().fromJSON( hole ) );

  		}

  		return this;

  	}

  }

  class Light extends Object3D {

  	constructor( color, intensity = 1 ) {

  		super();

  		this.type = 'Light';

  		this.color = new Color( color );
  		this.intensity = intensity;

  	}

  	dispose() {

  		// Empty here in base class; some subclasses override.

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );
  		this.intensity = source.intensity;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.color = this.color.getHex();
  		data.object.intensity = this.intensity;

  		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

  		if ( this.distance !== undefined ) data.object.distance = this.distance;
  		if ( this.angle !== undefined ) data.object.angle = this.angle;
  		if ( this.decay !== undefined ) data.object.decay = this.decay;
  		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

  		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

  		return data;

  	}

  }

  Light.prototype.isLight = true;

  class HemisphereLight extends Light {

  	constructor( skyColor, groundColor, intensity ) {

  		super( skyColor, intensity );

  		this.type = 'HemisphereLight';

  		this.position.copy( Object3D.DefaultUp );
  		this.updateMatrix();

  		this.groundColor = new Color( groundColor );

  	}

  	copy( source ) {

  		Light.prototype.copy.call( this, source );

  		this.groundColor.copy( source.groundColor );

  		return this;

  	}

  }

  HemisphereLight.prototype.isHemisphereLight = true;

  const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
  const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
  const _lookTarget$1 = /*@__PURE__*/ new Vector3();

  class LightShadow {

  	constructor( camera ) {

  		this.camera = camera;

  		this.bias = 0;
  		this.normalBias = 0;
  		this.radius = 1;

  		this.mapSize = new Vector2( 512, 512 );

  		this.map = null;
  		this.mapPass = null;
  		this.matrix = new Matrix4();

  		this.autoUpdate = true;
  		this.needsUpdate = false;

  		this._frustum = new Frustum();
  		this._frameExtents = new Vector2( 1, 1 );

  		this._viewportCount = 1;

  		this._viewports = [

  			new Vector4$1( 0, 0, 1, 1 )

  		];

  	}

  	getViewportCount() {

  		return this._viewportCount;

  	}

  	getFrustum() {

  		return this._frustum;

  	}

  	updateMatrices( light ) {

  		const shadowCamera = this.camera;
  		const shadowMatrix = this.matrix;

  		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
  		shadowCamera.position.copy( _lightPositionWorld$1 );

  		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
  		shadowCamera.lookAt( _lookTarget$1 );
  		shadowCamera.updateMatrixWorld();

  		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
  		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

  		shadowMatrix.set(
  			0.5, 0.0, 0.0, 0.5,
  			0.0, 0.5, 0.0, 0.5,
  			0.0, 0.0, 0.5, 0.5,
  			0.0, 0.0, 0.0, 1.0
  		);

  		shadowMatrix.multiply( shadowCamera.projectionMatrix );
  		shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

  	}

  	getViewport( viewportIndex ) {

  		return this._viewports[ viewportIndex ];

  	}

  	getFrameExtents() {

  		return this._frameExtents;

  	}

  	dispose() {

  		if ( this.map ) {

  			this.map.dispose();

  		}

  		if ( this.mapPass ) {

  			this.mapPass.dispose();

  		}

  	}

  	copy( source ) {

  		this.camera = source.camera.clone();

  		this.bias = source.bias;
  		this.radius = source.radius;

  		this.mapSize.copy( source.mapSize );

  		return this;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	toJSON() {

  		const object = {};

  		if ( this.bias !== 0 ) object.bias = this.bias;
  		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
  		if ( this.radius !== 1 ) object.radius = this.radius;
  		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

  		object.camera = this.camera.toJSON( false ).object;
  		delete object.camera.matrix;

  		return object;

  	}

  }

  class SpotLightShadow extends LightShadow {

  	constructor() {

  		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

  		this.focus = 1;

  	}

  	updateMatrices( light ) {

  		const camera = this.camera;

  		const fov = RAD2DEG * 2 * light.angle * this.focus;
  		const aspect = this.mapSize.width / this.mapSize.height;
  		const far = light.distance || camera.far;

  		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

  			camera.fov = fov;
  			camera.aspect = aspect;
  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  		super.updateMatrices( light );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.focus = source.focus;

  		return this;

  	}

  }

  SpotLightShadow.prototype.isSpotLightShadow = true;

  class SpotLight extends Light {

  	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {

  		super( color, intensity );

  		this.type = 'SpotLight';

  		this.position.copy( Object3D.DefaultUp );
  		this.updateMatrix();

  		this.target = new Object3D();

  		this.distance = distance;
  		this.angle = angle;
  		this.penumbra = penumbra;
  		this.decay = decay; // for physically correct lights, should be 2.

  		this.shadow = new SpotLightShadow();

  	}

  	get power() {

  		// intensity = power per solid angle.
  		// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  		return this.intensity * Math.PI;

  	}

  	set power( power ) {

  		// intensity = power per solid angle.
  		// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  		this.intensity = power / Math.PI;

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source ) {

  		super.copy( source );

  		this.distance = source.distance;
  		this.angle = source.angle;
  		this.penumbra = source.penumbra;
  		this.decay = source.decay;

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  SpotLight.prototype.isSpotLight = true;

  const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
  const _lightPositionWorld = /*@__PURE__*/ new Vector3();
  const _lookTarget = /*@__PURE__*/ new Vector3();

  class PointLightShadow extends LightShadow {

  	constructor() {

  		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

  		this._frameExtents = new Vector2( 4, 2 );

  		this._viewportCount = 6;

  		this._viewports = [
  			// These viewports map a cube-map onto a 2D texture with the
  			// following orientation:
  			//
  			//  xzXZ
  			//   y Y
  			//
  			// X - Positive x direction
  			// x - Negative x direction
  			// Y - Positive y direction
  			// y - Negative y direction
  			// Z - Positive z direction
  			// z - Negative z direction

  			// positive X
  			new Vector4$1( 2, 1, 1, 1 ),
  			// negative X
  			new Vector4$1( 0, 1, 1, 1 ),
  			// positive Z
  			new Vector4$1( 3, 1, 1, 1 ),
  			// negative Z
  			new Vector4$1( 1, 1, 1, 1 ),
  			// positive Y
  			new Vector4$1( 3, 0, 1, 1 ),
  			// negative Y
  			new Vector4$1( 1, 0, 1, 1 )
  		];

  		this._cubeDirections = [
  			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
  			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
  		];

  		this._cubeUps = [
  			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
  			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
  		];

  	}

  	updateMatrices( light, viewportIndex = 0 ) {

  		const camera = this.camera;
  		const shadowMatrix = this.matrix;

  		const far = light.distance || camera.far;

  		if ( far !== camera.far ) {

  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
  		camera.position.copy( _lightPositionWorld );

  		_lookTarget.copy( camera.position );
  		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
  		camera.up.copy( this._cubeUps[ viewportIndex ] );
  		camera.lookAt( _lookTarget );
  		camera.updateMatrixWorld();

  		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

  		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

  	}

  }

  PointLightShadow.prototype.isPointLightShadow = true;

  class PointLight extends Light {

  	constructor( color, intensity, distance = 0, decay = 1 ) {

  		super( color, intensity );

  		this.type = 'PointLight';

  		this.distance = distance;
  		this.decay = decay; // for physically correct lights, should be 2.

  		this.shadow = new PointLightShadow();

  	}

  	get power() {

  		// intensity = power per solid angle.
  		// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  		return this.intensity * 4 * Math.PI;

  	}

  	set power( power ) {

  		// intensity = power per solid angle.
  		// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  		this.intensity = power / ( 4 * Math.PI );

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source ) {

  		super.copy( source );

  		this.distance = source.distance;
  		this.decay = source.decay;

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  PointLight.prototype.isPointLight = true;

  class OrthographicCamera extends Camera {

  	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

  		super();

  		this.type = 'OrthographicCamera';

  		this.zoom = 1;
  		this.view = null;

  		this.left = left;
  		this.right = right;
  		this.top = top;
  		this.bottom = bottom;

  		this.near = near;
  		this.far = far;

  		this.updateProjectionMatrix();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.left = source.left;
  		this.right = source.right;
  		this.top = source.top;
  		this.bottom = source.bottom;
  		this.near = source.near;
  		this.far = source.far;

  		this.zoom = source.zoom;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		return this;

  	}

  	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	}

  	clearViewOffset() {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	}

  	updateProjectionMatrix() {

  		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
  		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  		const cx = ( this.right + this.left ) / 2;
  		const cy = ( this.top + this.bottom ) / 2;

  		let left = cx - dx;
  		let right = cx + dx;
  		let top = cy + dy;
  		let bottom = cy - dy;

  		if ( this.view !== null && this.view.enabled ) {

  			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
  			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

  			left += scaleW * this.view.offsetX;
  			right = left + scaleW * this.view.width;
  			top -= scaleH * this.view.offsetY;
  			bottom = top - scaleH * this.view.height;

  		}

  		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

  		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.zoom = this.zoom;
  		data.object.left = this.left;
  		data.object.right = this.right;
  		data.object.top = this.top;
  		data.object.bottom = this.bottom;
  		data.object.near = this.near;
  		data.object.far = this.far;

  		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  		return data;

  	}

  }

  OrthographicCamera.prototype.isOrthographicCamera = true;

  class DirectionalLightShadow extends LightShadow {

  	constructor() {

  		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

  	}

  }

  DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

  class DirectionalLight extends Light {

  	constructor( color, intensity ) {

  		super( color, intensity );

  		this.type = 'DirectionalLight';

  		this.position.copy( Object3D.DefaultUp );
  		this.updateMatrix();

  		this.target = new Object3D();

  		this.shadow = new DirectionalLightShadow();

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source ) {

  		super.copy( source );

  		this.target = source.target.clone();
  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  DirectionalLight.prototype.isDirectionalLight = true;

  class AmbientLight extends Light {

  	constructor( color, intensity ) {

  		super( color, intensity );

  		this.type = 'AmbientLight';

  	}

  }

  AmbientLight.prototype.isAmbientLight = true;

  class RectAreaLight extends Light {

  	constructor( color, intensity, width = 10, height = 10 ) {

  		super( color, intensity );

  		this.type = 'RectAreaLight';

  		this.width = width;
  		this.height = height;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.width = source.width;
  		this.height = source.height;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.width = this.width;
  		data.object.height = this.height;

  		return data;

  	}

  }

  RectAreaLight.prototype.isRectAreaLight = true;

  /**
   * Primary reference:
   *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
   *
   * Secondary reference:
   *   https://www.ppsloan.org/publications/StupidSH36.pdf
   */

  // 3-band SH defined by 9 coefficients

  class SphericalHarmonics3 {

  	constructor() {

  		this.coefficients = [];

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients.push( new Vector3() );

  		}

  	}

  	set( coefficients ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].copy( coefficients[ i ] );

  		}

  		return this;

  	}

  	zero() {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].set( 0, 0, 0 );

  		}

  		return this;

  	}

  	// get the radiance in the direction of the normal
  	// target is a Vector3
  	getAt( normal, target ) {

  		// normal is assumed to be unit length

  		const x = normal.x, y = normal.y, z = normal.z;

  		const coeff = this.coefficients;

  		// band 0
  		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

  		// band 1
  		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
  		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
  		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

  		// band 2
  		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
  		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
  		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
  		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
  		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

  		return target;

  	}

  	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  	// target is a Vector3
  	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
  	getIrradianceAt( normal, target ) {

  		// normal is assumed to be unit length

  		const x = normal.x, y = normal.y, z = normal.z;

  		const coeff = this.coefficients;

  		// band 0
  		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

  		// band 1
  		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
  		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
  		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

  		// band 2
  		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
  		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
  		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
  		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
  		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

  		return target;

  	}

  	add( sh ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].add( sh.coefficients[ i ] );

  		}

  		return this;

  	}

  	addScaledSH( sh, s ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

  		}

  		return this;

  	}

  	scale( s ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].multiplyScalar( s );

  		}

  		return this;

  	}

  	lerp( sh, alpha ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

  		}

  		return this;

  	}

  	equals( sh ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	copy( sh ) {

  		return this.set( sh.coefficients );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	fromArray( array, offset = 0 ) {

  		const coefficients = this.coefficients;

  		for ( let i = 0; i < 9; i ++ ) {

  			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

  		}

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		const coefficients = this.coefficients;

  		for ( let i = 0; i < 9; i ++ ) {

  			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

  		}

  		return array;

  	}

  	// evaluate the basis functions
  	// shBasis is an Array[ 9 ]
  	static getBasisAt( normal, shBasis ) {

  		// normal is assumed to be unit length

  		const x = normal.x, y = normal.y, z = normal.z;

  		// band 0
  		shBasis[ 0 ] = 0.282095;

  		// band 1
  		shBasis[ 1 ] = 0.488603 * y;
  		shBasis[ 2 ] = 0.488603 * z;
  		shBasis[ 3 ] = 0.488603 * x;

  		// band 2
  		shBasis[ 4 ] = 1.092548 * x * y;
  		shBasis[ 5 ] = 1.092548 * y * z;
  		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
  		shBasis[ 7 ] = 1.092548 * x * z;
  		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

  	}

  }

  SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

  class LightProbe extends Light {

  	constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

  		super( undefined, intensity );

  		this.sh = sh;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.sh.copy( source.sh );

  		return this;

  	}

  	fromJSON( json ) {

  		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
  		this.sh.fromArray( json.sh );

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.sh = this.sh.toArray();

  		return data;

  	}

  }

  LightProbe.prototype.isLightProbe = true;

  class MaterialLoader extends Loader {

  	constructor( manager ) {

  		super( manager );
  		this.textures = {};

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const scope = this;

  		const loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.setRequestHeader( scope.requestHeader );
  		loader.setWithCredentials( scope.withCredentials );
  		loader.load( url, function ( text ) {

  			try {

  				onLoad( scope.parse( JSON.parse( text ) ) );

  			} catch ( e ) {

  				if ( onError ) {

  					onError( e );

  				} else {

  					console.error( e );

  				}

  				scope.manager.itemError( url );

  			}

  		}, onProgress, onError );

  	}

  	parse( json ) {

  		const textures = this.textures;

  		function getTexture( name ) {

  			if ( textures[ name ] === undefined ) {

  				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

  			}

  			return textures[ name ];

  		}

  		const material = new Materials[ json.type ]();

  		if ( json.uuid !== undefined ) material.uuid = json.uuid;
  		if ( json.name !== undefined ) material.name = json.name;
  		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
  		if ( json.roughness !== undefined ) material.roughness = json.roughness;
  		if ( json.metalness !== undefined ) material.metalness = json.metalness;
  		if ( json.sheen !== undefined ) material.sheen = new Color().setHex( json.sheen );
  		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
  		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
  		if ( json.shininess !== undefined ) material.shininess = json.shininess;
  		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
  		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
  		if ( json.transmission !== undefined ) material.transmission = json.transmission;
  		if ( json.thickness !== undefined ) material.thickness = json.thickness;
  		if ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;
  		if ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );
  		if ( json.fog !== undefined ) material.fog = json.fog;
  		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
  		if ( json.blending !== undefined ) material.blending = json.blending;
  		if ( json.combine !== undefined ) material.combine = json.combine;
  		if ( json.side !== undefined ) material.side = json.side;
  		if ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;
  		if ( json.opacity !== undefined ) material.opacity = json.opacity;
  		if ( json.transparent !== undefined ) material.transparent = json.transparent;
  		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
  		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
  		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
  		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

  		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
  		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
  		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
  		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
  		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
  		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
  		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
  		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

  		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
  		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
  		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
  		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

  		if ( json.rotation !== undefined ) material.rotation = json.rotation;

  		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
  		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
  		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
  		if ( json.scale !== undefined ) material.scale = json.scale;

  		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
  		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
  		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

  		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
  		if ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;
  		if ( json.dithering !== undefined ) material.dithering = json.dithering;

  		if ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;
  		if ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;

  		if ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;

  		if ( json.visible !== undefined ) material.visible = json.visible;

  		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

  		if ( json.userData !== undefined ) material.userData = json.userData;

  		if ( json.vertexColors !== undefined ) {

  			if ( typeof json.vertexColors === 'number' ) {

  				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

  			} else {

  				material.vertexColors = json.vertexColors;

  			}

  		}

  		// Shader Material

  		if ( json.uniforms !== undefined ) {

  			for ( const name in json.uniforms ) {

  				const uniform = json.uniforms[ name ];

  				material.uniforms[ name ] = {};

  				switch ( uniform.type ) {

  					case 't':
  						material.uniforms[ name ].value = getTexture( uniform.value );
  						break;

  					case 'c':
  						material.uniforms[ name ].value = new Color().setHex( uniform.value );
  						break;

  					case 'v2':
  						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
  						break;

  					case 'v3':
  						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
  						break;

  					case 'v4':
  						material.uniforms[ name ].value = new Vector4$1().fromArray( uniform.value );
  						break;

  					case 'm3':
  						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
  						break;

  					case 'm4':
  						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
  						break;

  					default:
  						material.uniforms[ name ].value = uniform.value;

  				}

  			}

  		}

  		if ( json.defines !== undefined ) material.defines = json.defines;
  		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
  		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

  		if ( json.extensions !== undefined ) {

  			for ( const key in json.extensions ) {

  				material.extensions[ key ] = json.extensions[ key ];

  			}

  		}

  		// Deprecated

  		if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

  		// for PointsMaterial

  		if ( json.size !== undefined ) material.size = json.size;
  		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

  		// maps

  		if ( json.map !== undefined ) material.map = getTexture( json.map );
  		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

  		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

  		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
  		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

  		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
  		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
  		if ( json.normalScale !== undefined ) {

  			let normalScale = json.normalScale;

  			if ( Array.isArray( normalScale ) === false ) {

  				// Blender exporter used to export a scalar. See #7459

  				normalScale = [ normalScale, normalScale ];

  			}

  			material.normalScale = new Vector2().fromArray( normalScale );

  		}

  		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
  		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
  		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

  		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
  		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

  		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
  		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

  		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

  		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
  		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

  		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
  		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

  		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
  		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

  		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
  		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

  		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

  		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
  		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
  		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
  		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

  		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );
  		if ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );

  		return material;

  	}

  	setTextures( value ) {

  		this.textures = value;
  		return this;

  	}

  }

  class LoaderUtils {

  	static decodeText( array ) {

  		if ( typeof TextDecoder !== 'undefined' ) {

  			return new TextDecoder().decode( array );

  		}

  		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
  		// throws a "maximum call stack size exceeded" error for large arrays.

  		let s = '';

  		for ( let i = 0, il = array.length; i < il; i ++ ) {

  			// Implicitly assumes little-endian.
  			s += String.fromCharCode( array[ i ] );

  		}

  		try {

  			// merges multi-byte utf-8 characters.

  			return decodeURIComponent( escape( s ) );

  		} catch ( e ) { // see #16358

  			return s;

  		}

  	}

  	static extractUrlBase( url ) {

  		const index = url.lastIndexOf( '/' );

  		if ( index === - 1 ) return './';

  		return url.substr( 0, index + 1 );

  	}

  }

  class InstancedBufferGeometry extends BufferGeometry {

  	constructor() {

  		super();

  		this.type = 'InstancedBufferGeometry';
  		this.instanceCount = Infinity;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.instanceCount = source.instanceCount;

  		return this;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	toJSON() {

  		const data = super.toJSON( this );

  		data.instanceCount = this.instanceCount;

  		data.isInstancedBufferGeometry = true;

  		return data;

  	}

  }

  InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

  class InstancedBufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized, meshPerAttribute ) {

  		if ( typeof ( normalized ) === 'number' ) {

  			meshPerAttribute = normalized;

  			normalized = false;

  			console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

  		}

  		super( array, itemSize, normalized );

  		this.meshPerAttribute = meshPerAttribute || 1;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  	toJSON()	{

  		const data = super.toJSON();

  		data.meshPerAttribute = this.meshPerAttribute;

  		data.isInstancedBufferAttribute = true;

  		return data;

  	}

  }

  InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

  class BufferGeometryLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const scope = this;

  		const loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.setRequestHeader( scope.requestHeader );
  		loader.setWithCredentials( scope.withCredentials );
  		loader.load( url, function ( text ) {

  			try {

  				onLoad( scope.parse( JSON.parse( text ) ) );

  			} catch ( e ) {

  				if ( onError ) {

  					onError( e );

  				} else {

  					console.error( e );

  				}

  				scope.manager.itemError( url );

  			}

  		}, onProgress, onError );

  	}

  	parse( json ) {

  		const interleavedBufferMap = {};
  		const arrayBufferMap = {};

  		function getInterleavedBuffer( json, uuid ) {

  			if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

  			const interleavedBuffers = json.interleavedBuffers;
  			const interleavedBuffer = interleavedBuffers[ uuid ];

  			const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

  			const array = getTypedArray( interleavedBuffer.type, buffer );
  			const ib = new InterleavedBuffer( array, interleavedBuffer.stride );
  			ib.uuid = interleavedBuffer.uuid;

  			interleavedBufferMap[ uuid ] = ib;

  			return ib;

  		}

  		function getArrayBuffer( json, uuid ) {

  			if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

  			const arrayBuffers = json.arrayBuffers;
  			const arrayBuffer = arrayBuffers[ uuid ];

  			const ab = new Uint32Array( arrayBuffer ).buffer;

  			arrayBufferMap[ uuid ] = ab;

  			return ab;

  		}

  		const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

  		const index = json.data.index;

  		if ( index !== undefined ) {

  			const typedArray = getTypedArray( index.type, index.array );
  			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

  		}

  		const attributes = json.data.attributes;

  		for ( const key in attributes ) {

  			const attribute = attributes[ key ];
  			let bufferAttribute;

  			if ( attribute.isInterleavedBufferAttribute ) {

  				const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
  				bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

  			} else {

  				const typedArray = getTypedArray( attribute.type, attribute.array );
  				const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
  				bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

  			}

  			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
  			if ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );

  			if ( attribute.updateRange !== undefined ) {

  				bufferAttribute.updateRange.offset = attribute.updateRange.offset;
  				bufferAttribute.updateRange.count = attribute.updateRange.count;

  			}

  			geometry.setAttribute( key, bufferAttribute );

  		}

  		const morphAttributes = json.data.morphAttributes;

  		if ( morphAttributes ) {

  			for ( const key in morphAttributes ) {

  				const attributeArray = morphAttributes[ key ];

  				const array = [];

  				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

  					const attribute = attributeArray[ i ];
  					let bufferAttribute;

  					if ( attribute.isInterleavedBufferAttribute ) {

  						const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
  						bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

  					} else {

  						const typedArray = getTypedArray( attribute.type, attribute.array );
  						bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );

  					}

  					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
  					array.push( bufferAttribute );

  				}

  				geometry.morphAttributes[ key ] = array;

  			}

  		}

  		const morphTargetsRelative = json.data.morphTargetsRelative;

  		if ( morphTargetsRelative ) {

  			geometry.morphTargetsRelative = true;

  		}

  		const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

  		if ( groups !== undefined ) {

  			for ( let i = 0, n = groups.length; i !== n; ++ i ) {

  				const group = groups[ i ];

  				geometry.addGroup( group.start, group.count, group.materialIndex );

  			}

  		}

  		const boundingSphere = json.data.boundingSphere;

  		if ( boundingSphere !== undefined ) {

  			const center = new Vector3();

  			if ( boundingSphere.center !== undefined ) {

  				center.fromArray( boundingSphere.center );

  			}

  			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

  		}

  		if ( json.name ) geometry.name = json.name;
  		if ( json.userData ) geometry.userData = json.userData;

  		return geometry;

  	}

  }

  class ObjectLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const scope = this;

  		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
  		this.resourcePath = this.resourcePath || path;

  		const loader = new FileLoader( this.manager );
  		loader.setPath( this.path );
  		loader.setRequestHeader( this.requestHeader );
  		loader.setWithCredentials( this.withCredentials );
  		loader.load( url, function ( text ) {

  			let json = null;

  			try {

  				json = JSON.parse( text );

  			} catch ( error ) {

  				if ( onError !== undefined ) onError( error );

  				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

  				return;

  			}

  			const metadata = json.metadata;

  			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

  				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
  				return;

  			}

  			scope.parse( json, onLoad );

  		}, onProgress, onError );

  	}

  	parse( json, onLoad ) {

  		const animations = this.parseAnimations( json.animations );
  		const shapes = this.parseShapes( json.shapes );
  		const geometries = this.parseGeometries( json.geometries, shapes );

  		const images = this.parseImages( json.images, function () {

  			if ( onLoad !== undefined ) onLoad( object );

  		} );

  		const textures = this.parseTextures( json.textures, images );
  		const materials = this.parseMaterials( json.materials, textures );

  		const object = this.parseObject( json.object, geometries, materials, animations );
  		const skeletons = this.parseSkeletons( json.skeletons, object );

  		this.bindSkeletons( object, skeletons );

  		//

  		if ( onLoad !== undefined ) {

  			let hasImages = false;

  			for ( const uuid in images ) {

  				if ( images[ uuid ] instanceof HTMLImageElement ) {

  					hasImages = true;
  					break;

  				}

  			}

  			if ( hasImages === false ) onLoad( object );

  		}

  		return object;

  	}

  	parseShapes( json ) {

  		const shapes = {};

  		if ( json !== undefined ) {

  			for ( let i = 0, l = json.length; i < l; i ++ ) {

  				const shape = new Shape().fromJSON( json[ i ] );

  				shapes[ shape.uuid ] = shape;

  			}

  		}

  		return shapes;

  	}

  	parseSkeletons( json, object ) {

  		const skeletons = {};
  		const bones = {};

  		// generate bone lookup table

  		object.traverse( function ( child ) {

  			if ( child.isBone ) bones[ child.uuid ] = child;

  		} );

  		// create skeletons

  		if ( json !== undefined ) {

  			for ( let i = 0, l = json.length; i < l; i ++ ) {

  				const skeleton = new Skeleton().fromJSON( json[ i ], bones );

  				skeletons[ skeleton.uuid ] = skeleton;

  			}

  		}

  		return skeletons;

  	}

  	parseGeometries( json, shapes ) {

  		const geometries = {};
  		let geometryShapes;

  		if ( json !== undefined ) {

  			const bufferGeometryLoader = new BufferGeometryLoader();

  			for ( let i = 0, l = json.length; i < l; i ++ ) {

  				let geometry;
  				const data = json[ i ];

  				switch ( data.type ) {

  					case 'PlaneGeometry':
  					case 'PlaneBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.width,
  							data.height,
  							data.widthSegments,
  							data.heightSegments
  						);

  						break;

  					case 'BoxGeometry':
  					case 'BoxBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.width,
  							data.height,
  							data.depth,
  							data.widthSegments,
  							data.heightSegments,
  							data.depthSegments
  						);

  						break;

  					case 'CircleGeometry':
  					case 'CircleBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.segments,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'CylinderGeometry':
  					case 'CylinderBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radiusTop,
  							data.radiusBottom,
  							data.height,
  							data.radialSegments,
  							data.heightSegments,
  							data.openEnded,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'ConeGeometry':
  					case 'ConeBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.height,
  							data.radialSegments,
  							data.heightSegments,
  							data.openEnded,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'SphereGeometry':
  					case 'SphereBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.widthSegments,
  							data.heightSegments,
  							data.phiStart,
  							data.phiLength,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'DodecahedronGeometry':
  					case 'DodecahedronBufferGeometry':
  					case 'IcosahedronGeometry':
  					case 'IcosahedronBufferGeometry':
  					case 'OctahedronGeometry':
  					case 'OctahedronBufferGeometry':
  					case 'TetrahedronGeometry':
  					case 'TetrahedronBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.detail
  						);

  						break;

  					case 'RingGeometry':
  					case 'RingBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.innerRadius,
  							data.outerRadius,
  							data.thetaSegments,
  							data.phiSegments,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'TorusGeometry':
  					case 'TorusBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.tube,
  							data.radialSegments,
  							data.tubularSegments,
  							data.arc
  						);

  						break;

  					case 'TorusKnotGeometry':
  					case 'TorusKnotBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.tube,
  							data.tubularSegments,
  							data.radialSegments,
  							data.p,
  							data.q
  						);

  						break;

  					case 'TubeGeometry':
  					case 'TubeBufferGeometry':

  						// This only works for built-in curves (e.g. CatmullRomCurve3).
  						// User defined curves or instances of CurvePath will not be deserialized.
  						geometry = new Geometries[ data.type ](
  							new Curves[ data.path.type ]().fromJSON( data.path ),
  							data.tubularSegments,
  							data.radius,
  							data.radialSegments,
  							data.closed
  						);

  						break;

  					case 'LatheGeometry':
  					case 'LatheBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.points,
  							data.segments,
  							data.phiStart,
  							data.phiLength
  						);

  						break;

  					case 'PolyhedronGeometry':
  					case 'PolyhedronBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.vertices,
  							data.indices,
  							data.radius,
  							data.details
  						);

  						break;

  					case 'ShapeGeometry':
  					case 'ShapeBufferGeometry':

  						geometryShapes = [];

  						for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

  							const shape = shapes[ data.shapes[ j ] ];

  							geometryShapes.push( shape );

  						}

  						geometry = new Geometries[ data.type ](
  							geometryShapes,
  							data.curveSegments
  						);

  						break;


  					case 'ExtrudeGeometry':
  					case 'ExtrudeBufferGeometry':

  						geometryShapes = [];

  						for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

  							const shape = shapes[ data.shapes[ j ] ];

  							geometryShapes.push( shape );

  						}

  						const extrudePath = data.options.extrudePath;

  						if ( extrudePath !== undefined ) {

  							data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

  						}

  						geometry = new Geometries[ data.type ](
  							geometryShapes,
  							data.options
  						);

  						break;

  					case 'BufferGeometry':
  					case 'InstancedBufferGeometry':

  						geometry = bufferGeometryLoader.parse( data );

  						break;

  					case 'Geometry':

  						console.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' );

  						break;

  					default:

  						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

  						continue;

  				}

  				geometry.uuid = data.uuid;

  				if ( data.name !== undefined ) geometry.name = data.name;
  				if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

  				geometries[ data.uuid ] = geometry;

  			}

  		}

  		return geometries;

  	}

  	parseMaterials( json, textures ) {

  		const cache = {}; // MultiMaterial
  		const materials = {};

  		if ( json !== undefined ) {

  			const loader = new MaterialLoader();
  			loader.setTextures( textures );

  			for ( let i = 0, l = json.length; i < l; i ++ ) {

  				const data = json[ i ];

  				if ( data.type === 'MultiMaterial' ) {

  					// Deprecated

  					const array = [];

  					for ( let j = 0; j < data.materials.length; j ++ ) {

  						const material = data.materials[ j ];

  						if ( cache[ material.uuid ] === undefined ) {

  							cache[ material.uuid ] = loader.parse( material );

  						}

  						array.push( cache[ material.uuid ] );

  					}

  					materials[ data.uuid ] = array;

  				} else {

  					if ( cache[ data.uuid ] === undefined ) {

  						cache[ data.uuid ] = loader.parse( data );

  					}

  					materials[ data.uuid ] = cache[ data.uuid ];

  				}

  			}

  		}

  		return materials;

  	}

  	parseAnimations( json ) {

  		const animations = {};

  		if ( json !== undefined ) {

  			for ( let i = 0; i < json.length; i ++ ) {

  				const data = json[ i ];

  				const clip = AnimationClip.parse( data );

  				animations[ clip.uuid ] = clip;

  			}

  		}

  		return animations;

  	}

  	parseImages( json, onLoad ) {

  		const scope = this;
  		const images = {};

  		let loader;

  		function loadImage( url ) {

  			scope.manager.itemStart( url );

  			return loader.load( url, function () {

  				scope.manager.itemEnd( url );

  			}, undefined, function () {

  				scope.manager.itemError( url );
  				scope.manager.itemEnd( url );

  			} );

  		}

  		function deserializeImage( image ) {

  			if ( typeof image === 'string' ) {

  				const url = image;

  				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

  				return loadImage( path );

  			} else {

  				if ( image.data ) {

  					return {
  						data: getTypedArray( image.type, image.data ),
  						width: image.width,
  						height: image.height
  					};

  				} else {

  					return null;

  				}

  			}

  		}

  		if ( json !== undefined && json.length > 0 ) {

  			const manager = new LoadingManager( onLoad );

  			loader = new ImageLoader( manager );
  			loader.setCrossOrigin( this.crossOrigin );

  			for ( let i = 0, il = json.length; i < il; i ++ ) {

  				const image = json[ i ];
  				const url = image.url;

  				if ( Array.isArray( url ) ) {

  					// load array of images e.g CubeTexture

  					images[ image.uuid ] = [];

  					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

  						const currentUrl = url[ j ];

  						const deserializedImage = deserializeImage( currentUrl );

  						if ( deserializedImage !== null ) {

  							if ( deserializedImage instanceof HTMLImageElement ) {

  								images[ image.uuid ].push( deserializedImage );

  							} else {

  								// special case: handle array of data textures for cube textures

  								images[ image.uuid ].push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

  							}

  						}

  					}

  				} else {

  					// load single image

  					const deserializedImage = deserializeImage( image.url );

  					if ( deserializedImage !== null ) {

  						images[ image.uuid ] = deserializedImage;

  					}

  				}

  			}

  		}

  		return images;

  	}

  	parseTextures( json, images ) {

  		function parseConstant( value, type ) {

  			if ( typeof value === 'number' ) return value;

  			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

  			return type[ value ];

  		}

  		const textures = {};

  		if ( json !== undefined ) {

  			for ( let i = 0, l = json.length; i < l; i ++ ) {

  				const data = json[ i ];

  				if ( data.image === undefined ) {

  					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

  				}

  				if ( images[ data.image ] === undefined ) {

  					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

  				}

  				let texture;
  				const image = images[ data.image ];

  				if ( Array.isArray( image ) ) {

  					texture = new CubeTexture( image );

  					if ( image.length === 6 ) texture.needsUpdate = true;

  				} else {

  					if ( image && image.data ) {

  						texture = new DataTexture( image.data, image.width, image.height );

  					} else {

  						texture = new Texture( image );

  					}

  					if ( image ) texture.needsUpdate = true; // textures can have undefined image data

  				}

  				texture.uuid = data.uuid;

  				if ( data.name !== undefined ) texture.name = data.name;

  				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

  				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
  				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
  				if ( data.center !== undefined ) texture.center.fromArray( data.center );
  				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

  				if ( data.wrap !== undefined ) {

  					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
  					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

  				}

  				if ( data.format !== undefined ) texture.format = data.format;
  				if ( data.type !== undefined ) texture.type = data.type;
  				if ( data.encoding !== undefined ) texture.encoding = data.encoding;

  				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
  				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
  				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

  				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

  				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
  				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

  				textures[ data.uuid ] = texture;

  			}

  		}

  		return textures;

  	}

  	parseObject( data, geometries, materials, animations ) {

  		let object;

  		function getGeometry( name ) {

  			if ( geometries[ name ] === undefined ) {

  				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

  			}

  			return geometries[ name ];

  		}

  		function getMaterial( name ) {

  			if ( name === undefined ) return undefined;

  			if ( Array.isArray( name ) ) {

  				const array = [];

  				for ( let i = 0, l = name.length; i < l; i ++ ) {

  					const uuid = name[ i ];

  					if ( materials[ uuid ] === undefined ) {

  						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

  					}

  					array.push( materials[ uuid ] );

  				}

  				return array;

  			}

  			if ( materials[ name ] === undefined ) {

  				console.warn( 'THREE.ObjectLoader: Undefined material', name );

  			}

  			return materials[ name ];

  		}

  		let geometry, material;

  		switch ( data.type ) {

  			case 'Scene':

  				object = new Scene();

  				if ( data.background !== undefined ) {

  					if ( Number.isInteger( data.background ) ) {

  						object.background = new Color( data.background );

  					}

  				}

  				if ( data.fog !== undefined ) {

  					if ( data.fog.type === 'Fog' ) {

  						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

  					} else if ( data.fog.type === 'FogExp2' ) {

  						object.fog = new FogExp2( data.fog.color, data.fog.density );

  					}

  				}

  				break;

  			case 'PerspectiveCamera':

  				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

  				if ( data.focus !== undefined ) object.focus = data.focus;
  				if ( data.zoom !== undefined ) object.zoom = data.zoom;
  				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
  				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
  				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

  				break;

  			case 'OrthographicCamera':

  				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

  				if ( data.zoom !== undefined ) object.zoom = data.zoom;
  				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

  				break;

  			case 'AmbientLight':

  				object = new AmbientLight( data.color, data.intensity );

  				break;

  			case 'DirectionalLight':

  				object = new DirectionalLight( data.color, data.intensity );

  				break;

  			case 'PointLight':

  				object = new PointLight( data.color, data.intensity, data.distance, data.decay );

  				break;

  			case 'RectAreaLight':

  				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

  				break;

  			case 'SpotLight':

  				object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

  				break;

  			case 'HemisphereLight':

  				object = new HemisphereLight( data.color, data.groundColor, data.intensity );

  				break;

  			case 'LightProbe':

  				object = new LightProbe().fromJSON( data );

  				break;

  			case 'SkinnedMesh':

  				geometry = getGeometry( data.geometry );
  			 	material = getMaterial( data.material );

  				object = new SkinnedMesh( geometry, material );

  				if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
  				if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
  				if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

  				break;

  			case 'Mesh':

  				geometry = getGeometry( data.geometry );
  				material = getMaterial( data.material );

  				object = new Mesh( geometry, material );

  				break;

  			case 'InstancedMesh':

  				geometry = getGeometry( data.geometry );
  				material = getMaterial( data.material );
  				const count = data.count;
  				const instanceMatrix = data.instanceMatrix;
  				const instanceColor = data.instanceColor;

  				object = new InstancedMesh( geometry, material, count );
  				object.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );
  				if ( instanceColor !== undefined ) object.instanceColor = new BufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );

  				break;

  			case 'LOD':

  				object = new LOD();

  				break;

  			case 'Line':

  				object = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );

  				break;

  			case 'LineLoop':

  				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

  				break;

  			case 'LineSegments':

  				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

  				break;

  			case 'PointCloud':
  			case 'Points':

  				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

  				break;

  			case 'Sprite':

  				object = new Sprite( getMaterial( data.material ) );

  				break;

  			case 'Group':

  				object = new Group();

  				break;

  			case 'Bone':

  				object = new Bone();

  				break;

  			default:

  				object = new Object3D();

  		}

  		object.uuid = data.uuid;

  		if ( data.name !== undefined ) object.name = data.name;

  		if ( data.matrix !== undefined ) {

  			object.matrix.fromArray( data.matrix );

  			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
  			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

  		} else {

  			if ( data.position !== undefined ) object.position.fromArray( data.position );
  			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
  			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
  			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

  		}

  		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
  		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

  		if ( data.shadow ) {

  			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
  			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
  			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
  			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
  			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

  		}

  		if ( data.visible !== undefined ) object.visible = data.visible;
  		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
  		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
  		if ( data.userData !== undefined ) object.userData = data.userData;
  		if ( data.layers !== undefined ) object.layers.mask = data.layers;

  		if ( data.children !== undefined ) {

  			const children = data.children;

  			for ( let i = 0; i < children.length; i ++ ) {

  				object.add( this.parseObject( children[ i ], geometries, materials, animations ) );

  			}

  		}

  		if ( data.animations !== undefined ) {

  			const objectAnimations = data.animations;

  			for ( let i = 0; i < objectAnimations.length; i ++ ) {

  				const uuid = objectAnimations[ i ];

  				object.animations.push( animations[ uuid ] );

  			}

  		}

  		if ( data.type === 'LOD' ) {

  			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

  			const levels = data.levels;

  			for ( let l = 0; l < levels.length; l ++ ) {

  				const level = levels[ l ];
  				const child = object.getObjectByProperty( 'uuid', level.object );

  				if ( child !== undefined ) {

  					object.addLevel( child, level.distance );

  				}

  			}

  		}

  		return object;

  	}

  	bindSkeletons( object, skeletons ) {

  		if ( Object.keys( skeletons ).length === 0 ) return;

  		object.traverse( function ( child ) {

  			if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

  				const skeleton = skeletons[ child.skeleton ];

  				if ( skeleton === undefined ) {

  					console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

  				} else {

  					child.bind( skeleton, child.bindMatrix );

  				}

  			}

  		} );

  	}

  	/* DEPRECATED */

  	setTexturePath( value ) {

  		console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
  		return this.setResourcePath( value );

  	}

  }

  const TEXTURE_MAPPING = {
  	UVMapping: UVMapping,
  	CubeReflectionMapping: CubeReflectionMapping,
  	CubeRefractionMapping: CubeRefractionMapping,
  	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
  	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
  	CubeUVReflectionMapping: CubeUVReflectionMapping,
  	CubeUVRefractionMapping: CubeUVRefractionMapping
  };

  const TEXTURE_WRAPPING = {
  	RepeatWrapping: RepeatWrapping,
  	ClampToEdgeWrapping: ClampToEdgeWrapping,
  	MirroredRepeatWrapping: MirroredRepeatWrapping
  };

  const TEXTURE_FILTER = {
  	NearestFilter: NearestFilter,
  	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
  	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
  	LinearFilter: LinearFilter,
  	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
  	LinearMipmapLinearFilter: LinearMipmapLinearFilter
  };

  class ImageBitmapLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  		if ( typeof createImageBitmap === 'undefined' ) {

  			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

  		}

  		if ( typeof fetch === 'undefined' ) {

  			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

  		}

  		this.options = { premultiplyAlpha: 'none' };

  	}

  	setOptions( options ) {

  		this.options = options;

  		return this;

  	}

  	load( url, onLoad, onProgress, onError ) {

  		if ( url === undefined ) url = '';

  		if ( this.path !== undefined ) url = this.path + url;

  		url = this.manager.resolveURL( url );

  		const scope = this;

  		const cached = Cache.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) onLoad( cached );

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		const fetchOptions = {};
  		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
  		fetchOptions.headers = this.requestHeader;

  		fetch( url, fetchOptions ).then( function ( res ) {

  			return res.blob();

  		} ).then( function ( blob ) {

  			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

  		} ).then( function ( imageBitmap ) {

  			Cache.add( url, imageBitmap );

  			if ( onLoad ) onLoad( imageBitmap );

  			scope.manager.itemEnd( url );

  		} ).catch( function ( e ) {

  			if ( onError ) onError( e );

  			scope.manager.itemError( url );
  			scope.manager.itemEnd( url );

  		} );

  		scope.manager.itemStart( url );

  	}

  }

  ImageBitmapLoader.prototype.isImageBitmapLoader = true;

  class ShapePath {

  	constructor() {

  		this.type = 'ShapePath';

  		this.color = new Color();

  		this.subPaths = [];
  		this.currentPath = null;

  	}

  	moveTo( x, y ) {

  		this.currentPath = new Path();
  		this.subPaths.push( this.currentPath );
  		this.currentPath.moveTo( x, y );

  		return this;

  	}

  	lineTo( x, y ) {

  		this.currentPath.lineTo( x, y );

  		return this;

  	}

  	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

  		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

  		return this;

  	}

  	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

  		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

  		return this;

  	}

  	splineThru( pts ) {

  		this.currentPath.splineThru( pts );

  		return this;

  	}

  	toShapes( isCCW, noHoles ) {

  		function toShapesNoHoles( inSubpaths ) {

  			const shapes = [];

  			for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

  				const tmpPath = inSubpaths[ i ];

  				const tmpShape = new Shape();
  				tmpShape.curves = tmpPath.curves;

  				shapes.push( tmpShape );

  			}

  			return shapes;

  		}

  		function isPointInsidePolygon( inPt, inPolygon ) {

  			const polyLen = inPolygon.length;

  			// inPt on polygon contour => immediate success    or
  			// toggling of inside/outside at every single! intersection point of an edge
  			//  with the horizontal line through inPt, left of inPt
  			//  not counting lowerY endpoints of edges and whole edges on that line
  			let inside = false;
  			for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

  				let edgeLowPt = inPolygon[ p ];
  				let edgeHighPt = inPolygon[ q ];

  				let edgeDx = edgeHighPt.x - edgeLowPt.x;
  				let edgeDy = edgeHighPt.y - edgeLowPt.y;

  				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

  					// not parallel
  					if ( edgeDy < 0 ) {

  						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
  						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

  					}

  					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

  					if ( inPt.y === edgeLowPt.y ) {

  						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
  						// continue;				// no intersection or edgeLowPt => doesn't count !!!

  					} else {

  						const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
  						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
  						if ( perpEdge < 0 ) 				continue;
  						inside = ! inside;		// true intersection left of inPt

  					}

  				} else {

  					// parallel or collinear
  					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
  					// edge lies on the same horizontal line as inPt
  					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
  						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
  					// continue;

  				}

  			}

  			return	inside;

  		}

  		const isClockWise = ShapeUtils.isClockWise;

  		const subPaths = this.subPaths;
  		if ( subPaths.length === 0 ) return [];

  		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


  		let solid, tmpPath, tmpShape;
  		const shapes = [];

  		if ( subPaths.length === 1 ) {

  			tmpPath = subPaths[ 0 ];
  			tmpShape = new Shape();
  			tmpShape.curves = tmpPath.curves;
  			shapes.push( tmpShape );
  			return shapes;

  		}

  		let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
  		holesFirst = isCCW ? ! holesFirst : holesFirst;

  		// console.log("Holes first", holesFirst);

  		const betterShapeHoles = [];
  		const newShapes = [];
  		let newShapeHoles = [];
  		let mainIdx = 0;
  		let tmpPoints;

  		newShapes[ mainIdx ] = undefined;
  		newShapeHoles[ mainIdx ] = [];

  		for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

  			tmpPath = subPaths[ i ];
  			tmpPoints = tmpPath.getPoints();
  			solid = isClockWise( tmpPoints );
  			solid = isCCW ? ! solid : solid;

  			if ( solid ) {

  				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

  				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
  				newShapes[ mainIdx ].s.curves = tmpPath.curves;

  				if ( holesFirst )	mainIdx ++;
  				newShapeHoles[ mainIdx ] = [];

  				//console.log('cw', i);

  			} else {

  				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

  				//console.log('ccw', i);

  			}

  		}

  		// only Holes? -> probably all Shapes with wrong orientation
  		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


  		if ( newShapes.length > 1 ) {

  			let ambiguous = false;
  			const toChange = [];

  			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

  				betterShapeHoles[ sIdx ] = [];

  			}

  			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

  				const sho = newShapeHoles[ sIdx ];

  				for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

  					const ho = sho[ hIdx ];
  					let hole_unassigned = true;

  					for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

  						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

  							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
  							if ( hole_unassigned ) {

  								hole_unassigned = false;
  								betterShapeHoles[ s2Idx ].push( ho );

  							} else {

  								ambiguous = true;

  							}

  						}

  					}

  					if ( hole_unassigned ) {

  						betterShapeHoles[ sIdx ].push( ho );

  					}

  				}

  			}
  			// console.log("ambiguous: ", ambiguous);

  			if ( toChange.length > 0 ) {

  				// console.log("to change: ", toChange);
  				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

  			}

  		}

  		let tmpHoles;

  		for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

  			tmpShape = newShapes[ i ].s;
  			shapes.push( tmpShape );
  			tmpHoles = newShapeHoles[ i ];

  			for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

  				tmpShape.holes.push( tmpHoles[ j ].h );

  			}

  		}

  		//console.log("shape", shapes);

  		return shapes;

  	}

  }

  class Font {

  	constructor( data ) {

  		this.type = 'Font';

  		this.data = data;

  	}

  	generateShapes( text, size = 100 ) {

  		const shapes = [];
  		const paths = createPaths( text, size, this.data );

  		for ( let p = 0, pl = paths.length; p < pl; p ++ ) {

  			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

  		}

  		return shapes;

  	}

  }

  function createPaths( text, size, data ) {

  	const chars = Array.from( text );
  	const scale = size / data.resolution;
  	const line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

  	const paths = [];

  	let offsetX = 0, offsetY = 0;

  	for ( let i = 0; i < chars.length; i ++ ) {

  		const char = chars[ i ];

  		if ( char === '\n' ) {

  			offsetX = 0;
  			offsetY -= line_height;

  		} else {

  			const ret = createPath( char, scale, offsetX, offsetY, data );
  			offsetX += ret.offsetX;
  			paths.push( ret.path );

  		}

  	}

  	return paths;

  }

  function createPath( char, scale, offsetX, offsetY, data ) {

  	const glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

  	if ( ! glyph ) {

  		console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

  		return;

  	}

  	const path = new ShapePath();

  	let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

  	if ( glyph.o ) {

  		const outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

  		for ( let i = 0, l = outline.length; i < l; ) {

  			const action = outline[ i ++ ];

  			switch ( action ) {

  				case 'm': // moveTo

  					x = outline[ i ++ ] * scale + offsetX;
  					y = outline[ i ++ ] * scale + offsetY;

  					path.moveTo( x, y );

  					break;

  				case 'l': // lineTo

  					x = outline[ i ++ ] * scale + offsetX;
  					y = outline[ i ++ ] * scale + offsetY;

  					path.lineTo( x, y );

  					break;

  				case 'q': // quadraticCurveTo

  					cpx = outline[ i ++ ] * scale + offsetX;
  					cpy = outline[ i ++ ] * scale + offsetY;
  					cpx1 = outline[ i ++ ] * scale + offsetX;
  					cpy1 = outline[ i ++ ] * scale + offsetY;

  					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

  					break;

  				case 'b': // bezierCurveTo

  					cpx = outline[ i ++ ] * scale + offsetX;
  					cpy = outline[ i ++ ] * scale + offsetY;
  					cpx1 = outline[ i ++ ] * scale + offsetX;
  					cpy1 = outline[ i ++ ] * scale + offsetY;
  					cpx2 = outline[ i ++ ] * scale + offsetX;
  					cpy2 = outline[ i ++ ] * scale + offsetY;

  					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

  					break;

  			}

  		}

  	}

  	return { offsetX: glyph.ha * scale, path: path };

  }

  Font.prototype.isFont = true;

  class FontLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const scope = this;

  		const loader = new FileLoader( this.manager );
  		loader.setPath( this.path );
  		loader.setRequestHeader( this.requestHeader );
  		loader.setWithCredentials( scope.withCredentials );
  		loader.load( url, function ( text ) {

  			let json;

  			try {

  				json = JSON.parse( text );

  			} catch ( e ) {

  				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
  				json = JSON.parse( text.substring( 65, text.length - 2 ) );

  			}

  			const font = scope.parse( json );

  			if ( onLoad ) onLoad( font );

  		}, onProgress, onError );

  	}

  	parse( json ) {

  		return new Font( json );

  	}

  }

  let _context;

  const AudioContext = {

  	getContext: function () {

  		if ( _context === undefined ) {

  			_context = new ( window.AudioContext || window.webkitAudioContext )();

  		}

  		return _context;

  	},

  	setContext: function ( value ) {

  		_context = value;

  	}

  };

  class AudioLoader extends Loader {

  	constructor( manager ) {

  		super( manager );

  	}

  	load( url, onLoad, onProgress, onError ) {

  		const scope = this;

  		const loader = new FileLoader( this.manager );
  		loader.setResponseType( 'arraybuffer' );
  		loader.setPath( this.path );
  		loader.setRequestHeader( this.requestHeader );
  		loader.setWithCredentials( this.withCredentials );
  		loader.load( url, function ( buffer ) {

  			try {

  				// Create a copy of the buffer. The `decodeAudioData` method
  				// detaches the buffer when complete, preventing reuse.
  				const bufferCopy = buffer.slice( 0 );

  				const context = AudioContext.getContext();
  				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

  					onLoad( audioBuffer );

  				} );

  			} catch ( e ) {

  				if ( onError ) {

  					onError( e );

  				} else {

  					console.error( e );

  				}

  				scope.manager.itemError( url );

  			}

  		}, onProgress, onError );

  	}

  }

  class HemisphereLightProbe extends LightProbe {

  	constructor( skyColor, groundColor, intensity = 1 ) {

  		super( undefined, intensity );

  		const color1 = new Color().set( skyColor );
  		const color2 = new Color().set( groundColor );

  		const sky = new Vector3( color1.r, color1.g, color1.b );
  		const ground = new Vector3( color2.r, color2.g, color2.b );

  		// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
  		const c0 = Math.sqrt( Math.PI );
  		const c1 = c0 * Math.sqrt( 0.75 );

  		this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
  		this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

  	}

  }

  HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

  class AmbientLightProbe extends LightProbe {

  	constructor( color, intensity = 1 ) {

  		super( undefined, intensity );

  		const color1 = new Color().set( color );

  		// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
  		this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

  	}

  }

  AmbientLightProbe.prototype.isAmbientLightProbe = true;

  const _eyeRight = /*@__PURE__*/ new Matrix4();
  const _eyeLeft = /*@__PURE__*/ new Matrix4();

  class StereoCamera {

  	constructor() {

  		this.type = 'StereoCamera';

  		this.aspect = 1;

  		this.eyeSep = 0.064;

  		this.cameraL = new PerspectiveCamera();
  		this.cameraL.layers.enable( 1 );
  		this.cameraL.matrixAutoUpdate = false;

  		this.cameraR = new PerspectiveCamera();
  		this.cameraR.layers.enable( 2 );
  		this.cameraR.matrixAutoUpdate = false;

  		this._cache = {
  			focus: null,
  			fov: null,
  			aspect: null,
  			near: null,
  			far: null,
  			zoom: null,
  			eyeSep: null
  		};

  	}

  	update( camera ) {

  		const cache = this._cache;

  		const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
  			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
  			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

  		if ( needsUpdate ) {

  			cache.focus = camera.focus;
  			cache.fov = camera.fov;
  			cache.aspect = camera.aspect * this.aspect;
  			cache.near = camera.near;
  			cache.far = camera.far;
  			cache.zoom = camera.zoom;
  			cache.eyeSep = this.eyeSep;

  			// Off-axis stereoscopic effect based on
  			// http://paulbourke.net/stereographics/stereorender/

  			const projectionMatrix = camera.projectionMatrix.clone();
  			const eyeSepHalf = cache.eyeSep / 2;
  			const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
  			const ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
  			let xmin, xmax;

  			// translate xOffset

  			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
  			_eyeRight.elements[ 12 ] = eyeSepHalf;

  			// for left eye

  			xmin = - ymax * cache.aspect + eyeSepOnProjection;
  			xmax = ymax * cache.aspect + eyeSepOnProjection;

  			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
  			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

  			this.cameraL.projectionMatrix.copy( projectionMatrix );

  			// for right eye

  			xmin = - ymax * cache.aspect - eyeSepOnProjection;
  			xmax = ymax * cache.aspect - eyeSepOnProjection;

  			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
  			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

  			this.cameraR.projectionMatrix.copy( projectionMatrix );

  		}

  		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
  		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

  	}

  }

  class Clock {

  	constructor( autoStart = true ) {

  		this.autoStart = autoStart;

  		this.startTime = 0;
  		this.oldTime = 0;
  		this.elapsedTime = 0;

  		this.running = false;

  	}

  	start() {

  		this.startTime = now();

  		this.oldTime = this.startTime;
  		this.elapsedTime = 0;
  		this.running = true;

  	}

  	stop() {

  		this.getElapsedTime();
  		this.running = false;
  		this.autoStart = false;

  	}

  	getElapsedTime() {

  		this.getDelta();
  		return this.elapsedTime;

  	}

  	getDelta() {

  		let diff = 0;

  		if ( this.autoStart && ! this.running ) {

  			this.start();
  			return 0;

  		}

  		if ( this.running ) {

  			const newTime = now();

  			diff = ( newTime - this.oldTime ) / 1000;
  			this.oldTime = newTime;

  			this.elapsedTime += diff;

  		}

  		return diff;

  	}

  }

  function now() {

  	return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

  }

  const _position$1 = /*@__PURE__*/ new Vector3();
  const _quaternion$1 = /*@__PURE__*/ new Quaternion();
  const _scale$1 = /*@__PURE__*/ new Vector3();
  const _orientation$1 = /*@__PURE__*/ new Vector3();

  class AudioListener extends Object3D {

  	constructor() {

  		super();

  		this.type = 'AudioListener';

  		this.context = AudioContext.getContext();

  		this.gain = this.context.createGain();
  		this.gain.connect( this.context.destination );

  		this.filter = null;

  		this.timeDelta = 0;

  		// private

  		this._clock = new Clock();

  	}

  	getInput() {

  		return this.gain;

  	}

  	removeFilter() {

  		if ( this.filter !== null ) {

  			this.gain.disconnect( this.filter );
  			this.filter.disconnect( this.context.destination );
  			this.gain.connect( this.context.destination );
  			this.filter = null;

  		}

  		return this;

  	}

  	getFilter() {

  		return this.filter;

  	}

  	setFilter( value ) {

  		if ( this.filter !== null ) {

  			this.gain.disconnect( this.filter );
  			this.filter.disconnect( this.context.destination );

  		} else {

  			this.gain.disconnect( this.context.destination );

  		}

  		this.filter = value;
  		this.gain.connect( this.filter );
  		this.filter.connect( this.context.destination );

  		return this;

  	}

  	getMasterVolume() {

  		return this.gain.gain.value;

  	}

  	setMasterVolume( value ) {

  		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

  		return this;

  	}

  	updateMatrixWorld( force ) {

  		super.updateMatrixWorld( force );

  		const listener = this.context.listener;
  		const up = this.up;

  		this.timeDelta = this._clock.getDelta();

  		this.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );

  		_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );

  		if ( listener.positionX ) {

  			// code path for Chrome (see #14393)

  			const endTime = this.context.currentTime + this.timeDelta;

  			listener.positionX.linearRampToValueAtTime( _position$1.x, endTime );
  			listener.positionY.linearRampToValueAtTime( _position$1.y, endTime );
  			listener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );
  			listener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );
  			listener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );
  			listener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );
  			listener.upX.linearRampToValueAtTime( up.x, endTime );
  			listener.upY.linearRampToValueAtTime( up.y, endTime );
  			listener.upZ.linearRampToValueAtTime( up.z, endTime );

  		} else {

  			listener.setPosition( _position$1.x, _position$1.y, _position$1.z );
  			listener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );

  		}

  	}

  }

  class Audio extends Object3D {

  	constructor( listener ) {

  		super();

  		this.type = 'Audio';

  		this.listener = listener;
  		this.context = listener.context;

  		this.gain = this.context.createGain();
  		this.gain.connect( listener.getInput() );

  		this.autoplay = false;

  		this.buffer = null;
  		this.detune = 0;
  		this.loop = false;
  		this.loopStart = 0;
  		this.loopEnd = 0;
  		this.offset = 0;
  		this.duration = undefined;
  		this.playbackRate = 1;
  		this.isPlaying = false;
  		this.hasPlaybackControl = true;
  		this.source = null;
  		this.sourceType = 'empty';

  		this._startedAt = 0;
  		this._progress = 0;
  		this._connected = false;

  		this.filters = [];

  	}

  	getOutput() {

  		return this.gain;

  	}

  	setNodeSource( audioNode ) {

  		this.hasPlaybackControl = false;
  		this.sourceType = 'audioNode';
  		this.source = audioNode;
  		this.connect();

  		return this;

  	}

  	setMediaElementSource( mediaElement ) {

  		this.hasPlaybackControl = false;
  		this.sourceType = 'mediaNode';
  		this.source = this.context.createMediaElementSource( mediaElement );
  		this.connect();

  		return this;

  	}

  	setMediaStreamSource( mediaStream ) {

  		this.hasPlaybackControl = false;
  		this.sourceType = 'mediaStreamNode';
  		this.source = this.context.createMediaStreamSource( mediaStream );
  		this.connect();

  		return this;

  	}

  	setBuffer( audioBuffer ) {

  		this.buffer = audioBuffer;
  		this.sourceType = 'buffer';

  		if ( this.autoplay ) this.play();

  		return this;

  	}

  	play( delay = 0 ) {

  		if ( this.isPlaying === true ) {

  			console.warn( 'THREE.Audio: Audio is already playing.' );
  			return;

  		}

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		this._startedAt = this.context.currentTime + delay;

  		const source = this.context.createBufferSource();
  		source.buffer = this.buffer;
  		source.loop = this.loop;
  		source.loopStart = this.loopStart;
  		source.loopEnd = this.loopEnd;
  		source.onended = this.onEnded.bind( this );
  		source.start( this._startedAt, this._progress + this.offset, this.duration );

  		this.isPlaying = true;

  		this.source = source;

  		this.setDetune( this.detune );
  		this.setPlaybackRate( this.playbackRate );

  		return this.connect();

  	}

  	pause() {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		if ( this.isPlaying === true ) {

  			// update current progress

  			this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

  			if ( this.loop === true ) {

  				// ensure _progress does not exceed duration with looped audios

  				this._progress = this._progress % ( this.duration || this.buffer.duration );

  			}

  			this.source.stop();
  			this.source.onended = null;

  			this.isPlaying = false;

  		}

  		return this;

  	}

  	stop() {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		this._progress = 0;

  		this.source.stop();
  		this.source.onended = null;
  		this.isPlaying = false;

  		return this;

  	}

  	connect() {

  		if ( this.filters.length > 0 ) {

  			this.source.connect( this.filters[ 0 ] );

  			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

  				this.filters[ i - 1 ].connect( this.filters[ i ] );

  			}

  			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

  		} else {

  			this.source.connect( this.getOutput() );

  		}

  		this._connected = true;

  		return this;

  	}

  	disconnect() {

  		if ( this.filters.length > 0 ) {

  			this.source.disconnect( this.filters[ 0 ] );

  			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

  				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

  			}

  			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

  		} else {

  			this.source.disconnect( this.getOutput() );

  		}

  		this._connected = false;

  		return this;

  	}

  	getFilters() {

  		return this.filters;

  	}

  	setFilters( value ) {

  		if ( ! value ) value = [];

  		if ( this._connected === true ) {

  			this.disconnect();
  			this.filters = value.slice();
  			this.connect();

  		} else {

  			this.filters = value.slice();

  		}

  		return this;

  	}

  	setDetune( value ) {

  		this.detune = value;

  		if ( this.source.detune === undefined ) return; // only set detune when available

  		if ( this.isPlaying === true ) {

  			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

  		}

  		return this;

  	}

  	getDetune() {

  		return this.detune;

  	}

  	getFilter() {

  		return this.getFilters()[ 0 ];

  	}

  	setFilter( filter ) {

  		return this.setFilters( filter ? [ filter ] : [] );

  	}

  	setPlaybackRate( value ) {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.playbackRate = value;

  		if ( this.isPlaying === true ) {

  			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

  		}

  		return this;

  	}

  	getPlaybackRate() {

  		return this.playbackRate;

  	}

  	onEnded() {

  		this.isPlaying = false;

  	}

  	getLoop() {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return false;

  		}

  		return this.loop;

  	}

  	setLoop( value ) {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.loop = value;

  		if ( this.isPlaying === true ) {

  			this.source.loop = this.loop;

  		}

  		return this;

  	}

  	setLoopStart( value ) {

  		this.loopStart = value;

  		return this;

  	}

  	setLoopEnd( value ) {

  		this.loopEnd = value;

  		return this;

  	}

  	getVolume() {

  		return this.gain.gain.value;

  	}

  	setVolume( value ) {

  		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

  		return this;

  	}

  }

  const _position = /*@__PURE__*/ new Vector3();
  const _quaternion = /*@__PURE__*/ new Quaternion();
  const _scale = /*@__PURE__*/ new Vector3();
  const _orientation = /*@__PURE__*/ new Vector3();

  class PositionalAudio extends Audio {

  	constructor( listener ) {

  		super( listener );

  		this.panner = this.context.createPanner();
  		this.panner.panningModel = 'HRTF';
  		this.panner.connect( this.gain );

  	}

  	getOutput() {

  		return this.panner;

  	}

  	getRefDistance() {

  		return this.panner.refDistance;

  	}

  	setRefDistance( value ) {

  		this.panner.refDistance = value;

  		return this;

  	}

  	getRolloffFactor() {

  		return this.panner.rolloffFactor;

  	}

  	setRolloffFactor( value ) {

  		this.panner.rolloffFactor = value;

  		return this;

  	}

  	getDistanceModel() {

  		return this.panner.distanceModel;

  	}

  	setDistanceModel( value ) {

  		this.panner.distanceModel = value;

  		return this;

  	}

  	getMaxDistance() {

  		return this.panner.maxDistance;

  	}

  	setMaxDistance( value ) {

  		this.panner.maxDistance = value;

  		return this;

  	}

  	setDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

  		this.panner.coneInnerAngle = coneInnerAngle;
  		this.panner.coneOuterAngle = coneOuterAngle;
  		this.panner.coneOuterGain = coneOuterGain;

  		return this;

  	}

  	updateMatrixWorld( force ) {

  		super.updateMatrixWorld( force );

  		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

  		this.matrixWorld.decompose( _position, _quaternion, _scale );

  		_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );

  		const panner = this.panner;

  		if ( panner.positionX ) {

  			// code path for Chrome and Firefox (see #14393)

  			const endTime = this.context.currentTime + this.listener.timeDelta;

  			panner.positionX.linearRampToValueAtTime( _position.x, endTime );
  			panner.positionY.linearRampToValueAtTime( _position.y, endTime );
  			panner.positionZ.linearRampToValueAtTime( _position.z, endTime );
  			panner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );
  			panner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );
  			panner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );

  		} else {

  			panner.setPosition( _position.x, _position.y, _position.z );
  			panner.setOrientation( _orientation.x, _orientation.y, _orientation.z );

  		}

  	}

  }

  class AudioAnalyser {

  	constructor( audio, fftSize = 2048 ) {

  		this.analyser = audio.context.createAnalyser();
  		this.analyser.fftSize = fftSize;

  		this.data = new Uint8Array( this.analyser.frequencyBinCount );

  		audio.getOutput().connect( this.analyser );

  	}


  	getFrequencyData() {

  		this.analyser.getByteFrequencyData( this.data );

  		return this.data;

  	}

  	getAverageFrequency() {

  		let value = 0;
  		const data = this.getFrequencyData();

  		for ( let i = 0; i < data.length; i ++ ) {

  			value += data[ i ];

  		}

  		return value / data.length;

  	}

  }

  class PropertyMixer {

  	constructor( binding, typeName, valueSize ) {

  		this.binding = binding;
  		this.valueSize = valueSize;

  		let mixFunction,
  			mixFunctionAdditive,
  			setIdentity;

  		// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
  		//
  		// interpolators can use .buffer as their .result
  		// the data then goes to 'incoming'
  		//
  		// 'accu0' and 'accu1' are used frame-interleaved for
  		// the cumulative result and are compared to detect
  		// changes
  		//
  		// 'orig' stores the original state of the property
  		//
  		// 'add' is used for additive cumulative results
  		//
  		// 'work' is optional and is only present for quaternion types. It is used
  		// to store intermediate quaternion multiplication results

  		switch ( typeName ) {

  			case 'quaternion':
  				mixFunction = this._slerp;
  				mixFunctionAdditive = this._slerpAdditive;
  				setIdentity = this._setAdditiveIdentityQuaternion;

  				this.buffer = new Float64Array( valueSize * 6 );
  				this._workIndex = 5;
  				break;

  			case 'string':
  			case 'bool':
  				mixFunction = this._select;

  				// Use the regular mix function and for additive on these types,
  				// additive is not relevant for non-numeric types
  				mixFunctionAdditive = this._select;

  				setIdentity = this._setAdditiveIdentityOther;

  				this.buffer = new Array( valueSize * 5 );
  				break;

  			default:
  				mixFunction = this._lerp;
  				mixFunctionAdditive = this._lerpAdditive;
  				setIdentity = this._setAdditiveIdentityNumeric;

  				this.buffer = new Float64Array( valueSize * 5 );

  		}

  		this._mixBufferRegion = mixFunction;
  		this._mixBufferRegionAdditive = mixFunctionAdditive;
  		this._setIdentity = setIdentity;
  		this._origIndex = 3;
  		this._addIndex = 4;

  		this.cumulativeWeight = 0;
  		this.cumulativeWeightAdditive = 0;

  		this.useCount = 0;
  		this.referenceCount = 0;

  	}

  	// accumulate data in the 'incoming' region into 'accu<i>'
  	accumulate( accuIndex, weight ) {

  		// note: happily accumulating nothing when weight = 0, the caller knows
  		// the weight and shouldn't have made the call in the first place

  		const buffer = this.buffer,
  			stride = this.valueSize,
  			offset = accuIndex * stride + stride;

  		let currentWeight = this.cumulativeWeight;

  		if ( currentWeight === 0 ) {

  			// accuN := incoming * weight

  			for ( let i = 0; i !== stride; ++ i ) {

  				buffer[ offset + i ] = buffer[ i ];

  			}

  			currentWeight = weight;

  		} else {

  			// accuN := accuN + incoming * weight

  			currentWeight += weight;
  			const mix = weight / currentWeight;
  			this._mixBufferRegion( buffer, offset, 0, mix, stride );

  		}

  		this.cumulativeWeight = currentWeight;

  	}

  	// accumulate data in the 'incoming' region into 'add'
  	accumulateAdditive( weight ) {

  		const buffer = this.buffer,
  			stride = this.valueSize,
  			offset = stride * this._addIndex;

  		if ( this.cumulativeWeightAdditive === 0 ) {

  			// add = identity

  			this._setIdentity();

  		}

  		// add := add + incoming * weight

  		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
  		this.cumulativeWeightAdditive += weight;

  	}

  	// apply the state of 'accu<i>' to the binding when accus differ
  	apply( accuIndex ) {

  		const stride = this.valueSize,
  			buffer = this.buffer,
  			offset = accuIndex * stride + stride,

  			weight = this.cumulativeWeight,
  			weightAdditive = this.cumulativeWeightAdditive,

  			binding = this.binding;

  		this.cumulativeWeight = 0;
  		this.cumulativeWeightAdditive = 0;

  		if ( weight < 1 ) {

  			// accuN := accuN + original * ( 1 - cumulativeWeight )

  			const originalValueOffset = stride * this._origIndex;

  			this._mixBufferRegion(
  				buffer, offset, originalValueOffset, 1 - weight, stride );

  		}

  		if ( weightAdditive > 0 ) {

  			// accuN := accuN + additive accuN

  			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

  		}

  		for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

  			if ( buffer[ i ] !== buffer[ i + stride ] ) {

  				// value has changed -> update scene graph

  				binding.setValue( buffer, offset );
  				break;

  			}

  		}

  	}

  	// remember the state of the bound property and copy it to both accus
  	saveOriginalState() {

  		const binding = this.binding;

  		const buffer = this.buffer,
  			stride = this.valueSize,

  			originalValueOffset = stride * this._origIndex;

  		binding.getValue( buffer, originalValueOffset );

  		// accu[0..1] := orig -- initially detect changes against the original
  		for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

  			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

  		}

  		// Add to identity for additive
  		this._setIdentity();

  		this.cumulativeWeight = 0;
  		this.cumulativeWeightAdditive = 0;

  	}

  	// apply the state previously taken via 'saveOriginalState' to the binding
  	restoreOriginalState() {

  		const originalValueOffset = this.valueSize * 3;
  		this.binding.setValue( this.buffer, originalValueOffset );

  	}

  	_setAdditiveIdentityNumeric() {

  		const startIndex = this._addIndex * this.valueSize;
  		const endIndex = startIndex + this.valueSize;

  		for ( let i = startIndex; i < endIndex; i ++ ) {

  			this.buffer[ i ] = 0;

  		}

  	}

  	_setAdditiveIdentityQuaternion() {

  		this._setAdditiveIdentityNumeric();
  		this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

  	}

  	_setAdditiveIdentityOther() {

  		const startIndex = this._origIndex * this.valueSize;
  		const targetIndex = this._addIndex * this.valueSize;

  		for ( let i = 0; i < this.valueSize; i ++ ) {

  			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

  		}

  	}


  	// mix functions

  	_select( buffer, dstOffset, srcOffset, t, stride ) {

  		if ( t >= 0.5 ) {

  			for ( let i = 0; i !== stride; ++ i ) {

  				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

  			}

  		}

  	}

  	_slerp( buffer, dstOffset, srcOffset, t ) {

  		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

  	}

  	_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

  		const workOffset = this._workIndex * stride;

  		// Store result in intermediate buffer offset
  		Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

  		// Slerp to the intermediate result
  		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

  	}

  	_lerp( buffer, dstOffset, srcOffset, t, stride ) {

  		const s = 1 - t;

  		for ( let i = 0; i !== stride; ++ i ) {

  			const j = dstOffset + i;

  			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

  		}

  	}

  	_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

  		for ( let i = 0; i !== stride; ++ i ) {

  			const j = dstOffset + i;

  			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

  		}

  	}

  }

  // Characters [].:/ are reserved for track binding syntax.
  const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
  const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

  // Attempts to allow node names from any language. ES5's `\w` regexp matches
  // only latin characters, and the unicode \p{L} is not yet supported. So
  // instead, we exclude reserved characters and match everything else.
  const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
  const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

  // Parent directories, delimited by '/' or ':'. Currently unused, but must
  // be matched to parse the rest of the track name.
  const _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

  // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  const _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

  // Object on target node, and accessor. May not contain reserved
  // characters. Accessor may contain any character except closing bracket.
  const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

  // Property and accessor. May not contain reserved characters. Accessor may
  // contain any non-bracket characters.
  const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

  const _trackRe = new RegExp( ''
  	+ '^'
  	+ _directoryRe
  	+ _nodeRe
  	+ _objectRe
  	+ _propertyRe
  	+ '$'
  );

  const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

  class Composite {

  	constructor( targetGroup, path, optionalParsedPath ) {

  		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

  		this._targetGroup = targetGroup;
  		this._bindings = targetGroup.subscribe_( path, parsedPath );

  	}

  	getValue( array, offset ) {

  		this.bind(); // bind all binding

  		const firstValidIndex = this._targetGroup.nCachedObjects_,
  			binding = this._bindings[ firstValidIndex ];

  		// and only call .getValue on the first
  		if ( binding !== undefined ) binding.getValue( array, offset );

  	}

  	setValue( array, offset ) {

  		const bindings = this._bindings;

  		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].setValue( array, offset );

  		}

  	}

  	bind() {

  		const bindings = this._bindings;

  		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].bind();

  		}

  	}

  	unbind() {

  		const bindings = this._bindings;

  		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].unbind();

  		}

  	}

  }

  // Note: This class uses a State pattern on a per-method basis:
  // 'bind' sets 'this.getValue' / 'setValue' and shadows the
  // prototype version of these methods with one that represents
  // the bound state. When the property is not found, the methods
  // become no-ops.
  class PropertyBinding {

  	constructor( rootNode, path, parsedPath ) {

  		this.path = path;
  		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

  		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

  		this.rootNode = rootNode;

  		// initial state of these methods that calls 'bind'
  		this.getValue = this._getValue_unbound;
  		this.setValue = this._setValue_unbound;

  	}


  	static create( root, path, parsedPath ) {

  		if ( ! ( root && root.isAnimationObjectGroup ) ) {

  			return new PropertyBinding( root, path, parsedPath );

  		} else {

  			return new PropertyBinding.Composite( root, path, parsedPath );

  		}

  	}

  	/**
  	 * Replaces spaces with underscores and removes unsupported characters from
  	 * node names, to ensure compatibility with parseTrackName().
  	 *
  	 * @param {string} name Node name to be sanitized.
  	 * @return {string}
  	 */
  	static sanitizeNodeName( name ) {

  		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

  	}

  	static parseTrackName( trackName ) {

  		const matches = _trackRe.exec( trackName );

  		if ( ! matches ) {

  			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

  		}

  		const results = {
  			// directoryName: matches[ 1 ], // (tschw) currently unused
  			nodeName: matches[ 2 ],
  			objectName: matches[ 3 ],
  			objectIndex: matches[ 4 ],
  			propertyName: matches[ 5 ], // required
  			propertyIndex: matches[ 6 ]
  		};

  		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

  		if ( lastDot !== undefined && lastDot !== - 1 ) {

  			const objectName = results.nodeName.substring( lastDot + 1 );

  			// Object names must be checked against an allowlist. Otherwise, there
  			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
  			// 'bar' could be the objectName, or part of a nodeName (which can
  			// include '.' characters).
  			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

  				results.nodeName = results.nodeName.substring( 0, lastDot );
  				results.objectName = objectName;

  			}

  		}

  		if ( results.propertyName === null || results.propertyName.length === 0 ) {

  			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

  		}

  		return results;

  	}

  	static findNode( root, nodeName ) {

  		if ( ! nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

  			return root;

  		}

  		// search into skeleton bones.
  		if ( root.skeleton ) {

  			const bone = root.skeleton.getBoneByName( nodeName );

  			if ( bone !== undefined ) {

  				return bone;

  			}

  		}

  		// search into node subtree.
  		if ( root.children ) {

  			const searchNodeSubtree = function ( children ) {

  				for ( let i = 0; i < children.length; i ++ ) {

  					const childNode = children[ i ];

  					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

  						return childNode;

  					}

  					const result = searchNodeSubtree( childNode.children );

  					if ( result ) return result;

  				}

  				return null;

  			};

  			const subTreeNode = searchNodeSubtree( root.children );

  			if ( subTreeNode ) {

  				return subTreeNode;

  			}

  		}

  		return null;

  	}

  	// these are used to "bind" a nonexistent property
  	_getValue_unavailable() {}
  	_setValue_unavailable() {}

  	// Getters

  	_getValue_direct( buffer, offset ) {

  		buffer[ offset ] = this.node[ this.propertyName ];

  	}

  	_getValue_array( buffer, offset ) {

  		const source = this.resolvedProperty;

  		for ( let i = 0, n = source.length; i !== n; ++ i ) {

  			buffer[ offset ++ ] = source[ i ];

  		}

  	}

  	_getValue_arrayElement( buffer, offset ) {

  		buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

  	}

  	_getValue_toArray( buffer, offset ) {

  		this.resolvedProperty.toArray( buffer, offset );

  	}

  	// Direct

  	_setValue_direct( buffer, offset ) {

  		this.targetObject[ this.propertyName ] = buffer[ offset ];

  	}

  	_setValue_direct_setNeedsUpdate( buffer, offset ) {

  		this.targetObject[ this.propertyName ] = buffer[ offset ];
  		this.targetObject.needsUpdate = true;

  	}

  	_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

  		this.targetObject[ this.propertyName ] = buffer[ offset ];
  		this.targetObject.matrixWorldNeedsUpdate = true;

  	}

  	// EntireArray

  	_setValue_array( buffer, offset ) {

  		const dest = this.resolvedProperty;

  		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

  			dest[ i ] = buffer[ offset ++ ];

  		}

  	}

  	_setValue_array_setNeedsUpdate( buffer, offset ) {

  		const dest = this.resolvedProperty;

  		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

  			dest[ i ] = buffer[ offset ++ ];

  		}

  		this.targetObject.needsUpdate = true;

  	}

  	_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

  		const dest = this.resolvedProperty;

  		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

  			dest[ i ] = buffer[ offset ++ ];

  		}

  		this.targetObject.matrixWorldNeedsUpdate = true;

  	}

  	// ArrayElement

  	_setValue_arrayElement( buffer, offset ) {

  		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

  	}

  	_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

  		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  		this.targetObject.needsUpdate = true;

  	}

  	_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

  		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  		this.targetObject.matrixWorldNeedsUpdate = true;

  	}

  	// HasToFromArray

  	_setValue_fromArray( buffer, offset ) {

  		this.resolvedProperty.fromArray( buffer, offset );

  	}

  	_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

  		this.resolvedProperty.fromArray( buffer, offset );
  		this.targetObject.needsUpdate = true;

  	}

  	_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

  		this.resolvedProperty.fromArray( buffer, offset );
  		this.targetObject.matrixWorldNeedsUpdate = true;

  	}

  	_getValue_unbound( targetArray, offset ) {

  		this.bind();
  		this.getValue( targetArray, offset );

  	}

  	_setValue_unbound( sourceArray, offset ) {

  		this.bind();
  		this.setValue( sourceArray, offset );

  	}

  	// create getter / setter pair for a property in the scene graph
  	bind() {

  		let targetObject = this.node;
  		const parsedPath = this.parsedPath;

  		const objectName = parsedPath.objectName;
  		const propertyName = parsedPath.propertyName;
  		let propertyIndex = parsedPath.propertyIndex;

  		if ( ! targetObject ) {

  			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

  			this.node = targetObject;

  		}

  		// set fail state so we can just 'return' on error
  		this.getValue = this._getValue_unavailable;
  		this.setValue = this._setValue_unavailable;

  		// ensure there is a value node
  		if ( ! targetObject ) {

  			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
  			return;

  		}

  		if ( objectName ) {

  			let objectIndex = parsedPath.objectIndex;

  			// special cases were we need to reach deeper into the hierarchy to get the face materials....
  			switch ( objectName ) {

  				case 'materials':

  					if ( ! targetObject.material ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
  						return;

  					}

  					if ( ! targetObject.material.materials ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
  						return;

  					}

  					targetObject = targetObject.material.materials;

  					break;

  				case 'bones':

  					if ( ! targetObject.skeleton ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
  						return;

  					}

  					// potential future optimization: skip this if propertyIndex is already an integer
  					// and convert the integer string to a true integer.

  					targetObject = targetObject.skeleton.bones;

  					// support resolving morphTarget names into indices.
  					for ( let i = 0; i < targetObject.length; i ++ ) {

  						if ( targetObject[ i ].name === objectIndex ) {

  							objectIndex = i;
  							break;

  						}

  					}

  					break;

  				default:

  					if ( targetObject[ objectName ] === undefined ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
  						return;

  					}

  					targetObject = targetObject[ objectName ];

  			}


  			if ( objectIndex !== undefined ) {

  				if ( targetObject[ objectIndex ] === undefined ) {

  					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
  					return;

  				}

  				targetObject = targetObject[ objectIndex ];

  			}

  		}

  		// resolve property
  		const nodeProperty = targetObject[ propertyName ];

  		if ( nodeProperty === undefined ) {

  			const nodeName = parsedPath.nodeName;

  			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
  				'.' + propertyName + ' but it wasn\'t found.', targetObject );
  			return;

  		}

  		// determine versioning scheme
  		let versioning = this.Versioning.None;

  		this.targetObject = targetObject;

  		if ( targetObject.needsUpdate !== undefined ) { // material

  			versioning = this.Versioning.NeedsUpdate;

  		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

  			versioning = this.Versioning.MatrixWorldNeedsUpdate;

  		}

  		// determine how the property gets bound
  		let bindingType = this.BindingType.Direct;

  		if ( propertyIndex !== undefined ) {

  			// access a sub element of the property array (only primitives are supported right now)

  			if ( propertyName === 'morphTargetInfluences' ) {

  				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

  				// support resolving morphTarget names into indices.
  				if ( ! targetObject.geometry ) {

  					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
  					return;

  				}

  				if ( targetObject.geometry.isBufferGeometry ) {

  					if ( ! targetObject.geometry.morphAttributes ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
  						return;

  					}

  					if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

  						propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

  					}


  				} else {

  					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
  					return;

  				}

  			}

  			bindingType = this.BindingType.ArrayElement;

  			this.resolvedProperty = nodeProperty;
  			this.propertyIndex = propertyIndex;

  		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

  			// must use copy for Object3D.Euler/Quaternion

  			bindingType = this.BindingType.HasFromToArray;

  			this.resolvedProperty = nodeProperty;

  		} else if ( Array.isArray( nodeProperty ) ) {

  			bindingType = this.BindingType.EntireArray;

  			this.resolvedProperty = nodeProperty;

  		} else {

  			this.propertyName = propertyName;

  		}

  		// select getter / setter
  		this.getValue = this.GetterByBindingType[ bindingType ];
  		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

  	}

  	unbind() {

  		this.node = null;

  		// back to the prototype version of getValue / setValue
  		// note: avoiding to mutate the shape of 'this' via 'delete'
  		this.getValue = this._getValue_unbound;
  		this.setValue = this._setValue_unbound;

  	}

  }

  PropertyBinding.Composite = Composite;

  PropertyBinding.prototype.BindingType = {
  	Direct: 0,
  	EntireArray: 1,
  	ArrayElement: 2,
  	HasFromToArray: 3
  };

  PropertyBinding.prototype.Versioning = {
  	None: 0,
  	NeedsUpdate: 1,
  	MatrixWorldNeedsUpdate: 2
  };

  PropertyBinding.prototype.GetterByBindingType = [

  	PropertyBinding.prototype._getValue_direct,
  	PropertyBinding.prototype._getValue_array,
  	PropertyBinding.prototype._getValue_arrayElement,
  	PropertyBinding.prototype._getValue_toArray,

  ];

  PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

  	[
  		// Direct
  		PropertyBinding.prototype._setValue_direct,
  		PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
  		PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

  	], [

  		// EntireArray

  		PropertyBinding.prototype._setValue_array,
  		PropertyBinding.prototype._setValue_array_setNeedsUpdate,
  		PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

  	], [

  		// ArrayElement
  		PropertyBinding.prototype._setValue_arrayElement,
  		PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
  		PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

  	], [

  		// HasToFromArray
  		PropertyBinding.prototype._setValue_fromArray,
  		PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
  		PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

  	]

  ];

  /**
   *
   * A group of objects that receives a shared animation state.
   *
   * Usage:
   *
   *  - Add objects you would otherwise pass as 'root' to the
   *    constructor or the .clipAction method of AnimationMixer.
   *
   *  - Instead pass this object as 'root'.
   *
   *  - You can also add and remove objects later when the mixer
   *    is running.
   *
   * Note:
   *
   *    Objects of this class appear as one object to the mixer,
   *    so cache control of the individual objects must be done
   *    on the group.
   *
   * Limitation:
   *
   *  - The animated properties must be compatible among the
   *    all objects in the group.
   *
   *  - A single property can either be controlled through a
   *    target group or directly, but not both.
   */

  class AnimationObjectGroup {

  	constructor() {

  		this.uuid = generateUUID();

  		// cached objects followed by the active ones
  		this._objects = Array.prototype.slice.call( arguments );

  		this.nCachedObjects_ = 0; // threshold
  		// note: read by PropertyBinding.Composite

  		const indices = {};
  		this._indicesByUUID = indices; // for bookkeeping

  		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

  			indices[ arguments[ i ].uuid ] = i;

  		}

  		this._paths = []; // inside: string
  		this._parsedPaths = []; // inside: { we don't care, here }
  		this._bindings = []; // inside: Array< PropertyBinding >
  		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

  		const scope = this;

  		this.stats = {

  			objects: {
  				get total() {

  					return scope._objects.length;

  				},
  				get inUse() {

  					return this.total - scope.nCachedObjects_;

  				}
  			},
  			get bindingsPerObject() {

  				return scope._bindings.length;

  			}

  		};

  	}

  	add() {

  		const objects = this._objects,
  			indicesByUUID = this._indicesByUUID,
  			paths = this._paths,
  			parsedPaths = this._parsedPaths,
  			bindings = this._bindings,
  			nBindings = bindings.length;

  		let knownObject = undefined,
  			nObjects = objects.length,
  			nCachedObjects = this.nCachedObjects_;

  		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

  			const object = arguments[ i ],
  				uuid = object.uuid;
  			let index = indicesByUUID[ uuid ];

  			if ( index === undefined ) {

  				// unknown object -> add it to the ACTIVE region

  				index = nObjects ++;
  				indicesByUUID[ uuid ] = index;
  				objects.push( object );

  				// accounting is done, now do the same for all bindings

  				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

  					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

  				}

  			} else if ( index < nCachedObjects ) {

  				knownObject = objects[ index ];

  				// move existing object to the ACTIVE region

  				const firstActiveIndex = -- nCachedObjects,
  					lastCachedObject = objects[ firstActiveIndex ];

  				indicesByUUID[ lastCachedObject.uuid ] = index;
  				objects[ index ] = lastCachedObject;

  				indicesByUUID[ uuid ] = firstActiveIndex;
  				objects[ firstActiveIndex ] = object;

  				// accounting is done, now do the same for all bindings

  				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

  					const bindingsForPath = bindings[ j ],
  						lastCached = bindingsForPath[ firstActiveIndex ];

  					let binding = bindingsForPath[ index ];

  					bindingsForPath[ index ] = lastCached;

  					if ( binding === undefined ) {

  						// since we do not bother to create new bindings
  						// for objects that are cached, the binding may
  						// or may not exist

  						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

  					}

  					bindingsForPath[ firstActiveIndex ] = binding;

  				}

  			} else if ( objects[ index ] !== knownObject ) {

  				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
  					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

  			} // else the object is already where we want it to be

  		} // for arguments

  		this.nCachedObjects_ = nCachedObjects;

  	}

  	remove() {

  		const objects = this._objects,
  			indicesByUUID = this._indicesByUUID,
  			bindings = this._bindings,
  			nBindings = bindings.length;

  		let nCachedObjects = this.nCachedObjects_;

  		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

  			const object = arguments[ i ],
  				uuid = object.uuid,
  				index = indicesByUUID[ uuid ];

  			if ( index !== undefined && index >= nCachedObjects ) {

  				// move existing object into the CACHED region

  				const lastCachedIndex = nCachedObjects ++,
  					firstActiveObject = objects[ lastCachedIndex ];

  				indicesByUUID[ firstActiveObject.uuid ] = index;
  				objects[ index ] = firstActiveObject;

  				indicesByUUID[ uuid ] = lastCachedIndex;
  				objects[ lastCachedIndex ] = object;

  				// accounting is done, now do the same for all bindings

  				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

  					const bindingsForPath = bindings[ j ],
  						firstActive = bindingsForPath[ lastCachedIndex ],
  						binding = bindingsForPath[ index ];

  					bindingsForPath[ index ] = firstActive;
  					bindingsForPath[ lastCachedIndex ] = binding;

  				}

  			}

  		} // for arguments

  		this.nCachedObjects_ = nCachedObjects;

  	}

  	// remove & forget
  	uncache() {

  		const objects = this._objects,
  			indicesByUUID = this._indicesByUUID,
  			bindings = this._bindings,
  			nBindings = bindings.length;

  		let nCachedObjects = this.nCachedObjects_,
  			nObjects = objects.length;

  		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

  			const object = arguments[ i ],
  				uuid = object.uuid,
  				index = indicesByUUID[ uuid ];

  			if ( index !== undefined ) {

  				delete indicesByUUID[ uuid ];

  				if ( index < nCachedObjects ) {

  					// object is cached, shrink the CACHED region

  					const firstActiveIndex = -- nCachedObjects,
  						lastCachedObject = objects[ firstActiveIndex ],
  						lastIndex = -- nObjects,
  						lastObject = objects[ lastIndex ];

  					// last cached object takes this object's place
  					indicesByUUID[ lastCachedObject.uuid ] = index;
  					objects[ index ] = lastCachedObject;

  					// last object goes to the activated slot and pop
  					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
  					objects[ firstActiveIndex ] = lastObject;
  					objects.pop();

  					// accounting is done, now do the same for all bindings

  					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

  						const bindingsForPath = bindings[ j ],
  							lastCached = bindingsForPath[ firstActiveIndex ],
  							last = bindingsForPath[ lastIndex ];

  						bindingsForPath[ index ] = lastCached;
  						bindingsForPath[ firstActiveIndex ] = last;
  						bindingsForPath.pop();

  					}

  				} else {

  					// object is active, just swap with the last and pop

  					const lastIndex = -- nObjects,
  						lastObject = objects[ lastIndex ];

  					if ( lastIndex > 0 ) {

  						indicesByUUID[ lastObject.uuid ] = index;

  					}

  					objects[ index ] = lastObject;
  					objects.pop();

  					// accounting is done, now do the same for all bindings

  					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

  						const bindingsForPath = bindings[ j ];

  						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
  						bindingsForPath.pop();

  					}

  				} // cached or active

  			} // if object is known

  		} // for arguments

  		this.nCachedObjects_ = nCachedObjects;

  	}

  	// Internal interface used by befriended PropertyBinding.Composite:

  	subscribe_( path, parsedPath ) {

  		// returns an array of bindings for the given path that is changed
  		// according to the contained objects in the group

  		const indicesByPath = this._bindingsIndicesByPath;
  		let index = indicesByPath[ path ];
  		const bindings = this._bindings;

  		if ( index !== undefined ) return bindings[ index ];

  		const paths = this._paths,
  			parsedPaths = this._parsedPaths,
  			objects = this._objects,
  			nObjects = objects.length,
  			nCachedObjects = this.nCachedObjects_,
  			bindingsForPath = new Array( nObjects );

  		index = bindings.length;

  		indicesByPath[ path ] = index;

  		paths.push( path );
  		parsedPaths.push( parsedPath );
  		bindings.push( bindingsForPath );

  		for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

  			const object = objects[ i ];
  			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

  		}

  		return bindingsForPath;

  	}

  	unsubscribe_( path ) {

  		// tells the group to forget about a property path and no longer
  		// update the array previously obtained with 'subscribe_'

  		const indicesByPath = this._bindingsIndicesByPath,
  			index = indicesByPath[ path ];

  		if ( index !== undefined ) {

  			const paths = this._paths,
  				parsedPaths = this._parsedPaths,
  				bindings = this._bindings,
  				lastBindingsIndex = bindings.length - 1,
  				lastBindings = bindings[ lastBindingsIndex ],
  				lastBindingsPath = path[ lastBindingsIndex ];

  			indicesByPath[ lastBindingsPath ] = index;

  			bindings[ index ] = lastBindings;
  			bindings.pop();

  			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
  			parsedPaths.pop();

  			paths[ index ] = paths[ lastBindingsIndex ];
  			paths.pop();

  		}

  	}

  }

  AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

  class AnimationAction {

  	constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

  		this._mixer = mixer;
  		this._clip = clip;
  		this._localRoot = localRoot;
  		this.blendMode = blendMode;

  		const tracks = clip.tracks,
  			nTracks = tracks.length,
  			interpolants = new Array( nTracks );

  		const interpolantSettings = {
  			endingStart: ZeroCurvatureEnding,
  			endingEnd: ZeroCurvatureEnding
  		};

  		for ( let i = 0; i !== nTracks; ++ i ) {

  			const interpolant = tracks[ i ].createInterpolant( null );
  			interpolants[ i ] = interpolant;
  			interpolant.settings = interpolantSettings;

  		}

  		this._interpolantSettings = interpolantSettings;

  		this._interpolants = interpolants; // bound by the mixer

  		// inside: PropertyMixer (managed by the mixer)
  		this._propertyBindings = new Array( nTracks );

  		this._cacheIndex = null; // for the memory manager
  		this._byClipCacheIndex = null; // for the memory manager

  		this._timeScaleInterpolant = null;
  		this._weightInterpolant = null;

  		this.loop = LoopRepeat;
  		this._loopCount = - 1;

  		// global mixer time when the action is to be started
  		// it's set back to 'null' upon start of the action
  		this._startTime = null;

  		// scaled local time of the action
  		// gets clamped or wrapped to 0..clip.duration according to loop
  		this.time = 0;

  		this.timeScale = 1;
  		this._effectiveTimeScale = 1;

  		this.weight = 1;
  		this._effectiveWeight = 1;

  		this.repetitions = Infinity; // no. of repetitions when looping

  		this.paused = false; // true -> zero effective time scale
  		this.enabled = true; // false -> zero effective weight

  		this.clampWhenFinished = false;// keep feeding the last frame?

  		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
  		this.zeroSlopeAtEnd = true;// clips for start, loop and end

  	}

  	// State & Scheduling

  	play() {

  		this._mixer._activateAction( this );

  		return this;

  	}

  	stop() {

  		this._mixer._deactivateAction( this );

  		return this.reset();

  	}

  	reset() {

  		this.paused = false;
  		this.enabled = true;

  		this.time = 0; // restart clip
  		this._loopCount = - 1;// forget previous loops
  		this._startTime = null;// forget scheduling

  		return this.stopFading().stopWarping();

  	}

  	isRunning() {

  		return this.enabled && ! this.paused && this.timeScale !== 0 &&
  			this._startTime === null && this._mixer._isActiveAction( this );

  	}

  	// return true when play has been called
  	isScheduled() {

  		return this._mixer._isActiveAction( this );

  	}

  	startAt( time ) {

  		this._startTime = time;

  		return this;

  	}

  	setLoop( mode, repetitions ) {

  		this.loop = mode;
  		this.repetitions = repetitions;

  		return this;

  	}

  	// Weight

  	// set the weight stopping any scheduled fading
  	// although .enabled = false yields an effective weight of zero, this
  	// method does *not* change .enabled, because it would be confusing
  	setEffectiveWeight( weight ) {

  		this.weight = weight;

  		// note: same logic as when updated at runtime
  		this._effectiveWeight = this.enabled ? weight : 0;

  		return this.stopFading();

  	}

  	// return the weight considering fading and .enabled
  	getEffectiveWeight() {

  		return this._effectiveWeight;

  	}

  	fadeIn( duration ) {

  		return this._scheduleFading( duration, 0, 1 );

  	}

  	fadeOut( duration ) {

  		return this._scheduleFading( duration, 1, 0 );

  	}

  	crossFadeFrom( fadeOutAction, duration, warp ) {

  		fadeOutAction.fadeOut( duration );
  		this.fadeIn( duration );

  		if ( warp ) {

  			const fadeInDuration = this._clip.duration,
  				fadeOutDuration = fadeOutAction._clip.duration,

  				startEndRatio = fadeOutDuration / fadeInDuration,
  				endStartRatio = fadeInDuration / fadeOutDuration;

  			fadeOutAction.warp( 1.0, startEndRatio, duration );
  			this.warp( endStartRatio, 1.0, duration );

  		}

  		return this;

  	}

  	crossFadeTo( fadeInAction, duration, warp ) {

  		return fadeInAction.crossFadeFrom( this, duration, warp );

  	}

  	stopFading() {

  		const weightInterpolant = this._weightInterpolant;

  		if ( weightInterpolant !== null ) {

  			this._weightInterpolant = null;
  			this._mixer._takeBackControlInterpolant( weightInterpolant );

  		}

  		return this;

  	}

  	// Time Scale Control

  	// set the time scale stopping any scheduled warping
  	// although .paused = true yields an effective time scale of zero, this
  	// method does *not* change .paused, because it would be confusing
  	setEffectiveTimeScale( timeScale ) {

  		this.timeScale = timeScale;
  		this._effectiveTimeScale = this.paused ? 0 : timeScale;

  		return this.stopWarping();

  	}

  	// return the time scale considering warping and .paused
  	getEffectiveTimeScale() {

  		return this._effectiveTimeScale;

  	}

  	setDuration( duration ) {

  		this.timeScale = this._clip.duration / duration;

  		return this.stopWarping();

  	}

  	syncWith( action ) {

  		this.time = action.time;
  		this.timeScale = action.timeScale;

  		return this.stopWarping();

  	}

  	halt( duration ) {

  		return this.warp( this._effectiveTimeScale, 0, duration );

  	}

  	warp( startTimeScale, endTimeScale, duration ) {

  		const mixer = this._mixer,
  			now = mixer.time,
  			timeScale = this.timeScale;

  		let interpolant = this._timeScaleInterpolant;

  		if ( interpolant === null ) {

  			interpolant = mixer._lendControlInterpolant();
  			this._timeScaleInterpolant = interpolant;

  		}

  		const times = interpolant.parameterPositions,
  			values = interpolant.sampleValues;

  		times[ 0 ] = now;
  		times[ 1 ] = now + duration;

  		values[ 0 ] = startTimeScale / timeScale;
  		values[ 1 ] = endTimeScale / timeScale;

  		return this;

  	}

  	stopWarping() {

  		const timeScaleInterpolant = this._timeScaleInterpolant;

  		if ( timeScaleInterpolant !== null ) {

  			this._timeScaleInterpolant = null;
  			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

  		}

  		return this;

  	}

  	// Object Accessors

  	getMixer() {

  		return this._mixer;

  	}

  	getClip() {

  		return this._clip;

  	}

  	getRoot() {

  		return this._localRoot || this._mixer._root;

  	}

  	// Interna

  	_update( time, deltaTime, timeDirection, accuIndex ) {

  		// called by the mixer

  		if ( ! this.enabled ) {

  			// call ._updateWeight() to update ._effectiveWeight

  			this._updateWeight( time );
  			return;

  		}

  		const startTime = this._startTime;

  		if ( startTime !== null ) {

  			// check for scheduled start of action

  			const timeRunning = ( time - startTime ) * timeDirection;
  			if ( timeRunning < 0 || timeDirection === 0 ) {

  				return; // yet to come / don't decide when delta = 0

  			}

  			// start

  			this._startTime = null; // unschedule
  			deltaTime = timeDirection * timeRunning;

  		}

  		// apply time scale and advance time

  		deltaTime *= this._updateTimeScale( time );
  		const clipTime = this._updateTime( deltaTime );

  		// note: _updateTime may disable the action resulting in
  		// an effective weight of 0

  		const weight = this._updateWeight( time );

  		if ( weight > 0 ) {

  			const interpolants = this._interpolants;
  			const propertyMixers = this._propertyBindings;

  			switch ( this.blendMode ) {

  				case AdditiveAnimationBlendMode:

  					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

  						interpolants[ j ].evaluate( clipTime );
  						propertyMixers[ j ].accumulateAdditive( weight );

  					}

  					break;

  				case NormalAnimationBlendMode:
  				default:

  					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

  						interpolants[ j ].evaluate( clipTime );
  						propertyMixers[ j ].accumulate( accuIndex, weight );

  					}

  			}

  		}

  	}

  	_updateWeight( time ) {

  		let weight = 0;

  		if ( this.enabled ) {

  			weight = this.weight;
  			const interpolant = this._weightInterpolant;

  			if ( interpolant !== null ) {

  				const interpolantValue = interpolant.evaluate( time )[ 0 ];

  				weight *= interpolantValue;

  				if ( time > interpolant.parameterPositions[ 1 ] ) {

  					this.stopFading();

  					if ( interpolantValue === 0 ) {

  						// faded out, disable
  						this.enabled = false;

  					}

  				}

  			}

  		}

  		this._effectiveWeight = weight;
  		return weight;

  	}

  	_updateTimeScale( time ) {

  		let timeScale = 0;

  		if ( ! this.paused ) {

  			timeScale = this.timeScale;

  			const interpolant = this._timeScaleInterpolant;

  			if ( interpolant !== null ) {

  				const interpolantValue = interpolant.evaluate( time )[ 0 ];

  				timeScale *= interpolantValue;

  				if ( time > interpolant.parameterPositions[ 1 ] ) {

  					this.stopWarping();

  					if ( timeScale === 0 ) {

  						// motion has halted, pause
  						this.paused = true;

  					} else {

  						// warp done - apply final time scale
  						this.timeScale = timeScale;

  					}

  				}

  			}

  		}

  		this._effectiveTimeScale = timeScale;
  		return timeScale;

  	}

  	_updateTime( deltaTime ) {

  		const duration = this._clip.duration;
  		const loop = this.loop;

  		let time = this.time + deltaTime;
  		let loopCount = this._loopCount;

  		const pingPong = ( loop === LoopPingPong );

  		if ( deltaTime === 0 ) {

  			if ( loopCount === - 1 ) return time;

  			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

  		}

  		if ( loop === LoopOnce ) {

  			if ( loopCount === - 1 ) {

  				// just started

  				this._loopCount = 0;
  				this._setEndings( true, true, false );

  			}

  			handle_stop: {

  				if ( time >= duration ) {

  					time = duration;

  				} else if ( time < 0 ) {

  					time = 0;

  				} else {

  					this.time = time;

  					break handle_stop;

  				}

  				if ( this.clampWhenFinished ) this.paused = true;
  				else this.enabled = false;

  				this.time = time;

  				this._mixer.dispatchEvent( {
  					type: 'finished', action: this,
  					direction: deltaTime < 0 ? - 1 : 1
  				} );

  			}

  		} else { // repetitive Repeat or PingPong

  			if ( loopCount === - 1 ) {

  				// just started

  				if ( deltaTime >= 0 ) {

  					loopCount = 0;

  					this._setEndings( true, this.repetitions === 0, pingPong );

  				} else {

  					// when looping in reverse direction, the initial
  					// transition through zero counts as a repetition,
  					// so leave loopCount at -1

  					this._setEndings( this.repetitions === 0, true, pingPong );

  				}

  			}

  			if ( time >= duration || time < 0 ) {

  				// wrap around

  				const loopDelta = Math.floor( time / duration ); // signed
  				time -= duration * loopDelta;

  				loopCount += Math.abs( loopDelta );

  				const pending = this.repetitions - loopCount;

  				if ( pending <= 0 ) {

  					// have to stop (switch state, clamp time, fire event)

  					if ( this.clampWhenFinished ) this.paused = true;
  					else this.enabled = false;

  					time = deltaTime > 0 ? duration : 0;

  					this.time = time;

  					this._mixer.dispatchEvent( {
  						type: 'finished', action: this,
  						direction: deltaTime > 0 ? 1 : - 1
  					} );

  				} else {

  					// keep running

  					if ( pending === 1 ) {

  						// entering the last round

  						const atStart = deltaTime < 0;
  						this._setEndings( atStart, ! atStart, pingPong );

  					} else {

  						this._setEndings( false, false, pingPong );

  					}

  					this._loopCount = loopCount;

  					this.time = time;

  					this._mixer.dispatchEvent( {
  						type: 'loop', action: this, loopDelta: loopDelta
  					} );

  				}

  			} else {

  				this.time = time;

  			}

  			if ( pingPong && ( loopCount & 1 ) === 1 ) {

  				// invert time for the "pong round"

  				return duration - time;

  			}

  		}

  		return time;

  	}

  	_setEndings( atStart, atEnd, pingPong ) {

  		const settings = this._interpolantSettings;

  		if ( pingPong ) {

  			settings.endingStart = ZeroSlopeEnding;
  			settings.endingEnd = ZeroSlopeEnding;

  		} else {

  			// assuming for LoopOnce atStart == atEnd == true

  			if ( atStart ) {

  				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

  			} else {

  				settings.endingStart = WrapAroundEnding;

  			}

  			if ( atEnd ) {

  				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

  			} else {

  				settings.endingEnd 	 = WrapAroundEnding;

  			}

  		}

  	}

  	_scheduleFading( duration, weightNow, weightThen ) {

  		const mixer = this._mixer, now = mixer.time;
  		let interpolant = this._weightInterpolant;

  		if ( interpolant === null ) {

  			interpolant = mixer._lendControlInterpolant();
  			this._weightInterpolant = interpolant;

  		}

  		const times = interpolant.parameterPositions,
  			values = interpolant.sampleValues;

  		times[ 0 ] = now;
  		values[ 0 ] = weightNow;
  		times[ 1 ] = now + duration;
  		values[ 1 ] = weightThen;

  		return this;

  	}

  }

  class AnimationMixer extends EventDispatcher {

  	constructor( root ) {

  		super();

  		this._root = root;
  		this._initMemoryManager();
  		this._accuIndex = 0;
  		this.time = 0;
  		this.timeScale = 1.0;

  	}

  	_bindAction( action, prototypeAction ) {

  		const root = action._localRoot || this._root,
  			tracks = action._clip.tracks,
  			nTracks = tracks.length,
  			bindings = action._propertyBindings,
  			interpolants = action._interpolants,
  			rootUuid = root.uuid,
  			bindingsByRoot = this._bindingsByRootAndName;

  		let bindingsByName = bindingsByRoot[ rootUuid ];

  		if ( bindingsByName === undefined ) {

  			bindingsByName = {};
  			bindingsByRoot[ rootUuid ] = bindingsByName;

  		}

  		for ( let i = 0; i !== nTracks; ++ i ) {

  			const track = tracks[ i ],
  				trackName = track.name;

  			let binding = bindingsByName[ trackName ];

  			if ( binding !== undefined ) {

  				bindings[ i ] = binding;

  			} else {

  				binding = bindings[ i ];

  				if ( binding !== undefined ) {

  					// existing binding, make sure the cache knows

  					if ( binding._cacheIndex === null ) {

  						++ binding.referenceCount;
  						this._addInactiveBinding( binding, rootUuid, trackName );

  					}

  					continue;

  				}

  				const path = prototypeAction && prototypeAction.
  					_propertyBindings[ i ].binding.parsedPath;

  				binding = new PropertyMixer(
  					PropertyBinding.create( root, trackName, path ),
  					track.ValueTypeName, track.getValueSize() );

  				++ binding.referenceCount;
  				this._addInactiveBinding( binding, rootUuid, trackName );

  				bindings[ i ] = binding;

  			}

  			interpolants[ i ].resultBuffer = binding.buffer;

  		}

  	}

  	_activateAction( action ) {

  		if ( ! this._isActiveAction( action ) ) {

  			if ( action._cacheIndex === null ) {

  				// this action has been forgotten by the cache, but the user
  				// appears to be still using it -> rebind

  				const rootUuid = ( action._localRoot || this._root ).uuid,
  					clipUuid = action._clip.uuid,
  					actionsForClip = this._actionsByClip[ clipUuid ];

  				this._bindAction( action,
  					actionsForClip && actionsForClip.knownActions[ 0 ] );

  				this._addInactiveAction( action, clipUuid, rootUuid );

  			}

  			const bindings = action._propertyBindings;

  			// increment reference counts / sort out state
  			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

  				const binding = bindings[ i ];

  				if ( binding.useCount ++ === 0 ) {

  					this._lendBinding( binding );
  					binding.saveOriginalState();

  				}

  			}

  			this._lendAction( action );

  		}

  	}

  	_deactivateAction( action ) {

  		if ( this._isActiveAction( action ) ) {

  			const bindings = action._propertyBindings;

  			// decrement reference counts / sort out state
  			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

  				const binding = bindings[ i ];

  				if ( -- binding.useCount === 0 ) {

  					binding.restoreOriginalState();
  					this._takeBackBinding( binding );

  				}

  			}

  			this._takeBackAction( action );

  		}

  	}

  	// Memory manager

  	_initMemoryManager() {

  		this._actions = []; // 'nActiveActions' followed by inactive ones
  		this._nActiveActions = 0;

  		this._actionsByClip = {};
  		// inside:
  		// {
  		// 	knownActions: Array< AnimationAction > - used as prototypes
  		// 	actionByRoot: AnimationAction - lookup
  		// }


  		this._bindings = []; // 'nActiveBindings' followed by inactive ones
  		this._nActiveBindings = 0;

  		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


  		this._controlInterpolants = []; // same game as above
  		this._nActiveControlInterpolants = 0;

  		const scope = this;

  		this.stats = {

  			actions: {
  				get total() {

  					return scope._actions.length;

  				},
  				get inUse() {

  					return scope._nActiveActions;

  				}
  			},
  			bindings: {
  				get total() {

  					return scope._bindings.length;

  				},
  				get inUse() {

  					return scope._nActiveBindings;

  				}
  			},
  			controlInterpolants: {
  				get total() {

  					return scope._controlInterpolants.length;

  				},
  				get inUse() {

  					return scope._nActiveControlInterpolants;

  				}
  			}

  		};

  	}

  	// Memory management for AnimationAction objects

  	_isActiveAction( action ) {

  		const index = action._cacheIndex;
  		return index !== null && index < this._nActiveActions;

  	}

  	_addInactiveAction( action, clipUuid, rootUuid ) {

  		const actions = this._actions,
  			actionsByClip = this._actionsByClip;

  		let actionsForClip = actionsByClip[ clipUuid ];

  		if ( actionsForClip === undefined ) {

  			actionsForClip = {

  				knownActions: [ action ],
  				actionByRoot: {}

  			};

  			action._byClipCacheIndex = 0;

  			actionsByClip[ clipUuid ] = actionsForClip;

  		} else {

  			const knownActions = actionsForClip.knownActions;

  			action._byClipCacheIndex = knownActions.length;
  			knownActions.push( action );

  		}

  		action._cacheIndex = actions.length;
  		actions.push( action );

  		actionsForClip.actionByRoot[ rootUuid ] = action;

  	}

  	_removeInactiveAction( action ) {

  		const actions = this._actions,
  			lastInactiveAction = actions[ actions.length - 1 ],
  			cacheIndex = action._cacheIndex;

  		lastInactiveAction._cacheIndex = cacheIndex;
  		actions[ cacheIndex ] = lastInactiveAction;
  		actions.pop();

  		action._cacheIndex = null;


  		const clipUuid = action._clip.uuid,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ],
  			knownActionsForClip = actionsForClip.knownActions,

  			lastKnownAction =
  				knownActionsForClip[ knownActionsForClip.length - 1 ],

  			byClipCacheIndex = action._byClipCacheIndex;

  		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
  		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
  		knownActionsForClip.pop();

  		action._byClipCacheIndex = null;


  		const actionByRoot = actionsForClip.actionByRoot,
  			rootUuid = ( action._localRoot || this._root ).uuid;

  		delete actionByRoot[ rootUuid ];

  		if ( knownActionsForClip.length === 0 ) {

  			delete actionsByClip[ clipUuid ];

  		}

  		this._removeInactiveBindingsForAction( action );

  	}

  	_removeInactiveBindingsForAction( action ) {

  		const bindings = action._propertyBindings;

  		for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

  			const binding = bindings[ i ];

  			if ( -- binding.referenceCount === 0 ) {

  				this._removeInactiveBinding( binding );

  			}

  		}

  	}

  	_lendAction( action ) {

  		// [ active actions |  inactive actions  ]
  		// [  active actions >| inactive actions ]
  		//                 s        a
  		//                  <-swap->
  		//                 a        s

  		const actions = this._actions,
  			prevIndex = action._cacheIndex,

  			lastActiveIndex = this._nActiveActions ++,

  			firstInactiveAction = actions[ lastActiveIndex ];

  		action._cacheIndex = lastActiveIndex;
  		actions[ lastActiveIndex ] = action;

  		firstInactiveAction._cacheIndex = prevIndex;
  		actions[ prevIndex ] = firstInactiveAction;

  	}

  	_takeBackAction( action ) {

  		// [  active actions  | inactive actions ]
  		// [ active actions |< inactive actions  ]
  		//        a        s
  		//         <-swap->
  		//        s        a

  		const actions = this._actions,
  			prevIndex = action._cacheIndex,

  			firstInactiveIndex = -- this._nActiveActions,

  			lastActiveAction = actions[ firstInactiveIndex ];

  		action._cacheIndex = firstInactiveIndex;
  		actions[ firstInactiveIndex ] = action;

  		lastActiveAction._cacheIndex = prevIndex;
  		actions[ prevIndex ] = lastActiveAction;

  	}

  	// Memory management for PropertyMixer objects

  	_addInactiveBinding( binding, rootUuid, trackName ) {

  		const bindingsByRoot = this._bindingsByRootAndName,
  			bindings = this._bindings;

  		let bindingByName = bindingsByRoot[ rootUuid ];

  		if ( bindingByName === undefined ) {

  			bindingByName = {};
  			bindingsByRoot[ rootUuid ] = bindingByName;

  		}

  		bindingByName[ trackName ] = binding;

  		binding._cacheIndex = bindings.length;
  		bindings.push( binding );

  	}

  	_removeInactiveBinding( binding ) {

  		const bindings = this._bindings,
  			propBinding = binding.binding,
  			rootUuid = propBinding.rootNode.uuid,
  			trackName = propBinding.path,
  			bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ],

  			lastInactiveBinding = bindings[ bindings.length - 1 ],
  			cacheIndex = binding._cacheIndex;

  		lastInactiveBinding._cacheIndex = cacheIndex;
  		bindings[ cacheIndex ] = lastInactiveBinding;
  		bindings.pop();

  		delete bindingByName[ trackName ];

  		if ( Object.keys( bindingByName ).length === 0 ) {

  			delete bindingsByRoot[ rootUuid ];

  		}

  	}

  	_lendBinding( binding ) {

  		const bindings = this._bindings,
  			prevIndex = binding._cacheIndex,

  			lastActiveIndex = this._nActiveBindings ++,

  			firstInactiveBinding = bindings[ lastActiveIndex ];

  		binding._cacheIndex = lastActiveIndex;
  		bindings[ lastActiveIndex ] = binding;

  		firstInactiveBinding._cacheIndex = prevIndex;
  		bindings[ prevIndex ] = firstInactiveBinding;

  	}

  	_takeBackBinding( binding ) {

  		const bindings = this._bindings,
  			prevIndex = binding._cacheIndex,

  			firstInactiveIndex = -- this._nActiveBindings,

  			lastActiveBinding = bindings[ firstInactiveIndex ];

  		binding._cacheIndex = firstInactiveIndex;
  		bindings[ firstInactiveIndex ] = binding;

  		lastActiveBinding._cacheIndex = prevIndex;
  		bindings[ prevIndex ] = lastActiveBinding;

  	}


  	// Memory management of Interpolants for weight and time scale

  	_lendControlInterpolant() {

  		const interpolants = this._controlInterpolants,
  			lastActiveIndex = this._nActiveControlInterpolants ++;

  		let interpolant = interpolants[ lastActiveIndex ];

  		if ( interpolant === undefined ) {

  			interpolant = new LinearInterpolant(
  				new Float32Array( 2 ), new Float32Array( 2 ),
  				1, this._controlInterpolantsResultBuffer );

  			interpolant.__cacheIndex = lastActiveIndex;
  			interpolants[ lastActiveIndex ] = interpolant;

  		}

  		return interpolant;

  	}

  	_takeBackControlInterpolant( interpolant ) {

  		const interpolants = this._controlInterpolants,
  			prevIndex = interpolant.__cacheIndex,

  			firstInactiveIndex = -- this._nActiveControlInterpolants,

  			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

  		interpolant.__cacheIndex = firstInactiveIndex;
  		interpolants[ firstInactiveIndex ] = interpolant;

  		lastActiveInterpolant.__cacheIndex = prevIndex;
  		interpolants[ prevIndex ] = lastActiveInterpolant;

  	}

  	// return an action for a clip optionally using a custom root target
  	// object (this method allocates a lot of dynamic memory in case a
  	// previously unknown clip/root combination is specified)
  	clipAction( clip, optionalRoot, blendMode ) {

  		const root = optionalRoot || this._root,
  			rootUuid = root.uuid;

  		let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

  		const clipUuid = clipObject !== null ? clipObject.uuid : clip;

  		const actionsForClip = this._actionsByClip[ clipUuid ];
  		let prototypeAction = null;

  		if ( blendMode === undefined ) {

  			if ( clipObject !== null ) {

  				blendMode = clipObject.blendMode;

  			} else {

  				blendMode = NormalAnimationBlendMode;

  			}

  		}

  		if ( actionsForClip !== undefined ) {

  			const existingAction = actionsForClip.actionByRoot[ rootUuid ];

  			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

  				return existingAction;

  			}

  			// we know the clip, so we don't have to parse all
  			// the bindings again but can just copy
  			prototypeAction = actionsForClip.knownActions[ 0 ];

  			// also, take the clip from the prototype action
  			if ( clipObject === null )
  				clipObject = prototypeAction._clip;

  		}

  		// clip must be known when specified via string
  		if ( clipObject === null ) return null;

  		// allocate all resources required to run it
  		const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

  		this._bindAction( newAction, prototypeAction );

  		// and make the action known to the memory manager
  		this._addInactiveAction( newAction, clipUuid, rootUuid );

  		return newAction;

  	}

  	// get an existing action
  	existingAction( clip, optionalRoot ) {

  		const root = optionalRoot || this._root,
  			rootUuid = root.uuid,

  			clipObject = typeof clip === 'string' ?
  				AnimationClip.findByName( root, clip ) : clip,

  			clipUuid = clipObject ? clipObject.uuid : clip,

  			actionsForClip = this._actionsByClip[ clipUuid ];

  		if ( actionsForClip !== undefined ) {

  			return actionsForClip.actionByRoot[ rootUuid ] || null;

  		}

  		return null;

  	}

  	// deactivates all previously scheduled actions
  	stopAllAction() {

  		const actions = this._actions,
  			nActions = this._nActiveActions;

  		for ( let i = nActions - 1; i >= 0; -- i ) {

  			actions[ i ].stop();

  		}

  		return this;

  	}

  	// advance the time and update apply the animation
  	update( deltaTime ) {

  		deltaTime *= this.timeScale;

  		const actions = this._actions,
  			nActions = this._nActiveActions,

  			time = this.time += deltaTime,
  			timeDirection = Math.sign( deltaTime ),

  			accuIndex = this._accuIndex ^= 1;

  		// run active actions

  		for ( let i = 0; i !== nActions; ++ i ) {

  			const action = actions[ i ];

  			action._update( time, deltaTime, timeDirection, accuIndex );

  		}

  		// update scene graph

  		const bindings = this._bindings,
  			nBindings = this._nActiveBindings;

  		for ( let i = 0; i !== nBindings; ++ i ) {

  			bindings[ i ].apply( accuIndex );

  		}

  		return this;

  	}

  	// Allows you to seek to a specific time in an animation.
  	setTime( timeInSeconds ) {

  		this.time = 0; // Zero out time attribute for AnimationMixer object;
  		for ( let i = 0; i < this._actions.length; i ++ ) {

  			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

  		}

  		return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

  	}

  	// return this mixer's root target object
  	getRoot() {

  		return this._root;

  	}

  	// free all resources specific to a particular clip
  	uncacheClip( clip ) {

  		const actions = this._actions,
  			clipUuid = clip.uuid,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ];

  		if ( actionsForClip !== undefined ) {

  			// note: just calling _removeInactiveAction would mess up the
  			// iteration state and also require updating the state we can
  			// just throw away

  			const actionsToRemove = actionsForClip.knownActions;

  			for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

  				const action = actionsToRemove[ i ];

  				this._deactivateAction( action );

  				const cacheIndex = action._cacheIndex,
  					lastInactiveAction = actions[ actions.length - 1 ];

  				action._cacheIndex = null;
  				action._byClipCacheIndex = null;

  				lastInactiveAction._cacheIndex = cacheIndex;
  				actions[ cacheIndex ] = lastInactiveAction;
  				actions.pop();

  				this._removeInactiveBindingsForAction( action );

  			}

  			delete actionsByClip[ clipUuid ];

  		}

  	}

  	// free all resources specific to a particular root target object
  	uncacheRoot( root ) {

  		const rootUuid = root.uuid,
  			actionsByClip = this._actionsByClip;

  		for ( const clipUuid in actionsByClip ) {

  			const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
  				action = actionByRoot[ rootUuid ];

  			if ( action !== undefined ) {

  				this._deactivateAction( action );
  				this._removeInactiveAction( action );

  			}

  		}

  		const bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ];

  		if ( bindingByName !== undefined ) {

  			for ( const trackName in bindingByName ) {

  				const binding = bindingByName[ trackName ];
  				binding.restoreOriginalState();
  				this._removeInactiveBinding( binding );

  			}

  		}

  	}

  	// remove a targeted clip from the cache
  	uncacheAction( clip, optionalRoot ) {

  		const action = this.existingAction( clip, optionalRoot );

  		if ( action !== null ) {

  			this._deactivateAction( action );
  			this._removeInactiveAction( action );

  		}

  	}

  }

  AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );

  class Uniform {

  	constructor( value ) {

  		if ( typeof value === 'string' ) {

  			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
  			value = arguments[ 1 ];

  		}

  		this.value = value;

  	}

  	clone() {

  		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

  	}

  }

  class InstancedInterleavedBuffer extends InterleavedBuffer {

  	constructor( array, stride, meshPerAttribute = 1 ) {

  		super( array, stride );

  		this.meshPerAttribute = meshPerAttribute || 1;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  	clone( data ) {

  		const ib = super.clone( data );

  		ib.meshPerAttribute = this.meshPerAttribute;

  		return ib;

  	}

  	toJSON( data ) {

  		const json = super.toJSON( data );

  		json.isInstancedInterleavedBuffer = true;
  		json.meshPerAttribute = this.meshPerAttribute;

  		return json;

  	}

  }

  InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

  class GLBufferAttribute {

  	constructor( buffer, type, itemSize, elementSize, count ) {

  		this.buffer = buffer;
  		this.type = type;
  		this.itemSize = itemSize;
  		this.elementSize = elementSize;
  		this.count = count;

  		this.version = 0;

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	setBuffer( buffer ) {

  		this.buffer = buffer;

  		return this;

  	}

  	setType( type, elementSize ) {

  		this.type = type;
  		this.elementSize = elementSize;

  		return this;

  	}

  	setItemSize( itemSize ) {

  		this.itemSize = itemSize;

  		return this;

  	}

  	setCount( count ) {

  		this.count = count;

  		return this;

  	}

  }

  GLBufferAttribute.prototype.isGLBufferAttribute = true;

  class Raycaster {

  	constructor( origin, direction, near = 0, far = Infinity ) {

  		this.ray = new Ray( origin, direction );
  		// direction is assumed to be normalized (for accurate distance calculations)

  		this.near = near;
  		this.far = far;
  		this.camera = null;
  		this.layers = new Layers();

  		this.params = {
  			Mesh: {},
  			Line: { threshold: 1 },
  			LOD: {},
  			Points: { threshold: 1 },
  			Sprite: {}
  		};

  	}

  	set( origin, direction ) {

  		// direction is assumed to be normalized (for accurate distance calculations)

  		this.ray.set( origin, direction );

  	}

  	setFromCamera( coords, camera ) {

  		if ( camera && camera.isPerspectiveCamera ) {

  			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
  			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
  			this.camera = camera;

  		} else if ( camera && camera.isOrthographicCamera ) {

  			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
  			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
  			this.camera = camera;

  		} else {

  			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

  		}

  	}

  	intersectObject( object, recursive = false, intersects = [] ) {

  		intersectObject( object, this, intersects, recursive );

  		intersects.sort( ascSort );

  		return intersects;

  	}

  	intersectObjects( objects, recursive = false, intersects = [] ) {

  		for ( let i = 0, l = objects.length; i < l; i ++ ) {

  			intersectObject( objects[ i ], this, intersects, recursive );

  		}

  		intersects.sort( ascSort );

  		return intersects;

  	}

  }

  function ascSort( a, b ) {

  	return a.distance - b.distance;

  }

  function intersectObject( object, raycaster, intersects, recursive ) {

  	if ( object.layers.test( raycaster.layers ) ) {

  		object.raycast( raycaster, intersects );

  	}

  	if ( recursive === true ) {

  		const children = object.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			intersectObject( children[ i ], raycaster, intersects, true );

  		}

  	}

  }

  /**
   * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
   *
   * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
   * The azimuthal angle (theta) is measured from the positive z-axis.
   */

  class Spherical {

  	constructor( radius = 1, phi = 0, theta = 0 ) {

  		this.radius = radius;
  		this.phi = phi; // polar angle
  		this.theta = theta; // azimuthal angle

  		return this;

  	}

  	set( radius, phi, theta ) {

  		this.radius = radius;
  		this.phi = phi;
  		this.theta = theta;

  		return this;

  	}

  	copy( other ) {

  		this.radius = other.radius;
  		this.phi = other.phi;
  		this.theta = other.theta;

  		return this;

  	}

  	// restrict phi to be betwee EPS and PI-EPS
  	makeSafe() {

  		const EPS = 0.000001;
  		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

  		return this;

  	}

  	setFromVector3( v ) {

  		return this.setFromCartesianCoords( v.x, v.y, v.z );

  	}

  	setFromCartesianCoords( x, y, z ) {

  		this.radius = Math.sqrt( x * x + y * y + z * z );

  		if ( this.radius === 0 ) {

  			this.theta = 0;
  			this.phi = 0;

  		} else {

  			this.theta = Math.atan2( x, z );
  			this.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );

  		}

  		return this;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  /**
   * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
   */

  class Cylindrical {

  	constructor( radius = 1, theta = 0, y = 0 ) {

  		this.radius = radius; // distance from the origin to a point in the x-z plane
  		this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
  		this.y = y; // height above the x-z plane

  		return this;

  	}

  	set( radius, theta, y ) {

  		this.radius = radius;
  		this.theta = theta;
  		this.y = y;

  		return this;

  	}

  	copy( other ) {

  		this.radius = other.radius;
  		this.theta = other.theta;
  		this.y = other.y;

  		return this;

  	}

  	setFromVector3( v ) {

  		return this.setFromCartesianCoords( v.x, v.y, v.z );

  	}

  	setFromCartesianCoords( x, y, z ) {

  		this.radius = Math.sqrt( x * x + z * z );
  		this.theta = Math.atan2( x, z );
  		this.y = y;

  		return this;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _vector$4 = /*@__PURE__*/ new Vector2();

  class Box2 {

  	constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {

  		this.min = min;
  		this.max = max;

  	}

  	set( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	}

  	setFromPoints( points ) {

  		this.makeEmpty();

  		for ( let i = 0, il = points.length; i < il; i ++ ) {

  			this.expandByPoint( points[ i ] );

  		}

  		return this;

  	}

  	setFromCenterAndSize( center, size ) {

  		const halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );
  		this.min.copy( center ).sub( halfSize );
  		this.max.copy( center ).add( halfSize );

  		return this;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	}

  	makeEmpty() {

  		this.min.x = this.min.y = + Infinity;
  		this.max.x = this.max.y = - Infinity;

  		return this;

  	}

  	isEmpty() {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

  	}

  	getCenter( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Box2: .getCenter() target is now required' );
  			target = new Vector2();

  		}

  		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	}

  	getSize( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Box2: .getSize() target is now required' );
  			target = new Vector2();

  		}

  		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

  	}

  	expandByPoint( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	}

  	expandByVector( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	}

  	expandByScalar( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	}

  	containsPoint( point ) {

  		return point.x < this.min.x || point.x > this.max.x ||
  			point.y < this.min.y || point.y > this.max.y ? false : true;

  	}

  	containsBox( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y;

  	}

  	getParameter( point, target ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		if ( target === undefined ) {

  			console.warn( 'THREE.Box2: .getParameter() target is now required' );
  			target = new Vector2();

  		}

  		return target.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y )
  		);

  	}

  	intersectsBox( box ) {

  		// using 4 splitting planes to rule out intersections

  		return box.max.x < this.min.x || box.min.x > this.max.x ||
  			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

  	}

  	clampPoint( point, target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Box2: .clampPoint() target is now required' );
  			target = new Vector2();

  		}

  		return target.copy( point ).clamp( this.min, this.max );

  	}

  	distanceToPoint( point ) {

  		const clampedPoint = _vector$4.copy( point ).clamp( this.min, this.max );
  		return clampedPoint.sub( point ).length();

  	}

  	intersect( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		return this;

  	}

  	union( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	}

  	translate( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	}

  	equals( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  }

  Box2.prototype.isBox2 = true;

  const _startP = /*@__PURE__*/ new Vector3();
  const _startEnd = /*@__PURE__*/ new Vector3();

  class Line3 {

  	constructor( start = new Vector3(), end = new Vector3() ) {

  		this.start = start;
  		this.end = end;

  	}

  	set( start, end ) {

  		this.start.copy( start );
  		this.end.copy( end );

  		return this;

  	}

  	copy( line ) {

  		this.start.copy( line.start );
  		this.end.copy( line.end );

  		return this;

  	}

  	getCenter( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Line3: .getCenter() target is now required' );
  			target = new Vector3();

  		}

  		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

  	}

  	delta( target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Line3: .delta() target is now required' );
  			target = new Vector3();

  		}

  		return target.subVectors( this.end, this.start );

  	}

  	distanceSq() {

  		return this.start.distanceToSquared( this.end );

  	}

  	distance() {

  		return this.start.distanceTo( this.end );

  	}

  	at( t, target ) {

  		if ( target === undefined ) {

  			console.warn( 'THREE.Line3: .at() target is now required' );
  			target = new Vector3();

  		}

  		return this.delta( target ).multiplyScalar( t ).add( this.start );

  	}

  	closestPointToPointParameter( point, clampToLine ) {

  		_startP.subVectors( point, this.start );
  		_startEnd.subVectors( this.end, this.start );

  		const startEnd2 = _startEnd.dot( _startEnd );
  		const startEnd_startP = _startEnd.dot( _startP );

  		let t = startEnd_startP / startEnd2;

  		if ( clampToLine ) {

  			t = clamp( t, 0, 1 );

  		}

  		return t;

  	}

  	closestPointToPoint( point, clampToLine, target ) {

  		const t = this.closestPointToPointParameter( point, clampToLine );

  		if ( target === undefined ) {

  			console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
  			target = new Vector3();

  		}

  		return this.delta( target ).multiplyScalar( t ).add( this.start );

  	}

  	applyMatrix4( matrix ) {

  		this.start.applyMatrix4( matrix );
  		this.end.applyMatrix4( matrix );

  		return this;

  	}

  	equals( line ) {

  		return line.start.equals( this.start ) && line.end.equals( this.end );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  class ImmediateRenderObject extends Object3D {

  	constructor( material ) {

  		super();

  		this.material = material;
  		this.render = function ( /* renderCallback */ ) {};

  		this.hasPositions = false;
  		this.hasNormals = false;
  		this.hasColors = false;
  		this.hasUvs = false;

  		this.positionArray = null;
  		this.normalArray = null;
  		this.colorArray = null;
  		this.uvArray = null;

  		this.count = 0;

  	}

  }

  ImmediateRenderObject.prototype.isImmediateRenderObject = true;

  const _vector$3 = /*@__PURE__*/ new Vector3();

  class SpotLightHelper extends Object3D {

  	constructor( light, color ) {

  		super();
  		this.light = light;
  		this.light.updateMatrixWorld();

  		this.matrix = light.matrixWorld;
  		this.matrixAutoUpdate = false;

  		this.color = color;

  		const geometry = new BufferGeometry();

  		const positions = [
  			0, 0, 0, 	0, 0, 1,
  			0, 0, 0, 	1, 0, 1,
  			0, 0, 0,	- 1, 0, 1,
  			0, 0, 0, 	0, 1, 1,
  			0, 0, 0, 	0, - 1, 1
  		];

  		for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

  			const p1 = ( i / l ) * Math.PI * 2;
  			const p2 = ( j / l ) * Math.PI * 2;

  			positions.push(
  				Math.cos( p1 ), Math.sin( p1 ), 1,
  				Math.cos( p2 ), Math.sin( p2 ), 1
  			);

  		}

  		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

  		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

  		this.cone = new LineSegments( geometry, material );
  		this.add( this.cone );

  		this.update();

  	}

  	dispose() {

  		this.cone.geometry.dispose();
  		this.cone.material.dispose();

  	}

  	update() {

  		this.light.updateMatrixWorld();

  		const coneLength = this.light.distance ? this.light.distance : 1000;
  		const coneWidth = coneLength * Math.tan( this.light.angle );

  		this.cone.scale.set( coneWidth, coneWidth, coneLength );

  		_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );

  		this.cone.lookAt( _vector$3 );

  		if ( this.color !== undefined ) {

  			this.cone.material.color.set( this.color );

  		} else {

  			this.cone.material.color.copy( this.light.color );

  		}

  	}

  }

  const _vector$2 = /*@__PURE__*/ new Vector3();
  const _boneMatrix = /*@__PURE__*/ new Matrix4();
  const _matrixWorldInv = /*@__PURE__*/ new Matrix4();


  class SkeletonHelper extends LineSegments {

  	constructor( object ) {

  		const bones = getBoneList( object );

  		const geometry = new BufferGeometry();

  		const vertices = [];
  		const colors = [];

  		const color1 = new Color( 0, 0, 1 );
  		const color2 = new Color( 0, 1, 0 );

  		for ( let i = 0; i < bones.length; i ++ ) {

  			const bone = bones[ i ];

  			if ( bone.parent && bone.parent.isBone ) {

  				vertices.push( 0, 0, 0 );
  				vertices.push( 0, 0, 0 );
  				colors.push( color1.r, color1.g, color1.b );
  				colors.push( color2.r, color2.g, color2.b );

  			}

  		}

  		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  		const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

  		super( geometry, material );

  		this.type = 'SkeletonHelper';
  		this.isSkeletonHelper = true;

  		this.root = object;
  		this.bones = bones;

  		this.matrix = object.matrixWorld;
  		this.matrixAutoUpdate = false;

  	}

  	updateMatrixWorld( force ) {

  		const bones = this.bones;

  		const geometry = this.geometry;
  		const position = geometry.getAttribute( 'position' );

  		_matrixWorldInv.copy( this.root.matrixWorld ).invert();

  		for ( let i = 0, j = 0; i < bones.length; i ++ ) {

  			const bone = bones[ i ];

  			if ( bone.parent && bone.parent.isBone ) {

  				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
  				_vector$2.setFromMatrixPosition( _boneMatrix );
  				position.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );

  				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
  				_vector$2.setFromMatrixPosition( _boneMatrix );
  				position.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );

  				j += 2;

  			}

  		}

  		geometry.getAttribute( 'position' ).needsUpdate = true;

  		super.updateMatrixWorld( force );

  	}

  }


  function getBoneList( object ) {

  	const boneList = [];

  	if ( object && object.isBone ) {

  		boneList.push( object );

  	}

  	for ( let i = 0; i < object.children.length; i ++ ) {

  		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

  	}

  	return boneList;

  }

  class PointLightHelper extends Mesh {

  	constructor( light, sphereSize, color ) {

  		const geometry = new SphereGeometry( sphereSize, 4, 2 );
  		const material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

  		super( geometry, material );

  		this.light = light;
  		this.light.updateMatrixWorld();

  		this.color = color;

  		this.type = 'PointLightHelper';

  		this.matrix = this.light.matrixWorld;
  		this.matrixAutoUpdate = false;

  		this.update();


  		/*
  	// TODO: delete this comment?
  	const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
  	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

  	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

  	const d = light.distance;

  	if ( d === 0.0 ) {

  		this.lightDistance.visible = false;

  	} else {

  		this.lightDistance.scale.set( d, d, d );

  	}

  	this.add( this.lightDistance );
  	*/

  	}

  	dispose() {

  		this.geometry.dispose();
  		this.material.dispose();

  	}

  	update() {

  		if ( this.color !== undefined ) {

  			this.material.color.set( this.color );

  		} else {

  			this.material.color.copy( this.light.color );

  		}

  		/*
  		const d = this.light.distance;

  		if ( d === 0.0 ) {

  			this.lightDistance.visible = false;

  		} else {

  			this.lightDistance.visible = true;
  			this.lightDistance.scale.set( d, d, d );

  		}
  		*/

  	}

  }

  const _vector$1 = /*@__PURE__*/ new Vector3();
  const _color1 = /*@__PURE__*/ new Color();
  const _color2 = /*@__PURE__*/ new Color();

  class HemisphereLightHelper extends Object3D {

  	constructor( light, size, color ) {

  		super();
  		this.light = light;
  		this.light.updateMatrixWorld();

  		this.matrix = light.matrixWorld;
  		this.matrixAutoUpdate = false;

  		this.color = color;

  		const geometry = new OctahedronGeometry( size );
  		geometry.rotateY( Math.PI * 0.5 );

  		this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
  		if ( this.color === undefined ) this.material.vertexColors = true;

  		const position = geometry.getAttribute( 'position' );
  		const colors = new Float32Array( position.count * 3 );

  		geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

  		this.add( new Mesh( geometry, this.material ) );

  		this.update();

  	}

  	dispose() {

  		this.children[ 0 ].geometry.dispose();
  		this.children[ 0 ].material.dispose();

  	}

  	update() {

  		const mesh = this.children[ 0 ];

  		if ( this.color !== undefined ) {

  			this.material.color.set( this.color );

  		} else {

  			const colors = mesh.geometry.getAttribute( 'color' );

  			_color1.copy( this.light.color );
  			_color2.copy( this.light.groundColor );

  			for ( let i = 0, l = colors.count; i < l; i ++ ) {

  				const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

  				colors.setXYZ( i, color.r, color.g, color.b );

  			}

  			colors.needsUpdate = true;

  		}

  		mesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );

  	}

  }

  class GridHelper extends LineSegments {

  	constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

  		color1 = new Color( color1 );
  		color2 = new Color( color2 );

  		const center = divisions / 2;
  		const step = size / divisions;
  		const halfSize = size / 2;

  		const vertices = [], colors = [];

  		for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

  			vertices.push( - halfSize, 0, k, halfSize, 0, k );
  			vertices.push( k, 0, - halfSize, k, 0, halfSize );

  			const color = i === center ? color1 : color2;

  			color.toArray( colors, j ); j += 3;
  			color.toArray( colors, j ); j += 3;
  			color.toArray( colors, j ); j += 3;
  			color.toArray( colors, j ); j += 3;

  		}

  		const geometry = new BufferGeometry();
  		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

  		super( geometry, material );

  		this.type = 'GridHelper';

  	}

  }

  class PolarGridHelper extends LineSegments {

  	constructor( radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {

  		color1 = new Color( color1 );
  		color2 = new Color( color2 );

  		const vertices = [];
  		const colors = [];

  		// create the radials

  		for ( let i = 0; i <= radials; i ++ ) {

  			const v = ( i / radials ) * ( Math.PI * 2 );

  			const x = Math.sin( v ) * radius;
  			const z = Math.cos( v ) * radius;

  			vertices.push( 0, 0, 0 );
  			vertices.push( x, 0, z );

  			const color = ( i & 1 ) ? color1 : color2;

  			colors.push( color.r, color.g, color.b );
  			colors.push( color.r, color.g, color.b );

  		}

  		// create the circles

  		for ( let i = 0; i <= circles; i ++ ) {

  			const color = ( i & 1 ) ? color1 : color2;

  			const r = radius - ( radius / circles * i );

  			for ( let j = 0; j < divisions; j ++ ) {

  				// first vertex

  				let v = ( j / divisions ) * ( Math.PI * 2 );

  				let x = Math.sin( v ) * r;
  				let z = Math.cos( v ) * r;

  				vertices.push( x, 0, z );
  				colors.push( color.r, color.g, color.b );

  				// second vertex

  				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

  				x = Math.sin( v ) * r;
  				z = Math.cos( v ) * r;

  				vertices.push( x, 0, z );
  				colors.push( color.r, color.g, color.b );

  			}

  		}

  		const geometry = new BufferGeometry();
  		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

  		super( geometry, material );

  		this.type = 'PolarGridHelper';

  	}

  }

  const _v1 = /*@__PURE__*/ new Vector3();
  const _v2 = /*@__PURE__*/ new Vector3();
  const _v3 = /*@__PURE__*/ new Vector3();

  class DirectionalLightHelper extends Object3D {

  	constructor( light, size, color ) {

  		super();
  		this.light = light;
  		this.light.updateMatrixWorld();

  		this.matrix = light.matrixWorld;
  		this.matrixAutoUpdate = false;

  		this.color = color;

  		if ( size === undefined ) size = 1;

  		let geometry = new BufferGeometry();
  		geometry.setAttribute( 'position', new Float32BufferAttribute( [
  			- size, size, 0,
  			size, size, 0,
  			size, - size, 0,
  			- size, - size, 0,
  			- size, size, 0
  		], 3 ) );

  		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

  		this.lightPlane = new Line( geometry, material );
  		this.add( this.lightPlane );

  		geometry = new BufferGeometry();
  		geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

  		this.targetLine = new Line( geometry, material );
  		this.add( this.targetLine );

  		this.update();

  	}

  	dispose() {

  		this.lightPlane.geometry.dispose();
  		this.lightPlane.material.dispose();
  		this.targetLine.geometry.dispose();
  		this.targetLine.material.dispose();

  	}

  	update() {

  		_v1.setFromMatrixPosition( this.light.matrixWorld );
  		_v2.setFromMatrixPosition( this.light.target.matrixWorld );
  		_v3.subVectors( _v2, _v1 );

  		this.lightPlane.lookAt( _v2 );

  		if ( this.color !== undefined ) {

  			this.lightPlane.material.color.set( this.color );
  			this.targetLine.material.color.set( this.color );

  		} else {

  			this.lightPlane.material.color.copy( this.light.color );
  			this.targetLine.material.color.copy( this.light.color );

  		}

  		this.targetLine.lookAt( _v2 );
  		this.targetLine.scale.z = _v3.length();

  	}

  }

  const _vector = /*@__PURE__*/ new Vector3();
  const _camera = /*@__PURE__*/ new Camera();

  /**
   *	- shows frustum, line of sight and up of the camera
   *	- suitable for fast updates
   * 	- based on frustum visualization in lightgl.js shadowmap example
   *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
   */

  class CameraHelper extends LineSegments {

  	constructor( camera ) {

  		const geometry = new BufferGeometry();
  		const material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

  		const vertices = [];
  		const colors = [];

  		const pointMap = {};

  		// colors

  		const colorFrustum = new Color( 0xffaa00 );
  		const colorCone = new Color( 0xff0000 );
  		const colorUp = new Color( 0x00aaff );
  		const colorTarget = new Color( 0xffffff );
  		const colorCross = new Color( 0x333333 );

  		// near

  		addLine( 'n1', 'n2', colorFrustum );
  		addLine( 'n2', 'n4', colorFrustum );
  		addLine( 'n4', 'n3', colorFrustum );
  		addLine( 'n3', 'n1', colorFrustum );

  		// far

  		addLine( 'f1', 'f2', colorFrustum );
  		addLine( 'f2', 'f4', colorFrustum );
  		addLine( 'f4', 'f3', colorFrustum );
  		addLine( 'f3', 'f1', colorFrustum );

  		// sides

  		addLine( 'n1', 'f1', colorFrustum );
  		addLine( 'n2', 'f2', colorFrustum );
  		addLine( 'n3', 'f3', colorFrustum );
  		addLine( 'n4', 'f4', colorFrustum );

  		// cone

  		addLine( 'p', 'n1', colorCone );
  		addLine( 'p', 'n2', colorCone );
  		addLine( 'p', 'n3', colorCone );
  		addLine( 'p', 'n4', colorCone );

  		// up

  		addLine( 'u1', 'u2', colorUp );
  		addLine( 'u2', 'u3', colorUp );
  		addLine( 'u3', 'u1', colorUp );

  		// target

  		addLine( 'c', 't', colorTarget );
  		addLine( 'p', 'c', colorCross );

  		// cross

  		addLine( 'cn1', 'cn2', colorCross );
  		addLine( 'cn3', 'cn4', colorCross );

  		addLine( 'cf1', 'cf2', colorCross );
  		addLine( 'cf3', 'cf4', colorCross );

  		function addLine( a, b, color ) {

  			addPoint( a, color );
  			addPoint( b, color );

  		}

  		function addPoint( id, color ) {

  			vertices.push( 0, 0, 0 );
  			colors.push( color.r, color.g, color.b );

  			if ( pointMap[ id ] === undefined ) {

  				pointMap[ id ] = [];

  			}

  			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

  		}

  		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  		super( geometry, material );

  		this.type = 'CameraHelper';

  		this.camera = camera;
  		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

  		this.matrix = camera.matrixWorld;
  		this.matrixAutoUpdate = false;

  		this.pointMap = pointMap;

  		this.update();

  	}

  	update() {

  		const geometry = this.geometry;
  		const pointMap = this.pointMap;

  		const w = 1, h = 1;

  		// we need just camera projection matrix inverse
  		// world matrix must be identity

  		_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

  		// center / target

  		setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
  		setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

  		// near

  		setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
  		setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
  		setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
  		setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

  		// far

  		setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
  		setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
  		setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
  		setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

  		// up

  		setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
  		setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
  		setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

  		// cross

  		setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
  		setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
  		setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
  		setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

  		setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
  		setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
  		setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
  		setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

  		geometry.getAttribute( 'position' ).needsUpdate = true;

  	}

  	dispose() {

  		this.geometry.dispose();
  		this.material.dispose();

  	}

  }


  function setPoint( point, pointMap, geometry, camera, x, y, z ) {

  	_vector.set( x, y, z ).unproject( camera );

  	const points = pointMap[ point ];

  	if ( points !== undefined ) {

  		const position = geometry.getAttribute( 'position' );

  		for ( let i = 0, l = points.length; i < l; i ++ ) {

  			position.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );

  		}

  	}

  }

  const _box = /*@__PURE__*/ new Box3();

  class BoxHelper extends LineSegments {

  	constructor( object, color = 0xffff00 ) {

  		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
  		const positions = new Float32Array( 8 * 3 );

  		const geometry = new BufferGeometry();
  		geometry.setIndex( new BufferAttribute( indices, 1 ) );
  		geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

  		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

  		this.object = object;
  		this.type = 'BoxHelper';

  		this.matrixAutoUpdate = false;

  		this.update();

  	}

  	update( object ) {

  		if ( object !== undefined ) {

  			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

  		}

  		if ( this.object !== undefined ) {

  			_box.setFromObject( this.object );

  		}

  		if ( _box.isEmpty() ) return;

  		const min = _box.min;
  		const max = _box.max;

  		/*
  			5____4
  		1/___0/|
  		| 6__|_7
  		2/___3/

  		0: max.x, max.y, max.z
  		1: min.x, max.y, max.z
  		2: min.x, min.y, max.z
  		3: max.x, min.y, max.z
  		4: max.x, max.y, min.z
  		5: min.x, max.y, min.z
  		6: min.x, min.y, min.z
  		7: max.x, min.y, min.z
  		*/

  		const position = this.geometry.attributes.position;
  		const array = position.array;

  		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
  		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
  		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
  		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
  		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
  		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
  		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
  		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

  		position.needsUpdate = true;

  		this.geometry.computeBoundingSphere();


  	}

  	setFromObject( object ) {

  		this.object = object;
  		this.update();

  		return this;

  	}

  	copy( source ) {

  		LineSegments.prototype.copy.call( this, source );

  		this.object = source.object;

  		return this;

  	}

  }

  class Box3Helper extends LineSegments {

  	constructor( box, color = 0xffff00 ) {

  		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

  		const positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

  		const geometry = new BufferGeometry();

  		geometry.setIndex( new BufferAttribute( indices, 1 ) );

  		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

  		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

  		this.box = box;

  		this.type = 'Box3Helper';

  		this.geometry.computeBoundingSphere();

  	}

  	updateMatrixWorld( force ) {

  		const box = this.box;

  		if ( box.isEmpty() ) return;

  		box.getCenter( this.position );

  		box.getSize( this.scale );

  		this.scale.multiplyScalar( 0.5 );

  		super.updateMatrixWorld( force );

  	}

  }

  class PlaneHelper extends Line {

  	constructor( plane, size = 1, hex = 0xffff00 ) {

  		const color = hex;

  		const positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

  		const geometry = new BufferGeometry();
  		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
  		geometry.computeBoundingSphere();

  		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

  		this.type = 'PlaneHelper';

  		this.plane = plane;

  		this.size = size;

  		const positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

  		const geometry2 = new BufferGeometry();
  		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
  		geometry2.computeBoundingSphere();

  		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

  	}

  	updateMatrixWorld( force ) {

  		let scale = - this.plane.constant;

  		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

  		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

  		this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

  		this.lookAt( this.plane.normal );

  		super.updateMatrixWorld( force );

  	}

  }

  const _axis = /*@__PURE__*/ new Vector3();
  let _lineGeometry, _coneGeometry;

  class ArrowHelper extends Object3D {

  	// dir is assumed to be normalized

  	constructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

  		super();

  		this.type = 'ArrowHelper';

  		if ( _lineGeometry === undefined ) {

  			_lineGeometry = new BufferGeometry();
  			_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

  			_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );
  			_coneGeometry.translate( 0, - 0.5, 0 );

  		}

  		this.position.copy( origin );

  		this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
  		this.line.matrixAutoUpdate = false;
  		this.add( this.line );

  		this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
  		this.cone.matrixAutoUpdate = false;
  		this.add( this.cone );

  		this.setDirection( dir );
  		this.setLength( length, headLength, headWidth );

  	}

  	setDirection( dir ) {

  		// dir is assumed to be normalized

  		if ( dir.y > 0.99999 ) {

  			this.quaternion.set( 0, 0, 0, 1 );

  		} else if ( dir.y < - 0.99999 ) {

  			this.quaternion.set( 1, 0, 0, 0 );

  		} else {

  			_axis.set( dir.z, 0, - dir.x ).normalize();

  			const radians = Math.acos( dir.y );

  			this.quaternion.setFromAxisAngle( _axis, radians );

  		}

  	}

  	setLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

  		this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
  		this.line.updateMatrix();

  		this.cone.scale.set( headWidth, headLength, headWidth );
  		this.cone.position.y = length;
  		this.cone.updateMatrix();

  	}

  	setColor( color ) {

  		this.line.material.color.set( color );
  		this.cone.material.color.set( color );

  	}

  	copy( source ) {

  		super.copy( source, false );

  		this.line.copy( source.line );
  		this.cone.copy( source.cone );

  		return this;

  	}

  }

  class AxesHelper extends LineSegments {

  	constructor( size = 1 ) {

  		const vertices = [
  			0, 0, 0,	size, 0, 0,
  			0, 0, 0,	0, size, 0,
  			0, 0, 0,	0, 0, size
  		];

  		const colors = [
  			1, 0, 0,	1, 0.6, 0,
  			0, 1, 0,	0.6, 1, 0,
  			0, 0, 1,	0, 0.6, 1
  		];

  		const geometry = new BufferGeometry();
  		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

  		super( geometry, material );

  		this.type = 'AxesHelper';

  	}

  	dispose() {

  		this.geometry.dispose();
  		this.material.dispose();

  	}

  }

  const _floatView = new Float32Array( 1 );
  const _int32View = new Int32Array( _floatView.buffer );

  class DataUtils {

  	// Converts float32 to float16 (stored as uint16 value).

  	static toHalfFloat( val ) {

  		// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

  		/* This method is faster than the OpenEXR implementation (very often
  		* used, eg. in Ogre), with the additional benefit of rounding, inspired
  		* by James Tursa?s half-precision code. */

  		_floatView[ 0 ] = val;
  		const x = _int32View[ 0 ];

  		let bits = ( x >> 16 ) & 0x8000; /* Get the sign */
  		let m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */
  		const e = ( x >> 23 ) & 0xff; /* Using int is faster here */

  		/* If zero, or denormal, or exponent underflows too much for a denormal
  			* half, return signed zero. */
  		if ( e < 103 ) return bits;

  		/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
  		if ( e > 142 ) {

  			bits |= 0x7c00;
  			/* If exponent was 0xff and one mantissa bit was set, it means NaN,
  						* not Inf, so make sure we set one mantissa bit too. */
  			bits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );
  			return bits;

  		}

  		/* If exponent underflows but not too much, return a denormal */
  		if ( e < 113 ) {

  			m |= 0x0800;
  			/* Extra rounding may overflow and set mantissa to 0 and exponent
  				* to 1, which is OK. */
  			bits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );
  			return bits;

  		}

  		bits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );
  		/* Extra rounding. An overflow will set mantissa to 0 and increment
  			* the exponent, which is OK. */
  		bits += m & 1;
  		return bits;

  	}

  }

  const LOD_MIN = 4;
  const LOD_MAX = 8;
  const SIZE_MAX = Math.pow( 2, LOD_MAX );

  // The standard deviations (radians) associated with the extra mips. These are
  // chosen to approximate a Trowbridge-Reitz distribution function times the
  // geometric shadowing function. These sigma values squared must match the
  // variance #defines in cube_uv_reflection_fragment.glsl.js.
  const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

  const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

  // The maximum length of the blur for loop. Smaller sigmas will use fewer
  // samples and exit early, but not recompile the shader.
  const MAX_SAMPLES = 20;

  const ENCODINGS = {
  	[ LinearEncoding ]: 0,
  	[ sRGBEncoding ]: 1,
  	[ RGBEEncoding ]: 2,
  	[ RGBM7Encoding ]: 3,
  	[ RGBM16Encoding ]: 4,
  	[ RGBDEncoding ]: 5,
  	[ GammaEncoding ]: 6
  };

  const backgroundMaterial = new MeshBasicMaterial( {
  	side: BackSide,
  	depthWrite: false,
  	depthTest: false,
  } );
  const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

  const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
  const { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes();
  const _clearColor = /*@__PURE__*/ new Color();
  let _oldTarget = null;

  // Golden Ratio
  const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
  const INV_PHI = 1 / PHI;

  // Vertices of a dodecahedron (except the opposites, which represent the
  // same axis), used as axis directions evenly spread on a sphere.
  const _axisDirections = [
  	/*@__PURE__*/ new Vector3( 1, 1, 1 ),
  	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
  	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
  	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
  	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
  	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
  	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
  	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
  	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
  	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];

  /**
   * This class generates a Prefiltered, Mipmapped Radiance Environment Map
   * (PMREM) from a cubeMap environment texture. This allows different levels of
   * blur to be quickly accessed based on material roughness. It is packed into a
   * special CubeUV format that allows us to perform custom interpolation so that
   * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
   * chain, it only goes down to the LOD_MIN level (above), and then creates extra
   * even more filtered 'mips' at the same LOD_MIN resolution, associated with
   * higher roughness levels. In this way we maintain resolution to smoothly
   * interpolate diffuse lighting while limiting sampling computation.
   *
   * Paper: Fast, Accurate Image-Based Lighting
   * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
  */

  function convertLinearToRGBE( color ) {

  	const maxComponent = Math.max( color.r, color.g, color.b );
  	const fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );
  	color.multiplyScalar( Math.pow( 2.0, - fExp ) );

  	const alpha = ( fExp + 128.0 ) / 255.0;
  	return alpha;

  }

  class PMREMGenerator {

  	constructor( renderer ) {

  		this._renderer = renderer;
  		this._pingPongRenderTarget = null;

  		this._blurMaterial = _getBlurShader( MAX_SAMPLES );
  		this._equirectShader = null;
  		this._cubemapShader = null;

  		this._compileMaterial( this._blurMaterial );

  	}

  	/**
  	 * Generates a PMREM from a supplied Scene, which can be faster than using an
  	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
  	 * in radians to be applied to the scene before PMREM generation. Optional near
  	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
  	 * is placed at the origin).
  	 */
  	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

  		_oldTarget = this._renderer.getRenderTarget();
  		const cubeUVRenderTarget = this._allocateTargets();

  		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );
  		if ( sigma > 0 ) {

  			this._blur( cubeUVRenderTarget, 0, 0, sigma );

  		}

  		this._applyPMREM( cubeUVRenderTarget );
  		this._cleanup( cubeUVRenderTarget );

  		return cubeUVRenderTarget;

  	}

  	/**
  	 * Generates a PMREM from an equirectangular texture, which can be either LDR
  	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
  	 * as this matches best with the 256 x 256 cubemap output.
  	 */
  	fromEquirectangular( equirectangular ) {

  		return this._fromTexture( equirectangular );

  	}

  	/**
  	 * Generates a PMREM from an cubemap texture, which can be either LDR
  	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
  	 * as this matches best with the 256 x 256 cubemap output.
  	 */
  	fromCubemap( cubemap ) {

  		return this._fromTexture( cubemap );

  	}

  	/**
  	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */
  	compileCubemapShader() {

  		if ( this._cubemapShader === null ) {

  			this._cubemapShader = _getCubemapShader();
  			this._compileMaterial( this._cubemapShader );

  		}

  	}

  	/**
  	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */
  	compileEquirectangularShader() {

  		if ( this._equirectShader === null ) {

  			this._equirectShader = _getEquirectShader();
  			this._compileMaterial( this._equirectShader );

  		}

  	}

  	/**
  	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
  	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
  	 * one of them will cause any others to also become unusable.
  	 */
  	dispose() {

  		this._blurMaterial.dispose();

  		if ( this._cubemapShader !== null ) this._cubemapShader.dispose();
  		if ( this._equirectShader !== null ) this._equirectShader.dispose();

  		for ( let i = 0; i < _lodPlanes.length; i ++ ) {

  			_lodPlanes[ i ].dispose();

  		}

  	}

  	// private interface

  	_cleanup( outputTarget ) {

  		this._pingPongRenderTarget.dispose();
  		this._renderer.setRenderTarget( _oldTarget );
  		outputTarget.scissorTest = false;
  		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

  	}

  	_fromTexture( texture ) {

  		_oldTarget = this._renderer.getRenderTarget();
  		const cubeUVRenderTarget = this._allocateTargets( texture );
  		this._textureToCubeUV( texture, cubeUVRenderTarget );
  		this._applyPMREM( cubeUVRenderTarget );
  		this._cleanup( cubeUVRenderTarget );

  		return cubeUVRenderTarget;

  	}

  	_allocateTargets( texture ) { // warning: null texture is valid

  		const params = {
  			magFilter: NearestFilter,
  			minFilter: NearestFilter,
  			generateMipmaps: false,
  			type: UnsignedByteType,
  			format: RGBEFormat,
  			encoding: _isLDR( texture ) ? texture.encoding : RGBEEncoding,
  			depthBuffer: false
  		};

  		const cubeUVRenderTarget = _createRenderTarget( params );
  		cubeUVRenderTarget.depthBuffer = texture ? false : true;
  		this._pingPongRenderTarget = _createRenderTarget( params );
  		return cubeUVRenderTarget;

  	}

  	_compileMaterial( material ) {

  		const tmpMesh = new Mesh( _lodPlanes[ 0 ], material );
  		this._renderer.compile( tmpMesh, _flatCamera );

  	}

  	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

  		const fov = 90;
  		const aspect = 1;
  		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
  		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
  		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
  		const renderer = this._renderer;

  		const originalAutoClear = renderer.autoClear;
  		const outputEncoding = renderer.outputEncoding;
  		const toneMapping = renderer.toneMapping;
  		renderer.getClearColor( _clearColor );

  		renderer.toneMapping = NoToneMapping;
  		renderer.outputEncoding = LinearEncoding;
  		renderer.autoClear = false;

  		let useSolidColor = false;
  		const background = scene.background;
  		if ( background ) {

  			if ( background.isColor ) {

  				backgroundMaterial.color.copy( background ).convertSRGBToLinear();
  				scene.background = null;

  				const alpha = convertLinearToRGBE( backgroundMaterial.color );
  				backgroundMaterial.opacity = alpha;
  				useSolidColor = true;

  			}

  		} else {

  			backgroundMaterial.color.copy( _clearColor ).convertSRGBToLinear();

  			const alpha = convertLinearToRGBE( backgroundMaterial.color );
  			backgroundMaterial.opacity = alpha;
  			useSolidColor = true;

  		}


  		for ( let i = 0; i < 6; i ++ ) {

  			const col = i % 3;
  			if ( col == 0 ) {

  				cubeCamera.up.set( 0, upSign[ i ], 0 );
  				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

  			} else if ( col == 1 ) {

  				cubeCamera.up.set( 0, 0, upSign[ i ] );
  				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

  			} else {

  				cubeCamera.up.set( 0, upSign[ i ], 0 );
  				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

  			}

  			_setViewport( cubeUVRenderTarget,
  				col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );
  			renderer.setRenderTarget( cubeUVRenderTarget );

  			if ( useSolidColor ) {

  				renderer.render( backgroundBox, cubeCamera );

  			}

  			renderer.render( scene, cubeCamera );

  		}

  		renderer.toneMapping = toneMapping;
  		renderer.outputEncoding = outputEncoding;
  		renderer.autoClear = originalAutoClear;

  	}

  	_textureToCubeUV( texture, cubeUVRenderTarget ) {

  		const renderer = this._renderer;

  		if ( texture.isCubeTexture ) {

  			if ( this._cubemapShader == null ) {

  				this._cubemapShader = _getCubemapShader();

  			}

  		} else {

  			if ( this._equirectShader == null ) {

  				this._equirectShader = _getEquirectShader();

  			}

  		}

  		const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
  		const mesh = new Mesh( _lodPlanes[ 0 ], material );

  		const uniforms = material.uniforms;

  		uniforms[ 'envMap' ].value = texture;

  		if ( ! texture.isCubeTexture ) {

  			uniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );

  		}

  		uniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];
  		uniforms[ 'outputEncoding' ].value = ENCODINGS[ cubeUVRenderTarget.texture.encoding ];

  		_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );

  		renderer.setRenderTarget( cubeUVRenderTarget );
  		renderer.render( mesh, _flatCamera );

  	}

  	_applyPMREM( cubeUVRenderTarget ) {

  		const renderer = this._renderer;
  		const autoClear = renderer.autoClear;
  		renderer.autoClear = false;

  		for ( let i = 1; i < TOTAL_LODS; i ++ ) {

  			const sigma = Math.sqrt( _sigmas[ i ] * _sigmas[ i ] - _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );

  			const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

  			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

  		}

  		renderer.autoClear = autoClear;

  	}

  	/**
  	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
  	 * vertically and horizontally, but this breaks down on a cube. Here we apply
  	 * the blur latitudinally (around the poles), and then longitudinally (towards
  	 * the poles) to approximate the orthogonally-separable blur. It is least
  	 * accurate at the poles, but still does a decent job.
  	 */
  	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

  		const pingPongRenderTarget = this._pingPongRenderTarget;

  		this._halfBlur(
  			cubeUVRenderTarget,
  			pingPongRenderTarget,
  			lodIn,
  			lodOut,
  			sigma,
  			'latitudinal',
  			poleAxis );

  		this._halfBlur(
  			pingPongRenderTarget,
  			cubeUVRenderTarget,
  			lodOut,
  			lodOut,
  			sigma,
  			'longitudinal',
  			poleAxis );

  	}

  	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

  		const renderer = this._renderer;
  		const blurMaterial = this._blurMaterial;

  		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

  			console.error(
  				'blur direction must be either latitudinal or longitudinal!' );

  		}

  		// Number of standard deviations at which to cut off the discrete approximation.
  		const STANDARD_DEVIATIONS = 3;

  		const blurMesh = new Mesh( _lodPlanes[ lodOut ], blurMaterial );
  		const blurUniforms = blurMaterial.uniforms;

  		const pixels = _sizeLods[ lodIn ] - 1;
  		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
  		const sigmaPixels = sigmaRadians / radiansPerPixel;
  		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

  		if ( samples > MAX_SAMPLES ) {

  			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

  		}

  		const weights = [];
  		let sum = 0;

  		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

  			const x = i / sigmaPixels;
  			const weight = Math.exp( - x * x / 2 );
  			weights.push( weight );

  			if ( i == 0 ) {

  				sum += weight;

  			} else if ( i < samples ) {

  				sum += 2 * weight;

  			}

  		}

  		for ( let i = 0; i < weights.length; i ++ ) {

  			weights[ i ] = weights[ i ] / sum;

  		}

  		blurUniforms[ 'envMap' ].value = targetIn.texture;
  		blurUniforms[ 'samples' ].value = samples;
  		blurUniforms[ 'weights' ].value = weights;
  		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

  		if ( poleAxis ) {

  			blurUniforms[ 'poleAxis' ].value = poleAxis;

  		}

  		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
  		blurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;
  		blurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];
  		blurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];

  		const outputSize = _sizeLods[ lodOut ];
  		const x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );
  		const y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) + 2 * outputSize * ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );

  		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
  		renderer.setRenderTarget( targetOut );
  		renderer.render( blurMesh, _flatCamera );

  	}

  }

  function _isLDR( texture ) {

  	if ( texture === undefined || texture.type !== UnsignedByteType ) return false;

  	return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;

  }

  function _createPlanes() {

  	const _lodPlanes = [];
  	const _sizeLods = [];
  	const _sigmas = [];

  	let lod = LOD_MAX;

  	for ( let i = 0; i < TOTAL_LODS; i ++ ) {

  		const sizeLod = Math.pow( 2, lod );
  		_sizeLods.push( sizeLod );
  		let sigma = 1.0 / sizeLod;

  		if ( i > LOD_MAX - LOD_MIN ) {

  			sigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];

  		} else if ( i == 0 ) {

  			sigma = 0;

  		}

  		_sigmas.push( sigma );

  		const texelSize = 1.0 / ( sizeLod - 1 );
  		const min = - texelSize / 2;
  		const max = 1 + texelSize / 2;
  		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

  		const cubeFaces = 6;
  		const vertices = 6;
  		const positionSize = 3;
  		const uvSize = 2;
  		const faceIndexSize = 1;

  		const position = new Float32Array( positionSize * vertices * cubeFaces );
  		const uv = new Float32Array( uvSize * vertices * cubeFaces );
  		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

  		for ( let face = 0; face < cubeFaces; face ++ ) {

  			const x = ( face % 3 ) * 2 / 3 - 1;
  			const y = face > 2 ? 0 : - 1;
  			const coordinates = [
  				x, y, 0,
  				x + 2 / 3, y, 0,
  				x + 2 / 3, y + 1, 0,
  				x, y, 0,
  				x + 2 / 3, y + 1, 0,
  				x, y + 1, 0
  			];
  			position.set( coordinates, positionSize * vertices * face );
  			uv.set( uv1, uvSize * vertices * face );
  			const fill = [ face, face, face, face, face, face ];
  			faceIndex.set( fill, faceIndexSize * vertices * face );

  		}

  		const planes = new BufferGeometry();
  		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
  		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
  		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
  		_lodPlanes.push( planes );

  		if ( lod > LOD_MIN ) {

  			lod --;

  		}

  	}

  	return { _lodPlanes, _sizeLods, _sigmas };

  }

  function _createRenderTarget( params ) {

  	const cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );
  	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
  	cubeUVRenderTarget.scissorTest = true;
  	return cubeUVRenderTarget;

  }

  function _setViewport( target, x, y, width, height ) {

  	target.viewport.set( x, y, width, height );
  	target.scissor.set( x, y, width, height );

  }

  function _getBlurShader( maxSamples ) {

  	const weights = new Float32Array( maxSamples );
  	const poleAxis = new Vector3( 0, 1, 0 );
  	const shaderMaterial = new RawShaderMaterial( {

  		name: 'SphericalGaussianBlur',

  		defines: { 'n': maxSamples },

  		uniforms: {
  			'envMap': { value: null },
  			'samples': { value: 1 },
  			'weights': { value: weights },
  			'latitudinal': { value: false },
  			'dTheta': { value: 0 },
  			'mipInt': { value: 0 },
  			'poleAxis': { value: poleAxis },
  			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
  			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
  		},

  		vertexShader: _getCommonVertexShader(),

  		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${ _getEncodings() }

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

  		blending: NoBlending,
  		depthTest: false,
  		depthWrite: false

  	} );

  	return shaderMaterial;

  }

  function _getEquirectShader() {

  	const texelSize = new Vector2( 1, 1 );
  	const shaderMaterial = new RawShaderMaterial( {

  		name: 'EquirectangularToCubeUV',

  		uniforms: {
  			'envMap': { value: null },
  			'texelSize': { value: texelSize },
  			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
  			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
  		},

  		vertexShader: _getCommonVertexShader(),

  		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${ _getEncodings() }

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

  		blending: NoBlending,
  		depthTest: false,
  		depthWrite: false

  	} );

  	return shaderMaterial;

  }

  function _getCubemapShader() {

  	const shaderMaterial = new RawShaderMaterial( {

  		name: 'CubemapToCubeUV',

  		uniforms: {
  			'envMap': { value: null },
  			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
  			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
  		},

  		vertexShader: _getCommonVertexShader(),

  		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${ _getEncodings() }

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

  		blending: NoBlending,
  		depthTest: false,
  		depthWrite: false

  	} );

  	return shaderMaterial;

  }

  function _getCommonVertexShader() {

  	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

  }

  function _getEncodings() {

  	return /* glsl */`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;

  }

  const LineStrip = 0;
  const LinePieces = 1;
  const NoColors = 0;
  const FaceColors = 1;
  const VertexColors = 2;

  function MeshFaceMaterial( materials ) {

  	console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
  	return materials;

  }

  function MultiMaterial( materials = [] ) {

  	console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
  	materials.isMultiMaterial = true;
  	materials.materials = materials;
  	materials.clone = function () {

  		return materials.slice();

  	};

  	return materials;

  }

  function PointCloud( geometry, material ) {

  	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
  	return new Points( geometry, material );

  }

  function Particle( material ) {

  	console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
  	return new Sprite( material );

  }

  function ParticleSystem( geometry, material ) {

  	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
  	return new Points( geometry, material );

  }

  function PointCloudMaterial( parameters ) {

  	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
  	return new PointsMaterial( parameters );

  }

  function ParticleBasicMaterial( parameters ) {

  	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
  	return new PointsMaterial( parameters );

  }

  function ParticleSystemMaterial( parameters ) {

  	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
  	return new PointsMaterial( parameters );

  }

  function Vertex( x, y, z ) {

  	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
  	return new Vector3( x, y, z );

  }

  //

  function DynamicBufferAttribute( array, itemSize ) {

  	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );
  	return new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );

  }

  function Int8Attribute( array, itemSize ) {

  	console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
  	return new Int8BufferAttribute( array, itemSize );

  }

  function Uint8Attribute( array, itemSize ) {

  	console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
  	return new Uint8BufferAttribute( array, itemSize );

  }

  function Uint8ClampedAttribute( array, itemSize ) {

  	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
  	return new Uint8ClampedBufferAttribute( array, itemSize );

  }

  function Int16Attribute( array, itemSize ) {

  	console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
  	return new Int16BufferAttribute( array, itemSize );

  }

  function Uint16Attribute( array, itemSize ) {

  	console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
  	return new Uint16BufferAttribute( array, itemSize );

  }

  function Int32Attribute( array, itemSize ) {

  	console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
  	return new Int32BufferAttribute( array, itemSize );

  }

  function Uint32Attribute( array, itemSize ) {

  	console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
  	return new Uint32BufferAttribute( array, itemSize );

  }

  function Float32Attribute( array, itemSize ) {

  	console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
  	return new Float32BufferAttribute( array, itemSize );

  }

  function Float64Attribute( array, itemSize ) {

  	console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
  	return new Float64BufferAttribute( array, itemSize );

  }

  //

  Curve.create = function ( construct, getPoint ) {

  	console.log( 'THREE.Curve.create() has been deprecated' );

  	construct.prototype = Object.create( Curve.prototype );
  	construct.prototype.constructor = construct;
  	construct.prototype.getPoint = getPoint;

  	return construct;

  };

  //

  Path.prototype.fromPoints = function ( points ) {

  	console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
  	return this.setFromPoints( points );

  };

  //

  function AxisHelper( size ) {

  	console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
  	return new AxesHelper( size );

  }

  function BoundingBoxHelper( object, color ) {

  	console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
  	return new BoxHelper( object, color );

  }

  function EdgesHelper( object, hex ) {

  	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
  	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

  }

  GridHelper.prototype.setColors = function () {

  	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

  };

  SkeletonHelper.prototype.update = function () {

  	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

  };

  function WireframeHelper( object, hex ) {

  	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
  	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

  }

  //

  Loader.prototype.extractUrlBase = function ( url ) {

  	console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
  	return LoaderUtils.extractUrlBase( url );

  };

  Loader.Handlers = {

  	add: function ( /* regex, loader */ ) {

  		console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

  	},

  	get: function ( /* file */ ) {

  		console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

  	}

  };

  function XHRLoader( manager ) {

  	console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
  	return new FileLoader( manager );

  }

  function BinaryTextureLoader( manager ) {

  	console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
  	return new DataTextureLoader( manager );

  }

  //

  Box2.prototype.center = function ( optionalTarget ) {

  	console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
  	return this.getCenter( optionalTarget );

  };

  Box2.prototype.empty = function () {

  	console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
  	return this.isEmpty();

  };

  Box2.prototype.isIntersectionBox = function ( box ) {

  	console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
  	return this.intersectsBox( box );

  };

  Box2.prototype.size = function ( optionalTarget ) {

  	console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
  	return this.getSize( optionalTarget );

  };

  //

  Box3.prototype.center = function ( optionalTarget ) {

  	console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
  	return this.getCenter( optionalTarget );

  };

  Box3.prototype.empty = function () {

  	console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
  	return this.isEmpty();

  };

  Box3.prototype.isIntersectionBox = function ( box ) {

  	console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
  	return this.intersectsBox( box );

  };

  Box3.prototype.isIntersectionSphere = function ( sphere ) {

  	console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
  	return this.intersectsSphere( sphere );

  };

  Box3.prototype.size = function ( optionalTarget ) {

  	console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
  	return this.getSize( optionalTarget );

  };

  //

  Sphere.prototype.empty = function () {

  	console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );
  	return this.isEmpty();

  };

  //

  Frustum.prototype.setFromMatrix = function ( m ) {

  	console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
  	return this.setFromProjectionMatrix( m );

  };

  //

  Line3.prototype.center = function ( optionalTarget ) {

  	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
  	return this.getCenter( optionalTarget );

  };

  //

  Matrix3.prototype.flattenToArrayOffset = function ( array, offset ) {

  	console.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
  	return this.toArray( array, offset );

  };

  Matrix3.prototype.multiplyVector3 = function ( vector ) {

  	console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
  	return vector.applyMatrix3( this );

  };

  Matrix3.prototype.multiplyVector3Array = function ( /* a */ ) {

  	console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

  };

  Matrix3.prototype.applyToBufferAttribute = function ( attribute ) {

  	console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
  	return attribute.applyMatrix3( this );

  };

  Matrix3.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

  	console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

  };

  Matrix3.prototype.getInverse = function ( matrix ) {

  	console.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
  	return this.copy( matrix ).invert();

  };

  //

  Matrix4.prototype.extractPosition = function ( m ) {

  	console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
  	return this.copyPosition( m );

  };

  Matrix4.prototype.flattenToArrayOffset = function ( array, offset ) {

  	console.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
  	return this.toArray( array, offset );

  };

  Matrix4.prototype.getPosition = function () {

  	console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
  	return new Vector3().setFromMatrixColumn( this, 3 );

  };

  Matrix4.prototype.setRotationFromQuaternion = function ( q ) {

  	console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
  	return this.makeRotationFromQuaternion( q );

  };

  Matrix4.prototype.multiplyToArray = function () {

  	console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

  };

  Matrix4.prototype.multiplyVector3 = function ( vector ) {

  	console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
  	return vector.applyMatrix4( this );

  };

  Matrix4.prototype.multiplyVector4 = function ( vector ) {

  	console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
  	return vector.applyMatrix4( this );

  };

  Matrix4.prototype.multiplyVector3Array = function ( /* a */ ) {

  	console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

  };

  Matrix4.prototype.rotateAxis = function ( v ) {

  	console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
  	v.transformDirection( this );

  };

  Matrix4.prototype.crossVector = function ( vector ) {

  	console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
  	return vector.applyMatrix4( this );

  };

  Matrix4.prototype.translate = function () {

  	console.error( 'THREE.Matrix4: .translate() has been removed.' );

  };

  Matrix4.prototype.rotateX = function () {

  	console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

  };

  Matrix4.prototype.rotateY = function () {

  	console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

  };

  Matrix4.prototype.rotateZ = function () {

  	console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

  };

  Matrix4.prototype.rotateByAxis = function () {

  	console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

  };

  Matrix4.prototype.applyToBufferAttribute = function ( attribute ) {

  	console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
  	return attribute.applyMatrix4( this );

  };

  Matrix4.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

  	console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

  };

  Matrix4.prototype.makeFrustum = function ( left, right, bottom, top, near, far ) {

  	console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
  	return this.makePerspective( left, right, top, bottom, near, far );

  };

  Matrix4.prototype.getInverse = function ( matrix ) {

  	console.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
  	return this.copy( matrix ).invert();

  };

  //

  Plane.prototype.isIntersectionLine = function ( line ) {

  	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
  	return this.intersectsLine( line );

  };

  //

  Quaternion.prototype.multiplyVector3 = function ( vector ) {

  	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
  	return vector.applyQuaternion( this );

  };

  Quaternion.prototype.inverse = function ( ) {

  	console.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );
  	return this.invert();

  };

  //

  Ray.prototype.isIntersectionBox = function ( box ) {

  	console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
  	return this.intersectsBox( box );

  };

  Ray.prototype.isIntersectionPlane = function ( plane ) {

  	console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
  	return this.intersectsPlane( plane );

  };

  Ray.prototype.isIntersectionSphere = function ( sphere ) {

  	console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
  	return this.intersectsSphere( sphere );

  };

  //

  Triangle.prototype.area = function () {

  	console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
  	return this.getArea();

  };

  Triangle.prototype.barycoordFromPoint = function ( point, target ) {

  	console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
  	return this.getBarycoord( point, target );

  };

  Triangle.prototype.midpoint = function ( target ) {

  	console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
  	return this.getMidpoint( target );

  };

  Triangle.prototypenormal = function ( target ) {

  	console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
  	return this.getNormal( target );

  };

  Triangle.prototype.plane = function ( target ) {

  	console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
  	return this.getPlane( target );

  };

  Triangle.barycoordFromPoint = function ( point, a, b, c, target ) {

  	console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
  	return Triangle.getBarycoord( point, a, b, c, target );

  };

  Triangle.normal = function ( a, b, c, target ) {

  	console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
  	return Triangle.getNormal( a, b, c, target );

  };

  //

  Shape.prototype.extractAllPoints = function ( divisions ) {

  	console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
  	return this.extractPoints( divisions );

  };

  Shape.prototype.extrude = function ( options ) {

  	console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
  	return new ExtrudeGeometry( this, options );

  };

  Shape.prototype.makeGeometry = function ( options ) {

  	console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
  	return new ShapeGeometry( this, options );

  };

  //

  Vector2.prototype.fromAttribute = function ( attribute, index, offset ) {

  	console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
  	return this.fromBufferAttribute( attribute, index, offset );

  };

  Vector2.prototype.distanceToManhattan = function ( v ) {

  	console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
  	return this.manhattanDistanceTo( v );

  };

  Vector2.prototype.lengthManhattan = function () {

  	console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
  	return this.manhattanLength();

  };

  //

  Vector3.prototype.setEulerFromRotationMatrix = function () {

  	console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

  };

  Vector3.prototype.setEulerFromQuaternion = function () {

  	console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

  };

  Vector3.prototype.getPositionFromMatrix = function ( m ) {

  	console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
  	return this.setFromMatrixPosition( m );

  };

  Vector3.prototype.getScaleFromMatrix = function ( m ) {

  	console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
  	return this.setFromMatrixScale( m );

  };

  Vector3.prototype.getColumnFromMatrix = function ( index, matrix ) {

  	console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
  	return this.setFromMatrixColumn( matrix, index );

  };

  Vector3.prototype.applyProjection = function ( m ) {

  	console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
  	return this.applyMatrix4( m );

  };

  Vector3.prototype.fromAttribute = function ( attribute, index, offset ) {

  	console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
  	return this.fromBufferAttribute( attribute, index, offset );

  };

  Vector3.prototype.distanceToManhattan = function ( v ) {

  	console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
  	return this.manhattanDistanceTo( v );

  };

  Vector3.prototype.lengthManhattan = function () {

  	console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
  	return this.manhattanLength();

  };

  //

  Vector4$1.prototype.fromAttribute = function ( attribute, index, offset ) {

  	console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
  	return this.fromBufferAttribute( attribute, index, offset );

  };

  Vector4$1.prototype.lengthManhattan = function () {

  	console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
  	return this.manhattanLength();

  };

  //

  Object3D.prototype.getChildByName = function ( name ) {

  	console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
  	return this.getObjectByName( name );

  };

  Object3D.prototype.renderDepth = function () {

  	console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

  };

  Object3D.prototype.translate = function ( distance, axis ) {

  	console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
  	return this.translateOnAxis( axis, distance );

  };

  Object3D.prototype.getWorldRotation = function () {

  	console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

  };

  Object3D.prototype.applyMatrix = function ( matrix ) {

  	console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
  	return this.applyMatrix4( matrix );

  };

  Object.defineProperties( Object3D.prototype, {

  	eulerOrder: {
  		get: function () {

  			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
  			return this.rotation.order;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
  			this.rotation.order = value;

  		}
  	},
  	useQuaternion: {
  		get: function () {

  			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  		},
  		set: function () {

  			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  		}
  	}

  } );

  Mesh.prototype.setDrawMode = function () {

  	console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

  };

  Object.defineProperties( Mesh.prototype, {

  	drawMode: {
  		get: function () {

  			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
  			return TrianglesDrawMode;

  		},
  		set: function () {

  			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

  		}
  	}

  } );

  SkinnedMesh.prototype.initBones = function () {

  	console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

  };

  //

  PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

  	console.warn( 'THREE.PerspectiveCamera.setLens is deprecated. ' +
  			'Use .setFocalLength and .filmGauge for a photographic setup.' );

  	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
  	this.setFocalLength( focalLength );

  };

  //

  Object.defineProperties( Light.prototype, {
  	onlyShadow: {
  		set: function () {

  			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

  		}
  	},
  	shadowCameraFov: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
  			this.shadow.camera.fov = value;

  		}
  	},
  	shadowCameraLeft: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
  			this.shadow.camera.left = value;

  		}
  	},
  	shadowCameraRight: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
  			this.shadow.camera.right = value;

  		}
  	},
  	shadowCameraTop: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
  			this.shadow.camera.top = value;

  		}
  	},
  	shadowCameraBottom: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
  			this.shadow.camera.bottom = value;

  		}
  	},
  	shadowCameraNear: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
  			this.shadow.camera.near = value;

  		}
  	},
  	shadowCameraFar: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
  			this.shadow.camera.far = value;

  		}
  	},
  	shadowCameraVisible: {
  		set: function () {

  			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

  		}
  	},
  	shadowBias: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
  			this.shadow.bias = value;

  		}
  	},
  	shadowDarkness: {
  		set: function () {

  			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

  		}
  	},
  	shadowMapWidth: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
  			this.shadow.mapSize.width = value;

  		}
  	},
  	shadowMapHeight: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
  			this.shadow.mapSize.height = value;

  		}
  	}
  } );

  //

  Object.defineProperties( BufferAttribute.prototype, {

  	length: {
  		get: function () {

  			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
  			return this.array.length;

  		}
  	},
  	dynamic: {
  		get: function () {

  			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
  			return this.usage === DynamicDrawUsage;

  		},
  		set: function ( /* value */ ) {

  			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
  			this.setUsage( DynamicDrawUsage );

  		}
  	}

  } );

  BufferAttribute.prototype.setDynamic = function ( value ) {

  	console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
  	this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
  	return this;

  };

  BufferAttribute.prototype.copyIndicesArray = function ( /* indices */ ) {

  	console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

  },

  BufferAttribute.prototype.setArray = function ( /* array */ ) {

  	console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

  };

  //

  BufferGeometry.prototype.addIndex = function ( index ) {

  	console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
  	this.setIndex( index );

  };

  BufferGeometry.prototype.addAttribute = function ( name, attribute ) {

  	console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

  	if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

  		console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

  		return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

  	}

  	if ( name === 'index' ) {

  		console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
  		this.setIndex( attribute );

  		return this;

  	}

  	return this.setAttribute( name, attribute );

  };

  BufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset ) {

  	if ( indexOffset !== undefined ) {

  		console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

  	}

  	console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
  	this.addGroup( start, count );

  };

  BufferGeometry.prototype.clearDrawCalls = function () {

  	console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
  	this.clearGroups();

  };

  BufferGeometry.prototype.computeOffsets = function () {

  	console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

  };

  BufferGeometry.prototype.removeAttribute = function ( name ) {

  	console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

  	return this.deleteAttribute( name );

  };

  BufferGeometry.prototype.applyMatrix = function ( matrix ) {

  	console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
  	return this.applyMatrix4( matrix );

  };

  Object.defineProperties( BufferGeometry.prototype, {

  	drawcalls: {
  		get: function () {

  			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
  			return this.groups;

  		}
  	},
  	offsets: {
  		get: function () {

  			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
  			return this.groups;

  		}
  	}

  } );

  InterleavedBuffer.prototype.setDynamic = function ( value ) {

  	console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
  	this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
  	return this;

  };

  InterleavedBuffer.prototype.setArray = function ( /* array */ ) {

  	console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

  };

  //

  ExtrudeGeometry.prototype.getArrays = function () {

  	console.error( 'THREE.ExtrudeGeometry: .getArrays() has been removed.' );

  };

  ExtrudeGeometry.prototype.addShapeList = function () {

  	console.error( 'THREE.ExtrudeGeometry: .addShapeList() has been removed.' );

  };

  ExtrudeGeometry.prototype.addShape = function () {

  	console.error( 'THREE.ExtrudeGeometry: .addShape() has been removed.' );

  };

  //

  Scene.prototype.dispose = function () {

  	console.error( 'THREE.Scene: .dispose() has been removed.' );

  };

  //

  Uniform.prototype.onUpdate = function () {

  	console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
  	return this;

  };

  //

  Object.defineProperties( Material.prototype, {

  	wrapAround: {
  		get: function () {

  			console.warn( 'THREE.Material: .wrapAround has been removed.' );

  		},
  		set: function () {

  			console.warn( 'THREE.Material: .wrapAround has been removed.' );

  		}
  	},

  	overdraw: {
  		get: function () {

  			console.warn( 'THREE.Material: .overdraw has been removed.' );

  		},
  		set: function () {

  			console.warn( 'THREE.Material: .overdraw has been removed.' );

  		}
  	},

  	wrapRGB: {
  		get: function () {

  			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
  			return new Color();

  		}
  	},

  	shading: {
  		get: function () {

  			console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
  			this.flatShading = ( value === FlatShading );

  		}
  	},

  	stencilMask: {
  		get: function () {

  			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
  			return this.stencilFuncMask;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
  			this.stencilFuncMask = value;

  		}
  	}

  } );

  Object.defineProperties( ShaderMaterial.prototype, {

  	derivatives: {
  		get: function () {

  			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
  			return this.extensions.derivatives;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
  			this.extensions.derivatives = value;

  		}
  	}

  } );

  //

  WebGLRenderer.prototype.clearTarget = function ( renderTarget, color, depth, stencil ) {

  	console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
  	this.setRenderTarget( renderTarget );
  	this.clear( color, depth, stencil );

  };

  WebGLRenderer.prototype.animate = function ( callback ) {

  	console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
  	this.setAnimationLoop( callback );

  };

  WebGLRenderer.prototype.getCurrentRenderTarget = function () {

  	console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
  	return this.getRenderTarget();

  };

  WebGLRenderer.prototype.getMaxAnisotropy = function () {

  	console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
  	return this.capabilities.getMaxAnisotropy();

  };

  WebGLRenderer.prototype.getPrecision = function () {

  	console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
  	return this.capabilities.precision;

  };

  WebGLRenderer.prototype.resetGLState = function () {

  	console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
  	return this.state.reset();

  };

  WebGLRenderer.prototype.supportsFloatTextures = function () {

  	console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
  	return this.extensions.get( 'OES_texture_float' );

  };

  WebGLRenderer.prototype.supportsHalfFloatTextures = function () {

  	console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
  	return this.extensions.get( 'OES_texture_half_float' );

  };

  WebGLRenderer.prototype.supportsStandardDerivatives = function () {

  	console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
  	return this.extensions.get( 'OES_standard_derivatives' );

  };

  WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {

  	console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
  	return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

  };

  WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {

  	console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
  	return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  };

  WebGLRenderer.prototype.supportsBlendMinMax = function () {

  	console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
  	return this.extensions.get( 'EXT_blend_minmax' );

  };

  WebGLRenderer.prototype.supportsVertexTextures = function () {

  	console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
  	return this.capabilities.vertexTextures;

  };

  WebGLRenderer.prototype.supportsInstancedArrays = function () {

  	console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
  	return this.extensions.get( 'ANGLE_instanced_arrays' );

  };

  WebGLRenderer.prototype.enableScissorTest = function ( boolean ) {

  	console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
  	this.setScissorTest( boolean );

  };

  WebGLRenderer.prototype.initMaterial = function () {

  	console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

  };

  WebGLRenderer.prototype.addPrePlugin = function () {

  	console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

  };

  WebGLRenderer.prototype.addPostPlugin = function () {

  	console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

  };

  WebGLRenderer.prototype.updateShadowMap = function () {

  	console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

  };

  WebGLRenderer.prototype.setFaceCulling = function () {

  	console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

  };

  WebGLRenderer.prototype.allocTextureUnit = function () {

  	console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

  };

  WebGLRenderer.prototype.setTexture = function () {

  	console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

  };

  WebGLRenderer.prototype.setTexture2D = function () {

  	console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

  };

  WebGLRenderer.prototype.setTextureCube = function () {

  	console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

  };

  WebGLRenderer.prototype.getActiveMipMapLevel = function () {

  	console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
  	return this.getActiveMipmapLevel();

  };

  Object.defineProperties( WebGLRenderer.prototype, {

  	shadowMapEnabled: {
  		get: function () {

  			return this.shadowMap.enabled;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
  			this.shadowMap.enabled = value;

  		}
  	},
  	shadowMapType: {
  		get: function () {

  			return this.shadowMap.type;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
  			this.shadowMap.type = value;

  		}
  	},
  	shadowMapCullFace: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
  			return undefined;

  		},
  		set: function ( /* value */ ) {

  			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

  		}
  	},
  	context: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
  			return this.getContext();

  		}
  	},
  	vr: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
  			return this.xr;

  		}
  	},
  	gammaInput: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
  			return false;

  		},
  		set: function () {

  			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

  		}
  	},
  	gammaOutput: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
  			return false;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
  			this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

  		}
  	},
  	toneMappingWhitePoint: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );
  			return 1.0;

  		},
  		set: function () {

  			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );

  		}
  	},

  } );

  Object.defineProperties( WebGLShadowMap.prototype, {

  	cullFace: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
  			return undefined;

  		},
  		set: function ( /* cullFace */ ) {

  			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

  		}
  	},
  	renderReverseSided: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
  			return undefined;

  		},
  		set: function () {

  			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

  		}
  	},
  	renderSingleSided: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
  			return undefined;

  		},
  		set: function () {

  			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

  		}
  	}

  } );

  function WebGLRenderTargetCube( width, height, options ) {

  	console.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );
  	return new WebGLCubeRenderTarget( width, options );

  }

  //

  Object.defineProperties( WebGLRenderTarget.prototype, {

  	wrapS: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
  			return this.texture.wrapS;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
  			this.texture.wrapS = value;

  		}
  	},
  	wrapT: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
  			return this.texture.wrapT;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
  			this.texture.wrapT = value;

  		}
  	},
  	magFilter: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
  			return this.texture.magFilter;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
  			this.texture.magFilter = value;

  		}
  	},
  	minFilter: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
  			return this.texture.minFilter;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
  			this.texture.minFilter = value;

  		}
  	},
  	anisotropy: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
  			return this.texture.anisotropy;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
  			this.texture.anisotropy = value;

  		}
  	},
  	offset: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
  			return this.texture.offset;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
  			this.texture.offset = value;

  		}
  	},
  	repeat: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
  			return this.texture.repeat;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
  			this.texture.repeat = value;

  		}
  	},
  	format: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
  			return this.texture.format;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
  			this.texture.format = value;

  		}
  	},
  	type: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
  			return this.texture.type;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
  			this.texture.type = value;

  		}
  	},
  	generateMipmaps: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
  			return this.texture.generateMipmaps;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
  			this.texture.generateMipmaps = value;

  		}
  	}

  } );

  //

  Audio.prototype.load = function ( file ) {

  	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
  	const scope = this;
  	const audioLoader = new AudioLoader();
  	audioLoader.load( file, function ( buffer ) {

  		scope.setBuffer( buffer );

  	} );
  	return this;

  };


  AudioAnalyser.prototype.getData = function () {

  	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
  	return this.getFrequencyData();

  };

  //

  CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

  	console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
  	return this.update( renderer, scene );

  };

  CubeCamera.prototype.clear = function ( renderer, color, depth, stencil ) {

  	console.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );
  	return this.renderTarget.clear( renderer, color, depth, stencil );

  };

  ImageUtils.crossOrigin = undefined;

  ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

  	console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

  	const loader = new TextureLoader();
  	loader.setCrossOrigin( this.crossOrigin );

  	const texture = loader.load( url, onLoad, undefined, onError );

  	if ( mapping ) texture.mapping = mapping;

  	return texture;

  };

  ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

  	console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

  	const loader = new CubeTextureLoader();
  	loader.setCrossOrigin( this.crossOrigin );

  	const texture = loader.load( urls, onLoad, undefined, onError );

  	if ( mapping ) texture.mapping = mapping;

  	return texture;

  };

  ImageUtils.loadCompressedTexture = function () {

  	console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

  };

  ImageUtils.loadCompressedTextureCube = function () {

  	console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

  };

  //

  function CanvasRenderer() {

  	console.error( 'THREE.CanvasRenderer has been removed' );

  }

  //

  function JSONLoader() {

  	console.error( 'THREE.JSONLoader has been removed.' );

  }

  //

  const SceneUtils = {

  	createMultiMaterialObject: function ( /* geometry, materials */ ) {

  		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

  	},

  	detach: function ( /* child, parent, scene */ ) {

  		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

  	},

  	attach: function ( /* child, scene, parent */ ) {

  		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

  	}

  };

  //

  function LensFlare() {

  	console.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );

  }

  if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  	/* eslint-disable no-undef */
  	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
  		revision: REVISION,
  	} } ) );
  	/* eslint-enable no-undef */

  }

  if ( typeof window !== 'undefined' ) {

  	if ( window.__THREE__ ) {

  		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

  	} else {

  		window.__THREE__ = REVISION;

  	}

  }

  /**
   *  Three targets are provided for both GLSL and Sculpt/JS api.
   * 
   *  1: source -> Threejs shader source components (easy customization)
   *  2: source -> Threejs material
   *  3: source -> Threejs mesh (easy to use)
   * 
   * TODO: make these materials 'plug in' to threejs' lighting model, like unity's surface shaders
   */

  function glslToThreeJSShaderSource(source) {
    return {
      uniforms: baseUniforms(),
      frag: threeHeader + 'const float STEP_SIZE_CONSTANT = 0.9;\n' + 'const int MAX_ITERATIONS = 300;\n' + uniformsToGLSL(baseUniforms()) + sculptureStarterCode + source + fragFooter,
      vert: threeJSVertexSource
    };
  }
  function glslToThreeJSMaterial(source, payload) {
    var src = glslToThreeJSShaderSource(source);
    return makeMaterial(src.uniforms, src.vert, src.frag, payload);
  }
  function glslToThreeJSMesh(source, payload) {
    return makeBasicMesh(glslToThreeJSMaterial(source, payload));
  }
  function sculptToThreeJSShaderSource(source) {
    var src = sculptToGLSL(source);

    if (src.error) {
      console.log(src.error);
    }

    var frg = threeHeader + usePBRHeader + useHemisphereLight + uniformsToGLSL(src.uniforms) + 'const float STEP_SIZE_CONSTANT = ' + src.stepSizeConstant + ';\n' + 'const int MAX_ITERATIONS = ' + src.maxIterations + ';\n' + sculptureStarterCode + src.geoGLSL + '\n' + src.colorGLSL + '\n' + fragFooter;
    return {
      uniforms: src.uniforms,
      frag: frg,
      vert: threeJSVertexSource,
      error: src.error,
      geoGLSL: src.geoGLSL,
      colorGLSL: src.colorGLSL
    };
  }
  function sculptToThreeJSMaterial(source, payload) {
    var src = sculptToThreeJSShaderSource(source);
    var material = makeMaterial(src.uniforms, src.vert, src.frag, payload);
    material.uniformDescriptions = src.uniforms;
    return material;
  }
  function sculptToThreeJSMesh(source, payload) {
    if (typeof source === "function") {
      source = source.toString();
      source = source.slice(source.indexOf("{") + 1, source.lastIndexOf("}"));
    } else if (!(typeof source === "string")) {
      throw "sculptToThreeJSMesh requires the source code to be a function, or a string";
    }

    return makeBasicMesh(sculptToThreeJSMaterial(source, payload));
  }
  function createSculptureWithGeometry(geometry, source) {
    var uniformCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
      return {};
    };
    var params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    geometry.computeBoundingSphere();
    var radius = 'radius' in params ? params.radius : geometry.boundingSphere.radius;
    params.radius = radius;
    params.geometry = geometry;
    return createSculpture(source, uniformCallback, params);
  } // uniformCallback 

  function createSculpture(source) {
    var uniformCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
      return {};
    };
    var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (typeof source === "function") {
      source = source.toString();
      source = source.slice(source.indexOf("{") + 1, source.lastIndexOf("}"));
    } else if (!(typeof source === "string")) {
      throw "sculptToThreeJSMesh requires the source code to be a function, or a string";
    }

    var radius = 'radius' in params ? params.radius : 2;
    var segments = 'segments' in params ? params.segments : 8;
    var geometry = new SphereGeometry(radius, segments, segments);

    if ('geometry' in params) {
      geometry = params.geometry;
    }

    var material = sculptToThreeJSMaterial(source);
    material.uniforms['opacity'].value = 1.0;
    material.uniforms['mouse'].value = new Vector3();
    material.uniforms['_scale'].value = radius;
    var mesh = new Mesh(geometry, material);

    mesh.onBeforeRender = function (renderer, scene, camera, geometry, material, group) {
      var uniformsToUpdate = uniformCallback();

      if (!(_typeof(uniformsToUpdate) === "object")) {
        throw "createSculpture takes, (source, uniformCallback, params) the uniformCallback must be a function that returns a dictionary of uniforms to update";
      }

      for (var _i = 0, _Object$entries = Object.entries(uniformsToUpdate); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            uniform = _Object$entries$_i[0],
            value = _Object$entries$_i[1];

        material.uniforms[uniform].value = value;
      } // material.uniforms['sculptureCenter'].value = geometry.position;

    };

    return mesh;
  }

  function uniformDescriptionToThreeJSFormat(unifs, payload) {
    var finalUniforms = {};

    if (payload && payload !== undefined && payload.msdfTexture !== undefined) {
      finalUniforms["msdf"] = {
        value: payload.msdfTexture || new Texture()
      };
    }

    unifs.forEach(function (uniform) {
      if (uniform.type === 'float') {
        finalUniforms[uniform.name] = {
          value: uniform.value
        };
      } else if (uniform.type === 'vec2') {
        finalUniforms[uniform.name] = {
          value: new Vector2(uniform.value.x, uniform.value.y)
        };
      } else if (uniform.type === 'vec3') {
        finalUniforms[uniform.name] = {
          value: new Vector3(uniform.value.x, uniform.value.y, uniform.value.z)
        };
      } else if (uniform.type === 'vec4') {
        finalUniforms[uniform.name] = {
          value: new Vector4(uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w)
        };
      }
    });
    return finalUniforms;
  } // could use a scale parameter


  function makeMaterial(unifs, vert, frag, payload) {
    var material = new ShaderMaterial({
      uniforms: uniformDescriptionToThreeJSFormat(unifs, payload),
      vertexShader: vert,
      fragmentShader: frag,
      transparent: true,
      side: BackSide
    });
    material.extensions.fragDepth = false;
    return material;
  } // There should be more options supported like size and shape


  function makeBasicMesh(material) {
    return new Mesh(new BoxGeometry(2, 2, 2), material);
  }

  function uniformToCpp(uniforms) {
    var res = '';

    for (var i = 0; i < uniforms.length; i++) {
      var unif = uniforms[i];
      res += unif.type + ' ' + unif.name + ' = ';

      if (typeof unif.value === 'number') {
        // float
        res += unif.value + 0.0000001 + 'f';
      } else {
        // vec
        res += 'vec' + unif.value.length + '(';

        for (var j = 0; j < unif.value.length; j++) {
          res += unif.value[j] + 0.0000001 + 'f';

          if (j + 1 < unif.value.length) {
            res += ', ';
          }
        }

        res += ')';
      }

      res += ';\n';
    }

    return res;
  }

  var cppFooter = "\n\n";
  var cppHeader = uniformToCpp(baseUniforms());

  function glslToGLM(source) {
    // converts all numbers to floats
    var result = source.replace(/([^a-zA-Z][0-9]+([.][^a-zA-Z][0-9]*)|[.][0-9]+)()/g, '$1f'); // adds parentheses after swizzling for glm to pick up  

    result = result.replace(/([a-zA-Z0-9][.][w-z]{2,})()/g, '$1()');
    return result;
  }

  function glslToOfflineRenderer(source) {}
  function sculptToOfflineRenderer(source) {
    var src = sculptToGLSL(source); //console.log(filteredStarter);

    return cppHeader + glslToGLM('const float STEP_SIZE_CONSTANT = ' + src.stepSizeConstant + 'f;\n' + 'const int MAX_ITERATIONS = ' + src.maxIterations + ';\n' + sculptureStarterCode + src.geoGLSL + src.colorGLSL) + cppFooter;
  }

  function glslToMinimalRenderer(canvas, source, updateUniforms) {
    var fullFrag = minimalHeader + usePBRHeader + useHemisphereLight + uniformsToGLSL(baseUniforms()) + 'const float STEP_SIZE_CONSTANT = 0.9;\n' + 'const int MAX_ITERATIONS = 300;\n' + sculptureStarterCode + source + fragFooter;
    return fragToMinimalRenderer(canvas, fullFrag, updateUniforms);
  }
  /**
   * for fast and efficient use on the web
   * input - sculpt code
   * output - a fully self-contained lightweight html file which renders the sculpture
   **/

  function sculptToMinimalRenderer(canvas, source, updateUniforms) {
    if (typeof source === "function") {
      source = source.toString();
      source = source.slice(source.indexOf("{") + 1, source.lastIndexOf("}"));
    } else if (!(typeof source === "string")) {
      throw "sculptToMinimalRenderer requires the source code to be a function, or a string";
    }

    var generatedGLSL = sculptToGLSL(source);
    var fullFrag = minimalHeader + usePBRHeader + useHemisphereLight + uniformsToGLSL(generatedGLSL.uniforms) + 'const float STEP_SIZE_CONSTANT = ' + generatedGLSL.stepSizeConstant + ';\n' + 'const int MAX_ITERATIONS = ' + generatedGLSL.maxIterations + ';\n' + sculptureStarterCode + generatedGLSL.geoGLSL + '\n' + generatedGLSL.colorGLSL + '\n' + fragFooter;
    return fragToMinimalRenderer(canvas, fullFrag, updateUniforms);
  }

  function fragToMinimalRenderer(canvas, fullFrag, updateUniforms) {
    // if no update function is provided assume no-op
    if (updateUniforms === undefined) {
      updateUniforms = function updateUniforms() {
        return {};
      };
    }

    function resizeCanvas() {
      var devicePixelRatio = window.devicePixelRatio || 1; // change this so canvas doesn't have to fill entire window

      var width = window.innerWidth * devicePixelRatio;
      var height = window.innerHeight * devicePixelRatio;

      if (canvas.width != width || canvas.height != height) {
        canvas.width = width;
        canvas.height = height;
      }
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    var gl = canvas.getContext('webgl');
    var vertices = [-1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0];
    var indices = [3, 2, 1, 3, 1, 0];
    var vertex_buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    var Index_Buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    var vertShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, minimalVertexSource);
    gl.compileShader(vertShader);
    var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, fullFrag);
    gl.compileShader(fragShader);
    var compiled = gl.getShaderParameter(fragShader, gl.COMPILE_STATUS);
    console.log('Shader compiled successfully: ' + compiled);
    var compilationLog = gl.getShaderInfoLog(fragShader);
    if (!compiled) console.log('Shader compiler log: ' + compilationLog);
    var shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertShader);
    gl.attachShader(shaderProgram, fragShader);
    gl.linkProgram(shaderProgram);
    gl.useProgram(shaderProgram);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);
    var coord = gl.getAttribLocation(shaderProgram, "coordinates");
    gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(coord);
    gl.clearColor(1.0, 1.0, 1.0, 0.9);
    gl.enable(gl.DEPTH_TEST);
    var oTime = Date.now();
    var loc = gl.getUniformLocation(shaderProgram, "time");

    var _scale = gl.getUniformLocation(shaderProgram, "_scale");

    var resolution = gl.getUniformLocation(shaderProgram, "resolution");
    var opac = gl.getUniformLocation(shaderProgram, "opacity");
    var mouseloc = gl.getUniformLocation(shaderProgram, "mouse");
    gl.uniform1f(opac, 1.0);
    gl.uniform1f(_scale, 1.0);
    var userUniformUpdateFuncs = assignUniforms(updateUniforms);
    canvas.addEventListener("pointermove", function (e) {
      var devicePixelRatio = window.devicePixelRatio || 1;
      var canvasX = (e.pageX - canvas.offsetLeft) * devicePixelRatio;
      var canvasY = (e.pageY - canvas.offsetTop) * devicePixelRatio;
      gl.uniform3f(mouseloc, 2.0 * canvasX / canvas.width - 1.0, 2.0 * (1.0 - canvasY / canvas.height) - 1.0, -0.5);
    }, false);

    function updateDraw() {
      if (typeof updateUniforms === 'function') {
        callUniformFuncs(userUniformUpdateFuncs, updateUniforms());
      }

      gl.uniform1f(loc, (Date.now() - oTime) * 0.001);
      var devicePixelRatio = window.devicePixelRatio || 1;
      var wwidth = window.innerWidth * devicePixelRatio;
      var wheight = window.innerHeight * devicePixelRatio;
      gl.uniform2fv(resolution, [wwidth, wheight]);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
      window.requestAnimationFrame(updateDraw);
    }

    updateDraw(); // loops through a dictionary and calls the function sotred in the value

    function callUniformFuncs(uniformFuncs, updatedUniforms) {
      if (_typeof(updatedUniforms) !== 'object') {
        console.error('updateUniforms must return a dictionary of uniform names and values. Instead got: ', updateUniforms);
        return;
      }

      Object.entries(uniformFuncs).forEach(function (keys) {
        var _keys = _slicedToArray(keys, 2),
            key = _keys[0],
            uniformUpdateFunc = _keys[1];

        if (key in updatedUniforms) {
          uniformUpdateFunc(updatedUniforms[key]);
        }
      });
    }

    function assignUniforms(updateUniforms) {
      if (typeof updateUniforms !== 'function') {
        console.error('updateUniforms must be a function that returns a dictionary of uniform names and values');
        return {};
      }

      var userUniformUpdateFuncs = {};
      var uniformsDict = updateUniforms();

      if (uniformsDict !== undefined && _typeof(uniformsDict) === 'object') {
        Object.entries(uniformsDict).forEach(function (keys) {
          var _keys2 = _slicedToArray(keys, 2),
              key = _keys2[0],
              val = _keys2[1];

          var unifLocation = gl.getUniformLocation(shaderProgram, key);

          if (typeof val === 'number') {
            userUniformUpdateFuncs[key] = function (unif) {
              return gl.uniform1f(unifLocation, unif);
            };
          } else if (Array.isArray(val)) {
            if (val.length === 1) {
              userUniformUpdateFuncs[key] = function (unif) {
                return gl.uniform1f(unifLocation, unif[0]);
              };
            } else if (val.length === 2) {
              userUniformUpdateFuncs[key] = function (unif) {
                return gl.uniform2iv(unifLocation, unif);
              };
            } else if (val.length === 3) {
              userUniformUpdateFuncs[key] = function (unif) {
                return gl.uniform3iv(unifLocation, unif);
              };
            } else if (val.length === 4) {
              userUniformUpdateFuncs[key] = function (unif) {
                return gl.uniform4iv(unifLocation, unif);
              };
            } else {
              console.error('Uniforms must be either a float or an array with length 1, 2, 3 or 4');
            }
          } else {
            console.error('Uniforms must be either a float or an array with length 1, 2, 3 or 4');
          }
        });
      }

      return userUniformUpdateFuncs;
    }
  }

  /**
   * for fast tesing
   * input - sculpt code
   * output - self-contained lightweight html which renders the sculpture
   **/
  function sculptToMinimalHTMLRenderer(spCode, libPath) {
    return makeHTML(spCode, 'sculptToMinimalRenderer', libPath);
  }
  function glslToMinimalHTMLRenderer(spCode, libPath) {
    return makeHTML(spCode, 'glslToMinimalRenderer', libPath);
  }

  function makeHTML(spCode, minRenderFunc, libPath) {
    return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>Shader Park</title>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <style>\n        body {\n            margin: 2em;\n            width: 100vw; \n            height: 100vh; \n            margin : 0px; \n            padding : 0px;\n            border : 0px; \n            background-color : white;\n        }\n        canvas {\n            width: 100%;\n            height:100%;\n            margin : 0px;\n            padding : 0px;\n            border : 0px;\n            background-color : transparent;\n        }\n    </style>\n</head>  \n<body>    \n    <canvas class=\"my-canvas\"></canvas>\n    <script type=\"module\">\n    import {".concat(minRenderFunc, "} from '").concat(libPath, "';\n    let canvas = document.querySelector('.my-canvas');\n    ").concat(minRenderFunc, "(canvas, `").concat(spCode, "`);          \n    </script>\n</body>\n</html>");
  }

  /**
   * export for meshing with https://github.com/tdhooper/glsl-marching-cubes
   * input - sculpt code
   * output - glsl containing "mapDistance"
   **/

  function sculptToRawSDF4Meshing(source) {
    var minimalHeader = "\nprecision highp float;\n#define GLSL_NEED_ROUND\nuniform float w_width;\nuniform float w_height;\nuniform mat4 projectionMatrix;\n#define cameraPosition vec3(0.0,0.0,-1.0)\n#define vUv vec2(0.0)\n#define worldPos vec4(vec2((gl_FragCoord.x/w_width-0.5)*(w_width/w_height),gl_FragCoord.y/w_height-0.5)*1.75,0.0,0.0)\n#define STEP_SIZE_CONSTANT 0.9\n#define MAX_ITERATIONS 300\n#define stepSize 0.9\n#define mouse vec3(0.0)\n#define time 0.0\n";
    var generatedGLSL = sculptToGLSL(source);
    var fullFrag = minimalHeader + usePBRHeader + useHemisphereLight //+ uniformsToGLSL(generatedGLSL.uniforms) 
    + sculptureStarterCode + generatedGLSL.geoGLSL;
    return fullFrag.replace(/surfaceDistance/g, 'mapDistance');
  }

  /**
   *  TD target for GLSL and  Sculpt/JS api.
   * 
   *  TODO: make these materials 'plug in' to Touch Designer's ' PBR lighting model.
   */

  var TDHeader = "\nuniform float uShadowStrength;\nuniform vec3 uShadowColor;\nuniform vec4 uBaseColor;\nuniform float uMetallic;\nuniform float uRoughness;\nuniform float uSpecularLevel;\nuniform float uAmbientOcclusion;\nuniform vec3 cameraPosition;\nuniform sampler2D sBaseColorMap;\nuniform float useTDLighting;\n\n\nin Vertex\n{\n\tvec4 color;\n\tvec3 worldSpacePos;\n\tvec3 worldSpaceNorm;\n\tflat int cameraIndex;\n\tvec2 texCoord0;\n\tvec3 sculptureCenter;\n} iVert;\n\n#define sculptureCenter iVert.sculptureCenter;\n#define GLSL_NEED_ROUND\n#define worldPos iVert.worldSpacePos\nlayout(location = 0) out vec4 oFragColor[TD_NUM_COLOR_BUFFERS];\nout float depthTexture;\n";
  var TDFooter = "\nvoid main()\n{\n\t// This allows things such as order independent transparency\n\t// and Dual-Paraboloid rendering to work properly\n\tTDCheckDiscard();\n\n\t// Raymarching\n\tvec3 rayOrigin = worldPos.xyz-sculptureCenter;\n\tvec3 rayDirection = getRayDirection();\n\trayOrigin -= rayDirection*2.0;\n\tfloat t = intersect(rayOrigin, rayDirection, stepSize);\n    depthTexture = t;\n\n\tvec4 outcol = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec3 diffuseSum = vec3(0.0, 0.0, 0.0);\n\tvec3 specularSum = vec3(0.0, 0.0, 0.0);\n\n\tvec3 worldSpaceNorm = normalize(iVert.worldSpaceNorm.xyz);\n\t// vec3 normal = normalize(worldSpaceNorm.xyz);\n\tif(t < 2.5) {\n\t\tvec3 p = (rayOrigin + rayDirection*t);\n\t\tvec3 normal = calcNormal(p);\n\t\tvec3 raymarchedColor = shade(p, normal);\n\t\n\t\tvec3 baseColor = uBaseColor.rgb;\n\n\t\t// 0.08 is the value for dielectric specular that\n\t\t// Substance Designer uses for it's top-end.\n\t\tfloat specularLevel = 0.08 * uSpecularLevel;\n\t\tfloat metallic = uMetallic;\n\n\t\tfloat roughness = uRoughness;\n\n\t\tfloat ambientOcclusion = uAmbientOcclusion;\n\n\t\tvec3 finalBaseColor = baseColor.rgb * iVert.color.rgb;\n\n\t\tvec2 texCoord0 = iVert.texCoord0.st;\n\t\tvec4 baseColorMap = texture(sBaseColorMap, texCoord0.st);\n\t\tfinalBaseColor *= baseColorMap.rgb;\n\n\n\t\t// A roughness of exactly 0 is not allowed\n\t\troughness = max(roughness, 0.0001);\n\n\t\tvec3 pbrDiffuseColor = finalBaseColor * (1.0 - metallic);\n\t\tvec3 pbrSpecularColor = mix(vec3(specularLevel), finalBaseColor, metallic);\n\n\t\tvec3 viewVec = normalize(uTDMats[iVert.cameraIndex].camInverse[3].xyz - iVert.worldSpacePos.xyz );\n\n\n\t\t// Your shader will be recompiled based on the number\n\t\t// of lights in your scene, so this continues to work\n\t\t// even if you change your lighting setup after the shader\n\t\t// has been exported from the Phong MAT\n\t\tfor (int i = 0; i < TD_NUM_LIGHTS; i++)\n\t\t{\n\t\t\tTDPBRResult res;\n\t\t\tres = TDLightingPBR(i,\n\t\t\t\t\t\t\t\tpbrDiffuseColor,\n\t\t\t\t\t\t\t\tpbrSpecularColor,\n\t\t\t\t\t\t\t\tiVert.worldSpacePos.xyz,\n\t\t\t\t\t\t\t\tnormal,\n\t\t\t\t\t\t\t\tuShadowStrength, uShadowColor,\n\t\t\t\t\t\t\t\tviewVec,\n\t\t\t\t\t\t\t\troughness);\n\t\t\tdiffuseSum += res.diffuse;\n\t\t\tspecularSum += res.specular;\n\t\t}\n\n\t\t// Environment lights\n\t\tfor (int i = 0; i < TD_NUM_ENV_LIGHTS; i++)\n\t\t{\n\t\t\tTDPBRResult res;\n\t\t\tres = TDEnvLightingPBR(i,\n\t\t\t\t\t\tpbrDiffuseColor,\n\t\t\t\t\t\tpbrSpecularColor,\n\t\t\t\t\t\tnormal,\n\t\t\t\t\t\tviewVec,\n\t\t\t\t\t\troughness,\n\t\t\t\t\t\tambientOcclusion);\n\t\t\tdiffuseSum += res.diffuse;\n\t\t\tspecularSum += res.specular;\n\t\t}\n\t\t// Final Diffuse Contribution\n\t\tvec3 finalDiffuse = diffuseSum;\n\t\toutcol.rgb += finalDiffuse;\n\n\t\t// Final Specular Contribution\n\t\tvec3 finalSpecular = vec3(0.0);\n\t\tfinalSpecular += specularSum;\n\n\t\toutcol.rgb += finalSpecular;\n\n\n\t\t// Apply fog, this does nothing if fog is disabled\n\t\toutcol = TDFog(outcol, iVert.worldSpacePos.xyz, iVert.cameraIndex);\n\n\t\t// Alpha Calculation\n\t\tfloat alpha = uBaseColor.a * iVert.color.a ;\n\n\t\t// Dithering, does nothing if dithering is disabled\n\t\toutcol = TDDither(outcol);\n\n\t\toutcol.rgb *= alpha;\n\n\t\t// Modern GL removed the implicit alpha test, so we need to apply\n\t\t// it manually here. This function does nothing if alpha test is disabled.\n\t\tTDAlphaTest(alpha);\n\n\t\toutcol.a = alpha;\n\t\toutcol = mix(vec4(raymarchedColor, 1.0), outcol, useTDLighting);\n\t\toFragColor[0] = TDOutputSwizzle(outcol);\n\n\n\t\t// TD_NUM_COLOR_BUFFERS will be set to the number of color buffers\n\t\t// active in the render. By default we want to output zero to every\n\t\t// buffer except the first one.\n\t\tfor (int i = 1; i < TD_NUM_COLOR_BUFFERS; i++)\n\t\t{\n\t\t\toFragColor[i] = vec4(0.0);\n\t\t}\n\t} else {\n\t\tdiscard;\n\t}\n}\n";
  function glslToTouchDesignerShaderSource(source) {
    return {
      uniforms: baseUniforms(),
      frag: TDHeader + 'const float STEP_SIZE_CONSTANT = 0.9;\n' + 'const int MAX_ITERATIONS = 300;\n' + uniformsToGLSL(baseUniforms()) + sculptureStarterCode + source + TDFooter,
      vert: minimalVertexSource
    };
  }
  function sculptToTouchDesignerShaderSource(source) {
    var src = sculptToGLSL(source);

    if (src.error) {
      console.log(src.error);
    }

    var frg = TDHeader + usePBRHeader + useHemisphereLight + uniformsToGLSL(src.uniforms) + 'const float STEP_SIZE_CONSTANT = ' + src.stepSizeConstant + ';\n' + 'const int MAX_ITERATIONS = ' + src.maxIterations + ';\n' + sculptureStarterCode + src.geoGLSL + '\n' + src.colorGLSL + '\n' + TDFooter;
    return {
      uniforms: src.uniforms,
      frag: frg,
      vert: minimalVertexSource,
      error: src.error,
      geoGLSL: src.geoGLSL,
      colorGLSL: src.colorGLSL
    };
  }

  console.log('using shader-park version: 0.0.270'); /// Generate code for various targets

  exports.createSculpture = createSculpture;
  exports.createSculptureWithGeometry = createSculptureWithGeometry;
  exports.defaultFragSourceGLSL = defaultFragSourceGLSL;
  exports.glslToMinimalHTMLRenderer = glslToMinimalHTMLRenderer;
  exports.glslToMinimalRenderer = glslToMinimalRenderer;
  exports.glslToOfflineRenderer = glslToOfflineRenderer;
  exports.glslToThreeJSMaterial = glslToThreeJSMaterial;
  exports.glslToThreeJSMesh = glslToThreeJSMesh;
  exports.glslToThreeJSShaderSource = glslToThreeJSShaderSource;
  exports.glslToTouchDesignerShaderSource = glslToTouchDesignerShaderSource;
  exports.sculptToMinimalHTMLRenderer = sculptToMinimalHTMLRenderer;
  exports.sculptToMinimalRenderer = sculptToMinimalRenderer;
  exports.sculptToOfflineRenderer = sculptToOfflineRenderer;
  exports.sculptToRawSDF4Meshing = sculptToRawSDF4Meshing;
  exports.sculptToThreeJSMaterial = sculptToThreeJSMaterial;
  exports.sculptToThreeJSMesh = sculptToThreeJSMesh;
  exports.sculptToThreeJSShaderSource = sculptToThreeJSShaderSource;
  exports.sculptToTouchDesignerShaderSource = sculptToTouchDesignerShaderSource;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],"spCode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spCode = spCode;

// This function will be converted into a string so
// the scope is limited to this function only.
// To pass external data use the 'input' function. See other examples.
function spCode() {
  return "rotateY(-0.1 * time);\nlet n = noise(getSpace() * 40 + time + 10000000);\ncolor(vec3(0, 0, .5) + normal * .2);\nmetal(n);\nshine(n);\nsphere(0.5 + n * nsin(time) * 3);";
}

;
},{}],"node_modules/@codemirror/text/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.codePointAt = codePointAt;
exports.codePointSize = codePointSize;
exports.countColumn = countColumn;
exports.findClusterBreak = findClusterBreak;
exports.findColumn = findColumn;
exports.fromCodePoint = fromCodePoint;
exports.Text = exports.Line = void 0;
// Compressed representation of the Grapheme_Cluster_Break=Extend
// information from
// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.
// Each pair of elements represents a range, as an offet from the
// previous range and a length. Numbers are in base-36, with the empty
// string being a shorthand for 1.
let extend = /*@__PURE__*/"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(s => s ? parseInt(s, 36) : 1); // Convert offsets into absolute values

for (let i = 1; i < extend.length; i++) extend[i] += extend[i - 1];

function isExtendingChar(code) {
  for (let i = 1; i < extend.length; i += 2) if (extend[i] > code) return extend[i - 1] <= code;

  return false;
}

function isRegionalIndicator(code) {
  return code >= 0x1F1E6 && code <= 0x1F1FF;
}

const ZWJ = 0x200d;
/**
Returns a next grapheme cluster break _after_ (not equal to)
`pos`, if `forward` is true, or before otherwise. Returns `pos`
itself if no further cluster break is available in the string.
Moves across surrogate pairs, extending characters, characters
joined with zero-width joiners, and flag emoji.
*/

function findClusterBreak(str, pos, forward = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos);
}

function nextClusterBreak(str, pos) {
  if (pos == str.length) return pos; // If pos is in the middle of a surrogate pair, move to its start

  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);

  while (pos < str.length) {
    let next = codePointAt(str, pos);

    if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0,
          i = pos - 2;

      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
        countBefore++;
        i -= 2;
      }

      if (countBefore % 2 == 0) break;else pos += 2;
    } else {
      break;
    }
  }

  return pos;
}

function prevClusterBreak(str, pos) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2);
    if (found < pos) return found;
    pos--;
  }

  return 0;
}

function surrogateLow(ch) {
  return ch >= 0xDC00 && ch < 0xE000;
}

function surrogateHigh(ch) {
  return ch >= 0xD800 && ch < 0xDC00;
}
/**
Find the code point at the given position in a string (like the
[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)
string method).
*/


function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1)) return code0;
  return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;
}
/**
Given a Unicode codepoint, return the JavaScript string that
respresents it (like
[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).
*/


function fromCodePoint(code) {
  if (code <= 0xffff) return String.fromCharCode(code);
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);
}
/**
The first character that takes up two positions in a JavaScript
string. It is often useful to compare with this after calling
`codePointAt`, to figure out whether your character takes up 1 or
2 index positions.
*/


function codePointSize(code) {
  return code < 0x10000 ? 1 : 2;
}
/**
Count the column position at the given offset into the string,
taking extending characters and tab size into account.
*/


function countColumn(string, tabSize, to = string.length) {
  let n = 0;

  for (let i = 0; i < to;) {
    if (string.charCodeAt(i) == 9) {
      n += tabSize - n % tabSize;
      i++;
    } else {
      n++;
      i = findClusterBreak(string, i);
    }
  }

  return n;
}
/**
Find the offset that corresponds to the given column position in a
string, taking extending characters and tab size into account.
*/


function findColumn(string, col, tabSize) {
  for (let i = 0, n = 0; i < string.length;) {
    if (n >= col) return i;
    n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
    i = findClusterBreak(string, i);
  }

  return string.length;
}
/**
The data structure for documents.
*/


class Text {
  /**
  @internal
  */
  constructor() {}
  /**
  Get the line description around the given position.
  */


  lineAt(pos) {
    if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */


  line(n) {
    if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */


  replace(from, to, text) {
    let parts = [];
    this.decompose(0, from, parts, 2
    /* To */
    );
    if (text.length) text.decompose(0, text.length, parts, 1
    /* From */
    | 2
    /* To */
    );
    this.decompose(to, this.length, parts, 1
    /* From */
    );
    return TextNode.from(parts, this.length - (to - from) + text.length);
  }
  /**
  Append another document to this one.
  */


  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */


  slice(from, to = this.length) {
    let parts = [];
    this.decompose(from, to, parts, 0);
    return TextNode.from(parts, to - from);
  }
  /**
  Test whether this text is equal to another instance.
  */


  eq(other) {
    if (other == this) return true;
    if (other.length != this.length || other.lines != this.lines) return false;
    let a = new RawTextCursor(this),
        b = new RawTextCursor(other);

    for (;;) {
      a.next();
      b.next();
      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;
      if (a.done) return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings, and for long lines, might split lines
  themselves into multiple chunks as well.
  */


  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */


  iterRange(from, to = this.length) {
    return new PartialTextCursor(this, from, to);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */


  iterLines(from, to) {
    let inner;

    if (from == null) {
      inner = this.iter();
    } else {
      if (to == null) to = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
    }

    return new LineCursor(inner);
  }
  /**
  @internal
  */


  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#text.Text^of)).
  */


  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  Create a `Text` instance for the given array of lines.
  */


  static of(text) {
    if (text.length == 0) throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0]) return Text.empty;
    return text.length <= 32
    /* Branch */
    ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }

}

exports.Text = Text;
if (typeof Symbol != "undefined") Text.prototype[Symbol.iterator] = function () {
  return this.iter();
}; // Leaves store an array of line strings. There are always line breaks
// between these strings. Leaves are limited in size and have to be
// contained in TextNode instances for bigger documents.

class TextLeaf extends Text {
  constructor(text, length = textLength(text)) {
    super();
    this.text = text;
    this.length = length;
  }

  get lines() {
    return this.text.length;
  }

  get children() {
    return null;
  }

  lineInner(target, isLine, line, offset) {
    for (let i = 0;; i++) {
      let string = this.text[i],
          end = offset + string.length;
      if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);
      offset = end + 1;
      line++;
    }
  }

  decompose(from, to, target, open) {
    let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));

    if (open & 1
    /* From */
    ) {
        let prev = target.pop();
        let joined = appendText(text.text, prev.text.slice(), 0, text.length);

        if (joined.length <= 32
        /* Branch */
        ) {
            target.push(new TextLeaf(joined, prev.length + text.length));
          } else {
          let mid = joined.length >> 1;
          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
        }
      } else {
      target.push(text);
    }
  }

  replace(from, to, text) {
    if (!(text instanceof TextLeaf)) return super.replace(from, to, text);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
    let newLen = this.length + text.length - (to - from);
    if (lines.length <= 32
    /* Branch */
    ) return new TextLeaf(lines, newLen);
    return TextNode.from(TextLeaf.split(lines, []), newLen);
  }

  sliceString(from, to = this.length, lineSep = "\n") {
    let result = "";

    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
      let line = this.text[i],
          end = pos + line.length;
      if (pos > from && i) result += lineSep;
      if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);
      pos = end + 1;
    }

    return result;
  }

  flatten(target) {
    for (let line of this.text) target.push(line);
  }

  static split(text, target) {
    let part = [],
        len = -1;

    for (let line of text) {
      part.push(line);
      len += line.length + 1;

      if (part.length == 32
      /* Branch */
      ) {
          target.push(new TextLeaf(part, len));
          part = [];
          len = -1;
        }
    }

    if (len > -1) target.push(new TextLeaf(part, len));
    return target;
  }

} // Nodes provide the tree structure of the `Text` type. They store a
// number of other nodes or leaves, taking care to balance themselves
// on changes. There are implied line breaks _between_ the children of
// a node (but not before the first or after the last child).


class TextNode extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;

    for (let child of children) this.lines += child.lines;
  }

  lineInner(target, isLine, line, offset) {
    for (let i = 0;; i++) {
      let child = this.children[i],
          end = offset + child.length,
          endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }

  decompose(from, to, target, open) {
    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
      let child = this.children[i],
          end = pos + child.length;

      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1
        /* From */
        : 0) | (end >= to ? 2
        /* To */
        : 0));
        if (pos >= from && end <= to && !childOpen) target.push(child);else child.decompose(from - pos, to - pos, target, childOpen);
      }

      pos = end + 1;
    }
  }

  replace(from, to, text) {
    if (text.lines < this.lines) for (let i = 0, pos = 0; i < this.children.length; i++) {
      let child = this.children[i],
          end = pos + child.length; // Fast path: if the change only affects one child and the
      // child's size remains in the acceptable range, only update
      // that child

      if (from >= pos && to <= end) {
        let updated = child.replace(from - pos, to - pos, text);
        let totalLines = this.lines - child.lines + updated.lines;

        if (updated.lines < totalLines >> 5
        /* BranchShift */
        - 1 && updated.lines > totalLines >> 5
        /* BranchShift */
        + 1) {
          let copy = this.children.slice();
          copy[i] = updated;
          return new TextNode(copy, this.length - (to - from) + text.length);
        }

        return super.replace(pos, end, updated);
      }

      pos = end + 1;
    }
    return super.replace(from, to, text);
  }

  sliceString(from, to = this.length, lineSep = "\n") {
    let result = "";

    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
      let child = this.children[i],
          end = pos + child.length;
      if (pos > from && i) result += lineSep;
      if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);
      pos = end + 1;
    }

    return result;
  }

  flatten(target) {
    for (let child of this.children) child.flatten(target);
  }

  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
    let lines = 0;

    for (let ch of children) lines += ch.lines;

    if (lines < 32
    /* Branch */
    ) {
        let flat = [];

        for (let ch of children) ch.flatten(flat);

        return new TextLeaf(flat, length);
      }

    let chunk = Math.max(32
    /* Branch */
    , lines >> 5
    /* BranchShift */
    ),
        maxChunk = chunk << 1,
        minChunk = chunk >> 1;
    let chunked = [],
        currentLines = 0,
        currentLen = -1,
        currentChunk = [];

    function add(child) {
      let last;

      if (child.lines > maxChunk && child instanceof TextNode) {
        for (let node of child.children) add(node);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32
      /* Branch */
      ) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
        } else {
        if (currentLines + child.lines > chunk) flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }

    function flush() {
      if (currentLines == 0) return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }

    for (let child of children) add(child);

    flush();
    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
  }

}

Text.empty = /*@__PURE__*/new TextLeaf([""], 0);

function textLength(text) {
  let length = -1;

  for (let line of text) length += line.length + 1;

  return length;
}

function appendText(text, target, from = 0, to = 1e9) {
  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
    let line = text[i],
        end = pos + line.length;

    if (end >= from) {
      if (end > to) line = line.slice(0, to - pos);
      if (pos < from) line = line.slice(from - pos);

      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else target.push(line);
    }

    pos = end + 1;
  }

  return target;
}

function sliceText(text, from, to) {
  return appendText(text, [""], from, to);
}

class RawTextCursor {
  constructor(text, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
  }

  nextInner(skip, dir) {
    this.done = this.lineBreak = false;

    for (;;) {
      let last = this.nodes.length - 1;
      let top = this.nodes[last],
          offsetValue = this.offsets[last],
          offset = offsetValue >> 1;
      let size = top instanceof TextLeaf ? top.text.length : top.children.length;

      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }

        if (dir > 0) this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;

        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }

        skip--;
      } else if (top instanceof TextLeaf) {
        // Move to the next string
        let next = top.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;

        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }

        skip -= next.length;
      } else {
        let next = top.children[offset + (dir < 0 ? -1 : 0)];

        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0) this.offsets[last]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }

  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }

    return this.nextInner(skip, this.dir);
  }

}

class PartialTextCursor {
  constructor(text, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
    this.pos = start > end ? text.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }

  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }

    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit) skip = limit;
    limit -= skip;
    let {
      value
    } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }

  next(skip = 0) {
    if (skip < 0) skip = Math.max(skip, this.from - this.pos);else if (skip > 0) skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }

  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }

}

class LineCursor {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }

  next(skip = 0) {
    let {
      done,
      lineBreak,
      value
    } = this.inner.next(skip);

    if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }

    return this;
  }

  get lineBreak() {
    return false;
  }

}
/**
This type describes a line in the document. It is created
on-demand when lines are [queried](https://codemirror.net/6/docs/ref/#text.Text.lineAt).
*/


class Line {
  /**
  @internal
  */
  constructor(
  /**
  The position of the start of the line.
  */
  from,
  /**
  The position at the end of the line (_before_ the line break,
  or at the end of document for the last line).
  */
  to,
  /**
  This line's line number (1-based).
  */
  number,
  /**
  The line's content.
  */
  text) {
    this.from = from;
    this.to = to;
    this.number = number;
    this.text = text;
  }
  /**
  The length of the line (not including any line break after it).
  */


  get length() {
    return this.to - this.from;
  }

}

exports.Line = Line;
},{}],"node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"node_modules/@codemirror/state/dist/index.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combineConfig = combineConfig;
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function () {
    return _text.Text;
  }
});
exports.Transaction = exports.StateField = exports.StateEffectType = exports.StateEffect = exports.SelectionRange = exports.Prec = exports.MapMode = exports.Facet = exports.EditorState = exports.EditorSelection = exports.Compartment = exports.CharCategory = exports.ChangeSet = exports.ChangeDesc = exports.AnnotationType = exports.Annotation = void 0;

var _text = require("@codemirror/text");

const DefaultSplit = /\r\n?|\n/;
/**
Distinguishes different ways in which positions can be mapped.
*/

var MapMode = /*@__PURE__*/function (MapMode) {
  /**
  Map a position to a valid new position, even when its context
  was deleted.
  */
  MapMode[MapMode["Simple"] = 0] = "Simple";
  /**
  Return null if deletion happens across the position.
  */

  MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
  /**
  Return null if the character _before_ the position is deleted.
  */

  MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
  /**
  Return null if the character _after_ the position is deleted.
  */

  MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
  return MapMode;
}(MapMode || (exports.MapMode = MapMode = {}));
/**
A change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)
that doesn't store the inserted text. As such, it can't be
applied, but is cheaper to store and manipulate.
*/


exports.MapMode = MapMode;

class ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.

  /**
  @internal
  */
  constructor(
  /**
  @internal
  */
  sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */


  get length() {
    let result = 0;

    for (let i = 0; i < this.sections.length; i += 2) result += this.sections[i];

    return result;
  }
  /**
  The length of the document after the change.
  */


  get newLength() {
    let result = 0;

    for (let i = 0; i < this.sections.length; i += 2) {
      let ins = this.sections[i + 1];
      result += ins < 0 ? this.sections[i] : ins;
    }

    return result;
  }
  /**
  False when there are actual changes in this set.
  */


  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes.
  */


  iterGaps(f) {
    for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {
      let len = this.sections[i++],
          ins = this.sections[i++];

      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }

      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */


  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */


  get invertedDesc() {
    let sections = [];

    for (let i = 0; i < this.sections.length;) {
      let len = this.sections[i++],
          ins = this.sections[i++];
      if (ins < 0) sections.push(len, ins);else sections.push(ins, len);
    }

    return new ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */


  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */


  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }

  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0,
        posB = 0;

    for (let i = 0; i < this.sections.length;) {
      let len = this.sections[i++],
          ins = this.sections[i++],
          endA = posA + len;

      if (ins < 0) {
        if (endA > pos) return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;
        if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }

      posA = endA;
    }

    if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */


  touchesRange(from, to = from) {
    for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {
      let len = this.sections[i++],
          ins = this.sections[i++],
          end = pos + len;
      if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? "cover" : true;
      pos = end;
    }

    return false;
  }
  /**
  @internal
  */


  toString() {
    let result = "";

    for (let i = 0; i < this.sections.length;) {
      let len = this.sections[i++],
          ins = this.sections[i++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }

    return result;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */


  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */


  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != "number")) throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ChangeDesc(json);
  }

}
/**
A change set represents a group of modifications to a document. It
stores the document length, and can only be applied to documents
with exactly that length.
*/


exports.ChangeDesc = ChangeDesc;

class ChangeSet extends ChangeDesc {
  /**
  @internal
  */
  constructor(sections,
  /**
  @internal
  */
  inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */


  apply(doc) {
    if (this.length != doc.length) throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
    return doc;
  }

  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */


  invert(doc) {
    let sections = this.sections.slice(),
        inserted = [];

    for (let i = 0, pos = 0; i < sections.length; i += 2) {
      let len = sections[i],
          ins = sections[i + 1];

      if (ins >= 0) {
        sections[i] = ins;
        sections[i + 1] = len;
        let index = i >> 1;

        while (inserted.length < index) inserted.push(_text.Text.empty);

        inserted.push(len ? doc.slice(pos, pos + len) : _text.Text.empty);
      }

      pos += len;
    }

    return new ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */


  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */


  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each.
  
  When `individual` is true, adjacent changes are reported
  separately.
  */


  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */


  get desc() {
    return new ChangeDesc(this.sections);
  }
  /**
  @internal
  */


  filter(ranges) {
    let resultSections = [],
        resultInserted = [],
        filteredSections = [];
    let iter = new SectionIter(this);

    done: for (let i = 0, pos = 0;;) {
      let next = i == ranges.length ? 1e9 : ranges[i++];

      while (pos < next || pos == next && iter.len == 0) {
        if (iter.done) break done;
        let len = Math.min(iter.len, next - pos);
        addSection(filteredSections, len, -1);
        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
        addSection(resultSections, len, ins);
        if (ins > 0) addInsert(resultInserted, resultSections, iter.text);
        iter.forward(len);
        pos += len;
      }

      let end = ranges[i++];

      while (pos < end) {
        if (iter.done) break done;
        let len = Math.min(iter.len, end - pos);
        addSection(resultSections, len, -1);
        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
        iter.forward(len);
        pos += len;
      }
    }

    return {
      changes: new ChangeSet(resultSections, resultInserted),
      filtered: new ChangeDesc(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */


  toJSON() {
    let parts = [];

    for (let i = 0; i < this.sections.length; i += 2) {
      let len = this.sections[i],
          ins = this.sections[i + 1];
      if (ins < 0) parts.push(len);else if (ins == 0) parts.push([len]);else parts.push([len].concat(this.inserted[i >> 1].toJSON()));
    }

    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */


  static of(changes, length, lineSep) {
    let sections = [],
        inserted = [],
        pos = 0;
    let total = null;

    function flush(force = false) {
      if (!force && !sections.length) return;
      if (pos < length) addSection(sections, length - pos, -1);
      let set = new ChangeSet(sections, inserted);
      total = total ? total.compose(set.map(total)) : set;
      sections = [];
      inserted = [];
      pos = 0;
    }

    function process(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec) process(sub);
      } else if (spec instanceof ChangeSet) {
        if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let {
          from,
          to = from,
          insert
        } = spec;
        if (from > to || from < 0 || to > length) throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
        let insText = !insert ? _text.Text.empty : typeof insert == "string" ? _text.Text.of(insert.split(lineSep || DefaultSplit)) : insert;
        let insLen = insText.length;
        if (from == to && insLen == 0) return;
        if (from < pos) flush();
        if (from > pos) addSection(sections, from - pos, -1);
        addSection(sections, to - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }

    process(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */


  static empty(length) {
    return new ChangeSet(length ? [length, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */


  static fromJSON(json) {
    if (!Array.isArray(json)) throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [],
        inserted = [];

    for (let i = 0; i < json.length; i++) {
      let part = json[i];

      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i) => i && typeof e != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i) inserted.push(_text.Text.empty);

        inserted[i] = _text.Text.of(part.slice(1));
        sections.push(part[0], inserted[i].length);
      }
    }

    return new ChangeSet(sections, inserted);
  }

}

exports.ChangeSet = ChangeSet;

function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0) return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;else if (len == 0 && sections[last] == 0) sections[last + 1] += ins;else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else sections.push(len, ins);
}

function addInsert(values, sections, value) {
  if (value.length == 0) return;
  let index = sections.length - 2 >> 1;

  if (index < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index) values.push(_text.Text.empty);

    values.push(value);
  }
}

function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;

  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {
    let len = desc.sections[i++],
        ins = desc.sections[i++];

    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA,
          endB = posB,
          text = _text.Text.empty;

      for (;;) {
        endA += len;
        endB += ins;
        if (ins && inserted) text = text.append(inserted[i - 2 >> 1]);
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break;
        len = desc.sections[i++];
        ins = desc.sections[i++];
      }

      f(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}

function mapSet(setA, setB, before, mkSet = false) {
  let sections = [],
      insert = mkSet ? [] : null;
  let a = new SectionIter(setA),
      b = new SectionIter(setB);

  for (let posA = 0, posB = 0;;) {
    if (a.ins == -1) {
      posA += a.len;
      a.next();
    } else if (b.ins == -1 && posB < posA) {
      let skip = Math.min(b.len, posA - posB);
      b.forward(skip);
      addSection(sections, skip, -1);
      posB += skip;
    } else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {
      addSection(sections, b.ins, -1);

      while (posA > posB && !a.done && posA + a.len < posB + b.len) {
        posA += a.len;
        a.next();
      }

      posB += b.len;
      b.next();
    } else if (a.ins >= 0) {
      let len = 0,
          end = posA + a.len;

      for (;;) {
        if (b.ins >= 0 && posB > posA && posB + b.len < end) {
          len += b.ins;
          posB += b.len;
          b.next();
        } else if (b.ins == -1 && posB < end) {
          let skip = Math.min(b.len, end - posB);
          len += skip;
          b.forward(skip);
          posB += skip;
        } else {
          break;
        }
      }

      addSection(sections, len, a.ins);
      if (insert) addInsert(insert, sections, a.text);
      posA = end;
      a.next();
    } else if (a.done && b.done) {
      return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}

function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert = mkSet ? [] : null;
  let a = new SectionIter(setA),
      b = new SectionIter(setB);

  for (let open = false;;) {
    if (a.done && b.done) {
      return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);
    } else if (a.ins == 0) {
      // Deletion in A
      addSection(sections, a.len, 0, open);
      a.next();
    } else if (b.len == 0 && !b.done) {
      // Insertion in B
      addSection(sections, 0, b.ins, open);
      if (insert) addInsert(insert, sections, b.text);
      b.next();
    } else if (a.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a.len2, b.len),
          sectionLen = sections.length;

      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert && insB) addInsert(insert, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open);
        if (insert) addInsert(insert, sections, a.textBit(len));
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
        if (insert && !b.off) addInsert(insert, sections, b.text);
      }

      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a.forward2(len);
      b.forward(len);
    }
  }
}

class SectionIter {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.next();
  }

  next() {
    let {
      sections
    } = this.set;

    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }

    this.off = 0;
  }

  get done() {
    return this.ins == -2;
  }

  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }

  get text() {
    let {
      inserted
    } = this.set,
        index = this.i - 2 >> 1;
    return index >= inserted.length ? _text.Text.empty : inserted[index];
  }

  textBit(len) {
    let {
      inserted
    } = this.set,
        index = this.i - 2 >> 1;
    return index >= inserted.length && !len ? _text.Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);
  }

  forward(len) {
    if (len == this.len) this.next();else {
      this.len -= len;
      this.off += len;
    }
  }

  forward2(len) {
    if (this.ins == -1) this.forward(len);else if (len == this.ins) this.next();else {
      this.ins -= len;
      this.off += len;
    }
  }

}
/**
A single selection range. When
[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
is enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold
multiple ranges. By default, selections hold exactly one range.
*/


class SelectionRange {
  /**
  @internal
  */
  constructor(
  /**
  The lower boundary of the range.
  */
  from,
  /**
  The upper boundary of the range.
  */
  to, flags) {
    this.from = from;
    this.to = to;
    this.flags = flags;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */


  get anchor() {
    return this.flags & 16
    /* Inverted */
    ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */


  get head() {
    return this.flags & 16
    /* Inverted */
    ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */


  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */


  get assoc() {
    return this.flags & 4
    /* AssocBefore */
    ? -1 : this.flags & 8
    /* AssocAfter */
    ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */


  get bidiLevel() {
    let level = this.flags & 3
    /* BidiLevelMask */
    ;
    return level == 3 ? null : level;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */


  get goalColumn() {
    let value = this.flags >> 5
    /* GoalColumnOffset */
    ;
    return value == 33554431
    /* NoGoalColumn */
    ? undefined : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */


  map(change, assoc = -1) {
    let from = change.mapPos(this.from, assoc),
        to = change.mapPos(this.to, assoc);
    return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */


  extend(from, to = from) {
    if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
    return EditorSelection.range(this.anchor, head);
  }
  /**
  Compare this range to another range.
  */


  eq(other) {
    return this.anchor == other.anchor && this.head == other.head;
  }
  /**
  Return a JSON-serializable object representing the range.
  */


  toJSON() {
    return {
      anchor: this.anchor,
      head: this.head
    };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */


  static fromJSON(json) {
    if (!json || typeof json.anchor != "number" || typeof json.head != "number") throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json.anchor, json.head);
  }

}
/**
An editor selection holds one or more selection ranges.
*/


exports.SelectionRange = SelectionRange;

class EditorSelection {
  /**
  @internal
  */
  constructor(
  /**
  The ranges in the selection, sorted by position. Ranges cannot
  overlap (but they may touch, if they aren't empty).
  */
  ranges,
  /**
  The index of the _main_ range in the selection (which is
  usually the range that was added last).
  */
  mainIndex = 0) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */


  map(change, assoc = -1) {
    if (change.empty) return this;
    return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection.
  */


  eq(other) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;

    for (let i = 0; i < this.ranges.length; i++) if (!this.ranges[i].eq(other.ranges[i])) return false;

    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */


  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */


  asSingle() {
    return this.ranges.length == 1 ? this : new EditorSelection([this.main]);
  }
  /**
  Extend this selection with an extra range.
  */


  addRange(range, main = true) {
    return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */


  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */


  toJSON() {
    return {
      ranges: this.ranges.map(r => r.toJSON()),
      main: this.mainIndex
    };
  }
  /**
  Create a selection from a JSON representation.
  */


  static fromJSON(json) {
    if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length) throw new RangeError("Invalid JSON representation for EditorSelection");
    return new EditorSelection(json.ranges.map(r => SelectionRange.fromJSON(r)), json.main);
  }
  /**
  Create a selection holding a single range.
  */


  static single(anchor, head = anchor) {
    return new EditorSelection([EditorSelection.range(anchor, head)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */


  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0) throw new RangeError("A selection needs at least one range");

    for (let pos = 0, i = 0; i < ranges.length; i++) {
      let range = ranges[i];
      if (range.empty ? range.from <= pos : range.from < pos) return normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }

    return new EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */


  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return new SelectionRange(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4
    /* AssocBefore */
    : 8
    /* AssocAfter */
    ) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431
    /* NoGoalColumn */
    ) << 5
    /* GoalColumnOffset */
    );
  }
  /**
  Create a selection range.
  */


  static range(anchor, head, goalColumn) {
    let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431
    /* NoGoalColumn */
    ) << 5
    /* GoalColumnOffset */
    ;
    return head < anchor ? new SelectionRange(head, anchor, 16
    /* Inverted */
    | goal) : new SelectionRange(anchor, head, goal);
  }

}

exports.EditorSelection = EditorSelection;

function normalized(ranges, mainIndex = 0) {
  let main = ranges[mainIndex];
  ranges.sort((a, b) => a.from - b.from);
  mainIndex = ranges.indexOf(main);

  for (let i = 1; i < ranges.length; i++) {
    let range = ranges[i],
        prev = ranges[i - 1];

    if (range.empty ? range.from <= prev.to : range.from < prev.to) {
      let from = prev.from,
          to = Math.max(range.to, prev.to);
      if (i <= mainIndex) mainIndex--;
      ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
    }
  }

  return new EditorSelection(ranges, mainIndex);
}

function checkSelection(selection, docLength) {
  for (let range of selection.ranges) if (range.to > docLength) throw new RangeError("Selection points outside of document");
}

let nextID = 0;
/**
A facet is a labeled value that is associated with an editor
state. It takes inputs from any number of extensions, and combines
those into a single output value.

Examples of facets are the [theme](https://codemirror.net/6/docs/ref/#view.EditorView^theme) styles
associated with an editor or the [tab
size](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) (which is reduced to a single
value, using the input with the hightest precedence).
*/

class Facet {
  constructor(
  /**
  @internal
  */
  combine,
  /**
  @internal
  */
  compareInput,
  /**
  @internal
  */
  compare, isStatic,
  /**
  @internal
  */
  extensions) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare;
    this.isStatic = isStatic;
    this.extensions = extensions;
    /**
    @internal
    */

    this.id = nextID++;
    this.default = combine([]);
  }
  /**
  Define a new facet.
  */


  static define(config = {}) {
    return new Facet(config.combine || (a => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
  }
  /**
  Returns an extension that adds the given value for this facet.
  */


  of(value) {
    return new FacetProvider([], this, 0
    /* Static */
    , value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In most cases, you'll want to use the
  [`provide`](https://codemirror.net/6/docs/ref/#state.StateField^define^config.provide) option when
  defining a field instead.
  */


  compute(deps, get) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1
    /* Single */
    , get);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */


  computeN(deps, get) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2
    /* Multi */
    , get);
  }

  from(field, get) {
    if (!get) get = x => x;
    return this.compute([field], state => get(state.field(field)));
  }

}

exports.Facet = Facet;

function sameArray(a, b) {
  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}

class FacetProvider {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }

  dynamicSlot(addresses) {
    var _a;

    let getter = this.value;
    let compare = this.facet.compareInput;
    let idx = addresses[this.id] >> 1,
        multi = this.type == 2
    /* Multi */
    ;
    let depDoc = false,
        depSel = false,
        depAddrs = [];

    for (let dep of this.dependencies) {
      if (dep == "doc") depDoc = true;else if (dep == "selection") depSel = true;else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);
    }

    return (state, tr) => {
      if (!tr || tr.reconfigured) {
        state.values[idx] = getter(state);
        return 1
        /* Changed */
        ;
      } else {
        let depChanged = depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || depAddrs.some(addr => (ensureAddr(state, addr) & 1
        /* Changed */
        ) > 0);
        if (!depChanged) return 0;
        let newVal = getter(state),
            oldVal = tr.startState.values[idx];
        if (multi ? compareArray(newVal, oldVal, compare) : compare(newVal, oldVal)) return 0;
        state.values[idx] = newVal;
        return 1
        /* Changed */
        ;
      }
    };
  }

}

function compareArray(a, b, compare) {
  if (a.length != b.length) return false;

  for (let i = 0; i < a.length; i++) if (!compare(a[i], b[i])) return false;

  return true;
}

function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map(p => addresses[p.id]);
  let providerTypes = providers.map(p => p.type);
  let dynamic = providerAddrs.filter(p => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  return (state, tr) => {
    let oldAddr = !tr ? null : tr.reconfigured ? tr.startState.config.address[facet.id] : idx << 1;
    let changed = oldAddr == null;

    for (let dynAddr of dynamic) {
      if (ensureAddr(state, dynAddr) & 1
      /* Changed */
      ) changed = true;
    }

    if (!changed) return 0;
    let values = [];

    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i]);
      if (providerTypes[i] == 2
      /* Multi */
      ) for (let val of value) values.push(val);else values.push(value);
    }

    let newVal = facet.combine(values);
    if (oldAddr != null && facet.compare(newVal, getAddr(tr.startState, oldAddr))) return 0;
    state.values[idx] = newVal;
    return 1
    /* Changed */
    ;
  };
}

function maybeIndex(state, id) {
  let found = state.config.address[id];
  return found == null ? null : found >> 1;
}

const initField = /*@__PURE__*/Facet.define({
  static: true
});
/**
Fields can store additional information in an editor state, and
keep it in sync with the rest of the state.
*/

class StateField {
  constructor(
  /**
  @internal
  */
  id, createF, updateF, compareF,
  /**
  @internal
  */
  spec) {
    this.id = id;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    /**
    @internal
    */

    this.provides = undefined;
  }
  /**
  Define a state field.
  */


  static define(config) {
    let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
    if (config.provide) field.provides = config.provide(field);
    return field;
  }

  create(state) {
    let init = state.facet(initField).find(i => i.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */


  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return (state, tr) => {
      if (!tr || tr.reconfigured && maybeIndex(tr.startState, this.id) == null) {
        state.values[idx] = this.create(state);
        return 1
        /* Changed */
        ;
      }

      let oldVal,
          changed = 0;

      if (tr.reconfigured) {
        oldVal = tr.startState.values[maybeIndex(tr.startState, this.id)];
        changed = 1
        /* Changed */
        ;
      } else {
        oldVal = tr.startState.values[idx];
      }

      let value = this.updateF(oldVal, tr);
      if (!changed && !this.compareF(oldVal, value)) changed = 1
      /* Changed */
      ;
      if (changed) state.values[idx] = value;
      return changed;
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */


  init(create) {
    return [this, initField.of({
      field: this,
      create
    })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */


  get extension() {
    return this;
  }

}

exports.StateField = StateField;
const Prec_ = {
  fallback: 3,
  default: 2,
  extend: 1,
  override: 0
};

function prec(value) {
  return ext => new PrecExtension(ext, value);
}
/**
By default extensions are registered in the order they are found
in the flattened form of nested array that was provided.
Individual extension values can be assigned a precedence to
override this. Extensions that do not have a precedence set get
the precedence of the nearest parent with a precedence, or
[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The
final ordering of extensions is determined by first sorting by
precedence and then by order within each precedence.
*/


const Prec = {
  /**
  A precedence below the default precedence, which will cause
  default-precedence extensions to override it even if they are
  specified later in the extension ordering.
  */
  fallback: /*@__PURE__*/prec(Prec_.fallback),

  /**
  The regular default precedence.
  */
  default: /*@__PURE__*/prec(Prec_.default),

  /**
  A higher-than-default precedence.
  */
  extend: /*@__PURE__*/prec(Prec_.extend),

  /**
  Precedence above the `default` and `extend` precedences.
  */
  override: /*@__PURE__*/prec(Prec_.override)
};
exports.Prec = Prec;

class PrecExtension {
  constructor(inner, prec) {
    this.inner = inner;
    this.prec = prec;
  }

}
/**
Extension compartments can be used to make a configuration
dynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your
configuration in a compartment, you can later
[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a
transaction.
*/


class Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */


  reconfigure(content) {
    return Compartment.reconfigure.of({
      compartment: this,
      extension: content
    });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */


  get(state) {
    return state.config.compartments.get(this);
  }

}

exports.Compartment = Compartment;

class CompartmentInstance {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }

}

class Configuration {
  constructor(base, compartments, dynamicSlots, address, staticValues) {
    this.base = base;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.statusTemplate = [];

    while (this.statusTemplate.length < dynamicSlots.length) this.statusTemplate.push(0
    /* Uninitialized */
    );
  }

  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }

  static resolve(base, compartments, oldState) {
    let fields = [];
    let facets = Object.create(null);
    let newCompartments = new Map();

    for (let ext of flatten(base, compartments, newCompartments)) {
      if (ext instanceof StateField) fields.push(ext);else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }

    let address = Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];

    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push(a => field.slot(a));
    }

    for (let id in facets) {
      let providers = facets[id],
          facet = providers[0].facet;

      if (providers.every(p => p.type == 0
      /* Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        let value = facet.combine(providers.map(p => p.value));
        let oldAddr = oldState ? oldState.config.address[facet.id] : null;

        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (facet.compare(value, oldVal)) value = oldVal;
        }

        staticValues.push(value);
      } else {
        for (let p of providers) {
          if (p.type == 0
          /* Static */
          ) {
              address[p.id] = staticValues.length << 1 | 1;
              staticValues.push(p.value);
            } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push(a => p.dynamicSlot(a));
          }
        }

        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));
      }
    }

    return new Configuration(base, newCompartments, dynamicSlots.map(f => f(address)), address, staticValues);
  }

}

function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], []];
  let seen = new Map();

  function inner(ext, prec) {
    let known = seen.get(ext);

    if (known != null) {
      if (known >= prec) return;
      let found = result[known].indexOf(ext);
      if (found > -1) result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);
    }

    seen.set(ext, prec);

    if (Array.isArray(ext)) {
      for (let e of ext) inner(e, prec);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);
      let content = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content);
      inner(content, prec);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec].push(ext);
      if (ext.provides) inner(ext.provides, prec);
    } else if (ext instanceof FacetProvider) {
      result[prec].push(ext);
      if (ext.facet.extensions) inner(ext.facet.extensions, prec);
    } else {
      let content = ext.extension;
      if (!content) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content, prec);
    }
  }

  inner(extension, Prec_.default);
  return result.reduce((a, b) => a.concat(b));
}

function ensureAddr(state, addr) {
  if (addr & 1) return 2
  /* Computed */
  ;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4
  /* Computing */
  ) throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2
  /* Computed */
  ) return status;
  state.status[idx] = 4
  /* Computing */
  ;
  let changed = state.config.dynamicSlots[idx](state, state.applying);
  return state.status[idx] = 2
  /* Computed */
  | changed;
}

function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}

const languageData = /*@__PURE__*/Facet.define();
const allowMultipleSelections = /*@__PURE__*/Facet.define({
  combine: values => values.some(v => v),
  static: true
});
const lineSeparator = /*@__PURE__*/Facet.define({
  combine: values => values.length ? values[0] : undefined,
  static: true
});
const changeFilter = /*@__PURE__*/Facet.define();
const transactionFilter = /*@__PURE__*/Facet.define();
const transactionExtender = /*@__PURE__*/Facet.define();
const readOnly = /*@__PURE__*/Facet.define({
  combine: values => values.length ? values[0] : false
});
/**
Annotations are tagged values that are used to add metadata to
transactions in an extensible way. They should be used to model
things that effect the entire transaction (such as its [time
stamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its
[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen
_alongside_ the other changes made by the transaction, [state
effects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.
*/

class Annotation {
  /**
  @internal
  */
  constructor(
  /**
  The annotation type.
  */
  type,
  /**
  The value of this annotation.
  */
  value) {
    this.type = type;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */


  static define() {
    return new AnnotationType();
  }

}
/**
Marker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).
*/


exports.Annotation = Annotation;

class AnnotationType {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }

}
/**
Representation of a type of state effect. Defined with
[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).
*/


exports.AnnotationType = AnnotationType;

class StateEffectType {
  /**
  @internal
  */
  constructor( // The `any` types in these function types are there to work
  // around TypeScript issue #37631, where the type guard on
  // `StateEffect.is` mysteriously stops working when these properly
  // have type `Value`.

  /**
  @internal
  */
  map) {
    this.map = map;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */


  of(value) {
    return new StateEffect(this, value);
  }

}
/**
State effects can be used to represent additional effects
associated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They
are often useful to model changes to custom [state
fields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in
document or selection changes.
*/


exports.StateEffectType = StateEffectType;

class StateEffect {
  /**
  @internal
  */
  constructor(
  /**
  @internal
  */
  type,
  /**
  The value of this effect.
  */
  value) {
    this.type = type;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */


  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */


  is(type) {
    return this.type == type;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds.
  */


  static define(spec = {}) {
    return new StateEffectType(spec.map || (v => v));
  }
  /**
  Map an array of effects through a change set.
  */


  static mapEffects(effects, mapping) {
    if (!effects.length) return effects;
    let result = [];

    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped) result.push(mapped);
    }

    return result;
  }

}
/**
This effect can be used to reconfigure the root extensions of
the editor. Doing this will discard any extensions
[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset
the content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)
compartments.
*/


exports.StateEffect = StateEffect;
StateEffect.reconfigure = /*@__PURE__*/StateEffect.define();
/**
Append extensions to the top-level configuration of the editor.
*/

StateEffect.appendConfig = /*@__PURE__*/StateEffect.define();
/**
Changes to the editor state are grouped into transactions.
Typically, a user action creates a single transaction, which may
contain any number of document changes, may change the selection,
or have other effects. Create a transaction by calling
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
*/

class Transaction {
  /**
  @internal
  */
  constructor(
  /**
  The state from which the transaction starts.
  */
  startState,
  /**
  The document changes made by this transaction.
  */
  changes,
  /**
  The selection set by this transaction, or undefined if it
  doesn't explicitly set a selection.
  */
  selection,
  /**
  The effects added to the transaction.
  */
  effects,
  /**
  @internal
  */
  annotations,
  /**
  Whether the selection should be scrolled into view after this
  transaction is dispatched.
  */
  scrollIntoView) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView;
    /**
    @internal
    */

    this._doc = null;
    /**
    @internal
    */

    this._state = null;
    if (selection) checkSelection(selection, changes.newLength);
    if (!annotations.some(a => a.type == Transaction.time)) this.annotations = annotations.concat(Transaction.time.of(Date.now()));
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */


  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */


  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so itis recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */


  get state() {
    if (!this._state) this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */


  annotation(type) {
    for (let ann of this.annotations) if (ann.type == type) return ann.value;

    return undefined;
  }
  /**
  Indicates whether the transaction changed the document.
  */


  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */


  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */


  isUserEvent(event) {
    let e = this.annotation(Transaction.userEvent);
    return e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == ".");
  }

}
/**
Annotation used to store transaction timestamps.
*/


exports.Transaction = Transaction;
Transaction.time = /*@__PURE__*/Annotation.define();
/**
Annotation used to associate a transaction with a user interface
event. Holds a string identifying the event, using a
dot-separated format to support attaching more specific
information. The events used by the core libraries are:

 - `"input"` when content is entered
   - `"input.type"` for typed input
     - `"input.type.compose"` for composition
   - `"input.paste"` for pasted input
   - `"input.drop"` when adding content with drag-and-drop
   - `"input.complete"` when autocompleting
 - `"delete"` when the user deletes content
   - `"delete.selection"` when deleting the selection
   - `"delete.forward"` when deleting forward from the selection
   - `"delete.backward"` when deleting backward from the selection
   - `"delete.cut"` when cutting to the clipboard
 - `"move"` when content is moved
   - `"move.drop"` when content is moved within the editor through drag-and-drop
 - `"select"` when explicitly changing the selection
   - `"select.pointer"` when selecting with a mouse or other pointing device
 - `"undo"` and `"redo"` for history actions

Use [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check
whether the annotation matches a given event.
*/

Transaction.userEvent = /*@__PURE__*/Annotation.define();
/**
Annotation indicating whether a transaction should be added to
the undo history or not.
*/

Transaction.addToHistory = /*@__PURE__*/Annotation.define();
/**
Annotation indicating (when present and true) that a transaction
represents a change made by some other actor, not the user. This
is used, for example, to tag other people's changes in
collaborative editing.
*/

Transaction.remote = /*@__PURE__*/Annotation.define();

function joinRanges(a, b) {
  let result = [];

  for (let iA = 0, iB = 0;;) {
    let from, to;

    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from = a[iA++];
      to = a[iA++];
    } else if (iB < b.length) {
      from = b[iB++];
      to = b[iB++];
    } else return result;

    if (!result.length || result[result.length - 1] < from) result.push(from, to);else if (result[result.length - 1] < to) result[result.length - 1] = to;
  }
}

function mergeTransaction(a, b, sequential) {
  var _a;

  let mapForA, mapForB, changes;

  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a.changes);
    mapForB = a.changes.mapDesc(b.changes, true);
    changes = a.changes.compose(mapForA);
  }

  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  };
}

function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection,
      annotations = asArray(spec.annotations);
  if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}

function resolveTransaction(state, specs, filter) {
  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false) filter = false;

  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false) filter = false;
    let seq = !!specs[i].sequential;
    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
  }

  let tr = new Transaction(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr) : tr);
} // Finish a transaction by applying filters if necessary.


function filterTransaction(tr) {
  let state = tr.startState; // Change filters

  let result = true;

  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr);

    if (value === false) {
      result = false;
      break;
    }

    if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);
  }

  if (result !== true) {
    let changes, back;

    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.invertedDesc;
    }

    tr = new Transaction(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  } // Transaction filters


  let filters = state.facet(transactionFilter);

  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr);
    if (filtered instanceof Transaction) tr = filtered;else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr = filtered[0];else tr = resolveTransaction(state, asArray(filtered), false);
  }

  return tr;
}

function extendTransaction(tr) {
  let state = tr.startState,
      extenders = state.facet(transactionExtender),
      spec = tr;

  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension = extenders[i](tr);
    if (extension && Object.keys(extension).length) spec = mergeTransaction(tr, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }

  return spec == tr ? tr : new Transaction(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}

const none = [];

function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
/**
The categories produced by a [character
categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used
do things like selecting by word.
*/


var CharCategory = /*@__PURE__*/function (CharCategory) {
  /**
  Word characters.
  */
  CharCategory[CharCategory["Word"] = 0] = "Word";
  /**
  Whitespace.
  */

  CharCategory[CharCategory["Space"] = 1] = "Space";
  /**
  Anything else.
  */

  CharCategory[CharCategory["Other"] = 2] = "Other";
  return CharCategory;
}(CharCategory || (exports.CharCategory = CharCategory = {}));

exports.CharCategory = CharCategory;
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;

try {
  wordChar = /*@__PURE__*/new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {}

function hasWordChar(str) {
  if (wordChar) return wordChar.test(str);

  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;
  }

  return false;
}

function makeCategorizer(wordChars) {
  return char => {
    if (!/\S/.test(char)) return CharCategory.Space;
    if (hasWordChar(char)) return CharCategory.Word;

    for (let i = 0; i < wordChars.length; i++) if (char.indexOf(wordChars[i]) > -1) return CharCategory.Word;

    return CharCategory.Other;
  };
}
/**
The editor state class is a persistent (immutable) data structure.
To update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a
[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state
instance, without modifying the original object.

As such, _never_ mutate properties of a state directly. That'll
just break things.
*/


class EditorState {
  /**
  @internal
  */
  constructor(
  /**
  @internal
  */
  config,
  /**
  The current document.
  */
  doc,
  /**
  The current selection.
  */
  selection, tr = null) {
    this.config = config;
    this.doc = doc;
    this.selection = selection;
    /**
    @internal
    */

    this.applying = null;
    this.status = config.statusTemplate.slice();

    if (tr && tr.startState.config == config) {
      this.values = tr.startState.values.slice();
    } else {
      this.values = config.dynamicSlots.map(_ => null); // Copy over old values for shared facets/fields if this is a reconfigure

      if (tr) for (let id in config.address) {
        let cur = config.address[id],
            prev = tr.startState.config.address[id];
        if (prev != null && (cur & 1) == 0) this.values[cur >> 1] = getAddr(tr.startState, prev);
      }
    }

    this.applying = tr; // Fill in the computed state immediately, so that further queries
    // for it made during the update return this state

    if (tr) tr._state = this;

    for (let i = 0; i < this.config.dynamicSlots.length; i++) ensureAddr(this, i << 1);

    this.applying = null;
  }

  field(field, require = true) {
    let addr = this.config.address[field.id];

    if (addr == null) {
      if (require) throw new RangeError("Field is not present in this state");
      return undefined;
    }

    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */


  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */


  applyTransaction(tr) {
    let conf = this.config,
        {
      base,
      compartments
    } = conf;

    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }

        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base = asArray(base).concat(effect.value);
      }
    }

    new EditorState(conf || Configuration.resolve(base, compartments, this), tr.newDoc, tr.newSelection, tr);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */


  replaceSelection(text) {
    if (typeof text == "string") text = this.toText(text);
    return this.changeByRange(range => ({
      changes: {
        from: range.from,
        to: range.to,
        insert: text
      },
      range: EditorSelection.cursor(range.from + text.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */


  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes),
        ranges = [result1.range];
    let effects = asArray(result1.effects);

    for (let i = 1; i < sel.ranges.length; i++) {
      let result = f(sel.ranges[i]);
      let newChanges = this.changes(result.changes),
          newMapped = newChanges.map(changes);

      for (let j = 0; j < i; j++) ranges[j] = ranges[j].map(newMapped);

      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
    }

    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */


  changes(spec = []) {
    if (spec instanceof ChangeSet) return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#text.Text) instance from the given string.
  */


  toText(string) {
    return _text.Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */


  sliceDoc(from = 0, to = this.doc.length) {
    return this.doc.sliceString(from, to, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */


  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null) return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */


  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields) for (let prop in fields) {
      let value = fields[prop];
      if (value instanceof StateField) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
    }
    return result;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */


  static fromJSON(json, config = {}, fields) {
    if (!json || typeof json.doc != "string") throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields) for (let prop in fields) {
      let field = fields[prop],
          value = json[prop];
      fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));
    }
    return EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */


  static create(config = {}) {
    let configuration = Configuration.resolve(config.extensions || [], new Map());
    let doc = config.doc instanceof _text.Text ? config.doc : _text.Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
    let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
    checkSelection(selection, doc.length);
    if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();
    return new EditorState(configuration, doc, selection);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */


  get tabSize() {
    return this.facet(EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */


  get lineBreak() {
    return this.facet(EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */


  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  */


  phrase(phrase) {
    for (let map of this.facet(EditorState.phrases)) if (Object.prototype.hasOwnProperty.call(map, phrase)) return map[phrase];

    return phrase;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  */


  languageDataAt(name, pos, side = -1) {
    let values = [];

    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name)) values.push(result[name]);
      }
    }

    return values;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#text.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */


  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */


  wordAt(pos) {
    let {
      text,
      from,
      length
    } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from,
        end = pos - from;

    while (start > 0) {
      let prev = (0, _text.findClusterBreak)(text, start, false);
      if (cat(text.slice(prev, start)) != CharCategory.Word) break;
      start = prev;
    }

    while (end < length) {
      let next = (0, _text.findClusterBreak)(text, end);
      if (cat(text.slice(end, next)) != CharCategory.Word) break;
      end = next;
    }

    return start == end ? null : EditorSelection.range(start + from, end + from);
  }

}
/**
A facet that, when enabled, causes the editor to allow multiple
ranges to be selected. Be careful though, because by default the
editor relies on the native DOM selection, which cannot handle
multiple selections. An extension like
[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make
secondary selections visible to the user.
*/


exports.EditorState = EditorState;
EditorState.allowMultipleSelections = allowMultipleSelections;
/**
Configures the tab size to use in this state. The first
(highest-precedence) value of the facet is used. If no value is
given, this defaults to 4.
*/

EditorState.tabSize = /*@__PURE__*/Facet.define({
  combine: values => values.length ? values[0] : 4
});
/**
The line separator to use. By default, any of `"\n"`, `"\r\n"`
and `"\r"` is treated as a separator when splitting lines, and
lines are joined with `"\n"`.

When you configure a value here, only that precise separator
will be used, allowing you to round-trip documents through the
editor without normalizing line separators.
*/

EditorState.lineSeparator = lineSeparator;
/**
This facet controls the value of the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is
consulted by commands and extensions that implement editing
functionality to determine whether they should apply. It
defaults to false, but when its highest-precedence value is
`true`, such functionality disables itself.

Not to be confused with
[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which
controls whether the editor's DOM is set to be editable (and
thus focusable).
*/

EditorState.readOnly = readOnly;
/**
Registers translation phrases. The
[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through
all objects registered with this facet to find translations for
its argument.
*/

EditorState.phrases = /*@__PURE__*/Facet.define();
/**
A facet used to register [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.
*/

EditorState.languageData = languageData;
/**
Facet used to register change filters, which are called for each
transaction (unless explicitly
[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress
part of the transaction's changes.

Such a function can return `true` to indicate that it doesn't
want to do anything, `false` to completely stop the changes in
the transaction, or a set of ranges in which changes should be
suppressed. Such ranges are represented as an array of numbers,
with each pair of two number indicating the start and end of a
range. So for example `[10, 20, 100, 110]` suppresses changes
between 10 and 20, and between 100 and 110.
*/

EditorState.changeFilter = changeFilter;
/**
Facet used to register a hook that gets a chance to update or
replace transaction specs before they are applied. This will
only be applied for transactions that don't have
[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You
can either return a single transaction spec (possibly the input
transaction), or an array of specs (which will be combined in
the same way as the arguments to
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).

When possible, it is recommended to avoid accessing
[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,
since it will force creation of a state that will then be
discarded again, if the transaction is actually filtered.

(This functionality should be used with care. Indiscriminately
modifying transaction is likely to break something or degrade
the user experience.)
*/

EditorState.transactionFilter = transactionFilter;
/**
This is a more limited form of
[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),
which can only add
[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and
[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type
of filter runs even the transaction has disabled regular
[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable
for effects that don't need to touch the changes or selection,
but do want to process every transaction.

Extenders run _after_ filters, when both are applied.
*/

EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /*@__PURE__*/StateEffect.define();
/**
Utility function for combining behaviors to fill in a config
object from an array of provided configs. Will, by default, error
when a field gets two values that aren't `===`-equal, but you can
provide combine functions per field to do something else.
*/

function combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that
combine = {}) {
  let result = {};

  for (let config of configs) for (let key of Object.keys(config)) {
    let value = config[key],
        current = result[key];
    if (current === undefined) result[key] = value;else if (current === value || value === undefined) ; // No conflict
    else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value);else throw new Error("Config merge conflict for field " + key);
  }

  for (let key in defaults) if (result[key] === undefined) result[key] = defaults[key];

  return result;
}
},{"@codemirror/text":"node_modules/@codemirror/text/dist/index.js","process":"node_modules/process/browser.js"}],"node_modules/style-mod/src/style-mod.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StyleModule = void 0;
const C = "\u037c";
const COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {}; // :: - Style modules encapsulate a set of CSS rules defined from
// JavaScript. Their definitions are only available in a given DOM
// root after it has been _mounted_ there with `StyleModule.mount`.
//
// Style modules should be created once and stored somewhere, as
// opposed to re-creating them every time you need them. The amount of
// CSS rules generated for a given DOM root is bounded by the amount
// of style modules that were used. So to avoid leaking rules, don't
// create these dynamically, but treat them as one-time allocations.

class StyleModule {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = [];
    let {
      finish
    } = options || {};

    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }

    function render(selectors, spec, target, isKeyframes) {
      let local = [],
          isAt = /^@(\w+)\b/.exec(selectors[0]),
          keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec == null) return target.push(selectors[0] + ";");

      for (let prop in spec) {
        let value = spec[prop];

        if (/&/.test(prop)) {
          render(prop.split(/,\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);
        } else if (value && typeof value == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, l => "-" + l.toLowerCase()) + ": " + value + ";");
        }
      }

      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }

    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
  } // :: () → string
  // Returns a string containing the module's CSS rules.


  getRules() {
    return this.rules.join("\n");
  } // :: () → string
  // Generate a new unique CSS class name.


  static newName() {
    let id = top[COUNT] || 1;
    top[COUNT] = id + 1;
    return C + id.toString(36);
  } // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.


  static mount(root, modules) {
    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
  }

}

exports.StyleModule = StyleModule;
let adoptedSet = null;

class StyleSet {
  constructor(root) {
    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
      if (adoptedSet) {
        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
        return root[SET] = adoptedSet;
      }

      this.sheet = new CSSStyleSheet();
      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
      adoptedSet = this;
    } else {
      this.styleTag = (root.ownerDocument || root).createElement("style");
      let target = root.head || root;
      target.insertBefore(this.styleTag, target.firstChild);
    }

    this.modules = [];
    root[SET] = this;
  }

  mount(modules) {
    let sheet = this.sheet;
    let pos = 0
    /* Current rule offset */
    ,
        j = 0;
    /* Index into this.modules */

    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i],
          index = this.modules.indexOf(mod);

      if (index < j && index > -1) {
        // Ordering conflict
        this.modules.splice(index, 1);
        j--;
        index = -1;
      }

      if (index == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet) for (let k = 0; k < mod.rules.length; k++) sheet.insertRule(mod.rules[k], pos++);
      } else {
        while (j < index) pos += this.modules[j++].rules.length;

        pos += mod.rules.length;
        j++;
      }
    }

    if (!sheet) {
      let text = "";

      for (let i = 0; i < this.modules.length; i++) text += this.modules[i].getRules() + "\n";

      this.styleTag.textContent = text;
    }
  }

} // Style::Object<union<Style,string>>
//
// A style is an object that, in the simple case, maps CSS property
// names to strings holding their values, as in `{color: "red",
// fontWeight: "bold"}`. The property names can be given in
// camel-case—the library will insert a dash before capital letters
// when converting them to CSS.
//
// If you include an underscore in a property name, it and everything
// after it will be removed from the output, which can be useful when
// providing a property multiple times, for browser compatibility
// reasons.
//
// A property in a style object can also be a sub-selector, which
// extends the current context to add a pseudo-selector or a child
// selector. Such a property should contain a `&` character, which
// will be replaced by the current selector. For example `{"&:before":
// {content: '"hi"'}}`. Sub-selectors and regular properties can
// freely be mixed in a given object. Any property containing a `&` is
// assumed to be a sub-selector.
//
// Finally, a property can specify an @-block to be wrapped around the
// styles defined inside the object that's the property's value. For
// example to create a media query you can do `{"@media screen and
// (min-width: 400px)": {...}}`.
},{}],"node_modules/@codemirror/rangeset/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RangeValue = exports.RangeSetBuilder = exports.RangeSet = exports.Range = void 0;

var _state = require("@codemirror/state");

/**
Each range is associated with a value, which must inherit from
this class.
*/
class RangeValue {
  /**
  Compare this value with another value. The default
  implementation compares by identity.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.
  */


  range(from, to = from) {
    return new Range(from, to, this);
  }

}

exports.RangeValue = RangeValue;
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = _state.MapMode.TrackDel;
/**
A range associates a value with a range of positions.
*/

class Range {
  /**
  @internal
  */
  constructor(
  /**
  The range's start position.
  */
  from,
  /**
  Its end position.
  */
  to,
  /**
  The value associated with this range.
  */
  value) {
    this.from = from;
    this.to = to;
    this.value = value;
  }

}

exports.Range = Range;

function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide;
}

class Chunk {
  constructor(from, to, value, // Chunks are marked with the largest point that occurs
  // in them (or -1 for no points), so that scans that are
  // only interested in points (such as the
  // heightmap-related logic) can skip range-only chunks.
  maxPoint) {
    this.from = from;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }

  get length() {
    return this.to[this.to.length - 1];
  } // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.


  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;

    for (let lo = startAt, hi = arr.length;;) {
      if (lo == hi) return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo) return diff >= 0 ? lo : hi;
      if (diff >= 0) hi = mid;else lo = mid + 1;
    }
  }

  between(offset, from, to, f) {
    for (let i = this.findIndex(from, -1000000000
    /* Far */
    , true), e = this.findIndex(to, 1000000000
    /* Far */
    , false, i); i < e; i++) if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;
  }

  map(offset, changes) {
    let value = [],
        from = [],
        to = [],
        newPos = -1,
        maxPoint = -1;

    for (let i = 0; i < this.value.length; i++) {
      let val = this.value[i],
          curFrom = this.from[i] + offset,
          curTo = this.to[i] + offset,
          newFrom,
          newTo;

      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null) continue;
        newFrom = newTo = mapped;
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;
      }

      if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;
      if (newPos < 0) newPos = newFrom;
      if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to.push(newTo - newPos);
    }

    return {
      mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,
      pos: newPos
    };
  }

}
/**
A range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a
way that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and
[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data
structure.
*/


class RangeSet {
  /**
  @internal
  */
  constructor(
  /**
  @internal
  */
  chunkPos,
  /**
  @internal
  */
  chunk,
  /**
  @internal
  */
  nextLayer = RangeSet.empty,
  /**
  @internal
  */
  maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */


  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */


  get size() {
    if (this.isEmpty) return 0;
    let size = this.nextLayer.size;

    for (let chunk of this.chunk) size += chunk.value.length;

    return size;
  }
  /**
  @internal
  */


  chunkEnd(index) {
    return this.chunkPos[index] + this.chunk[index].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (The extra type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */


  update(updateSpec) {
    let {
      add = [],
      sort = false,
      filterFrom = 0,
      filterTo = this.length
    } = updateSpec;
    let filter = updateSpec.filter;
    if (add.length == 0 && !filter) return this;
    if (sort) add.slice().sort(cmpRange);
    if (this.isEmpty) return add.length ? RangeSet.of(add) : this;
    let cur = new LayerCursor(this, null, -1).goto(0),
        i = 0,
        spill = [];
    let builder = new RangeSetBuilder();

    while (cur.value || i < add.length) {
      if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
        let range = add[i++];
        if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);
      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
        cur.nextChunk();
      } else {
        if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
          if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(new Range(cur.from, cur.to, cur.value));
        }

        cur.next();
      }
    }

    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({
      add: spill,
      filter,
      filterFrom,
      filterTo
    }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */


  map(changes) {
    if (changes.length == 0 || this.isEmpty) return this;
    let chunks = [],
        chunkPos = [],
        maxPoint = -1;

    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i],
          chunk = this.chunk[i];
      let touch = changes.touchesRange(start, start + chunk.length);

      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let {
          mapped,
          pos
        } = chunk.map(start, changes);

        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }

    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */


  between(from, to, f) {
    if (this.isEmpty) return;

    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i],
          chunk = this.chunk[i];
      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;
    }

    this.nextLayer.between(from, to, f);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */


  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  /**
  @internal
  */


  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */


  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */


  static compare(oldSets, newSets,
  /**
  This indicates how the underlying data changed between these
  ranges, and is needed to synchronize the iteration. `from` and
  `to` are coordinates in the _new_ space, after these changes.
  */
  textDiff, comparator,
  /**
  Can be used to ignore all non-point ranges, and points below
  the given size. When -1, all ranges are compared.
  */
  minPointSize = -1) {
    let a = oldSets.filter(set => set.maxPoint >= 500
    /* BigPointSize */
    || !set.isEmpty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);
    let b = newSets.filter(set => set.maxPoint >= 500
    /* BigPointSize */
    || !set.isEmpty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */


  static eq(oldSets, newSets, from = 0, to) {
    if (to == null) to = 1000000000
    /* Far */
    ;
    let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);
    let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);
    if (a.length != b.length) return false;
    if (!a.length) return true;
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from),
        sideB = new SpanCursor(b, sharedChunks, 0).goto(from);

    for (;;) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;
      if (sideA.to >= to) return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end
  of the iteration.
  */


  static spans(sets, from, to, iterator,
  /**
  When given and greater than -1, only points of at least this
  size are taken into account.
  */
  minPointSize = -1) {
    let cursor = new SpanCursor(sets, null, minPointSize).goto(from),
        pos = from;
    let open = cursor.openStart;

    for (;;) {
      let curTo = Math.min(cursor.to, to);

      if (cursor.point) {
        iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);
        open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor.active, open);
        open = cursor.openEnd(curTo);
      }

      if (cursor.to > to) break;
      pos = cursor.to;
      cursor.next();
    }

    return open;
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */


  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();

    for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges) build.add(range.from, range.to, range.value);

    return build.finish();
  }

}
/**
The empty set of ranges.
*/


exports.RangeSet = RangeSet;
RangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);

function lazySort(ranges) {
  if (ranges.length > 1) for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
    let cur = ranges[i];
    if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);
    prev = cur;
  }
  return ranges;
}

RangeSet.empty.nextLayer = RangeSet.empty;
/**
A range set builder is a data structure that helps build up a
[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating
an array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.
*/

class RangeSetBuilder {
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1000000000
    /* Far */
    ;
    this.lastTo = -1000000000
    /* Far */
    ;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }

  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;

    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */


  add(from, to, value) {
    if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
  }
  /**
  @internal
  */


  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0) return false;
    if (this.from.length == 250
    /* ChunkSize */
    ) this.finishChunk(true);
    if (this.chunkStart < 0) this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to;
    this.value.push(value);
    if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);
    return true;
  }
  /**
  @internal
  */


  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;
    if (this.from.length) this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from;
    this.lastTo = chunk.to[last] + from;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */


  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */


  finishInner(next) {
    if (this.from.length) this.finishChunk(false);
    if (this.chunks.length == 0) return next;
    let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null; // Make sure further `add` calls produce errors

    return result;
  }

}

exports.RangeSetBuilder = RangeSetBuilder;

function findSharedChunks(a, b) {
  let inA = new Map();

  for (let set of a) for (let i = 0; i < set.chunk.length; i++) if (set.chunk[i].maxPoint < 500
  /* BigPointSize */
  ) inA.set(set.chunk[i], set.chunkPos[i]);

  let shared = new Set();

  for (let set of b) for (let i = 0; i < set.chunk.length; i++) if (inA.get(set.chunk[i]) == set.chunkPos[i]) shared.add(set.chunk[i]);

  return shared;
}

class LayerCursor {
  constructor(layer, skip, minPoint, rank = 0) {
    this.layer = layer;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }

  get startSide() {
    return this.value ? this.value.startSide : 0;
  }

  get endSide() {
    return this.value ? this.value.endSide : 0;
  }

  goto(pos, side = -1000000000
  /* Far */
  ) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }

  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;
      this.chunkIndex++;
      forward = false;
    }

    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);
    }

    this.next();
  }

  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);
  }

  next() {
    for (;;) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1000000000
        /* Far */
        ;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex],
            chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;
      }
    }
  }

  setRangeIndex(index) {
    if (index == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;

      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) this.chunkIndex++;
      }

      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index;
    }
  }

  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }

  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;
  }

}

class HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }

  static from(sets, skip = null, minPoint = -1) {
    let heap = [];

    for (let i = 0; i < sets.length; i++) {
      for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
        if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));
      }
    }

    return heap.length == 1 ? heap[0] : new HeapCursor(heap);
  }

  get startSide() {
    return this.value ? this.value.startSide : 0;
  }

  goto(pos, side = -1000000000
  /* Far */
  ) {
    for (let cur of this.heap) cur.goto(pos, side);

    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);

    this.next();
    return this;
  }

  forward(pos, side) {
    for (let cur of this.heap) cur.forward(pos, side);

    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);

    if ((this.to - pos || this.value.endSide - side) < 0) this.next();
  }

  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1000000000
      /* Far */
      ;
      this.value = null;
      this.rank = -1;
    } else {
      let top = this.heap[0];
      this.from = top.from;
      this.to = top.to;
      this.value = top.value;
      this.rank = top.rank;
      if (top.value) top.next();
      heapBubble(this.heap, 0);
    }
  }

}

function heapBubble(heap, index) {
  for (let cur = heap[index];;) {
    let childIndex = (index << 1) + 1;
    if (childIndex >= heap.length) break;
    let child = heap[childIndex];

    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }

    if (cur.compare(child) < 0) break;
    heap[childIndex] = cur;
    heap[index] = child;
    index = childIndex;
  }
}

class SpanCursor {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1; // A currently active point range, if any

    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1000000000
    /* Far */
    ;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }

  goto(pos, side = -1000000000
  /* Far */
  ) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }

  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) this.removeActive(this.minActive);

    this.cursor.forward(pos, side);
  }

  removeActive(index) {
    remove(this.active, index);
    remove(this.activeTo, index);
    remove(this.activeRank, index);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }

  addActive(trackOpen) {
    let i = 0,
        {
      value,
      to,
      rank
    } = this.cursor;

    while (i < this.activeRank.length && this.activeRank[i] <= rank) i++;

    insert(this.active, i, value);
    insert(this.activeTo, i, to);
    insert(this.activeRank, i, rank);
    if (trackOpen) insert(trackOpen, i, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  } // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.


  next() {
    let from = this.to,
        wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null,
        trackExtra = 0;

    for (;;) {
      let a = this.minActive;

      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a] > from) {
          this.to = this.activeTo[a];
          this.endSide = this.active[a].endSide;
          break;
        }

        this.removeActive(a);
        if (trackOpen) remove(trackOpen, a);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1000000000
        /* Far */
        ;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;

        if (!nextVal.point) {
          // Opening a range
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to && nextVal.endSide == this.endSide) {
          // Ignore any non-empty points that end precisely at the end of the prev point
          this.cursor.next();
        } else {
          // New point
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          if (this.cursor.from < from) trackExtra = 1;
          this.cursor.next();
          if (this.to > from) this.forward(this.to, this.endSide);
          break;
        }
      }
    }

    if (trackOpen) {
      let openStart = 0;

      while (openStart < trackOpen.length && trackOpen[openStart] < from) openStart++;

      this.openStart = openStart + trackExtra;
    }
  }

  activeForPoint(to) {
    if (!this.active.length) return this.active;
    let active = [];

    for (let i = this.active.length - 1; i >= 0; i--) {
      if (this.activeRank[i] < this.pointRank) break;
      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide) active.push(this.active[i]);
    }

    return active.reverse();
  }

  openEnd(to) {
    let open = 0;

    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--) open++;

    return open;
  }

}

function compare(a, startA, b, startB, length, comparator) {
  a.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB,
      dPos = startB - startA;

  for (;;) {
    let diff = a.to + dPos - b.to || a.endSide - b.endSide;
    let end = diff < 0 ? a.to + dPos : b.to,
        clipEnd = Math.min(end, endB);

    if (a.point || b.point) {
      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);
    }

    if (end > endB) break;
    pos = end;
    if (diff <= 0) a.next();
    if (diff >= 0) b.next();
  }
}

function sameValues(a, b) {
  if (a.length != b.length) return false;

  for (let i = 0; i < a.length; i++) if (a[i] != b[i] && !a[i].eq(b[i])) return false;

  return true;
}

function remove(array, index) {
  for (let i = index, e = array.length - 1; i < e; i++) array[i] = array[i + 1];

  array.pop();
}

function insert(array, index, value) {
  for (let i = array.length - 1; i >= index; i--) array[i + 1] = array[i];

  array[index] = value;
}

function findMinIndex(value, array) {
  let found = -1,
      foundPos = 1000000000
  /* Far */
  ;

  for (let i = 0; i < array.length; i++) if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
    found = i;
    foundPos = array[i];
  }

  return found;
}
},{"@codemirror/state":"node_modules/@codemirror/state/dist/index.js"}],"node_modules/w3c-keyname/index.es.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keyName = keyName;
exports.shift = exports.base = void 0;
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
exports.base = base;
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\"",
  229: "Q"
};
exports.shift = shift;
var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac; // Fill in the digit keys

for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i); // The function keys


for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i; // And the alphabetic keys


for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
} // For each code that doesn't have a shift-equivalent, copy the base name


for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];

function keyName(event) {
  // Don't trust event.key in Chrome when there are modifiers until
  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari || ie) && event.shiftKey && event.key && event.key.length == 1;
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified"; // Edge sometimes produces wrong names (Issue #3)

  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete"; // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/

  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}
},{}],"node_modules/@codemirror/view/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawSelection = drawSelection;
exports.highlightActiveLine = highlightActiveLine;
exports.highlightSpecialChars = highlightSpecialChars;
exports.logException = logException;
exports.placeholder = placeholder;
exports.runScopeHandlers = runScopeHandlers;
exports.scrollPastEnd = scrollPastEnd;
Object.defineProperty(exports, "Range", {
  enumerable: true,
  get: function () {
    return _rangeset.Range;
  }
});
exports.keymap = exports.__test = exports.WidgetType = exports.ViewUpdate = exports.ViewPlugin = exports.PluginFieldProvider = exports.PluginField = exports.MatchDecorator = exports.EditorView = exports.Direction = exports.Decoration = exports.BlockType = exports.BlockInfo = exports.BidiSpan = void 0;

var _state = require("@codemirror/state");

var _styleMod = require("style-mod");

var _rangeset = require("@codemirror/rangeset");

var _text = require("@codemirror/text");

var _w3cKeyname = require("w3c-keyname");

function getSelection(root) {
  let target; // Browsers differ on whether shadow roots have a getSelection
  // method. If it exists, use that, otherwise, call it on the
  // document.

  if (root.nodeType == 11) {
    // Shadow root
    target = root.getSelection ? root : root.ownerDocument;
  } else {
    target = root;
  }

  return target.getSelection();
}

function contains(dom, node) {
  return node ? dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}

function deepActiveElement() {
  let elt = document.activeElement;

  while (elt && elt.shadowRoot) elt = elt.shadowRoot.activeElement;

  return elt;
}

function hasSelection(dom, selection) {
  if (!selection.anchorNode) return false;

  try {
    // Firefox will raise 'permission denied' errors when accessing
    // properties of `sel.anchorNode` when it's in a generated CSS
    // element.
    return contains(dom, selection.anchorNode);
  } catch (_) {
    return false;
  }
}

function clientRectsFor(dom) {
  if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();else if (dom.nodeType == 1) return dom.getClientRects();else return [];
} // Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)


function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}

function domIndex(node) {
  for (var index = 0;; index++) {
    node = node.previousSibling;
    if (!node) return index;
  }
}

function scanFor(node, off, targetNode, targetOff, dir) {
  for (;;) {
    if (node == targetNode && off == targetOff) return true;

    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV") return false;
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1) return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.nodeType == 1 && node.contentEditable == "false") return false;
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}

function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}

const Rect0 = {
  left: 0,
  right: 0,
  top: 0,
  bottom: 0
};

function flattenRect(rect, left) {
  let x = left ? rect.left : rect.right;
  return {
    left: x,
    right: x,
    top: rect.top,
    bottom: rect.bottom
  };
}

function windowRect(win) {
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}

const ScrollSpace = 5;

function scrollRectIntoView(dom, rect, side) {
  let doc = dom.ownerDocument,
      win = doc.defaultView;

  for (let cur = dom.parentNode; cur;) {
    if (cur.nodeType == 1) {
      // Element
      let bounding,
          top = cur == doc.body;

      if (top) {
        bounding = windowRect(win);
      } else {
        if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
          cur = cur.parentNode;
          continue;
        }

        let rect = cur.getBoundingClientRect(); // Make sure scrollbar width isn't included in the rectangle

        bounding = {
          left: rect.left,
          right: rect.left + cur.clientWidth,
          top: rect.top,
          bottom: rect.top + cur.clientHeight
        };
      }

      let moveX = 0,
          moveY = 0;

      if (rect.top < bounding.top) {
        moveY = -(bounding.top - rect.top + ScrollSpace);
        if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + moveY + ScrollSpace;
      } else if (rect.bottom > bounding.bottom) {
        moveY = rect.bottom - bounding.bottom + ScrollSpace;
        if (side < 0 && rect.top - moveY < bounding.top) moveY = -(bounding.top + moveY - rect.top + ScrollSpace);
      }

      if (rect.left < bounding.left) {
        moveX = -(bounding.left - rect.left + ScrollSpace);
        if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + moveX + ScrollSpace;
      } else if (rect.right > bounding.right) {
        moveX = rect.right - bounding.right + ScrollSpace;
        if (side < 0 && rect.left < bounding.left + moveX) moveX = -(bounding.left + moveX - rect.left + ScrollSpace);
      }

      if (moveX || moveY) {
        if (top) {
          win.scrollBy(moveX, moveY);
        } else {
          if (moveY) {
            let start = cur.scrollTop;
            cur.scrollTop += moveY;
            moveY = cur.scrollTop - start;
          }

          if (moveX) {
            let start = cur.scrollLeft;
            cur.scrollLeft += moveX;
            moveX = cur.scrollLeft - start;
          }

          rect = {
            left: rect.left - moveX,
            top: rect.top - moveY,
            right: rect.right - moveX,
            bottom: rect.bottom - moveY
          };
        }
      }

      if (top) break;
      cur = cur.assignedSlot || cur.parentNode;
    } else if (cur.nodeType == 11) {
      // A shadow root
      cur = cur.host;
    } else {
      break;
    }
  }
}

class DOMSelection {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }

  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }

  set(domSel) {
    this.anchorNode = domSel.anchorNode;
    this.anchorOffset = domSel.anchorOffset;
    this.focusNode = domSel.focusNode;
    this.focusOffset = domSel.focusOffset;
  }

}

let preventScrollSupported = null; // Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.

function focusPreventScroll(dom) {
  if (dom.setActive) return dom.setActive(); // in IE

  if (preventScrollSupported) return dom.focus(preventScrollSupported);
  let stack = [];

  for (let cur = dom; cur; cur = cur.parentNode) {
    stack.push(cur, cur.scrollTop, cur.scrollLeft);
    if (cur == cur.ownerDocument) break;
  }

  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = {
        preventScroll: true
      };
      return true;
    }

  } : undefined);

  if (!preventScrollSupported) {
    preventScrollSupported = false;

    for (let i = 0; i < stack.length;) {
      let elt = stack[i++],
          top = stack[i++],
          left = stack[i++];
      if (elt.scrollTop != top) elt.scrollTop = top;
      if (elt.scrollLeft != left) elt.scrollLeft = left;
    }
  }
}

let scratchRange;

function textRange(node, from, to = from) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node, to);
  range.setStart(node, from);
  return range;
}

function dispatchKey(elt, name, code) {
  let options = {
    key: name,
    code: name,
    keyCode: code,
    which: code,
    cancelable: true
  };
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options);
  up.synthetic = true;
  elt.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}

let _plainTextSupported = null;

function contentEditablePlainTextSupported() {
  if (_plainTextSupported == null) {
    _plainTextSupported = false;
    let dummy = document.createElement("div");

    try {
      dummy.contentEditable = "plaintext-only";
      _plainTextSupported = dummy.contentEditable == "plaintext-only";
    } catch (_) {}
  }

  return _plainTextSupported;
}

class DOMPos {
  constructor(node, offset, precise = true) {
    this.node = node;
    this.offset = offset;
    this.precise = precise;
  }

  static before(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom), precise);
  }

  static after(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }

}

const none$3 = [];

class ContentView {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.dirty = 2
    /* Node */
    ;
  }

  get editorView() {
    if (!this.parent) throw new Error("Accessing view in orphan content view");
    return this.parent.editorView;
  }

  get overrideDOMText() {
    return null;
  }

  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }

  get posAtEnd() {
    return this.posAtStart + this.length;
  }

  posBefore(view) {
    let pos = this.posAtStart;

    for (let child of this.children) {
      if (child == view) return pos;
      pos += child.length + child.breakAfter;
    }

    throw new RangeError("Invalid child in posBefore");
  }

  posAfter(view) {
    return this.posBefore(view) + view.length;
  } // Will return a rectangle directly before (when side < 0), after
  // (side > 0) or directly on (when the browser supports it) the
  // given position.


  coordsAt(_pos, _side) {
    return null;
  }

  sync(track) {
    var _a;

    if (this.dirty & 2
    /* Node */
    ) {
        let parent = this.dom,
            pos = null;

        for (let child of this.children) {
          if (child.dirty) {
            let next = pos ? pos.nextSibling : parent.firstChild;
            if (!child.dom && next && !((_a = ContentView.get(next)) === null || _a === void 0 ? void 0 : _a.parent)) child.reuseDOM(next);
            child.sync(track);
            child.dirty = 0
            /* Not */
            ;
          }

          if (track && track.node == parent && pos != child.dom) track.written = true;
          syncNodeInto(parent, pos, child.dom);
          pos = child.dom;
        }

        let next = pos ? pos.nextSibling : parent.firstChild;
        if (next && track && track.node == parent) track.written = true;

        while (next) next = rm(next);
      } else if (this.dirty & 1
    /* Child */
    ) {
        for (let child of this.children) if (child.dirty) {
          child.sync(track);
          child.dirty = 0
          /* Not */
          ;
        }
      }
  }

  reuseDOM(_dom) {
    return false;
  }

  localPosFromDOM(node, offset) {
    let after;

    if (node == this.dom) {
      after = this.dom.childNodes[offset];
    } else {
      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;

      for (;;) {
        let parent = node.parentNode;
        if (parent == this.dom) break;

        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node == parent.firstChild) bias = -1;else bias = 1;
        }

        node = parent;
      }

      if (bias < 0) after = node;else after = node.nextSibling;
    }

    if (after == this.dom.firstChild) return 0;

    while (after && !ContentView.get(after)) after = after.nextSibling;

    if (!after) return this.length;

    for (let i = 0, pos = 0;; i++) {
      let child = this.children[i];
      if (child.dom == after) return pos;
      pos += child.length + child.breakAfter;
    }
  }

  domBoundsAround(from, to, offset = 0) {
    let fromI = -1,
        fromStart = -1,
        toI = -1,
        toEnd = -1;

    for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
      let child = this.children[i],
          end = pos + child.length;
      if (pos < from && end > to) return child.domBoundsAround(from, to, pos);

      if (end >= from && fromI == -1) {
        fromI = i;
        fromStart = pos;
      }

      if (pos > to && child.dom.parentNode == this.dom) {
        toI = i;
        toEnd = prevEnd;
        break;
      }

      prevEnd = end;
      pos = end + child.breakAfter;
    }

    return {
      from: fromStart,
      to: toEnd < 0 ? offset + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }

  markDirty(andParent = false) {
    this.dirty |= 2
    /* Node */
    ;
    this.markParentsDirty(andParent);
  }

  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList) parent.dirty |= 2
      /* Node */
      ;
      if (parent.dirty & 1
      /* Child */
      ) return;
      parent.dirty |= 1
      /* Child */
      ;
      childList = false;
    }
  }

  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.dirty) this.markParentsDirty(true);
    }
  }

  setDOM(dom) {
    if (this.dom) this.dom.cmView = null;
    this.dom = dom;
    dom.cmView = this;
  }

  get rootView() {
    for (let v = this;;) {
      let parent = v.parent;
      if (!parent) return v;
      v = parent;
    }
  }

  replaceChildren(from, to, children = none$3) {
    this.markDirty();

    for (let i = from; i < to; i++) {
      let child = this.children[i];
      if (child.parent == this) child.parent = null;
    }

    this.children.splice(from, to - from, ...children);

    for (let i = 0; i < children.length; i++) children[i].setParent(this);
  }

  ignoreMutation(_rec) {
    return false;
  }

  ignoreEvent(_event) {
    return false;
  }

  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }

  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }

  toString() {
    let name = this.constructor.name.replace("View", "");
    return name + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }

  static get(node) {
    return node.cmView;
  }

}

ContentView.prototype.breakAfter = 0; // Remove a DOM node and return its next sibling.

function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}

function syncNodeInto(parent, after, dom) {
  let next = after ? after.nextSibling : parent.firstChild;
  if (dom.parentNode == parent) while (next != dom) next = rm(next);else parent.insertBefore(dom, next);
}

class ChildCursor {
  constructor(children, pos, i) {
    this.children = children;
    this.pos = pos;
    this.i = i;
    this.off = 0;
  }

  findPos(pos, bias = 1) {
    for (;;) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }

      let next = this.children[--this.i];
      this.pos -= next.length + next.breakAfter;
    }
  }

}

let [nav, doc] = typeof navigator != "undefined" ? [navigator, document] : [{
  userAgent: "",
  vendor: "",
  platform: ""
}, {
  documentElement: {
    style: {}
  }
}];
const ie_edge = /*@__PURE__*/ /Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /*@__PURE__*/ /MSIE \d/.test(nav.userAgent);
const ie_11up = /*@__PURE__*/ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !ie && /*@__PURE__*/ /gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !ie && /*@__PURE__*/ /Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = ("webkitFontSmoothing" in doc.documentElement.style);
const safari = !ie && /*@__PURE__*/ /Apple Computer/.test(nav.vendor);
var browser = {
  mac: /*@__PURE__*/ /Mac/.test(nav.platform),
  ie,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +( /*@__PURE__*/ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios: safari && ( /*@__PURE__*/ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2),
  android: /*@__PURE__*/ /Android\b/.test(nav.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +( /*@__PURE__*/ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const none$2 = [];

class InlineView extends ContentView {
  /**
  Return true when this view is equivalent to `other` and can take
  on its role.
  */
  become(_other) {
    return false;
  } // When this is a zero-length view with a side, this should return a
  // negative number to indicate it is before its position, or a
  // positive number when after its position.


  getSide() {
    return 0;
  }

}

InlineView.prototype.children = none$2;
const MaxJoinLen = 256;

class TextView extends InlineView {
  constructor(text) {
    super();
    this.text = text;
  }

  get length() {
    return this.text.length;
  }

  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }

  sync(track) {
    if (!this.dom) this.createDOM();

    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom) track.written = true;
      this.dom.nodeValue = this.text;
    }
  }

  reuseDOM(dom) {
    if (dom.nodeType != 3) return false;
    this.createDOM(dom);
    return true;
  }

  merge(from, to, source) {
    if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen)) return false;
    this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
    this.markDirty();
    return true;
  }

  slice(from) {
    let result = new TextView(this.text.slice(from));
    this.text = this.text.slice(0, from);
    return result;
  }

  localPosFromDOM(node, offset) {
    return node == this.dom ? offset : offset ? this.text.length : 0;
  }

  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }

  domBoundsAround(_from, _to, offset) {
    return {
      from: offset,
      to: offset + this.length,
      startDOM: this.dom,
      endDOM: this.dom.nextSibling
    };
  }

  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }

}

class MarkView extends InlineView {
  constructor(mark, children = [], length = 0) {
    super();
    this.mark = mark;
    this.children = children;
    this.length = length;

    for (let ch of children) ch.setParent(this);
  }

  createDOM() {
    let dom = document.createElement(this.mark.tagName);
    if (this.mark.class) dom.className = this.mark.class;
    if (this.mark.attrs) for (let name in this.mark.attrs) dom.setAttribute(name, this.mark.attrs[name]);
    this.setDOM(dom);
  }

  sync(track) {
    if (!this.dom || this.dirty & 4
    /* Attrs */
    ) this.createDOM();
    super.sync(track);
  }

  merge(from, to, source, openStart, openEnd) {
    if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
    mergeInlineChildren(this, from, to, source ? source.children : none$2, openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }

  slice(from) {
    let result = [],
        off = 0,
        detachFrom = -1,
        i = 0;

    for (let elt of this.children) {
      let end = off + elt.length;
      if (end > from) result.push(off < from ? elt.slice(from - off) : elt);
      if (detachFrom < 0 && off >= from) detachFrom = i;
      off = end;
      i++;
    }

    let length = this.length - from;
    this.length = from;
    if (detachFrom > -1) this.replaceChildren(detachFrom, this.children.length);
    return new MarkView(this.mark, result, length);
  }

  domAtPos(pos) {
    return inlineDOMAtPos(this.dom, this.children, pos);
  }

  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }

}

function textCoords(text, pos, side) {
  let length = text.nodeValue.length;
  if (pos > length) pos = length;
  let from = pos,
      to = pos,
      flatten = 0;

  if (pos == 0 && side < 0 || pos == length && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      // These browsers reliably return valid rectangles for empty ranges
      if (pos) {
        from--;
        flatten = 1;
      } // FIXME this is wrong in RTL text
      else {
          to++;
          flatten = -1;
        }
    }
  } else {
    if (side < 0) from--;else to++;
  }

  let rects = textRange(text, from, to).getClientRects();
  if (!rects.length) return Rect0;
  let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, r => r.width) || rect;
  return flatten ? flattenRect(rect, flatten < 0) : rect;
} // Also used for collapsed ranges that don't have a placeholder widget!


class WidgetView extends InlineView {
  constructor(widget, length, side) {
    super();
    this.widget = widget;
    this.length = length;
    this.side = side;
  }

  static create(widget, length, side) {
    return new (widget.customView || WidgetView)(widget, length, side);
  }

  slice(from) {
    let result = WidgetView.create(this.widget, this.length - from, this.side);
    this.length -= from;
    return result;
  }

  sync() {
    if (!this.dom || !this.widget.updateDOM(this.dom)) {
      this.setDOM(this.widget.toDOM(this.editorView));
      this.dom.contentEditable = "false";
    }
  }

  getSide() {
    return this.side;
  }

  merge(from, to, source, openStart, openEnd) {
    if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }

  become(other) {
    if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
      if (this.widget.constructor == other.widget.constructor) {
        if (!this.widget.eq(other.widget)) this.markDirty(true);
        this.widget = other.widget;
        return true;
      }
    }

    return false;
  }

  ignoreMutation() {
    return true;
  }

  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }

  get overrideDOMText() {
    if (this.length == 0) return _text.Text.empty;
    let top = this;

    while (top.parent) top = top.parent;

    let view = top.editorView,
        text = view && view.state.doc,
        start = this.posAtStart;
    return text ? text.slice(start, start + this.length) : _text.Text.empty;
  }

  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }

  domBoundsAround() {
    return null;
  }

  coordsAt(pos, side) {
    let rects = this.dom.getClientRects(),
        rect = null;
    if (!rects.length) return Rect0;

    for (let i = pos > 0 ? rects.length - 1 : 0;; i += pos > 0 ? -1 : 1) {
      rect = rects[i];
      if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;
    }

    return pos == 0 && side > 0 || pos == this.length && side <= 0 ? rect : flattenRect(rect, pos == 0);
  }

}

class CompositionView extends WidgetView {
  domAtPos(pos) {
    return new DOMPos(this.widget.text, pos);
  }

  sync() {
    if (!this.dom) this.setDOM(this.widget.toDOM());
  }

  localPosFromDOM(node, offset) {
    return !offset ? 0 : node.nodeType == 3 ? Math.min(offset, this.length) : this.length;
  }

  ignoreMutation() {
    return false;
  }

  get overrideDOMText() {
    return null;
  }

  coordsAt(pos, side) {
    return textCoords(this.widget.text, pos, side);
  }

}

function mergeInlineChildren(parent, from, to, elts, openStart, openEnd) {
  let cur = parent.childCursor();
  let {
    i: toI,
    off: toOff
  } = cur.findPos(to, 1);
  let {
    i: fromI,
    off: fromOff
  } = cur.findPos(from, -1);
  let dLen = from - to;

  for (let view of elts) dLen += view.length;

  parent.length += dLen;
  let {
    children
  } = parent; // Both from and to point into the same child view

  if (fromI == toI && fromOff) {
    let start = children[fromI]; // Maybe just update that view and be done

    if (elts.length == 1 && start.merge(fromOff, toOff, elts[0], openStart, openEnd)) return;

    if (elts.length == 0) {
      start.merge(fromOff, toOff, null, openStart, openEnd);
      return;
    } // Otherwise split it, so that we don't have to worry about aliasing front/end afterwards


    let after = start.slice(toOff);
    if (after.merge(0, 0, elts[elts.length - 1], 0, openEnd)) elts[elts.length - 1] = after;else elts.push(after);
    toI++;
    openEnd = toOff = 0;
  } // Make sure start and end positions fall on node boundaries
  // (fromOff/toOff are no longer used after this), and that if the
  // start or end of the elts can be merged with adjacent nodes,
  // this is done


  if (toOff) {
    let end = children[toI];

    if (elts.length && end.merge(0, toOff, elts[elts.length - 1], 0, openEnd)) {
      elts.pop();
      openEnd = elts.length ? 0 : openStart;
    } else {
      end.merge(0, toOff, null, 0, 0);
    }
  } else if (toI < children.length && elts.length && children[toI].merge(0, 0, elts[elts.length - 1], 0, openEnd)) {
    elts.pop();
    openEnd = elts.length ? 0 : openStart;
  }

  if (fromOff) {
    let start = children[fromI];

    if (elts.length && start.merge(fromOff, start.length, elts[0], openStart, 0)) {
      elts.shift();
      openStart = elts.length ? 0 : openEnd;
    } else {
      start.merge(fromOff, start.length, null, 0, 0);
    }

    fromI++;
  } else if (fromI && elts.length) {
    let end = children[fromI - 1];

    if (end.merge(end.length, end.length, elts[0], openStart, 0)) {
      elts.shift();
      openStart = elts.length ? 0 : openEnd;
    }
  } // Then try to merge any mergeable nodes at the start and end of
  // the changed range


  while (fromI < toI && elts.length && children[toI - 1].become(elts[elts.length - 1])) {
    elts.pop();
    toI--;
    openEnd = elts.length ? 0 : openStart;
  }

  while (fromI < toI && elts.length && children[fromI].become(elts[0])) {
    elts.shift();
    fromI++;
    openStart = elts.length ? 0 : openEnd;
  }

  if (!elts.length && fromI && toI < children.length && children[toI].merge(0, 0, children[fromI - 1], openStart, openEnd)) fromI--; // And if anything remains, splice the child array to insert the new elts

  if (elts.length || fromI != toI) parent.replaceChildren(fromI, toI, elts);
}

function inlineDOMAtPos(dom, children, pos) {
  let i = 0;

  for (let off = 0; i < children.length; i++) {
    let child = children[i],
        end = off + child.length;
    if (end == off && child.getSide() <= 0) continue;
    if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);
    if (pos <= off) break;
    off = end;
  }

  for (; i > 0; i--) {
    let before = children[i - 1].dom;
    if (before.parentNode == dom) return DOMPos.after(before);
  }

  return new DOMPos(dom, 0);
} // Assumes `view`, if a mark view, has precisely 1 child.


function joinInlineInto(parent, view, open) {
  let last,
      {
    children
  } = parent;

  if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
    joinInlineInto(last, view.children[0], open - 1);
  } else {
    children.push(view);
    view.setParent(parent);
  }

  parent.length += view.length;
}

function coordsInChildren(view, pos, side) {
  for (let off = 0, i = 0; i < view.children.length; i++) {
    let child = view.children[i],
        end = off + child.length,
        next;

    if ((side <= 0 || end == view.length || child.getSide() > 0 ? end >= pos : end > pos) && (pos < end || i + 1 == view.children.length || (next = view.children[i + 1]).length || next.getSide() > 0)) {
      let flatten = 0;

      if (end == off) {
        if (child.getSide() <= 0) continue;
        flatten = side = -child.getSide();
      }

      let rect = child.coordsAt(pos - off, side);
      return flatten && rect ? flattenRect(rect, side < 0) : rect;
    }

    off = end;
  }

  let last = view.dom.lastChild;
  if (!last) return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1];
}

function combineAttrs(source, target) {
  for (let name in source) {
    if (name == "class" && target.class) target.class += " " + source.class;else if (name == "style" && target.style) target.style += ";" + source.style;else target[name] = source[name];
  }

  return target;
}

function attrsEq(a, b) {
  if (a == b) return true;
  if (!a || !b) return false;
  let keysA = Object.keys(a),
      keysB = Object.keys(b);
  if (keysA.length != keysB.length) return false;

  for (let key of keysA) {
    if (keysB.indexOf(key) == -1 || a[key] !== b[key]) return false;
  }

  return true;
}

function updateAttrs(dom, prev, attrs) {
  if (prev) for (let name in prev) if (!(attrs && name in attrs)) dom.removeAttribute(name);
  if (attrs) for (let name in attrs) if (!(prev && prev[name] == attrs[name])) dom.setAttribute(name, attrs[name]);
}
/**
Widgets added to the content are described by subclasses of this
class. Using a description object like that makes it possible to
delay creating of the DOM structure for a widget until it is
needed, and to avoid redrawing widgets even when the decorations
that define them are recreated.
*/


class WidgetType {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(_widget) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */


  updateDOM(_dom) {
    return false;
  }
  /**
  @internal
  */


  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */


  get estimatedHeight() {
    return -1;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */


  ignoreEvent(_event) {
    return true;
  }
  /**
  @internal
  */


  get customView() {
    return null;
  }

}
/**
The different types of blocks that can occur in an editor view.
*/


exports.WidgetType = WidgetType;

var BlockType = /*@__PURE__*/function (BlockType) {
  /**
  A line of text.
  */
  BlockType[BlockType["Text"] = 0] = "Text";
  /**
  A block widget associated with the position after it.
  */

  BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
  /**
  A block widget associated with the position before it.
  */

  BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
  /**
  A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.
  */

  BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
  return BlockType;
}(BlockType || (exports.BlockType = BlockType = {}));
/**
A decoration provides information on how to draw or style a piece
of content. You'll usually use it wrapped in a
[`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range), which adds a start and end position.
*/


exports.BlockType = BlockType;

class Decoration extends _rangeset.RangeValue {
  /**
  @internal
  */
  constructor(
  /**
  @internal
  */
  startSide,
  /**
  @internal
  */
  endSide,
  /**
  @internal
  */
  widget,
  /**
  The config object used to create this decoration. You can
  include additional properties in there to store metadata about
  your decoration.
  */
  spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  /**
  @internal
  */


  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations) or
  (below the facet-provided decorations) [view
  plugin](https://codemirror.net/6/docs/ref/#view.PluginSpec.decorations). Such elements are split
  on line boundaries and on the boundaries of higher-precedence
  decorations.
  */


  static mark(spec) {
    return new MarkDecoration(spec);
  }
  /**
  Create a widget decoration, which adds an element at the given
  position.
  */


  static widget(spec) {
    let side = spec.side || 0;
    if (spec.block) side += (200000000
    /* BigBlock */
    + 1) * (side > 0 ? 1 : -1);
    return new PointDecoration(spec, side, side, !!spec.block, spec.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */


  static replace(spec) {
    let block = !!spec.block;
    let {
      start,
      end
    } = getInclusive(spec);
    let startSide = block ? -200000000
    /* BigBlock */
    * (start ? 2 : 1) : 100000000
    /* BigInline */
    * (start ? -1 : 1);
    let endSide = block ? 200000000
    /* BigBlock */
    * (end ? 2 : 1) : 100000000
    /* BigInline */
    * (end ? 1 : -1);
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */


  static line(spec) {
    return new LineDecoration(spec);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */


  static set(of, sort = false) {
    return _rangeset.RangeSet.of(of, sort);
  }
  /**
  @internal
  */


  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }

}
/**
The empty set of decorations.
*/


exports.Decoration = Decoration;
Decoration.none = _rangeset.RangeSet.empty;

class MarkDecoration extends Decoration {
  constructor(spec) {
    let {
      start,
      end
    } = getInclusive(spec);
    super(100000000
    /* BigInline */
    * (start ? -1 : 1), 100000000
    /* BigInline */
    * (end ? 1 : -1), null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }

  eq(other) {
    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
  }

  range(from, to = from) {
    if (from >= to) throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to);
  }

}

MarkDecoration.prototype.point = false;

class LineDecoration extends Decoration {
  constructor(spec) {
    super(-100000000
    /* BigInline */
    , -100000000
    /* BigInline */
    , null, spec);
  }

  eq(other) {
    return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
  }

  range(from, to = from) {
    if (to != from) throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to);
  }

}

LineDecoration.prototype.mapMode = _state.MapMode.TrackBefore;
LineDecoration.prototype.point = true;

class PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? _state.MapMode.TrackDel : startSide < 0 ? _state.MapMode.TrackBefore : _state.MapMode.TrackAfter;
  } // Only relevant when this.block == true


  get type() {
    return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide < 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }

  get heightRelevant() {
    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
  }

  eq(other) {
    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }

  range(from, to = from) {
    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide < 0)) throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from) throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to);
  }

}

PointDecoration.prototype.point = true;

function getInclusive(spec) {
  let {
    inclusiveStart: start,
    inclusiveEnd: end
  } = spec;
  if (start == null) start = spec.inclusive;
  if (end == null) end = spec.inclusive;
  return {
    start: start || false,
    end: end || false
  };
}

function widgetsEq(a, b) {
  return a == b || !!(a && b && a.compare(b));
}

function addRange(from, to, ranges, margin = 0) {
  let last = ranges.length - 1;
  if (last >= 0 && ranges[last] + margin > from) ranges[last] = Math.max(ranges[last], to);else ranges.push(from, to);
}

class LineView extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = undefined;
    this.attrs = null;
    this.breakAfter = 0;
  } // Consumes source


  merge(from, to, source, takeDeco, openStart, openEnd) {
    if (source) {
      if (!(source instanceof LineView)) return false;
      if (!this.dom) source.transferDOM(this); // Reuse source.dom when appropriate
    }

    if (takeDeco) this.setDeco(source ? source.attrs : null);
    mergeInlineChildren(this, from, to, source ? source.children : none$1, openStart, openEnd);
    return true;
  }

  split(at) {
    let end = new LineView();
    end.breakAfter = this.breakAfter;
    if (this.length == 0) return end;
    let {
      i,
      off
    } = this.childPos(at);

    if (off) {
      end.append(this.children[i].slice(off), 0);
      this.children[i].merge(off, this.children[i].length, null, 0, 0);
      i++;
    }

    for (let j = i; j < this.children.length; j++) end.append(this.children[j], 0);

    while (i > 0 && this.children[i - 1].length == 0) {
      this.children[i - 1].parent = null;
      i--;
    }

    this.children.length = i;
    this.markDirty();
    this.length = at;
    return end;
  }

  transferDOM(other) {
    if (!this.dom) return;
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
    this.prevAttrs = undefined;
    this.dom = null;
  }

  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }

      this.attrs = attrs;
    }
  } // Only called when building a line view in ContentBuilder


  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  } // Only called when building a line view in ContentBuilder


  addLineDeco(deco) {
    let attrs = deco.spec.attributes;
    if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});
  }

  domAtPos(pos) {
    return inlineDOMAtPos(this.dom, this.children, pos);
  }

  sync(track) {
    if (!this.dom || this.dirty & 4
    /* Attrs */
    ) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : undefined;
    }

    if (this.prevAttrs !== undefined) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = undefined;
    }

    super.sync(track);
    let last = this.dom.lastChild;

    while (last && ContentView.get(last) instanceof MarkView) last = last.lastChild;

    if (!last || last.nodeName != "BR" && ContentView.get(last) instanceof WidgetView && (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }

  measureTextSize() {
    if (this.children.length == 0 || this.length > 20) return null;
    let totalWidth = 0;

    for (let child of this.children) {
      if (!(child instanceof TextView)) return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1) return null;
      totalWidth += rects[0].width;
    }

    return {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length
    };
  }

  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }

  match(_other) {
    return false;
  }

  get type() {
    return BlockType.Text;
  }

  static find(docView, pos) {
    for (let i = 0, off = 0;; i++) {
      let block = docView.children[i],
          end = off + block.length;

      if (end >= pos) {
        if (block instanceof LineView) return block;
        if (block.length) return null;
      }

      off = end + block.breakAfter;
    }
  }

}

const none$1 = [];

class BlockWidgetView extends ContentView {
  constructor(widget, length, type) {
    super();
    this.widget = widget;
    this.length = length;
    this.type = type;
    this.breakAfter = 0;
  }

  merge(from, to, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }

  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }

  split(at) {
    let len = this.length - at;
    this.length = at;
    return new BlockWidgetView(this.widget, len, this.type);
  }

  get children() {
    return none$1;
  }

  sync() {
    if (!this.dom || !this.widget.updateDOM(this.dom)) {
      this.setDOM(this.widget.toDOM(this.editorView));
      this.dom.contentEditable = "false";
    }
  }

  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _state.Text.empty;
  }

  domBoundsAround() {
    return null;
  }

  match(other) {
    if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.eq(this.widget)) this.markDirty(true);
      this.widget = other.widget;
      this.length = other.length;
      this.breakAfter = other.breakAfter;
      return true;
    }

    return false;
  }

  ignoreMutation() {
    return true;
  }

  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }

}

class ContentBuilder {
  constructor(doc, pos, end) {
    this.doc = doc;
    this.pos = pos;
    this.end = end;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc.iter();
    this.skip = pos;
  }

  posCovered() {
    if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last = this.content[this.content.length - 1];
    return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
  }

  getLine() {
    if (!this.curLine) this.content.push(this.curLine = new LineView());
    return this.curLine;
  }

  addWidget(view) {
    this.curLine = null;
    this.content.push(view);
  }

  finish() {
    if (!this.posCovered()) this.getLine();
  }

  wrapMarks(view, active) {
    for (let mark of active) view = new MarkView(mark, [view], view.length);

    return view;
  }

  buildText(length, active, openStart) {
    while (length > 0) {
      if (this.textOff == this.text.length) {
        let {
          value,
          lineBreak,
          done
        } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done) throw new Error("Ran out of text content when drawing inline views");

        if (lineBreak) {
          if (!this.posCovered()) this.getLine();
          if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;else this.breakAtStart = 1;
          this.curLine = null;
          length--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }

      let take = Math.min(this.text.length - this.textOff, length, 512
      /* Chunk */
      );
      this.getLine().append(this.wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
      this.textOff += take;
      length -= take;
      openStart = 0;
    }
  }

  span(from, to, active, openStart) {
    this.buildText(to - from, active, openStart);
    this.pos = to;
    if (this.openStart < 0) this.openStart = openStart;
  }

  point(from, to, deco, active, openStart) {
    let len = to - from;

    if (deco instanceof PointDecoration) {
      if (deco.block) {
        let {
          type
        } = deco;
        if (type == BlockType.WidgetAfter && !this.posCovered()) this.getLine();
        this.addWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
      } else {
        let widget = this.wrapMarks(WidgetView.create(deco.widget || new NullWidget("span"), len, deco.startSide), active);
        this.getLine().append(widget, openStart);
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      // Line decoration
      this.getLine().addLineDeco(deco);
    }

    if (len) {
      // Advance the iterator past the replaced content
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }

      this.pos = to;
    }

    if (this.openStart < 0) this.openStart = openStart;
  }

  static build(text, from, to, decorations) {
    let builder = new ContentBuilder(text, from, to);
    builder.openEnd = _rangeset.RangeSet.spans(decorations, from, to, builder);
    if (builder.openStart < 0) builder.openStart = builder.openEnd;
    builder.finish();
    return builder;
  }

}

class NullWidget extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }

  eq(other) {
    return other.tag == this.tag;
  }

  toDOM() {
    return document.createElement(this.tag);
  }

  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }

}

const none = [];

const clickAddsSelectionRange = /*@__PURE__*/_state.Facet.define();

const dragMovesSelection$1 = /*@__PURE__*/_state.Facet.define();

const mouseSelectionStyle = /*@__PURE__*/_state.Facet.define();

const exceptionSink = /*@__PURE__*/_state.Facet.define();

const updateListener = /*@__PURE__*/_state.Facet.define();

const inputHandler = /*@__PURE__*/_state.Facet.define();

const scrollTo = /*@__PURE__*/_state.StateEffect.define({
  map: (range, changes) => range.map(changes)
});
/**
Log or report an unhandled exception in client code. Should
probably only be used by extension code that allows client code to
provide functions, and calls those functions in a context where an
exception can't be propagated to calling code in a reasonable way
(for example when in an event handler).

Either calls a handler registered with
[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),
`window.onerror`, if defined, or `console.error` (in which case
it'll pass `context`, when given, as first argument).
*/


function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length) handler[0](exception);else if (window.onerror) window.onerror(String(exception), context, undefined, undefined, exception);else if (context) console.error(context + ":", exception);else console.error(exception);
}

const editable = /*@__PURE__*/_state.Facet.define({
  combine: values => values.length ? values[0] : true
});
/**
Used to [declare](https://codemirror.net/6/docs/ref/#view.PluginSpec.provide) which
[fields](https://codemirror.net/6/docs/ref/#view.PluginValue) a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin)
provides.
*/


class PluginFieldProvider {
  /**
  @internal
  */
  constructor(
  /**
  @internal
  */
  field,
  /**
  @internal
  */
  get) {
    this.field = field;
    this.get = get;
  }

}
/**
Plugin fields are a mechanism for allowing plugins to provide
values that can be retrieved through the
[`pluginField`](https://codemirror.net/6/docs/ref/#view.EditorView.pluginField) view method.
*/


exports.PluginFieldProvider = PluginFieldProvider;

class PluginField {
  /**
  Create a [provider](https://codemirror.net/6/docs/ref/#view.PluginFieldProvider) for this field,
  to use with a plugin's [provide](https://codemirror.net/6/docs/ref/#view.PluginSpec.provide)
  option.
  */
  from(get) {
    return new PluginFieldProvider(this, get);
  }
  /**
  Define a new plugin field.
  */


  static define() {
    return new PluginField();
  }

}
/**
This field can be used by plugins to provide
[decorations](https://codemirror.net/6/docs/ref/#view.Decoration).

**Note**: For reasons of data flow (plugins are only updated
after the viewport is computed), decorations produced by plugins
are _not_ taken into account when predicting the vertical layout
structure of the editor. Thus, things like large widgets or big
replacements (i.e. code folding) should be provided through the
state-level [`decorations` facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations),
not this plugin field. Specifically, replacing decorations that
cross line boundaries will break if provided through a plugin.
*/


exports.PluginField = PluginField;
PluginField.decorations = /*@__PURE__*/PluginField.define();
/**
Used to provide ranges that should be treated as atoms as far as
cursor motion is concerned. This causes methods like
[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and
[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the
commands built on top of them) to skip across such regions when
a selection endpoint would enter them. This does _not_ prevent
direct programmatic [selection
updates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such
regions.
*/

PluginField.atomicRanges = /*@__PURE__*/PluginField.define();
/**
Plugins can provide additional scroll margins (space around the
sides of the scrolling element that should be considered
invisible) through this field. This can be useful when the
plugin introduces elements that cover part of that element (for
example a horizontally fixed gutter).
*/

PluginField.scrollMargins = /*@__PURE__*/PluginField.define();
let nextPluginID = 0;

const viewPlugin = /*@__PURE__*/_state.Facet.define();
/**
View plugins associate stateful values with a view. They can
influence the way the content is drawn, and are notified of things
that happen in the view.
*/


class ViewPlugin {
  constructor(
  /**
  @internal
  */
  id,
  /**
  @internal
  */
  create,
  /**
  @internal
  */
  fields) {
    this.id = id;
    this.create = create;
    this.fields = fields;
    this.extension = viewPlugin.of(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */


  static define(create, spec) {
    let {
      eventHandlers,
      provide,
      decorations
    } = spec || {};
    let fields = [];
    if (provide) for (let provider of Array.isArray(provide) ? provide : [provide]) fields.push(provider);
    if (eventHandlers) fields.push(domEventHandlers.from(value => ({
      plugin: value,
      handlers: eventHandlers
    })));
    if (decorations) fields.push(PluginField.decorations.from(decorations));
    return new ViewPlugin(nextPluginID++, create, fields);
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */


  static fromClass(cls, spec) {
    return ViewPlugin.define(view => new cls(view), spec);
  }

}

exports.ViewPlugin = ViewPlugin;
const domEventHandlers = /*@__PURE__*/PluginField.define();

class PluginInstance {
  constructor(spec) {
    this.spec = spec; // When starting an update, all plugins have this field set to the
    // update object, indicating they need to be updated. When finished
    // updating, it is set to `false`. Retrieving a plugin that needs to
    // be updated with `view.plugin` forces an eager update.

    this.mustUpdate = null; // This is null when the plugin is initially created, but
    // initialized on the first update.

    this.value = null;
  }

  takeField(type, target) {
    for (let {
      field,
      get
    } of this.spec.fields) if (field == type) target.push(get(this.value));
  }

  update(view) {
    if (!this.value) {
      try {
        this.value = this.spec.create(view);
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
        return PluginInstance.dummy;
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (!this.value.update) return this;

      try {
        this.value.update(update);
      } catch (e) {
        logException(update.state, e, "CodeMirror plugin crashed");
        if (this.value.destroy) try {
          this.value.destroy();
        } catch (_) {}
        return PluginInstance.dummy;
      }
    }

    return this;
  }

  destroy(view) {
    var _a;

    if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
      try {
        this.value.destroy();
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
      }
    }
  }

}

PluginInstance.dummy = /*@__PURE__*/new PluginInstance( /*@__PURE__*/ViewPlugin.define(() => ({})));

const editorAttributes = /*@__PURE__*/_state.Facet.define({
  combine: values => values.reduce((a, b) => combineAttrs(b, a), {})
});

const contentAttributes = /*@__PURE__*/_state.Facet.define({
  combine: values => values.reduce((a, b) => combineAttrs(b, a), {})
}); // Provide decorations


const decorations = /*@__PURE__*/_state.Facet.define();

const styleModule = /*@__PURE__*/_state.Facet.define();

class ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }

  join(other) {
    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }

  addToSet(set) {
    let i = set.length,
        me = this;

    for (; i > 0; i--) {
      let range = set[i - 1];
      if (range.fromA > me.toA) continue;
      if (range.toA < me.fromA) break;
      me = me.join(range);
      set.splice(i - 1, 1);
    }

    set.splice(i, 0, me);
    return set;
  }

  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0) return diff;
    let result = [];

    for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {
      let next = dI == diff.length ? null : diff[dI],
          off = posA - posB;
      let end = next ? next.fromB : 1e9;

      while (rI < ranges.length && ranges[rI] < end) {
        let from = ranges[rI],
            to = ranges[rI + 1];
        let fromB = Math.max(posB, from),
            toB = Math.min(end, to);
        if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
        if (to > end) break;else rI += 2;
      }

      if (!next) return result;
      new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
      posA = next.toA;
      posB = next.toB;
    }
  }

}
/**
View [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this
class, which describe what happened, whenever the view is updated.
*/


class ViewUpdate {
  /**
  @internal
  */
  constructor(
  /**
  The editor view that the update is associated with.
  */
  view,
  /**
  The new editor state.
  */
  state,
  /**
  The transactions involved in the update. May be empty.
  */
  transactions = none) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    /**
    @internal
    */

    this.flags = 0;
    this.startState = view.state;
    this.changes = _state.ChangeSet.empty(this.startState.doc.length);

    for (let tr of transactions) this.changes = this.changes.compose(tr.changes);

    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
    let focus = view.hasFocus;

    if (focus != view.inputState.notifiedFocused) {
      view.inputState.notifiedFocused = focus;
      this.flags |= 1
      /* Focus */
      ;
    }

    if (this.docChanged) this.flags |= 2
    /* Height */
    ;
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */


  get viewportChanged() {
    return (this.flags & 4
    /* Viewport */
    ) > 0;
  }
  /**
  Indicates whether the line height in the editor changed in this update.
  */


  get heightChanged() {
    return (this.flags & 2
    /* Height */
    ) > 0;
  }
  /**
  Returns true when the document changed or the size of the editor
  or the lines or characters within it has changed.
  */


  get geometryChanged() {
    return this.docChanged || (this.flags & (8
    /* Geometry */
    | 2
    /* Height */
    )) > 0;
  }
  /**
  True when this update indicates a focus change.
  */


  get focusChanged() {
    return (this.flags & 1
    /* Focus */
    ) > 0;
  }
  /**
  Whether the document changed in this update.
  */


  get docChanged() {
    return this.transactions.some(tr => tr.docChanged);
  }
  /**
  Whether the selection was explicitly set in this update.
  */


  get selectionSet() {
    return this.transactions.some(tr => tr.selection);
  }
  /**
  @internal
  */


  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }

}

exports.ViewUpdate = ViewUpdate;

class DocView extends ContentView {
  constructor(view) {
    super();
    this.view = view;
    this.compositionDeco = Decoration.none;
    this.decorations = []; // Track a minimum width for the editor. When measuring sizes in
    // checkLayout, this is updated to point at the width of a given
    // element and its extent in the document. When a change happens in
    // that range, these are reset. That way, once we've seen a
    // line/element of a given length, we keep the editor wide enough to
    // fit at least that element, until it is changed, at which point we
    // forget it again.

    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0; // Track whether the DOM selection was set in a lossy way, so that
    // we don't mess it up when reading it back it

    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], this.updateDeco(), 0);
  }

  get root() {
    return this.view.root;
  }

  get editorView() {
    return this.view;
  }

  get length() {
    return this.view.state.doc.length;
  } // Update the document view to a given state. scrollIntoView can be
  // used as a hint to compute a new viewport that includes that
  // position, if we know the editor is going to scroll that position
  // into view.


  update(update) {
    let changedRanges = update.changedRanges;

    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({
        fromA,
        toA
      }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }

    if (this.view.inputState.composing < 0) this.compositionDeco = Decoration.none;else if (update.transactions.length) this.compositionDeco = computeCompositionDeco(this.view, update.changes); // When the DOM nodes around the selection are moved to another
    // parent, Chrome sometimes reports a different selection through
    // getSelection than the one that it actually shows to the user.
    // This forces a selection update when lines are joined to work
    // around that. Issue #54

    let forceSelection = (browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines;
    let prevDeco = this.decorations,
        deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    let pointerSel = update.transactions.some(tr => tr.isUserEvent("select.pointer"));

    if (this.dirty == 0
    /* Not */
    && changedRanges.length == 0 && !(update.flags & 4
    /* Viewport */
    ) && update.state.selection.main.from >= this.view.viewport.from && update.state.selection.main.to <= this.view.viewport.to) {
      this.updateSelection(forceSelection, pointerSel);
      return false;
    } else {
      this.updateInner(changedRanges, deco, update.startState.doc.length, forceSelection, pointerSel);
      return true;
    }
  } // Used both by update and checkLayout do perform the actual DOM
  // update


  updateInner(changes, deco, oldLength, forceSelection = false, pointerSel = false) {
    this.updateChildren(changes, deco, oldLength);
    let {
      observer
    } = this.view;
    observer.ignore(() => {
      // Lock the height during redrawing, since Chrome sometimes
      // messes with the scroll position during DOM mutation (though
      // no relayout is triggered and I cannot imagine how it can
      // recompute the scroll position without a layout)
      this.dom.style.height = this.view.viewState.domHeight + "px";
      this.dom.style.minWidth = this.minWidth ? this.minWidth + "px" : ""; // Chrome will sometimes, when DOM mutations occur directly
      // around the selection, get confused and report a different
      // selection from the one it displays (issue #218). This tries
      // to detect that situation.

      let track = browser.chrome || browser.ios ? {
        node: observer.selectionRange.focusNode,
        written: false
      } : undefined;
      this.sync(track);
      this.dirty = 0
      /* Not */
      ;
      if (track && (track.written || observer.selectionRange.focusNode != track.node)) forceSelection = true;
      this.updateSelection(forceSelection, pointerSel);
      this.dom.style.height = "";
    });
  }

  updateChildren(changes, deco, oldLength) {
    let cursor = this.childCursor(oldLength);

    for (let i = changes.length - 1;; i--) {
      let next = i >= 0 ? changes[i] : null;
      if (!next) break;
      let {
        fromA,
        toA,
        fromB,
        toB
      } = next;
      let {
        content,
        breakAtStart,
        openStart,
        openEnd
      } = ContentBuilder.build(this.view.state.doc, fromB, toB, deco);
      let {
        i: toI,
        off: toOff
      } = cursor.findPos(toA, 1);
      let {
        i: fromI,
        off: fromOff
      } = cursor.findPos(fromA, -1);
      this.replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
    }
  }

  replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd) {
    let before = this.children[fromI],
        last = content.length ? content[content.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart; // Change within a single line

    if (fromI == toI && !breakAtStart && !breakAtEnd && content.length < 2 && before.merge(fromOff, toOff, content.length ? last : null, fromOff == 0, openStart, openEnd)) return;
    let after = this.children[toI]; // Make sure the end of the line after the update is preserved in `after`

    if (toOff < after.length) {
      // If we're splitting a line, separate part of the start line to
      // avoid that being mangled when updating the start line.
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      } // If the element after the replacement should be merged with
      // the last replacing element, update `content`


      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
        content[content.length - 1] = after;
      } else {
        // Remove the start of the after element, if necessary, and
        // add it to `content`.
        if (toOff) after.merge(0, toOff, null, false, 0, openEnd);
        content.push(after);
      }
    } else if (after.breakAfter) {
      // The element at `toI` is entirely covered by this range.
      // Preserve its line break, if any.
      if (last) last.breakAfter = 1;else breakAtStart = 1;
    } // Since we've handled the next element from the current elements
    // now, make sure `toI` points after that.


    toI++;
    before.breakAfter = breakAtStart;

    if (fromOff > 0) {
      if (!breakAtStart && content.length && before.merge(fromOff, before.length, content[0], false, openStart, 0)) {
        before.breakAfter = content.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }

      fromI++;
    } // Try to merge widgets on the boundaries of the replacement


    while (fromI < toI && content.length) {
      if (this.children[toI - 1].match(content[content.length - 1])) toI--, content.pop();else if (this.children[fromI].match(content[0])) fromI++, content.shift();else break;
    }

    if (fromI < toI || content.length) this.replaceChildren(fromI, toI, content);
  } // Sync the DOM selection to this.state.selection


  updateSelection(force = false, fromPointer = false) {
    if (!(fromPointer || this.mayControlSelection()) || browser.ios && this.view.inputState.rapidCompositionStart) return;
    let main = this.view.state.selection.main; // FIXME need to handle the case where the selection falls inside a block range

    let anchor = this.domAtPos(main.anchor);
    let head = main.empty ? anchor : this.domAtPos(main.head); // Always reset on Firefox when next to an uneditable node to
    // avoid invisible cursor bugs (#111)

    if (browser.gecko && main.empty && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }

    let domSel = this.view.observer.selectionRange; // If the selection is already here, or in an equivalent position, don't touch it

    if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
      this.view.observer.ignore(() => {
        let rawSel = getSelection(this.root);

        if (main.empty) {
          // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);

            if (nextTo && nextTo != (1
            /* Before */
            | 2
            /* After */
            )) {
              let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1
              /* Before */
              ? 1 : -1);
              if (text) anchor = new DOMPos(text, nextTo == 1
              /* Before */
              ? 0 : text.nodeValue.length);
            }
          }

          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && domSel.cursorBidiLevel != null) domSel.cursorBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          // Selection.extend can be used to create an 'inverted' selection
          // (one where the focus is before the anchor), but not all
          // browsers support it yet.
          rawSel.collapse(anchor.node, anchor.offset);
          rawSel.extend(head.node, head.offset);
        } else {
          // Primitive (IE) way
          let range = document.createRange();
          if (main.anchor > main.head) [anchor, head] = [head, anchor];
          range.setEnd(head.node, head.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }

    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }

  enforceCursorAssoc() {
    if (this.view.composing) return;
    let cursor = this.view.state.selection.main;
    let sel = getSelection(this.root);
    if (!cursor.empty || !cursor.assoc || !sel.modify) return;
    let line = LineView.find(this, cursor.head);
    if (!line) return;
    let lineStart = line.posAtStart;
    if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;
    let before = this.coordsAt(cursor.head, -1),
        after = this.coordsAt(cursor.head, 1);
    if (!before || !after || before.bottom > after.top) return;
    let dom = this.domAtPos(cursor.head + cursor.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
  }

  mayControlSelection() {
    return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, this.view.observer.selectionRange);
  }

  nearest(dom) {
    for (let cur = dom; cur;) {
      let domView = ContentView.get(cur);
      if (domView && domView.rootView == this) return domView;
      cur = cur.parentNode;
    }

    return null;
  }

  posFromDOM(node, offset) {
    let view = this.nearest(node);
    if (!view) throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node, offset) + view.posAtStart;
  }

  domAtPos(pos) {
    let {
      i,
      off
    } = this.childCursor().findPos(pos, -1);

    for (; i < this.children.length - 1;) {
      let child = this.children[i];
      if (off < child.length || child instanceof LineView) break;
      i++;
      off = 0;
    }

    return this.children[i].domAtPos(off);
  }

  coordsAt(pos, side) {
    for (let off = this.length, i = this.children.length - 1;; i--) {
      let child = this.children[i],
          start = off - child.breakAfter - child.length;
      if (pos > start || pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2)) return child.coordsAt(pos - start, side);
      off = start;
    }
  }

  measureVisibleLineHeights() {
    let result = [],
        {
      from,
      to
    } = this.view.viewState.viewport;
    let minWidth = Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;

    for (let pos = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i],
          end = pos + child.length;
      if (end > to) break;

      if (pos >= from) {
        result.push(child.dom.getBoundingClientRect().height);
        let width = child.dom.scrollWidth;

        if (width > minWidth) {
          this.minWidth = minWidth = width;
          this.minWidthFrom = pos;
          this.minWidthTo = end;
        }
      }

      pos = end + child.breakAfter;
    }

    return result;
  }

  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure) return measure;
      }
    } // If no workable line exists, force a layout of a measurable element


    let dummy = document.createElement("div"),
        lineHeight,
        charWidth;
    dummy.className = "cm-line";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect ? rect.width / 27 : 7;
      dummy.remove();
    });
    return {
      lineHeight,
      charWidth
    };
  }

  childCursor(pos = this.length) {
    // Move back to start of last element when possible, so that
    // `ChildCursor.findPos` doesn't have to deal with the edge case
    // of being after the last element.
    let i = this.children.length;
    if (i) pos -= this.children[--i].length;
    return new ChildCursor(this.children, pos, i);
  }

  computeBlockGapDeco() {
    let deco = [],
        vs = this.view.viewState;

    for (let pos = 0, i = 0;; i++) {
      let next = i == vs.viewports.length ? null : vs.viewports[i];
      let end = next ? next.from - 1 : this.length;

      if (end > pos) {
        let height = vs.lineAt(end, 0).bottom - vs.lineAt(pos, 0).top;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true
        }).range(pos, end));
      }

      if (!next) break;
      pos = next.to + 1;
    }

    return Decoration.set(deco);
  }

  updateDeco() {
    return this.decorations = [...this.view.pluginField(PluginField.decorations), ...this.view.state.facet(decorations), this.compositionDeco, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco];
  }

  scrollRangeIntoView(range) {
    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1),
        other;
    if (!rect) return;
    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {
      left: Math.min(rect.left, other.left),
      top: Math.min(rect.top, other.top),
      right: Math.max(rect.right, other.right),
      bottom: Math.max(rect.bottom, other.bottom)
    };
    let mLeft = 0,
        mRight = 0,
        mTop = 0,
        mBottom = 0;

    for (let margins of this.view.pluginField(PluginField.scrollMargins)) if (margins) {
      let {
        left,
        right,
        top,
        bottom
      } = margins;
      if (left != null) mLeft = Math.max(mLeft, left);
      if (right != null) mRight = Math.max(mRight, right);
      if (top != null) mTop = Math.max(mTop, top);
      if (bottom != null) mBottom = Math.max(mBottom, bottom);
    }

    scrollRectIntoView(this.dom, {
      left: rect.left - mLeft,
      top: rect.top - mTop,
      right: rect.right + mRight,
      bottom: rect.bottom + mBottom
    }, range.head < range.anchor ? -1 : 1);
  }

}

function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}

class BlockGapWidget extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }

  toDOM() {
    let elt = document.createElement("div");
    this.updateDOM(elt);
    return elt;
  }

  eq(other) {
    return other.height == this.height;
  }

  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }

  get estimatedHeight() {
    return this.height;
  }

}

function computeCompositionDeco(view, changes) {
  let sel = view.observer.selectionRange;
  let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
  if (!textNode) return Decoration.none;
  let cView = view.docView.nearest(textNode);
  let from,
      to,
      topNode = textNode;

  if (cView instanceof InlineView) {
    while (cView.parent instanceof InlineView) cView = cView.parent;

    from = cView.posAtStart;
    to = from + cView.length;
    topNode = cView.dom;
  } else if (cView instanceof LineView) {
    while (topNode.parentNode != cView.dom) topNode = topNode.parentNode;

    let prev = topNode.previousSibling;

    while (prev && !ContentView.get(prev)) prev = prev.previousSibling;

    from = to = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
  } else {
    return Decoration.none;
  }

  let newFrom = changes.mapPos(from, 1),
      newTo = Math.max(newFrom, changes.mapPos(to, -1));
  let text = textNode.nodeValue,
      {
    state
  } = view;

  if (newTo - newFrom < text.length) {
    if (state.sliceDoc(newFrom, Math.min(state.doc.length, newFrom + text.length)) == text) newTo = newFrom + text.length;else if (state.sliceDoc(Math.max(0, newTo - text.length), newTo) == text) newFrom = newTo - text.length;else return Decoration.none;
  } else if (state.sliceDoc(newFrom, newTo) != text) {
    return Decoration.none;
  }

  return Decoration.set(Decoration.replace({
    widget: new CompositionWidget(topNode, textNode)
  }).range(newFrom, newTo));
}

class CompositionWidget extends WidgetType {
  constructor(top, text) {
    super();
    this.top = top;
    this.text = text;
  }

  eq(other) {
    return this.top == other.top && this.text == other.text;
  }

  toDOM() {
    return this.top;
  }

  ignoreEvent() {
    return false;
  }

  get customView() {
    return CompositionView;
  }

}

function nearbyTextNode(node, offset, side) {
  for (;;) {
    if (node.nodeType == 3) return node;

    if (node.nodeType == 1 && offset > 0 && side <= 0) {
      node = node.childNodes[offset - 1];
      offset = maxOffset(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null;
    }
  }
}

function nextToUneditable(node, offset) {
  if (node.nodeType != 1) return 0;
  return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1
  /* Before */
  : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2
  /* After */
  : 0);
}

class DecorationComparator$1 {
  constructor() {
    this.changes = [];
  }

  compareRange(from, to) {
    addRange(from, to, this.changes);
  }

  comparePoint(from, to) {
    addRange(from, to, this.changes);
  }

}

function findChangedDeco(a, b, diff) {
  let comp = new DecorationComparator$1();

  _rangeset.RangeSet.compare(a, b, diff, comp);

  return comp.changes;
}
/**
Used to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
*/


var Direction = /*@__PURE__*/function (Direction) {
  // (These are chosen to match the base levels, in bidi algorithm
  // terms, of spans in that direction.)

  /**
  Left-to-right.
  */
  Direction[Direction["LTR"] = 0] = "LTR";
  /**
  Right-to-left.
  */

  Direction[Direction["RTL"] = 1] = "RTL";
  return Direction;
}(Direction || (exports.Direction = Direction = {}));

exports.Direction = Direction;
const LTR = Direction.LTR,
      RTL = Direction.RTL; // Decode a string with each type encoded as log2(type)

function dec(str) {
  let result = [];

  for (let i = 0; i < str.length; i++) result.push(1 << +str[i]);

  return result;
} // Character types for codepoints 0 to 0xf8


const LowTypes = /*@__PURE__*/dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"); // Character types for codepoints 0x600 to 0x6f9

const ArabicTypes = /*@__PURE__*/dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = /*@__PURE__*/Object.create(null),
      BracketStack = []; // There's a lot more in
// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,
// which are left out to keep code size down.

for (let p of ["()", "[]", "{}"]) {
  let l = /*@__PURE__*/p.charCodeAt(0),
      r = /*@__PURE__*/p.charCodeAt(1);
  Brackets[l] = r;
  Brackets[r] = -l;
}

function charType(ch) {
  return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2
  /* R */
  : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4
  /* AL */
  : 0x2000 <= ch && ch <= 0x200b ? 256
  /* NI */
  : ch == 0x200c ? 256
  /* NI */
  : 1
  /* L */
  ;
}

const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
/**
Represents a contiguous range of text that has a single direction
(as in left-to-right or right-to-left).
*/

class BidiSpan {
  /**
  @internal
  */
  constructor(
  /**
  The start of the span (relative to the start of the line).
  */
  from,
  /**
  The end of the span.
  */
  to,
  /**
  The ["bidi
  level"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)
  of the span (in this context, 0 means
  left-to-right, 1 means right-to-left, 2 means left-to-right
  number inside right-to-left text).
  */
  level) {
    this.from = from;
    this.to = to;
    this.level = level;
  }
  /**
  The direction of this span.
  */


  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  /**
  @internal
  */


  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  /**
  @internal
  */


  static find(order, index, level, assoc) {
    let maybe = -1;

    for (let i = 0; i < order.length; i++) {
      let span = order[i];

      if (span.from <= index && span.to >= index) {
        if (span.level == level) return i; // When multiple spans match, if assoc != 0, take the one that
        // covers that side, otherwise take the one with the minimum
        // level.

        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;
      }
    }

    if (maybe < 0) throw new RangeError("Index out of range");
    return maybe;
  }

} // Reused array of character types


exports.BidiSpan = BidiSpan;
const types = [];

function computeOrder(line, direction) {
  let len = line.length,
      outerType = direction == LTR ? 1
  /* L */
  : 2
  /* R */
  ,
      oppositeType = direction == LTR ? 2
  /* R */
  : 1
  /* L */
  ;
  if (!line || outerType == 1
  /* L */
  && !BidiRE.test(line)) return trivialOrder(len); // W1. Examine each non-spacing mark (NSM) in the level run, and
  // change the type of the NSM to the type of the previous
  // character. If the NSM is at the start of the level run, it will
  // get the type of sor.
  // W2. Search backwards from each instance of a European number
  // until the first strong type (R, L, AL, or sor) is found. If an
  // AL is found, change the type of the European number to Arabic
  // number.
  // W3. Change all ALs to R.
  // (Left after this: L, R, EN, AN, ET, CS, NI)

  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
    let type = charType(line.charCodeAt(i));
    if (type == 512
    /* NSM */
    ) type = prev;else if (type == 8
    /* EN */
    && prevStrong == 4
    /* AL */
    ) type = 16
      /* AN */
      ;
    types[i] = type == 4
    /* AL */
    ? 2
    /* R */
    : type;
    if (type & 7
    /* Strong */
    ) prevStrong = type;
    prev = type;
  } // W5. A sequence of European terminators adjacent to European
  // numbers changes to all European numbers.
  // W6. Otherwise, separators and terminators change to Other
  // Neutral.
  // W7. Search backwards from each instance of a European number
  // until the first strong type (R, L, or sor) is found. If an L is
  // found, then change the type of the European number to L.
  // (Left after this: L, R, EN+AN, NI)


  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
    let type = types[i];

    if (type == 128
    /* CS */
    ) {
        if (i < len - 1 && prev == types[i + 1] && prev & 24
        /* Num */
        ) type = types[i] = prev;else types[i] = 256
        /* NI */
        ;
      } else if (type == 64
    /* ET */
    ) {
        let end = i + 1;

        while (end < len && types[end] == 64
        /* ET */
        ) end++;

        let replace = i && prev == 8
        /* EN */
        || end < len && types[end] == 8
        /* EN */
        ? prevStrong == 1
        /* L */
        ? 1
        /* L */
        : 8
        /* EN */
        : 256
        /* NI */
        ;

        for (let j = i; j < end; j++) types[j] = replace;

        i = end - 1;
      } else if (type == 8
    /* EN */
    && prevStrong == 1
    /* L */
    ) {
        types[i] = 1
        /* L */
        ;
      }

    prev = type;
    if (type & 7
    /* Strong */
    ) prevStrong = type;
  } // N0. Process bracket pairs in an isolating run sequence
  // sequentially in the logical order of the text positions of the
  // opening paired brackets using the logic given below. Within this
  // scope, bidirectional types EN and AN are treated as R.


  for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {
    // Keeps [startIndex, type, strongSeen] triples for each open
    // bracket on BracketStack.
    if (br = Brackets[ch = line.charCodeAt(i)]) {
      if (br < 0) {
        // Closing bracket
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          if (BracketStack[sJ + 1] == -br) {
            let flags = BracketStack[sJ + 2];
            let type = flags & 2
            /* EmbedInside */
            ? outerType : !(flags & 4
            /* OppositeInside */
            ) ? 0 : flags & 1
            /* OppositeBefore */
            ? oppositeType : outerType;
            if (type) types[i] = types[BracketStack[sJ]] = type;
            sI = sJ;
            break;
          }
        }
      } else if (BracketStack.length == 189
      /* MaxDepth */
      ) {
          break;
        } else {
        BracketStack[sI++] = i;
        BracketStack[sI++] = ch;
        BracketStack[sI++] = context;
      }
    } else if ((type = types[i]) == 2
    /* R */
    || type == 1
    /* L */
    ) {
        let embed = type == outerType;
        context = embed ? 0 : 1
        /* OppositeBefore */
        ;

        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur = BracketStack[sJ + 2];
          if (cur & 2
          /* EmbedInside */
          ) break;

          if (embed) {
            BracketStack[sJ + 2] |= 2
            /* EmbedInside */
            ;
          } else {
            if (cur & 4
            /* OppositeInside */
            ) break;
            BracketStack[sJ + 2] |= 4
            /* OppositeInside */
            ;
          }
        }
      }
  } // N1. A sequence of neutrals takes the direction of the
  // surrounding strong text if the text on both sides has the same
  // direction. European and Arabic numbers act as if they were R in
  // terms of their influence on neutrals. Start-of-level-run (sor)
  // and end-of-level-run (eor) are used at level run boundaries.
  // N2. Any remaining neutrals take the embedding direction.
  // (Left after this: L, R, EN+AN)


  for (let i = 0; i < len; i++) {
    if (types[i] == 256
    /* NI */
    ) {
        let end = i + 1;

        while (end < len && types[end] == 256
        /* NI */
        ) end++;

        let beforeL = (i ? types[i - 1] : outerType) == 1
        /* L */
        ;
        let afterL = (end < len ? types[end] : outerType) == 1
        /* L */
        ;
        let replace = beforeL == afterL ? beforeL ? 1
        /* L */
        : 2
        /* R */
        : outerType;

        for (let j = i; j < end; j++) types[j] = replace;

        i = end - 1;
      }
  } // Here we depart from the documented algorithm, in order to avoid
  // building up an actual levels array. Since there are only three
  // levels (0, 1, 2) in an implementation that doesn't take
  // explicit embedding into account, we can build up the order on
  // the fly, without following the level-based algorithm.


  let order = [];

  if (outerType == 1
  /* L */
  ) {
      for (let i = 0; i < len;) {
        let start = i,
            rtl = types[i++] != 1
        /* L */
        ;

        while (i < len && rtl == (types[i] != 1
        /* L */
        )) i++;

        if (rtl) {
          for (let j = i; j > start;) {
            let end = j,
                l = types[--j] != 2
            /* R */
            ;

            while (j > start && l == (types[j - 1] != 2
            /* R */
            )) j--;

            order.push(new BidiSpan(j, end, l ? 2 : 1));
          }
        } else {
          order.push(new BidiSpan(start, i, 0));
        }
      }
    } else {
    for (let i = 0; i < len;) {
      let start = i,
          rtl = types[i++] == 2
      /* R */
      ;

      while (i < len && rtl == (types[i] == 2
      /* R */
      )) i++;

      order.push(new BidiSpan(start, i, rtl ? 1 : 2));
    }
  }

  return order;
}

function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}

let movedOver = "";

function moveVisually(line, order, dir, start, forward) {
  var _a;

  let startIndex = start.head - line.from,
      spanI = -1;

  if (startIndex == 0) {
    if (!forward || !line.length) return null;

    if (order[0].level != dir) {
      startIndex = order[0].side(false, dir);
      spanI = 0;
    }
  } else if (startIndex == line.length) {
    if (forward) return null;
    let last = order[order.length - 1];

    if (last.level != dir) {
      startIndex = last.side(true, dir);
      spanI = order.length - 1;
    }
  }

  if (spanI < 0) spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
  let span = order[spanI]; // End of span. (But not end of line--that was checked for above.)

  if (startIndex == span.side(forward, dir)) {
    span = order[spanI += forward ? 1 : -1];
    startIndex = span.side(!forward, dir);
  }

  let indexForward = forward == (span.dir == dir);
  let nextIndex = (0, _text.findClusterBreak)(line.text, startIndex, indexForward);
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  if (nextIndex != span.side(forward, dir)) return _state.EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (!nextSpan && span.level != dir) return _state.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
  if (nextSpan && nextSpan.level < span.level) return _state.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
  return _state.EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
}

function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos),
      linePos = pos - line.from;
  if (line.length == 0) return _state.EditorSelection.cursor(pos);
  if (linePos == 0) bias = 1;else if (linePos == line.length) bias = -1;
  let from = linePos,
      to = linePos;
  if (bias < 0) from = (0, _text.findClusterBreak)(line.text, linePos, false);else to = (0, _text.findClusterBreak)(line.text, linePos);
  let cat = categorize(line.text.slice(from, to));

  while (from > 0) {
    let prev = (0, _text.findClusterBreak)(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat) break;
    from = prev;
  }

  while (to < line.length) {
    let next = (0, _text.findClusterBreak)(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat) break;
    to = next;
  }

  return _state.EditorSelection.range(from + line.from, to + line.from);
} // Search the DOM for the {node, offset} position closest to the given
// coordinates. Very inefficient and crude, but can usually be avoided
// by calling caret(Position|Range)FromPoint instead.


function getdx(x, rect) {
  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}

function getdy(y, rect) {
  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}

function yOverlap(a, b) {
  return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}

function upTop(rect, top) {
  return top < rect.top ? {
    top,
    left: rect.left,
    right: rect.right,
    bottom: rect.bottom
  } : rect;
}

function upBot(rect, bottom) {
  return bottom > rect.bottom ? {
    top: rect.top,
    left: rect.left,
    right: rect.right,
    bottom
  } : rect;
}

function domPosAtCoords(parent, x, y) {
  let closest, closestRect, closestX, closestY;
  let above, below, aboveRect, belowRect;

  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);

    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx = getdx(x, rect),
          dy = getdy(y, rect);
      if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);

      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect;
        closestX = dx;
        closestY = dy;
      }

      if (dx == 0) {
        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }

  if (aboveRect && aboveRect.bottom >= y) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y) {
    closest = below;
    closestRect = belowRect;
  }

  if (!closest) return {
    node: parent,
    offset: 0
  };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
  if (closest.nodeType == 3) return domPosInText(closest, clipX, y);
  if (!closestX && closest.contentEditable == "true") return domPosAtCoords(closest, clipX, y);
  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return {
    node: parent,
    offset
  };
}

function domPosInText(node, x, y) {
  let len = node.nodeValue.length;
  let closestOffset = -1,
      closestDY = 1e9,
      generalSide = 0;

  for (let i = 0; i < len; i++) {
    let rects = textRange(node, i, i + 1).getClientRects();

    for (let j = 0; j < rects.length; j++) {
      let rect = rects[j];
      if (rect.top == rect.bottom) continue;
      if (!generalSide) generalSide = x - rect.left;
      let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;

      if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
        let right = x >= (rect.left + rect.right) / 2,
            after = right;

        if (browser.chrome || browser.gecko) {
          // Check for RTL on browsers that support getting client
          // rects for empty ranges.
          let rectBefore = textRange(node, i).getBoundingClientRect();
          if (rectBefore.left == rect.right) after = !right;
        }

        if (dy <= 0) return {
          node,
          offset: i + (after ? 1 : 0)
        };
        closestOffset = i + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }

  return {
    node,
    offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0
  };
}

function posAtCoords(view, {
  x,
  y
}, precise, bias = -1) {
  let content = view.contentDOM.getBoundingClientRect(),
      block;
  let halfLine = view.defaultLineHeight / 2;

  for (let bounced = false;;) {
    block = view.blockAtHeight(y, content.top);

    if (block.top > y || block.bottom < y) {
      bias = block.top > y ? -1 : 1;
      y = Math.min(block.bottom - halfLine, Math.max(block.top + halfLine, y));
      if (bounced) return precise ? null : 0;else bounced = true;
    }

    if (block.type == BlockType.Text) break;
    y = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
  }

  let lineStart = block.from; // Clip x to the viewport sides

  x = Math.max(content.left + 1, Math.min(content.right - 1, x)); // If this is outside of the rendered viewport, we can't determine a position

  if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : posAtCoordsImprecise(view, content, block, x, y);
  if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : posAtCoordsImprecise(view, content, block, x, y); // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not

  let doc = view.dom.ownerDocument;
  let element = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(x, y); // There's visible editor content under the point, so we can try
  // using caret(Position|Range)FromPoint as a shortcut

  let node,
      offset = -1;

  if (element && view.contentDOM.contains(element) && !(view.docView.nearest(element) instanceof WidgetView)) {
    if (doc.caretPositionFromPoint) {
      let pos = doc.caretPositionFromPoint(x, y);
      if (pos) ({
        offsetNode: node,
        offset
      } = pos);
    } else if (doc.caretRangeFromPoint) {
      let range = doc.caretRangeFromPoint(x, y);

      if (range) {
        ({
          startContainer: node,
          startOffset: offset
        } = range);
        if (browser.safari && isSuspiciousCaretResult(node, offset, x)) node = undefined;
      }
    }
  } // No luck, do our own (potentially expensive) search


  if (!node || !view.docView.dom.contains(node)) {
    let line = LineView.find(view.docView, lineStart);
    ({
      node,
      offset
    } = domPosAtCoords(line.dom, x, y));
  }

  return view.docView.posFromDOM(node, offset);
}

function posAtCoordsImprecise(view, contentRect, block, x, y) {
  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);

  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let line = Math.floor((y - block.top) / view.defaultLineHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }

  let content = view.state.sliceDoc(block.from, block.to);
  return block.from + (0, _text.findColumn)(content, into, view.state.tabSize);
} // In case of a high line height, Safari's caretRangeFromPoint treats
// the space between lines as belonging to the last character of the
// line before. This is used to detect such a result so that it can be
// ignored (issue #401).


function isSuspiciousCaretResult(node, offset, x) {
  let len;
  if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;

  for (let next = node.nextSibling; next; next = next.nextSibling) if (next.nodeType != 1 || next.nodeName != "BR") return false;

  return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}

function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = view.state.doc.lineAt(start.head);
  let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);

  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let pos = view.posAtCoords({
      x: forward == (view.textDirection == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null) return _state.EditorSelection.cursor(pos, forward ? -1 : 1);
  }

  let lineView = LineView.find(view.docView, start.head);
  let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
  return _state.EditorSelection.cursor(end, forward ? -1 : 1);
}

function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head),
      spans = view.bidiSpans(line);

  for (let cur = start, check = null;;) {
    let next = moveVisually(line, spans, view.textDirection, cur, forward),
        char = movedOver;

    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1)) return cur;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = _state.EditorSelection.cursor(forward ? line.from : line.to);
    }

    if (!check) {
      if (!by) return next;
      check = by(char);
    } else if (!check(char)) {
      return cur;
    }

    cur = next;
  }
}

function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return next => {
    let nextCat = categorize(next);
    if (cat == _state.CharCategory.Space) cat = nextCat;
    return cat == nextCat;
  };
}

function moveVertically(view, start, forward, distance) {
  let startPos = start.head,
      dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0)) return _state.EditorSelection.cursor(startPos);
  let goal = start.goalColumn,
      startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos);

  if (startCoords) {
    if (goal == null) goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineAt(startPos, view.dom.getBoundingClientRect().top);
    if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = dir < 0 ? line.top : line.bottom;
  }

  let resolvedGoal = rect.left + goal;
  let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;

  for (let extra = 0;; extra += 10) {
    let curY = startY + (dist + extra) * dir;
    let pos = posAtCoords(view, {
      x: resolvedGoal,
      y: curY
    }, false, dir);
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) return _state.EditorSelection.cursor(pos, undefined, undefined, goal);
  }
}

function skipAtoms(view, oldPos, pos) {
  let atoms = view.pluginField(PluginField.atomicRanges);

  for (;;) {
    let moved = false;

    for (let set of atoms) {
      set.between(pos.from - 1, pos.from + 1, (from, to, value) => {
        if (pos.from > from && pos.from < to) {
          pos = oldPos.from > pos.from ? _state.EditorSelection.cursor(from, 1) : _state.EditorSelection.cursor(to, -1);
          moved = true;
        }
      });
    }

    if (!moved) return pos;
  }
} // This will also be where dragging info and such goes


class InputState {
  constructor(view) {
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.pendingIOSKey = null;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastEscPress = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.registeredEvents = [];
    this.customHandlers = []; // -1 means not in a composition. Otherwise, this counts the number
    // of changes made during the composition. The count is used to
    // avoid treating the start state of the composition, before any
    // changes have been made, as part of the composition.

    this.composing = -1; // Tracks whether the next change should be marked as starting the
    // composition (null means no composition, true means next is the
    // first, false means first has already been marked for this
    // composition)

    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.rapidCompositionStart = false;
    this.mouseSelection = null;

    for (let type in handlers) {
      let handler = handlers[type];
      view.contentDOM.addEventListener(type, event => {
        if (type == "keydown" && this.keydown(view, event)) return;
        if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event)) return;
        if (this.mustFlushObserver(event)) view.observer.forceFlush();
        if (this.runCustomHandlers(type, view, event)) event.preventDefault();else handler(view, event);
      });
      this.registeredEvents.push(type);
    }

    this.notifiedFocused = view.hasFocus;
    this.ensureHandlers(view); // On Safari adding an input event handler somehow prevents an
    // issue where the composition vanishes when you press enter.

    if (browser.safari) view.contentDOM.addEventListener("input", () => null);
  }

  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }

  ensureHandlers(view) {
    let handlers = this.customHandlers = view.pluginField(domEventHandlers);

    for (let set of handlers) {
      for (let type in set.handlers) if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
        this.registeredEvents.push(type);
        view.contentDOM.addEventListener(type, event => {
          if (!eventBelongsToEditor(view, event)) return;
          if (this.runCustomHandlers(type, view, event)) event.preventDefault();
        });
      }
    }
  }

  runCustomHandlers(type, view, event) {
    for (let set of this.customHandlers) {
      let handler = set.handlers[type],
          handled = false;

      if (handler) {
        try {
          handled = handler.call(set.plugin, event, view);
        } catch (e) {
          logException(view.state, e);
        }

        if (handled || event.defaultPrevented) {
          // Chrome for Android often applies a bunch of nonsensical
          // DOM changes after an enter press, even when
          // preventDefault-ed. This tries to ignore those.
          if (browser.android && type == "keydown" && event.keyCode == 13) view.observer.flushSoon();
          return true;
        }
      }
    }

    return false;
  }

  runScrollHandlers(view, event) {
    for (let set of this.customHandlers) {
      let handler = set.handlers.scroll;

      if (handler) {
        try {
          handler.call(set.plugin, event, view);
        } catch (e) {
          logException(view.state, e);
        }
      }
    }
  }

  keydown(view, event) {
    // Must always run, even if a custom handler handled the event
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (this.screenKeyEvent(view, event)) return true; // Prevent the default behavior of Enter on iOS makes the
    // virtual keyboard get stuck in the wrong (lowercase)
    // state. So we let it go through, and then, in
    // applyDOMChange, notify key handlers of it and reset to
    // the state they produce.

    if (browser.ios && (event.keyCode == 13 || event.keyCode == 8) && !(event.ctrlKey || event.altKey || event.metaKey) && !event.synthetic) {
      this.pendingIOSKey = event.keyCode == 13 ? "enter" : "backspace";
      setTimeout(() => this.flushIOSKey(view), 250);
      return true;
    }

    return false;
  }

  flushIOSKey(view) {
    if (!this.pendingIOSKey) return false;
    let dom = view.contentDOM,
        key = this.pendingIOSKey;
    this.pendingIOSKey = null;
    return key == "enter" ? dispatchKey(dom, "Enter", 13) : dispatchKey(dom, "Backspace", 8);
  }

  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type)) return false;
    if (this.composing > 0) return true; // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
    // On some input method editors (IMEs), the Enter key is used to
    // confirm character selection. On Safari, when Enter is pressed,
    // compositionend and keydown events are sometimes emitted in the
    // wrong order. The key event should still be ignored, even when
    // it happens after the compositionend event.

    if (browser.safari && Date.now() - this.compositionEndedAt < 500) {
      this.compositionEndedAt = 0;
      return true;
    }

    return false;
  }

  screenKeyEvent(view, event) {
    let protectedTab = event.keyCode == 9 && Date.now() < this.lastEscPress + 2000;
    if (event.keyCode == 27) this.lastEscPress = Date.now();else if (modifierCodes.indexOf(event.keyCode) < 0) this.lastEscPress = 0;
    return protectedTab;
  }

  mustFlushObserver(event) {
    return event.type == "keydown" && event.keyCode != 229 || event.type == "compositionend" && !browser.ios;
  }

  startMouseSelection(view, event, style) {
    if (this.mouseSelection) this.mouseSelection.destroy();
    this.mouseSelection = new MouseSelection(this, view, event, style);
  }

  update(update) {
    if (this.mouseSelection) this.mouseSelection.update(update);
    if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;
  }

  destroy() {
    if (this.mouseSelection) this.mouseSelection.destroy();
  }

} // Key codes for modifier keys


const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];

class MouseSelection {
  constructor(inputState, view, startEvent, style) {
    this.inputState = inputState;
    this.view = view;
    this.style = style;
    this.lastEvent = startEvent;
    let doc = view.contentDOM.ownerDocument;
    doc.addEventListener("mousemove", this.move = this.move.bind(this));
    doc.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(_state.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragMove = dragMovesSelection(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) ? null : false; // When clicking outside of the selection, immediately apply the
    // effect of starting the selection

    if (this.dragging === false) {
      startEvent.preventDefault();
      this.select(startEvent);
    }
  }

  move(event) {
    if (event.buttons == 0) return this.destroy();
    if (this.dragging !== false) return;
    this.select(this.lastEvent = event);
  }

  up(event) {
    if (this.dragging == null) this.select(this.lastEvent);
    if (!this.dragging) event.preventDefault();
    this.destroy();
  }

  destroy() {
    let doc = this.view.contentDOM.ownerDocument;
    doc.removeEventListener("mousemove", this.move);
    doc.removeEventListener("mouseup", this.up);
    this.inputState.mouseSelection = null;
  }

  select(event) {
    let selection = this.style.get(event, this.extend, this.multiple);
    if (!selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc) this.view.dispatch({
      selection,
      userEvent: "select.pointer",
      scrollIntoView: true
    });
  }

  update(update) {
    if (update.docChanged && this.dragging) this.dragging = this.dragging.map(update.changes);
    if (this.style.update(update)) setTimeout(() => this.select(this.lastEvent), 20);
  }

}

function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}

function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}

function isInPrimarySelection(view, event) {
  let {
    main
  } = view.state.selection;
  if (main.empty) return false; // On boundary clicks, check whether the coordinates are inside the
  // selection's client rectangles

  let sel = getSelection(view.root);
  if (sel.rangeCount == 0) return true;
  let rects = sel.getRangeAt(0).getClientRects();

  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;
  }

  return false;
}

function eventBelongsToEditor(view, event) {
  if (!event.bubbles) return true;
  if (event.defaultPrevented) return false;

  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode) if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;

  return true;
}

const handlers = /*@__PURE__*/Object.create(null); // This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.

const brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;

function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent) return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}

function doPaste(view, input) {
  let {
    state
  } = view,
      changes,
      i = 1,
      text = state.toText(input);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();

  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange(range => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine) return {
        range
      };
      lastLine = line.from;
      let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
      return {
        changes: {
          from: line.from,
          insert
        },
        range: _state.EditorSelection.cursor(range.from + insert.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange(range => {
      let line = text.line(i++);
      return {
        changes: {
          from: range.from,
          to: range.to,
          insert: line.text
        },
        range: _state.EditorSelection.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }

  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}

handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("select");
};

let lastTouch = 0;

handlers.touchstart = (view, e) => {
  lastTouch = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};

handlers.touchmove = view => {
  view.inputState.setSelectionOrigin("select.pointer");
};

handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (lastTouch > Date.now() - 2000) return; // Ignore touch interaction

  let style = null;

  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event);
    if (style) break;
  }

  if (!style && event.button == 0) style = basicMouseSelection(view, event);

  if (style) {
    if (view.root.activeElement != view.contentDOM) view.observer.ignore(() => focusPreventScroll(view.contentDOM));
    view.inputState.startMouseSelection(view, event, style);
  }
};

function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    // Single click
    return _state.EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    // Double click
    return groupAt(view.state, pos, bias);
  } else {
    // Triple click
    let visual = LineView.find(view.docView, pos),
        line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from,
        to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to) to++;
    return _state.EditorSelection.range(from, to);
  }
}

let insideY = (y, rect) => y >= rect.top && y <= rect.bottom;

let inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right; // Try to determine, for the given coordinates, associated with the
// given position, whether they are related to the element before or
// the element after the position.


function findPositionSide(view, pos, x, y) {
  let line = LineView.find(view.docView, pos);
  if (!line) return 1;
  let off = pos - line.posAtStart; // Line boundaries point into the line

  if (off == 0) return 1;
  if (off == line.length) return -1; // Positions on top of an element point at that element

  let before = line.coordsAt(off, -1);
  if (before && inside(x, y, before)) return -1;
  let after = line.coordsAt(off, 1);
  if (after && inside(x, y, after)) return 1; // This is probably a line wrap point. Pick before if the point is
  // beside it.

  return before && insideY(y, before) ? -1 : 1;
}

function queryPos(view, event) {
  let pos = view.posAtCoords({
    x: event.clientX,
    y: event.clientY
  }, false);
  return {
    pos,
    bias: findPositionSide(view, pos, event.clientX, event.clientY)
  };
}

const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null,
    lastMouseDownCount = 0,
    lastMouseDownTime = 0;

function getClickType(event) {
  if (!BadMouseDetail) return event.detail;
  let last = lastMouseDown,
      lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}

function basicMouseSelection(view, event) {
  let start = queryPos(view, event),
      type = getClickType(event);
  let startSel = view.state.selection;
  let last = start,
      lastEvent = event;
  return {
    update(update) {
      if (update.changes) {
        if (start) start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
        lastEvent = null;
      }
    },

    get(event, extend, multiple) {
      let cur;
      if (lastEvent && event.clientX == lastEvent.clientX && event.clientY == lastEvent.clientY) cur = last;else {
        cur = last = queryPos(view, event);
        lastEvent = event;
      }
      if (!cur || !start) return startSel;
      let range = rangeForClick(view, cur.pos, cur.bias, type);

      if (start.pos != cur.pos && !extend) {
        let startRange = rangeForClick(view, start.pos, start.bias, type);
        let from = Math.min(startRange.from, range.from),
            to = Math.max(startRange.to, range.to);
        range = from < range.from ? _state.EditorSelection.range(from, to) : _state.EditorSelection.range(to, from);
      }

      if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to));else if (multiple) return startSel.addRange(range);else return _state.EditorSelection.create([range]);
    }

  };
}

handlers.dragstart = (view, event) => {
  let {
    selection: {
      main
    }
  } = view.state;
  let {
    mouseSelection
  } = view.inputState;
  if (mouseSelection) mouseSelection.dragging = main;

  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
    event.dataTransfer.effectAllowed = "copyMove";
  }
};

function dropText(view, event, text, direct) {
  let dropPos = view.posAtCoords({
    x: event.clientX,
    y: event.clientY
  });
  if (dropPos == null || !text) return;
  event.preventDefault();
  let {
    mouseSelection
  } = view.inputState;
  let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? {
    from: mouseSelection.dragging.from,
    to: mouseSelection.dragging.to
  } : null;
  let ins = {
    from: dropPos,
    insert: text
  };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: {
      anchor: changes.mapPos(dropPos, -1),
      head: changes.mapPos(dropPos, 1)
    },
    userEvent: del ? "move.drop" : "input.drop"
  });
}

handlers.drop = (view, event) => {
  if (!event.dataTransfer) return;
  if (view.state.readOnly) return event.preventDefault();
  let files = event.dataTransfer.files;

  if (files && files.length) {
    // For a file drop, read the file's text.
    event.preventDefault();
    let text = Array(files.length),
        read = 0;

    let finishFile = () => {
      if (++read == files.length) dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);
    };

    for (let i = 0; i < files.length; i++) {
      let reader = new FileReader();
      reader.onerror = finishFile;

      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result)) text[i] = reader.result;
        finishFile();
      };

      reader.readAsText(files[i]);
    }
  } else {
    dropText(view, event, event.dataTransfer.getData("Text"), true);
  }
};

handlers.paste = (view, event) => {
  if (view.state.readOnly) return event.preventDefault();
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event.clipboardData;

  if (data) {
    doPaste(view, data.getData("text/plain"));
    event.preventDefault();
  } else {
    capturePaste(view);
  }
};

function captureCopy(view, text) {
  // The extra wrapper is somehow necessary on IE/Edge to prevent the
  // content from being mangled when it is put onto the clipboard
  let parent = view.dom.parentNode;
  if (!parent) return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}

function copiedRange(state) {
  let content = [],
      ranges = [],
      linewise = false;

  for (let range of state.selection.ranges) if (!range.empty) {
    content.push(state.sliceDoc(range.from, range.to));
    ranges.push(range);
  }

  if (!content.length) {
    // Nothing selected, do a line-wise copy
    let upto = -1;

    for (let {
      from
    } of state.selection.ranges) {
      let line = state.doc.lineAt(from);

      if (line.number > upto) {
        content.push(line.text);
        ranges.push({
          from: line.from,
          to: Math.min(state.doc.length, line.to + 1)
        });
      }

      upto = line.number;
    }

    linewise = true;
  }

  return {
    text: content.join(state.lineBreak),
    ranges,
    linewise
  };
}

let lastLinewiseCopy = null;

handlers.copy = handlers.cut = (view, event) => {
  let {
    text,
    ranges,
    linewise
  } = copiedRange(view.state);
  if (!text && !linewise) return;
  lastLinewiseCopy = linewise ? text : null;
  let data = brokenClipboardAPI ? null : event.clipboardData;

  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/plain", text);
  } else {
    captureCopy(view, text);
  }

  if (event.type == "cut" && !view.state.readOnly) view.dispatch({
    changes: ranges,
    scrollIntoView: true,
    userEvent: "delete.cut"
  });
};

handlers.focus = handlers.blur = view => {
  setTimeout(() => {
    if (view.hasFocus != view.inputState.notifiedFocused) view.update([]);
  }, 10);
};

handlers.beforeprint = view => {
  view.viewState.printing = true;
  view.requestMeasure();
  setTimeout(() => {
    view.viewState.printing = false;
    view.requestMeasure();
  }, 2000);
};

function forceClearComposition(view, rapid) {
  if (view.docView.compositionDeco.size) {
    view.inputState.rapidCompositionStart = rapid;

    try {
      view.update([]);
    } finally {
      view.inputState.rapidCompositionStart = false;
    }
  }
}

handlers.compositionstart = handlers.compositionupdate = view => {
  if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;

  if (view.inputState.composing < 0) {
    if (view.docView.compositionDeco.size) {
      view.observer.flush();
      forceClearComposition(view, true);
    } // FIXME possibly set a timeout to clear it again on Android


    view.inputState.composing = 0;
  }
};

handlers.compositionend = view => {
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionFirstChange = null;
  setTimeout(() => {
    if (view.inputState.composing < 0) forceClearComposition(view, false);
  }, 50);
};

handlers.contextmenu = view => {
  view.inputState.lastContextMenu = Date.now();
};

const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line"];

class HeightOracle {
  constructor() {
    this.doc = _text.Text.empty;
    this.lineWrapping = false;
    this.direction = Direction.LTR;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.lineLength = 30; // Used to track, during updateHeight, if any actual heights changed

    this.heightChanged = false;
  }

  heightForGap(from, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping) lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);
    return this.lineHeight * lines;
  }

  heightForLine(length) {
    if (!this.lineWrapping) return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }

  setDoc(doc) {
    this.doc = doc;
    return this;
  }

  mustRefresh(lineHeights, whiteSpace, direction) {
    let newHeight = false;

    for (let i = 0; i < lineHeights.length; i++) {
      let h = lineHeights[i];

      if (h < 0) {
        i++;
      } else if (!this.heightSamples[Math.floor(h * 10)]) {
        // Round to .1 pixels
        newHeight = true;
        this.heightSamples[Math.floor(h * 10)] = true;
      }
    }

    return newHeight || wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping || this.direction != direction;
  }

  refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping || this.direction != direction;
    this.lineWrapping = lineWrapping;
    this.direction = direction;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.lineLength = lineLength;

    if (changed) {
      this.heightSamples = {};

      for (let i = 0; i < knownHeights.length; i++) {
        let h = knownHeights[i];
        if (h < 0) i++;else this.heightSamples[Math.floor(h * 10)] = true;
      }
    }

    return changed;
  }

} // This object is used by `updateHeight` to make DOM measurements
// arrive at the right nides. The `heights` array is a sequence of
// block heights, starting from position `from`.


class MeasuredHeights {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }

  get more() {
    return this.index < this.heights.length;
  }

}
/**
Record used to represent information about a block-level element
in the editor view.
*/


class BlockInfo {
  /**
  @internal
  */
  constructor(
  /**
  The start of the element in the document.
  */
  from,
  /**
  The length of the element.
  */
  length,
  /**
  The top position of the element.
  */
  top,
  /**
  Its height.
  */
  height,
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  type) {
    this.from = from;
    this.length = length;
    this.top = top;
    this.height = height;
    this.type = type;
  }
  /**
  The end of the element as a document position.
  */


  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */


  get bottom() {
    return this.top + this.height;
  }
  /**
  @internal
  */


  join(other) {
    let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
  }

}

exports.BlockInfo = BlockInfo;

var QueryType = /*@__PURE__*/function (QueryType) {
  QueryType[QueryType["ByPos"] = 0] = "ByPos";
  QueryType[QueryType["ByHeight"] = 1] = "ByHeight";
  QueryType[QueryType["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType;
}(QueryType || (QueryType = {}));

const Epsilon = 1e-4;

class HeightMap {
  constructor(length, // The number of characters covered
  height, // Height of this part of the document
  flags = 2
  /* Outdated */
  ) {
    this.length = length;
    this.height = height;
    this.flags = flags;
  }

  get outdated() {
    return (this.flags & 2
    /* Outdated */
    ) > 0;
  }

  set outdated(value) {
    this.flags = (value ? 2
    /* Outdated */
    : 0) | this.flags & ~2
    /* Outdated */
    ;
  }

  setHeight(oracle, height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon) oracle.heightChanged = true;
      this.height = height;
    }
  } // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)


  replace(_from, _to, nodes) {
    return HeightMap.of(nodes);
  } // Again, these are base cases, and are overridden for branch and gap nodes.


  decomposeLeft(_to, result) {
    result.push(this);
  }

  decomposeRight(_from, result) {
    result.push(this);
  }

  applyChanges(decorations, oldDoc, oracle, changes) {
    let me = this;

    for (let i = changes.length - 1; i >= 0; i--) {
      let {
        fromA,
        toA,
        fromB,
        toB
      } = changes[i];
      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
      toB += end.to - toA;
      toA = end.to;

      while (i > 0 && start.from <= changes[i - 1].toA) {
        fromA = changes[i - 1].fromA;
        fromB = changes[i - 1].fromB;
        i--;
        if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
      }

      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);
      me = me.replace(fromA, toA, nodes);
    }

    return me.updateHeight(oracle, 0);
  }

  static empty() {
    return new HeightMapText(0, 0);
  } // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).


  static of(nodes) {
    if (nodes.length == 1) return nodes[0];
    let i = 0,
        j = nodes.length,
        before = 0,
        after = 0;

    for (;;) {
      if (i == j) {
        if (before > after * 2) {
          let split = nodes[i - 1];
          if (split.break) nodes.splice(--i, 1, split.left, null, split.right);else nodes.splice(--i, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break) nodes.splice(j, 1, split.left, null, split.right);else nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i++];
        if (next) before += next.size;
      } else {
        let next = nodes[--j];
        if (next) after += next.size;
      }
    }

    let brk = 0;

    if (nodes[i - 1] == null) {
      brk = 1;
      i--;
    } else if (nodes[i] == null) {
      brk = 1;
      j++;
    }

    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
  }

}

HeightMap.prototype.size = 1;

class HeightMapBlock extends HeightMap {
  constructor(length, height, type) {
    super(length, height);
    this.type = type;
  }

  blockAt(_height, _doc, top, offset) {
    return new BlockInfo(offset, this.length, top, this.height, this.type);
  }

  lineAt(_value, _type, doc, top, offset) {
    return this.blockAt(0, doc, top, offset);
  }

  forEachLine(_from, _to, doc, top, offset, f) {
    f(this.blockAt(0, doc, top, offset));
  }

  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }

  toString() {
    return `block(${this.length})`;
  }

}

class HeightMapText extends HeightMapBlock {
  constructor(length, height) {
    super(length, height, BlockType.Text);
    this.collapsed = 0; // Amount of collapsed content in the line

    this.widgetHeight = 0; // Maximum inline widget height
  }

  replace(_from, _to, nodes) {
    let node = nodes[0];

    if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4
    /* SingleLine */
    ) && Math.abs(this.length - node.length) < 10) {
      if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);else node.height = this.height;
      if (!this.outdated) node.outdated = false;
      return node;
    } else {
      return HeightMap.of(nodes);
    }
  }

  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);else if (force || this.outdated) this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
    this.outdated = false;
    return this;
  }

  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }

}

class HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0);
  }

  lines(doc, offset) {
    let firstLine = doc.lineAt(offset).number,
        lastLine = doc.lineAt(offset + this.length).number;
    return {
      firstLine,
      lastLine,
      lineHeight: this.height / (lastLine - firstLine + 1)
    };
  }

  blockAt(height, doc, top, offset) {
    let {
      firstLine,
      lastLine,
      lineHeight
    } = this.lines(doc, offset);
    let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));
    let {
      from,
      length
    } = doc.line(firstLine + line);
    return new BlockInfo(from, length, top + lineHeight * line, lineHeight, BlockType.Text);
  }

  lineAt(value, type, doc, top, offset) {
    if (type == QueryType.ByHeight) return this.blockAt(value, doc, top, offset);

    if (type == QueryType.ByPosNoHeight) {
      let {
        from,
        to
      } = doc.lineAt(value);
      return new BlockInfo(from, to - from, 0, 0, BlockType.Text);
    }

    let {
      firstLine,
      lineHeight
    } = this.lines(doc, offset);
    let {
      from,
      length,
      number
    } = doc.lineAt(value);
    return new BlockInfo(from, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);
  }

  forEachLine(from, to, doc, top, offset, f) {
    let {
      firstLine,
      lineHeight
    } = this.lines(doc, offset);

    for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end;) {
      let line = doc.lineAt(pos);
      if (pos == from) top += lineHeight * (line.number - firstLine);
      f(new BlockInfo(line.from, line.length, top, lineHeight, BlockType.Text));
      top += lineHeight;
      pos = line.to + 1;
    }
  }

  replace(from, to, nodes) {
    let after = this.length - to;

    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);else nodes.push(null, new HeightMapGap(after - 1));
    }

    if (from > 0) {
      let first = nodes[0];
      if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);else nodes.unshift(new HeightMapGap(from - 1), null);
    }

    return HeightMap.of(nodes);
  }

  decomposeLeft(to, result) {
    result.push(new HeightMapGap(to - 1), null);
  }

  decomposeRight(from, result) {
    result.push(null, new HeightMapGap(this.length - from - 1));
  }

  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;

    if (measured && measured.from <= offset + this.length && measured.more) {
      // Fill in part of this gap with measured lines. We know there
      // can't be widgets or collapsed ranges in those lines, because
      // they would already have been added to the heightmap (gaps
      // only contain plain text).
      let nodes = [],
          pos = Math.max(offset, measured.from);
      if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));

      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length) nodes.push(null);
        let line = new HeightMapText(len, measured.heights[measured.index++]);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }

      if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
      oracle.heightChanged = true;
      return HeightMap.of(nodes);
    } else if (force || this.outdated) {
      this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }

    return this;
  }

  toString() {
    return `gap(${this.length})`;
  }

}

class HeightMapBranch extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2
    /* Outdated */
    : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }

  get break() {
    return this.flags & 1
    /* Break */
    ;
  }

  blockAt(height, doc, top, offset) {
    let mid = top + this.left.height;
    return height < mid || this.right.height == 0 ? this.left.blockAt(height, doc, top, offset) : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);
  }

  lineAt(value, type, doc, top, offset) {
    let rightTop = top + this.left.height,
        rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop || this.right.height == 0 : value < rightOffset;
    let base = left ? this.left.lineAt(value, type, doc, top, offset) : this.right.lineAt(value, type, doc, rightTop, rightOffset);
    if (this.break || (left ? base.to < rightOffset : base.from > rightOffset)) return base;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left) return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));else return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);
  }

  forEachLine(from, to, doc, top, offset, f) {
    let rightTop = top + this.left.height,
        rightOffset = offset + this.left.length + this.break;

    if (this.break) {
      if (from < rightOffset) this.left.forEachLine(from, to, doc, top, offset, f);
      if (to >= rightOffset) this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);
      if (from < mid.from) this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);
      if (mid.to >= from && mid.from <= to) f(mid);
      if (to > mid.to) this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);
    }
  }

  replace(from, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);
    if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
    let result = [];
    if (from > 0) this.decomposeLeft(from, result);
    let left = result.length;

    for (let node of nodes) result.push(node);

    if (from > 0) mergeGaps(result, left - 1);

    if (to < this.length) {
      let right = result.length;
      this.decomposeRight(to, result);
      mergeGaps(result, right);
    }

    return HeightMap.of(result);
  }

  decomposeLeft(to, result) {
    let left = this.left.length;
    if (to <= left) return this.left.decomposeLeft(to, result);
    result.push(this.left);

    if (this.break) {
      left++;
      if (to >= left) result.push(null);
    }

    if (to > left) this.right.decomposeLeft(to - left, result);
  }

  decomposeRight(from, result) {
    let left = this.left.length,
        right = left + this.break;
    if (from >= right) return this.right.decomposeRight(from - right, result);
    if (from < left) this.left.decomposeRight(from, result);
    if (this.break && from < right) result.push(null);
    result.push(this.right);
  }

  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = left;
    this.right = right;
    this.height = left.height + right.height;
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }

  updateHeight(oracle, offset = 0, force = false, measured) {
    let {
      left,
      right
    } = this,
        rightStart = offset + left.length + this.break,
        rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);else left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);else right.updateHeight(oracle, rightStart, force);
    if (rebalance) return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }

  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }

}

function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}

const relevantWidgetHeight = 5;

class NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }

  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }

  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd),
          last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText) last.length += end - this.pos;else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));
      this.writtenTo = end;

      if (to > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }

    this.pos = to;
  }

  point(from, to, deco) {
    if (from < to || deco.heightRelevant) {
      let height = deco.widget ? Math.max(0, deco.widget.estimatedHeight) : 0;
      let len = to - from;

      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco.type));
      } else if (len || height >= relevantWidgetHeight) {
        this.addLineDeco(height, len);
      }
    } else if (to > from) {
      this.span(from, to);
    }

    if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }

  enterLine() {
    if (this.lineStart > -1) return;
    let {
      from,
      to
    } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to;

    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }

    if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));
    this.writtenTo = this.pos;
  }

  blankContent(from, to) {
    let gap = new HeightMapGap(to - from);
    if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4
    /* SingleLine */
    ;
    return gap;
  }

  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText) return last;
    let line = new HeightMapText(0, -1);
    this.nodes.push(line);
    return line;
  }

  addBlock(block) {
    this.enterLine();
    if (block.type == BlockType.WidgetAfter && !this.isCovered) this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (block.type != BlockType.WidgetBefore) this.covering = block;
  }

  addLineDeco(height, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    this.writtenTo = this.pos = this.pos + length;
  }

  finish(from) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;

    for (let node of this.nodes) {
      if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);
      pos += node ? node.length : 1;
    }

    return this.nodes;
  } // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.


  static build(oracle, decorations, from, to) {
    let builder = new NodeBuilder(from, oracle);

    _rangeset.RangeSet.spans(decorations, from, to, builder, 0);

    return builder.finish(from);
  }

}

function heightRelevantDecoChanges(a, b, diff) {
  let comp = new DecorationComparator();

  _rangeset.RangeSet.compare(a, b, diff, comp, 0);

  return comp.changes;
}

class DecorationComparator {
  constructor() {
    this.changes = [];
  }

  compareRange() {}

  comparePoint(from, to, a, b) {
    if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);
  }

}

function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let left = Math.max(0, rect.left),
      right = Math.min(innerWidth, rect.right);
  let top = Math.max(0, rect.top),
      bottom = Math.min(innerHeight, rect.bottom);

  for (let parent = dom.parentNode; parent;) {
    // (Cast to any because TypeScript is useless with Node types)
    if (parent.nodeType == 1) {
      let style = window.getComputedStyle(parent);

      if ((parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth) && style.overflow != "visible") {
        let parentRect = parent.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top = Math.max(top, parentRect.top);
        bottom = Math.min(bottom, parentRect.bottom);
      }

      parent = style.position == "absolute" || style.position == "fixed" ? parent.offsetParent : parent.parentNode;
    } else if (parent.nodeType == 11) {
      // Shadow root
      parent = parent.host;
    } else {
      break;
    }
  }

  return {
    left: left - rect.left,
    right: right - rect.left,
    top: top - (rect.top + paddingTop),
    bottom: bottom - (rect.top + paddingTop)
  };
} // Line gaps are placeholder widgets used to hide pieces of overlong
// lines within the viewport, as a kludge to keep the editor
// responsive when a ridiculously long line is loaded into it.


class LineGap {
  constructor(from, to, size) {
    this.from = from;
    this.to = to;
    this.size = size;
  }

  static same(a, b) {
    if (a.length != b.length) return false;

    for (let i = 0; i < a.length; i++) {
      let gA = a[i],
          gB = b[i];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;
    }

    return true;
  }

  draw(wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(this.size, wrapping)
    }).range(this.from, this.to);
  }

}

class LineGapWidget extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }

  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }

  toDOM() {
    let elt = document.createElement("div");

    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }

    return elt;
  }

  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }

}

class ViewState {
  constructor(state) {
    this.state = state; // These are contentDOM-local coordinates

    this.pixelViewport = {
      left: 0,
      right: window.innerWidth,
      top: 0,
      bottom: 0
    };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentWidth = 0;
    this.heightOracle = new HeightOracle(); // See VP.MaxDOMHeight

    this.scaler = IdScaler;
    this.scrollTo = null; // Briefly set to true when printing, to disable viewport limiting

    this.printing = false;
    this.visibleRanges = []; // Cursor 'assoc' is only significant when the cursor is on a line
    // wrap point, where it must stick to the character that it is
    // associated with. Since browsers don't provide a reasonable
    // interface to set or query this, when a selection is set that
    // might cause this to be significant, this flag is set. The next
    // measure phase will check whether the cursor is on a line-wrapping
    // boundary and, if so, reset it to make sure it is positioned in
    // the right place.

    this.mustEnforceCursorAssoc = false;
    this.heightMap = HeightMap.empty().applyChanges(state.facet(decorations), _text.Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    this.viewport = this.getViewport(0, null);
    this.updateForViewport();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(false)));
    this.computeVisibleRanges();
  }

  updateForViewport() {
    let viewports = [this.viewport],
        {
      main
    } = this.state.selection;

    for (let i = 0; i <= 1; i++) {
      let pos = i ? main.head : main.anchor;

      if (!viewports.some(({
        from,
        to
      }) => pos >= from && pos <= to)) {
        let {
          from,
          to
        } = this.lineAt(pos, 0);
        viewports.push(new Viewport(from, to));
      }
    }

    this.viewports = viewports.sort((a, b) => a.from - b.from);
    this.scaler = this.heightMap.height <= 7000000
    /* MaxDOMHeight */
    ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
  }

  update(update, scrollTo = null) {
    let prev = this.state;
    this.state = update.state;
    let newDeco = this.state.facet(decorations);
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(update.startState.facet(decorations), newDeco, update ? update.changes : _state.ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight) update.flags |= 2
    /* Height */
    ;
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTo && (scrollTo.head < viewport.from || scrollTo.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTo);
    this.viewport = viewport;
    this.updateForViewport();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000
    /* MinViewPort */
    ) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges();
    if (scrollTo) this.scrollTo = scrollTo;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc) this.mustEnforceCursorAssoc = true;
  }

  measure(docView, repeated) {
    let dom = docView.dom,
        whiteSpace = "",
        direction = Direction.LTR;

    if (!repeated) {
      // Vertical padding
      let style = window.getComputedStyle(dom);
      whiteSpace = style.whiteSpace, direction = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      this.paddingTop = parseInt(style.paddingTop) || 0;
      this.paddingBottom = parseInt(style.paddingBottom) || 0;
    } // Pixel viewport


    let pixelViewport = this.printing ? {
      top: -1e8,
      bottom: 1e8,
      left: -1e8,
      right: 1e8
    } : visiblePixelRange(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top,
        dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    this.inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (!this.inView) return 0;
    let lineHeights = docView.measureVisibleLineHeights();
    let refresh = false,
        bias = 0,
        result = 0,
        oracle = this.heightOracle;

    if (!repeated) {
      let contentWidth = docView.dom.clientWidth;

      if (oracle.mustRefresh(lineHeights, whiteSpace, direction) || oracle.lineWrapping && Math.abs(contentWidth - this.contentWidth) > oracle.charWidth) {
        let {
          lineHeight,
          charWidth
        } = docView.measureTextSize();
        refresh = oracle.refresh(whiteSpace, direction, lineHeight, charWidth, contentWidth / charWidth, lineHeights);

        if (refresh) {
          docView.minWidth = 0;
          result |= 8
          /* Geometry */
          ;
        }
      }

      if (this.contentWidth != contentWidth) {
        this.contentWidth = contentWidth;
        result |= 8
        /* Geometry */
        ;
      }

      if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);
    }

    oracle.heightChanged = false;
    this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));
    if (oracle.heightChanged) result |= 2
    /* Height */
    ;
    if (!this.viewportIsAppropriate(this.viewport, bias) || this.scrollTo && (this.scrollTo.head < this.viewport.from || this.scrollTo.head > this.viewport.to)) this.viewport = this.getViewport(bias, this.scrollTo);
    this.updateForViewport();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000
    /* MinViewPort */
    ) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));
    result |= this.computeVisibleRanges();

    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false; // This is done in the read stage, because moving the selection
      // to a line end is going to trigger a layout anyway, so it
      // can't be a pure write. It should be rare that it does any
      // writing.

      docView.enforceCursorAssoc();
    }

    return result;
  }

  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top, 0);
  }

  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom, 0);
  }

  getViewport(bias, scrollTo) {
    // This will divide VP.Margin between the top and the
    // bottom, depending on the bias (the change in viewport position
    // since the last update). It'll hold a number between 0 and 1
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000
    /* Margin */
    / 2));
    let map = this.heightMap,
        doc = this.state.doc,
        {
      visibleTop,
      visibleBottom
    } = this;
    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000
    /* Margin */
    , QueryType.ByHeight, doc, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000
    /* Margin */
    , QueryType.ByHeight, doc, 0, 0).to); // If scrollTo is given, make sure the viewport includes that position

    if (scrollTo) {
      if (scrollTo.head < viewport.from) {
        let {
          top: newTop
        } = map.lineAt(scrollTo.head, QueryType.ByPos, doc, 0, 0);
        viewport = new Viewport(map.lineAt(newTop - 1000
        /* Margin */
        / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newTop + (visibleBottom - visibleTop) + 1000
        /* Margin */
        / 2, QueryType.ByHeight, doc, 0, 0).to);
      } else if (scrollTo.head > viewport.to) {
        let {
          bottom: newBottom
        } = map.lineAt(scrollTo.head, QueryType.ByPos, doc, 0, 0);
        viewport = new Viewport(map.lineAt(newBottom - (visibleBottom - visibleTop) - 1000
        /* Margin */
        / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newBottom + 1000
        /* Margin */
        / 2, QueryType.ByHeight, doc, 0, 0).to);
      }
    }

    return viewport;
  }

  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1),
        to = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
  } // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.


  viewportIsAppropriate({
    from,
    to
  }, bias = 0) {
    let {
      top
    } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);
    let {
      bottom
    } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);
    let {
      visibleTop,
      visibleBottom
    } = this;
    return (from == 0 || top <= visibleTop - Math.max(10
    /* MinCoverMargin */
    , Math.min(-bias, 250
    /* MaxCoverMargin */
    ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10
    /* MinCoverMargin */
    , Math.min(bias, 250
    /* MaxCoverMargin */
    ))) && top > visibleTop - 2 * 1000
    /* Margin */
    && bottom < visibleBottom + 2 * 1000
    /* Margin */
    ;
  }

  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty) return gaps;
    let mapped = [];

    for (let gap of gaps) if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));

    return mapped;
  } // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.


  ensureLineGaps(current) {
    let gaps = []; // This won't work at all in predominantly right-to-left text.

    if (this.heightOracle.direction != Direction.LTR) return gaps;
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, line => {
      if (line.length < 10000
      /* Margin */
      ) return;
      let structure = lineStructure(line.from, line.to, this.state);
      if (structure.total < 10000
      /* Margin */
      ) return;
      let viewFrom, viewTo;

      if (this.heightOracle.lineWrapping) {
        if (line.from != this.viewport.from) viewFrom = line.from;else viewFrom = findPosition(structure, (this.visibleTop - line.top) / line.height);
        if (line.to != this.viewport.to) viewTo = line.to;else viewTo = findPosition(structure, (this.visibleBottom - line.top) / line.height);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        viewFrom = findPosition(structure, this.pixelViewport.left / totalWidth);
        viewTo = findPosition(structure, this.pixelViewport.right / totalWidth);
      }

      let sel = this.state.selection.main; // Make sure the gap doesn't cover a selection end

      if (sel.from <= viewFrom && sel.to >= line.from) viewFrom = sel.from;
      if (sel.from <= line.to && sel.to >= viewTo) viewTo = sel.to;
      let gapTo = viewFrom - 10000
      /* Margin */
      ,
          gapFrom = viewTo + 10000
      /* Margin */
      ;
      if (gapTo > line.from + 5000
      /* HalfMargin */
      ) gaps.push(find(current, gap => gap.from == line.from && gap.to > gapTo - 5000
        /* HalfMargin */
        && gap.to < gapTo + 5000
        /* HalfMargin */
        ) || new LineGap(line.from, gapTo, this.gapSize(line, gapTo, true, structure)));
      if (gapFrom < line.to - 5000
      /* HalfMargin */
      ) gaps.push(find(current, gap => gap.to == line.to && gap.from > gapFrom - 5000
        /* HalfMargin */
        && gap.from < gapFrom + 5000
        /* HalfMargin */
        ) || new LineGap(gapFrom, line.to, this.gapSize(line, gapFrom, false, structure)));
    });
    return gaps;
  }

  gapSize(line, pos, start, structure) {
    if (this.heightOracle.lineWrapping) {
      let height = line.height * findFraction(structure, pos);
      return start ? height : line.height - height;
    } else {
      let ratio = findFraction(structure, pos);
      return structure.total * this.heightOracle.charWidth * (start ? ratio : 1 - ratio);
    }
  }

  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this.heightOracle.lineWrapping)));
    }
  }

  computeVisibleRanges() {
    let deco = this.state.facet(decorations);
    if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);
    let ranges = [];

    _rangeset.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to) {
        ranges.push({
          from,
          to
        });
      },

      point() {}

    }, 20);

    let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
    this.visibleRanges = ranges;
    return changed ? 4
    /* Viewport */
    : 0;
  }

  lineAt(pos, editorTop) {
    editorTop += this.paddingTop;
    return scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, editorTop, 0), this.scaler, editorTop);
  }

  lineAtHeight(height, editorTop) {
    editorTop += this.paddingTop;
    return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height, editorTop), QueryType.ByHeight, this.state.doc, editorTop, 0), this.scaler, editorTop);
  }

  blockAtHeight(height, editorTop) {
    editorTop += this.paddingTop;
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height, editorTop), this.state.doc, editorTop, 0), this.scaler, editorTop);
  }

  forEachLine(from, to, f, editorTop) {
    editorTop += this.paddingTop;
    return this.heightMap.forEachLine(from, to, this.state.doc, editorTop, 0, this.scaler.scale == 1 ? f : b => f(scaleBlock(b, this.scaler, editorTop)));
  }

  get contentHeight() {
    return this.domHeight + this.paddingTop + this.paddingBottom;
  }

  get domHeight() {
    return this.scaler.toDOM(this.heightMap.height, this.paddingTop);
  }

}

class Viewport {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }

}

function lineStructure(from, to, state) {
  let ranges = [],
      pos = from,
      total = 0;

  _rangeset.RangeSet.spans(state.facet(decorations), from, to, {
    span() {},

    point(from, to) {
      if (from > pos) {
        ranges.push({
          from: pos,
          to: from
        });
        total += from - pos;
      }

      pos = to;
    }

  }, 20); // We're only interested in collapsed ranges of a significant size


  if (pos < to) {
    ranges.push({
      from: pos,
      to
    });
    total += to - pos;
  }

  return {
    total,
    ranges
  };
}

function findPosition({
  total,
  ranges
}, ratio) {
  if (ratio <= 0) return ranges[0].from;
  if (ratio >= 1) return ranges[ranges.length - 1].to;
  let dist = Math.floor(total * ratio);

  for (let i = 0;; i++) {
    let {
      from,
      to
    } = ranges[i],
        size = to - from;
    if (dist <= size) return from + dist;
    dist -= size;
  }
}

function findFraction(structure, pos) {
  let counted = 0;

  for (let {
    from,
    to
  } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from;
      break;
    }

    counted += to - from;
  }

  return counted / structure.total;
}

function find(array, f) {
  for (let val of array) if (f(val)) return val;

  return undefined;
} // Don't scale when the document height is within the range of what
// the DOM can handle.


const IdScaler = {
  toDOM(n) {
    return n;
  },

  fromDOM(n) {
    return n;
  },

  scale: 1
}; // When the height is too big (> VP.MaxDOMHeight), scale down the
// regions outside the viewports so that the total height is
// VP.MaxDOMHeight.

class BigScaler {
  constructor(doc, heightMap, viewports) {
    let vpHeight = 0,
        base = 0,
        domBase = 0;
    this.viewports = viewports.map(({
      from,
      to
    }) => {
      let top = heightMap.lineAt(from, QueryType.ByPos, doc, 0, 0).top;
      let bottom = heightMap.lineAt(to, QueryType.ByPos, doc, 0, 0).bottom;
      vpHeight += bottom - top;
      return {
        from,
        to,
        top,
        bottom,
        domTop: 0,
        domBottom: 0
      };
    });
    this.scale = (7000000
    /* MaxDOMHeight */
    - vpHeight) / (heightMap.height - vpHeight);

    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base = obj.bottom;
    }
  }

  toDOM(n, top) {
    n -= top;

    for (let i = 0, base = 0, domBase = 0;; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.top) return domBase + (n - base) * this.scale + top;
      if (n <= vp.bottom) return vp.domTop + (n - vp.top) + top;
      base = vp.bottom;
      domBase = vp.domBottom;
    }
  }

  fromDOM(n, top) {
    n -= top;

    for (let i = 0, base = 0, domBase = 0;; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.domTop) return base + (n - domBase) / this.scale + top;
      if (n <= vp.domBottom) return vp.top + (n - vp.domTop) + top;
      base = vp.bottom;
      domBase = vp.domBottom;
    }
  }

}

function scaleBlock(block, scaler, top) {
  if (scaler.scale == 1) return block;
  let bTop = scaler.toDOM(block.top, top),
      bBottom = scaler.toDOM(block.bottom, top);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map(b => scaleBlock(b, scaler, top)) : block.type);
}

const theme = /*@__PURE__*/_state.Facet.define({
  combine: strs => strs.join(" ")
});

const darkTheme = /*@__PURE__*/_state.Facet.define({
  combine: values => values.indexOf(true) > -1
});

const baseThemeID = /*@__PURE__*/_styleMod.StyleModule.newName(),
      baseLightID = /*@__PURE__*/_styleMod.StyleModule.newName(),
      baseDarkID = /*@__PURE__*/_styleMod.StyleModule.newName();

const lightDarkIDs = {
  "&light": "." + baseLightID,
  "&dark": "." + baseDarkID
};

function buildTheme(main, spec, scopes) {
  return new _styleMod.StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, m => {
        if (m == "&") return main;
        if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);
        return scopes[m];
      }) : main + " " + sel;
    }

  });
}

const baseTheme = /*@__PURE__*/buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    minHeight: "100%",
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none"
  },
  ".cm-lineWrapping": {
    whiteSpace: "pre-wrap",
    wordBreak: "break-word",
    overflowWrap: "anywhere"
  },
  "&light .cm-content": {
    caretColor: "black"
  },
  "&dark .cm-content": {
    caretColor: "white"
  },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 4px"
  },
  ".cm-selectionLayer": {
    zIndex: -1,
    contain: "size style"
  },
  ".cm-selectionBackground": {
    position: "absolute"
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    zIndex: 100,
    contain: "size style",
    pointerEvents: "none"
  },
  "&.cm-focused .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": {
    "0%": {},
    "50%": {
      visibility: "hidden"
    },
    "100%": {}
  },
  "@keyframes cm-blink2": {
    "0%": {},
    "50%": {
      visibility: "hidden"
    },
    "100%": {}
  },
  ".cm-cursor": {
    position: "absolute",
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none",
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  "&.cm-focused .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": {
    backgroundColor: "#f3f9ff"
  },
  "&dark .cm-activeLine": {
    backgroundColor: "#223039"
  },
  "&light .cm-specialChar": {
    color: "red"
  },
  "&dark .cm-specialChar": {
    color: "#f78"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "3px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
const observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
}; // IE11 has very broken mutation observers, so we also listen to
// DOMCharacterDataModified there

const useCharData = browser.ie && browser.ie_version <= 11;

class DOMObserver {
  constructor(view, onChange, onScrollChanged) {
    this.view = view;
    this.onChange = onChange;
    this.onScrollChanged = onScrollChanged;
    this.active = false;
    this.ignoreSelection = new DOMSelection();
    this.delayedFlush = -1;
    this.queue = [];
    this.lastFlush = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.intersecting = false; // Used to work around a Safari Selection/shadow DOM bug (#414)

    this._selectionRange = null; // Timeout for scheduling check of the parents that need scroll handlers

    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver(mutations => {
      for (let mut of mutations) this.queue.push(mut);

      this._selectionRange = null; // IE11 will sometimes (on typing over a selection or
      // backspacing out a single character text node) call the
      // observer callback before actually updating the DOM.
      //
      // Unrelatedly, iOS Safari will, when ending a composition,
      // sometimes first clear it, deliver the mutations, and then
      // reinsert the finished text. CodeMirror's handling of the
      // deletion will prevent the reinsertion from happening,
      // breaking composition.

      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some(m => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();else this.flush();
    });
    if (useCharData) this.onCharData = event => {
      this.queue.push({
        target: event.target,
        type: "characterData",
        oldValue: event.prevValue
      });
      this.flushSoon();
    };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.start();
    this.onScroll = this.onScroll.bind(this);
    window.addEventListener("scroll", this.onScroll);

    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver(entries => {
        if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);

        if (entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent("Event"));
        }
      }, {});
      this.intersection.observe(this.dom);
    }

    this.listenForScroll();
  }

  onScroll(e) {
    if (this.intersecting) this.flush();
    this.onScrollChanged(e);
  }

  onSelectionChange(event) {
    if (this.lastFlush < Date.now() - 50) this._selectionRange = null;
    let {
      view
    } = this,
        sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel)) return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event)) return; // Deletions on IE11 fire their events in the wrong order, giving
    // us a selection change event before the DOM changes are
    // reported.
    // (Selection.isCollapsed isn't reliable on IE)

    if (browser.ie && browser.ie_version <= 11 && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();else this.flush();
  }

  get selectionRange() {
    if (!this._selectionRange) {
      let {
        root
      } = this.view,
          sel = getSelection(root); // The Selection object is broken in shadow roots in Safari. See
      // https://github.com/codemirror/codemirror.next/issues/414

      if (browser.safari && root.nodeType == 11 && deepActiveElement() == this.view.contentDOM) sel = safariSelectionRangeHack(this.view) || sel;
      this._selectionRange = sel;
    }

    return this._selectionRange;
  }

  setSelectionRange(anchor, head) {
    var _a;

    if (!((_a = this._selectionRange) === null || _a === void 0 ? void 0 : _a.type)) this._selectionRange = {
      anchorNode: anchor.node,
      anchorOffset: anchor.offset,
      focusNode: head.node,
      focusOffset: head.offset
    };
  }

  listenForScroll() {
    this.parentCheck = -1;
    let i = 0,
        changed = null;

    for (let dom = this.dom; dom;) {
      if (dom.nodeType == 1) {
        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;else if (!changed) changed = this.scrollTargets.slice(0, i);
        if (changed) changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        // Shadow root
        dom = dom.host;
      } else {
        break;
      }
    }

    if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);

    if (changed) {
      for (let dom of this.scrollTargets) dom.removeEventListener("scroll", this.onScroll);

      for (let dom of this.scrollTargets = changed) dom.addEventListener("scroll", this.onScroll);
    }
  }

  ignore(f) {
    if (!this.active) return f();

    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }

  start() {
    if (this.active) return;
    this.observer.observe(this.dom, observeOptions);
    this.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    if (useCharData) this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }

  stop() {
    if (!this.active) return;
    this.active = false;
    this.observer.disconnect();
    this.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    if (useCharData) this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }

  clearSelection() {
    this.ignoreSelection.set(this.selectionRange);
  } // Throw away any pending changes


  clear() {
    this.observer.takeRecords();
    this.queue.length = 0;
    this.clearSelection();
  }

  flushSoon() {
    if (this.delayedFlush < 0) this.delayedFlush = window.setTimeout(() => {
      this.delayedFlush = -1;
      this.flush();
    }, 20);
  }

  forceFlush() {
    if (this.delayedFlush >= 0) {
      window.clearTimeout(this.delayedFlush);
      this.delayedFlush = -1;
      this.flush();
    }
  } // Apply pending changes, if any


  flush() {
    if (this.delayedFlush >= 0) return;
    this.lastFlush = Date.now();
    let records = this.queue;

    for (let mut of this.observer.takeRecords()) records.push(mut);

    if (records.length) this.queue = [];
    let selection = this.selectionRange;
    let newSel = !this.ignoreSelection.eq(selection) && hasSelection(this.dom, selection);
    if (records.length == 0 && !newSel) return;
    let from = -1,
        to = -1,
        typeOver = false;

    for (let record of records) {
      let range = this.readMutation(record);
      if (!range) continue;
      if (range.typeOver) typeOver = true;

      if (from == -1) {
        ({
          from,
          to
        } = range);
      } else {
        from = Math.min(range.from, from);
        to = Math.max(range.to, to);
      }
    }

    let startState = this.view.state;
    if (from > -1 || newSel) this.onChange(from, to, typeOver);

    if (this.view.state == startState) {
      // The view wasn't updated
      if (this.view.docView.dirty) {
        this.ignore(() => this.view.docView.sync());
        this.view.docView.dirty = 0
        /* Not */
        ;
      }

      if (newSel) this.view.docView.updateSelection();
    }

    this.clearSelection();
  }

  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec)) return null;
    cView.markDirty(rec.type == "attributes");
    if (rec.type == "attributes") cView.dirty |= 4
    /* Attrs */
    ;

    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return {
        from: cView.posAtStart,
        to: cView.posAtEnd,
        typeOver: rec.target.nodeValue == rec.oldValue
      };
    } else {
      return null;
    }
  }

  destroy() {
    this.stop();
    if (this.intersection) this.intersection.disconnect();

    for (let dom of this.scrollTargets) dom.removeEventListener("scroll", this.onScroll);

    window.removeEventListener("scroll", this.onScroll);
    clearTimeout(this.parentCheck);
  }

}

function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView) return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }

  return null;
}

function safariSelectionRangeHack(view) {
  let found = null; // Because Safari (at least in 2018-2021) doesn't provide regular
  // access to the selection inside a shadowroot, we have to perform a
  // ridiculous hack to get at it—using `execCommand` to trigger a
  // `beforeInput` event so that we can read the target range from the
  // event.

  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }

  view.contentDOM.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  if (!found) return null;
  let anchorNode = found.startContainer,
      anchorOffset = found.startOffset;
  let focusNode = found.endContainer,
      focusOffset = found.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor); // Since such a range doesn't distinguish between anchor and head,
  // use a heuristic that flips it around if its end matches the
  // current anchor.

  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return {
    anchorNode,
    anchorOffset,
    focusNode,
    focusOffset
  };
}

function applyDOMChange(view, start, end, typeOver) {
  let change, newSel;
  let sel = view.state.selection.main,
      bounds;

  if (start > -1 && !view.state.readOnly && (bounds = view.docView.domBoundsAround(start, end, 0))) {
    let {
      from,
      to
    } = bounds;
    let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view);
    let reader = new DOMReader(selPoints, view);
    reader.readRange(bounds.startDOM, bounds.endDOM);
    newSel = selectionFromPoints(selPoints, from);
    let preferredPos = sel.from,
        preferredSide = null; // Prefer anchoring to end when Backspace is pressed (or, on
    // Android, when something was deleted)

    if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && reader.text.length < to - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }

    let diff = findDiff(view.state.sliceDoc(from, to), reader.text, preferredPos - from, preferredSide);
    if (diff) change = {
      from: from + diff.from,
      to: from + diff.toA,
      insert: view.state.toText(reader.text.slice(diff.from, diff.toB))
    };
  } else if (view.hasFocus || !view.state.facet(editable)) {
    let domSel = view.observer.selectionRange;
    let {
      impreciseHead: iHead,
      impreciseAnchor: iAnchor
    } = view.docView;
    let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
    let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (head != sel.head || anchor != sel.anchor) newSel = _state.EditorSelection.single(anchor, head);
  }

  if (!change && !newSel) return; // Heuristic to notice typing over a selected character

  if (!change && typeOver && !sel.empty && newSel && newSel.main.empty) change = {
    from: sel.from,
    to: sel.to,
    insert: view.state.doc.slice(sel.from, sel.to)
  }; // If the change is inside the selection and covers most of it,
  // assume it is a selection replace (with identical characters at
  // the start/end not included in the diff)
  else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };

  if (change) {
    let startState = view.state; // Android browsers don't fire reasonable key events for enter,
    // backspace, or delete. So this detects changes that look like
    // they're caused by those keys, and reinterprets them as key
    // events.

    if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)) || browser.ios && view.inputState.flushIOSKey(view)) return;
    let text = change.insert.toString();
    if (view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text))) return;
    if (view.inputState.composing >= 0) view.inputState.composing++;
    let tr;

    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length)) {
      let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
      let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
      tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));
    } else {
      let changes = startState.changes(change);
      tr = {
        changes,
        selection: newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? startState.selection.replaceRange(newSel.main) : undefined
      };
    }

    let userEvent = "input.type";

    if (view.composing) {
      userEvent += ".compose";

      if (view.inputState.compositionFirstChange) {
        userEvent += ".start";
        view.inputState.compositionFirstChange = false;
      }
    }

    view.dispatch(tr, {
      scrollIntoView: true,
      userEvent
    });
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView = false,
        userEvent = "select";

    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select") scrollIntoView = true;
      userEvent = view.inputState.lastSelectionOrigin;
    }

    view.dispatch({
      selection: newSel,
      scrollIntoView,
      userEvent
    });
  }
}

function findDiff(a, b, preferredPos, preferredSide) {
  let minLen = Math.min(a.length, b.length);
  let from = 0;

  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from)) from++;

  if (from == minLen && a.length == b.length) return null;
  let toA = a.length,
      toB = b.length;

  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }

  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }

  if (toA < from && a.length < b.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move;
    toA = from + (toA - toB);
    toB = from;
  }

  return {
    from,
    toA,
    toB
  };
}

class DOMReader {
  constructor(points, view) {
    this.points = points;
    this.view = view;
    this.text = "";
    this.lineBreak = view.state.lineBreak;
  }

  readRange(start, end) {
    if (!start) return;
    let parent = start.parentNode;

    for (let cur = start;;) {
      this.findPointBefore(parent, cur);
      this.readNode(cur);
      let next = cur.nextSibling;
      if (next == end) break;
      let view = ContentView.get(cur),
          nextView = ContentView.get(next);
      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore)) this.text += this.lineBreak;
      cur = next;
    }

    this.findPointBefore(parent, end);
  }

  readNode(node) {
    if (node.cmIgnore) return;
    let view = ContentView.get(node);
    let fromView = view && view.overrideDOMText;
    let text;
    if (fromView != null) text = fromView.sliceString(0, undefined, this.lineBreak);else if (node.nodeType == 3) text = node.nodeValue;else if (node.nodeName == "BR") text = node.nextSibling ? this.lineBreak : "";else if (node.nodeType == 1) this.readRange(node.firstChild, null);

    if (text != null) {
      this.findPointIn(node, text.length);
      this.text += text; // Chrome inserts two newlines when pressing shift-enter at the
      // end of a line. This drops one of those.

      if (browser.chrome && this.view.inputState.lastKeyCode == 13 && !node.nextSibling && /\n\n$/.test(this.text)) this.text = this.text.slice(0, -1);
    }
  }

  findPointBefore(node, next) {
    for (let point of this.points) if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;
  }

  findPointIn(node, maxLen) {
    for (let point of this.points) if (point.node == node) point.pos = this.text.length + Math.min(point.offset, maxLen);
  }

}

function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}

class DOMPoint {
  constructor(node, offset) {
    this.node = node;
    this.offset = offset;
    this.pos = -1;
  }

}

function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM) return result;
  let {
    anchorNode,
    anchorOffset,
    focusNode,
    focusOffset
  } = view.observer.selectionRange;

  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));
  }

  return result;
}

function selectionFromPoints(points, base) {
  if (points.length == 0) return null;
  let anchor = points[0].pos,
      head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? _state.EditorSelection.single(anchor + base, head + base) : null;
} // The editor's update state machine looks something like this:
//
//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle
//                                         ↑      ↓
//                                         Updating (measure)
//
// The difference between 'Idle' and 'Idle (unchecked)' lies in
// whether a layout check has been scheduled. A regular update through
// the `update` method updates the DOM in a write-only fashion, and
// relies on a check (scheduled with `requestAnimationFrame`) to make
// sure everything is where it should be and the viewport covers the
// visible code. That check continues to measure and then optionally
// update until it reaches a coherent state.

/**
An editor view represents the editor's user interface. It holds
the editable DOM surface, and possibly other elements such as the
line number gutter. It handles events and dispatches state
transactions for editing actions.
*/


class EditorView {
  /**
  Construct a new view. You'll usually want to put `view.dom` into
  your document after creating a view, so that the user can see
  it.
  */
  constructor(
  /**
  Initialization options.
  */
  config = {}) {
    this.plugins = [];
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    /**
    @internal
    */

    this.updateState = 2
    /* Updating */
    ;
    /**
    @internal
    */

    this.measureScheduled = -1;
    /**
    @internal
    */

    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.style.cssText = "position: absolute; top: -10000px";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);

    this._dispatch = config.dispatch || (tr => this.update([tr]));

    this.dispatch = this.dispatch.bind(this);
    this.root = config.root || document;
    this.viewState = new ViewState(config.state || _state.EditorState.create());
    this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec).update(this));
    this.observer = new DOMObserver(this, (from, to, typeOver) => {
      applyDOMChange(this, from, to, typeOver);
    }, event => {
      this.inputState.runScrollHandlers(this, event);
      if (this.observer.intersecting) this.measure();
    });
    this.inputState = new InputState(this);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0
    /* Idle */
    ;
    ensureGlobalHandler();
    this.requestMeasure();
    if (config.parent) config.parent.appendChild(this.dom);
  }
  /**
  The current editor state.
  */


  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */


  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */


  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */


  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method).
  */


  get composing() {
    return this.inputState.composing > 0;
  }

  dispatch(...input) {
    this._dispatch(input.length == 1 && input[0] instanceof _state.Transaction ? input[0] : this.state.update(...input));
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */


  update(transactions) {
    if (this.updateState != 0
    /* Idle */
    ) throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false,
        update;
    let state = this.state;

    for (let tr of transactions) {
      if (tr.startState != state) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }

    if (this.destroyed) {
      this.viewState.state = state;
      return;
    } // When the phrases change, redraw the editor


    if (state.facet(_state.EditorState.phrases) != this.state.facet(_state.EditorState.phrases)) return this.setState(state);
    update = new ViewUpdate(this, state, transactions);
    let scrollPos = null;

    try {
      this.updateState = 2
      /* Updating */
      ;

      for (let tr of transactions) {
        if (scrollPos) scrollPos = scrollPos.map(tr.changes);

        if (tr.scrollIntoView) {
          let {
            main
          } = tr.state.selection;
          scrollPos = main.empty ? main : _state.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1);
        }

        for (let e of tr.effects) if (e.is(scrollTo)) scrollPos = e.value;
      }

      this.viewState.update(update, scrollPos);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);

      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }

      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();
      this.updateAttrs();
      this.showAnnouncements(transactions);
    } finally {
      this.updateState = 0
      /* Idle */
      ;
    }

    if (redrawn || scrollPos || this.viewState.mustEnforceCursorAssoc) this.requestMeasure();
    if (!update.empty) for (let listener of this.state.facet(updateListener)) listener(update);
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */


  setState(newState) {
    if (this.updateState != 0
    /* Idle */
    ) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");

    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }

    this.updateState = 2
    /* Updating */
    ;

    try {
      for (let plugin of this.plugins) plugin.destroy(this);

      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec).update(this));
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0
      /* Idle */
      ;
    }

    this.requestMeasure();
  }

  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin),
        specs = update.state.facet(viewPlugin);

    if (prevSpecs != specs) {
      let newPlugins = [];

      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);

        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin = this.plugins[found];
          plugin.mustUpdate = update;
          newPlugins.push(plugin);
        }
      }

      for (let plugin of this.plugins) if (plugin.mustUpdate != update) plugin.destroy(this);

      this.plugins = newPlugins;
      this.inputState.ensureHandlers(this);
    } else {
      for (let p of this.plugins) p.mustUpdate = update;
    }

    for (let i = 0; i < this.plugins.length; i++) this.plugins[i] = this.plugins[i].update(this);
  }
  /**
  @internal
  */


  measure(flush = true) {
    if (this.destroyed) return;
    if (this.measureScheduled > -1) cancelAnimationFrame(this.measureScheduled);
    this.measureScheduled = -1; // Prevent requestMeasure calls from scheduling another animation frame

    if (flush) this.observer.flush();
    let updated = null;

    try {
      for (let i = 0;; i++) {
        this.updateState = 1
        /* Measuring */
        ;
        let oldViewport = this.viewport;
        let changed = this.viewState.measure(this.docView, i > 0);
        let measuring = this.measureRequests;
        if (!changed && !measuring.length && this.viewState.scrollTo == null) break;
        this.measureRequests = [];

        if (i > 5) {
          console.warn("Viewport failed to stabilize");
          break;
        }

        let measured = measuring.map(m => {
          try {
            return m.read(this);
          } catch (e) {
            logException(this.state, e);
            return BadMeasure;
          }
        });
        let update = new ViewUpdate(this, this.state);
        update.flags |= changed;
        if (!updated) updated = update;else updated.flags |= changed;
        this.updateState = 2
        /* Updating */
        ;

        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
        }

        this.updateAttrs();
        if (changed) this.docView.update(update);

        for (let i = 0; i < measuring.length; i++) if (measured[i] != BadMeasure) {
          try {
            measuring[i].write(measured[i], this);
          } catch (e) {
            logException(this.state, e);
          }
        }

        if (this.viewState.scrollTo) {
          this.docView.scrollRangeIntoView(this.viewState.scrollTo);
          this.viewState.scrollTo = null;
        }

        if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && this.measureRequests.length == 0) break;
      }
    } finally {
      this.updateState = 0
      /* Idle */
      ;
    }

    this.measureScheduled = -1;
    if (updated && !updated.empty) for (let listener of this.state.facet(updateListener)) listener(updated);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */


  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }

  updateAttrs() {
    let editorAttrs = combineAttrs(this.state.facet(editorAttributes), {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    updateAttrs(this.dom, this.editorAttrs, editorAttrs);
    this.editorAttrs = editorAttrs;
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      contenteditable: !this.state.facet(editable) ? "false" : contentEditablePlainTextSupported() ? "plaintext-only" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly) contentAttrs["aria-readonly"] = "true";
    combineAttrs(this.state.facet(contentAttributes), contentAttrs);
    updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
    this.contentAttrs = contentAttrs;
  }

  showAnnouncements(trs) {
    let first = true;

    for (let tr of trs) for (let effect of tr.effects) if (effect.is(EditorView.announce)) {
      if (first) this.announceDOM.textContent = "";
      first = false;
      let div = this.announceDOM.appendChild(document.createElement("div"));
      div.textContent = effect.value;
    }
  }

  mountStyles() {
    this.styleModules = this.state.facet(styleModule);

    _styleMod.StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());
  }

  readMeasured() {
    if (this.updateState == 2
    /* Updating */
    ) throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0
    /* Idle */
    && this.measureScheduled > -1) this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */


  requestMeasure(request) {
    if (this.measureScheduled < 0) this.measureScheduled = requestAnimationFrame(() => this.measure());

    if (request) {
      if (request.key != null) for (let i = 0; i < this.measureRequests.length; i++) {
        if (this.measureRequests[i].key === request.key) {
          this.measureRequests[i] = request;
          return;
        }
      }
      this.measureRequests.push(request);
    }
  }
  /**
  Collect all values provided by the active plugins for a given
  field.
  */


  pluginField(field) {
    let result = [];

    for (let plugin of this.plugins) plugin.update(this).takeField(field, result);

    return result;
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */


  plugin(plugin) {
    for (let inst of this.plugins) if (inst.spec == plugin) return inst.update(this).value;

    return null;
  }
  /**
  Find the line or block widget at the given vertical position.
  
  By default, this position is interpreted as a screen position,
  meaning `docTop` is set to the DOM top position of the editor
  content (forcing a layout). You can pass a different `docTop`
  value—for example 0 to interpret `height` as a document-relative
  position, or a precomputed document top
  (`view.contentDOM.getBoundingClientRect().top`) to limit layout
  queries.
  */


  blockAtHeight(height, docTop) {
    this.readMeasured();
    return this.viewState.blockAtHeight(height, ensureTop(docTop, this.contentDOM));
  }
  /**
  Find information for the visual line (see
  [`visualLineAt`](https://codemirror.net/6/docs/ref/#view.EditorView.visualLineAt)) at the given
  vertical position. The resulting block info might hold another
  array of block info structs in its `type` field if this line
  consists of more than one block.
  
  Defaults to treating `height` as a screen position. See
  [`blockAtHeight`](https://codemirror.net/6/docs/ref/#view.EditorView.blockAtHeight) for the
  interpretation of the `docTop` parameter.
  */


  visualLineAtHeight(height, docTop) {
    this.readMeasured();
    return this.viewState.lineAtHeight(height, ensureTop(docTop, this.contentDOM));
  }
  /**
  Iterate over the height information of the visual lines in the
  viewport. The heights of lines are reported relative to the
  given document top, which defaults to the screen position of the
  document (forcing a layout).
  */


  viewportLines(f, docTop) {
    let {
      from,
      to
    } = this.viewport;
    this.viewState.forEachLine(from, to, f, ensureTop(docTop, this.contentDOM));
  }
  /**
  Find the extent and height of the visual line (a range delimited
  on both sides by either non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^range)
  line breaks, or the start/end of the document) at the given position.
  
  Vertical positions are computed relative to the `docTop`
  argument, which defaults to 0 for this method. You can pass
  `view.contentDOM.getBoundingClientRect().top` here to get screen
  coordinates.
  */


  visualLineAt(pos, docTop = 0) {
    return this.viewState.lineAt(pos, docTop);
  }
  /**
  The editor's total content height.
  */


  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#text.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. Motion in
  bidirectional text is in visual order, in the editor's [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). When the start
  position was the last one on the line, the returned position
  will be across the line break. If there is no further line, the
  original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */


  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */


  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */


  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */


  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  /**
  Scroll the given document position into view.
  */


  scrollPosIntoView(pos) {
    this.viewState.scrollTo = _state.EditorSelection.cursor(pos);
    this.requestMeasure();
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  */


  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */


  posAtDOM(node, offset = 0) {
    return this.docView.posFromDOM(node, offset);
  }

  posAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */


  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right) return rect;
    let line = this.state.doc.lineAt(pos),
        order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */


  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */


  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor.
  */


  get textDirection() {
    return this.viewState.heightOracle.direction;
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */


  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */


  bidiSpans(line) {
    if (line.length > MaxBidiLine) return trivialOrder(line.length);
    let dir = this.textDirection;

    for (let entry of this.bidiCache) if (entry.from == line.from && entry.dir == dir) return entry.order;

    let order = computeOrder(line.text, this.textDirection);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
    return order;
  }
  /**
  Check whether the editor has focus.
  */


  get hasFocus() {
    var _a; // Safari return false for hasFocus when the context menu is open
    // or closing, which leads us to ignore selection changes from the
    // context menu because it looks like the editor isn't focused.
    // This kludges around that.


    return (document.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */


  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */


  destroy() {
    for (let plugin of this.plugins) plugin.destroy(this);

    this.plugins = [];
    this.inputState.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1) cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  /**
  Facet that can be used to add DOM event handlers. The value
  should be an object mapping event names to handler functions. The
  first such function to return true will be assumed to have handled
  that event, and no other handlers or built-in behavior will be
  activated for it.
  These are registered on the [content
  element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except for `scroll`
  handlers, which will be called any time the editor's [scroll
  element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of its parent nodes
  is scrolled.
  */


  static domEventHandlers(handlers) {
    return ViewPlugin.define(() => ({}), {
      eventHandlers: handlers
    });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */


  static theme(spec, options) {
    let prefix = _styleMod.StyleModule.newName();

    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark) result.push(darkTheme.of(true));
    return result;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */


  static baseTheme(spec) {
    return _state.Prec.fallback(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }

}
/**
Effect that can be [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a
transaction to make it scroll the given range into view.
*/


exports.EditorView = EditorView;
EditorView.scrollTo = scrollTo;
/**
Facet to add a [style
module](https://github.com/marijnh/style-mod#documentation) to
an editor view. The view will ensure that the module is
mounted in its [document
root](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).
*/

EditorView.styleModule = styleModule;
/**
An input handler can override the way changes to the editable
DOM content are handled. Handlers are passed the document
positions between which the change was found, and the new
content. When one returns true, no further input handlers are
called and the default behavior is prevented.
*/

EditorView.inputHandler = inputHandler;
/**
Allows you to provide a function that should be called when the
library catches an exception from an extension (mostly from view
plugins, but may be used by other extensions to route exceptions
from user-code-provided callbacks). This is mostly useful for
debugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).
*/

EditorView.exceptionSink = exceptionSink;
/**
A facet that can be used to register a function to be called
every time the view updates.
*/

EditorView.updateListener = updateListener;
/**
Facet that controls whether the editor content DOM is editable.
When its highest-precedence value is `false`, the element will
not longer have its `contenteditable` attribute set. (Note that
this doesn't affect API calls that change the editor content,
even when those are bound to keys or buttons. See the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)
*/

EditorView.editable = editable;
/**
Allows you to influence the way mouse selection happens. The
functions in this facet will be called for a `mousedown` event
on the editor, and can return an object that overrides the way a
selection is computed from that mouse click or drag.
*/

EditorView.mouseSelectionStyle = mouseSelectionStyle;
/**
Facet used to configure whether a given selection drag event
should move or copy the selection. The given predicate will be
called with the `mousedown` event, and can return `true` when
the drag should move the content.
*/

EditorView.dragMovesSelection = dragMovesSelection$1;
/**
Facet used to configure whether a given selecting click adds
a new range to the existing selection or replaces it entirely.
*/

EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
/**
A facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)
are shown in the view. See also [view
plugins](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), which have a separate
mechanism for providing decorations.
*/

EditorView.decorations = decorations;
/**
Facet that provides additional DOM attributes for the editor's
editable DOM element.
*/

EditorView.contentAttributes = contentAttributes;
/**
Facet that provides DOM attributes for the editor's outer
element.
*/

EditorView.editorAttributes = editorAttributes;
/**
An extension that enables line wrapping in the editor (by
setting CSS `white-space` to `pre-wrap` in the content).
*/

EditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({
  "class": "cm-lineWrapping"
});
/**
State effect used to include screen reader announcements in a
transaction. These will be added to the DOM in a visually hidden
element with `aria-live="polite"` set, and should be used to
describe effects that are visually obvious but may not be
noticed by screen reader users (such as moving to the next
search match).
*/

EditorView.announce = /*@__PURE__*/_state.StateEffect.define(); // Maximum line length for which we compute accurate bidi info

const MaxBidiLine = 4096;

function ensureTop(given, dom) {
  return given == null ? dom.getBoundingClientRect().top : given;
}

let resizeDebounce = -1;

function ensureGlobalHandler() {
  window.addEventListener("resize", () => {
    if (resizeDebounce == -1) resizeDebounce = setTimeout(handleResize, 50);
  });
}

function handleResize() {
  resizeDebounce = -1;
  let found = document.querySelectorAll(".cm-content");

  for (let i = 0; i < found.length; i++) {
    let docView = ContentView.get(found[i]);
    if (docView) docView.editorView.requestMeasure();
  }
}

const BadMeasure = {};

class CachedOrder {
  constructor(from, to, dir, order) {
    this.from = from;
    this.to = to;
    this.dir = dir;
    this.order = order;
  }

  static update(cache, changes) {
    if (changes.empty) return cache;
    let result = [],
        lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;

    for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
      let entry = cache[i];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
    }

    return result;
  }

}

const currentPlatform = typeof navigator == "undefined" ? "key" : /*@__PURE__*/ /Mac/.test(navigator.platform) ? "mac" : /*@__PURE__*/ /Win/.test(navigator.platform) ? "win" : /*@__PURE__*/ /Linux|X11/.test(navigator.platform) ? "linux" : "key";

function normalizeKeyName(name, platform) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space") result = " ";
  let alt, ctrl, shift, meta;

  for (let i = 0; i < parts.length - 1; ++i) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {
      if (platform == "mac") meta = true;else ctrl = true;
    } else throw new Error("Unrecognized modifier name: " + mod);
  }

  if (alt) result = "Alt-" + result;
  if (ctrl) result = "Ctrl-" + result;
  if (meta) result = "Meta-" + result;
  if (shift) result = "Shift-" + result;
  return result;
}

function modifiers(name, event, shift) {
  if (event.altKey) name = "Alt-" + name;
  if (event.ctrlKey) name = "Ctrl-" + name;
  if (event.metaKey) name = "Meta-" + name;
  if (shift !== false && event.shiftKey) name = "Shift-" + name;
  return name;
}

const handleKeyEvents = /*@__PURE__*/EditorView.domEventHandlers({
  keydown(event, view) {
    return runHandlers(getKeymap(view.state), event, view, "editor");
  }

});
/**
Facet used for registering keymaps.

You can add multiple keymaps to an editor. Their priorities
determine their precedence (the ones specified early or with high
priority get checked first). When a handler has returned `true`
for a given key, no further handlers are called.
*/

const keymap = /*@__PURE__*/_state.Facet.define({
  enables: handleKeyEvents
});

exports.keymap = keymap;
const Keymaps = /*@__PURE__*/new WeakMap(); // This is hidden behind an indirection, rather than directly computed
// by the facet, to keep internal types out of the facet's type.

function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map = Keymaps.get(bindings);
  if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
  return map;
}
/**
Run the key handlers registered for a given scope. The event
object should be `"keydown"` event. Returns true if any of the
handlers handled it.
*/


function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope);
}

let storedPrefix = null;
const PrefixTimeout = 4000;

function buildKeymap(bindings, platform = currentPlatform) {
  let bound = Object.create(null);
  let isPrefix = Object.create(null);

  let checkPrefix = (name, is) => {
    let current = isPrefix[name];
    if (current == null) isPrefix[name] = is;else if (current != is) throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
  };

  let add = (scope, key, command, preventDefault) => {
    let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
    let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));

    for (let i = 1; i < parts.length; i++) {
      let prefix = parts.slice(0, i).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix]) scopeObj[prefix] = {
        preventDefault: true,
        commands: [view => {
          let ourObj = storedPrefix = {
            view,
            prefix,
            scope
          };
          setTimeout(() => {
            if (storedPrefix == ourObj) storedPrefix = null;
          }, PrefixTimeout);
          return true;
        }]
      };
    }

    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = {
      preventDefault: false,
      commands: []
    });
    binding.commands.push(command);
    if (preventDefault) binding.preventDefault = true;
  };

  for (let b of bindings) {
    let name = b[platform] || b.key;
    if (!name) continue;

    for (let scope of b.scope ? b.scope.split(" ") : ["editor"]) {
      add(scope, name, b.run, b.preventDefault);
      if (b.shift) add(scope, "Shift-" + name, b.shift, b.preventDefault);
    }
  }

  return bound;
}

function runHandlers(map, event, view, scope) {
  let name = (0, _w3cKeyname.keyName)(event),
      isChar = name.length == 1 && name != " ";
  let prefix = "",
      fallthrough = false;

  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0) storedPrefix = null;
  }

  let runFor = binding => {
    if (binding) {
      for (let cmd of binding.commands) if (cmd(view)) return true;

      if (binding.preventDefault) fallthrough = true;
    }

    return false;
  };

  let scopeObj = map[scope],
      baseName;

  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) return true;

    if (isChar && (event.shiftKey || event.altKey || event.metaKey) && (baseName = _w3cKeyname.base[event.keyCode]) && baseName != name) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) return true;
    } else if (isChar && event.shiftKey) {
      if (runFor(scopeObj[prefix + modifiers(name, event, true)])) return true;
    }
  }

  return fallthrough;
}

const CanHidePrimary = !browser.ios; // FIXME test IE

const selectionConfig = /*@__PURE__*/_state.Facet.define({
  combine(configs) {
    return (0, _state.combineConfig)(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a, b) => Math.min(a, b),
      drawRangeCursor: (a, b) => a || b
    });
  }

});
/**
Returns an extension that hides the browser's native selection and
cursor, replacing the selection with a background behind the text
(with the `cm-selectionBackground` class), and the
cursors with elements overlaid over the code (using
`cm-cursor-primary` and `cm-cursor-secondary`).

This allows the editor to display secondary selection ranges, and
tends to produce a type of selection more in line with that users
expect in a text editor (the native selection styling will often
leave gaps between lines and won't fill the horizontal space after
a line when the selection continues past it).

It does have a performance cost, in that it requires an extra DOM
layout cycle for many updates (the selection is drawn based on DOM
layout information that's only available after laying out the
content).
*/


function drawSelection(config = {}) {
  return [selectionConfig.of(config), drawSelectionPlugin, hideNativeSelection];
}

class Piece {
  constructor(left, top, width, height, className) {
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
    this.className = className;
  }

  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }

  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    if (this.width >= 0) elt.style.width = this.width + "px";
    elt.style.height = this.height + "px";
  }

  eq(p) {
    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
  }

}

const drawSelectionPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.rangePieces = [];
    this.cursors = [];
    this.measureReq = {
      read: this.readPos.bind(this),
      write: this.drawSel.bind(this)
    };
    this.selectionLayer = view.scrollDOM.appendChild(document.createElement("div"));
    this.selectionLayer.className = "cm-selectionLayer";
    this.selectionLayer.setAttribute("aria-hidden", "true");
    this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
    this.cursorLayer.className = "cm-cursorLayer";
    this.cursorLayer.setAttribute("aria-hidden", "true");
    view.requestMeasure(this.measureReq);
    this.setBlinkRate();
  }

  setBlinkRate() {
    this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + "ms";
  }

  update(update) {
    let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
    if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged) this.view.requestMeasure(this.measureReq);
    if (update.transactions.some(tr => tr.scrollIntoView)) this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    if (confChanged) this.setBlinkRate();
  }

  readPos() {
    let {
      state
    } = this.view,
        conf = state.facet(selectionConfig);
    let rangePieces = state.selection.ranges.map(r => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));
    let cursors = [];

    for (let r of state.selection.ranges) {
      let prim = r == state.selection.main;

      if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
        let piece = measureCursor(this.view, r, prim);
        if (piece) cursors.push(piece);
      }
    }

    return {
      rangePieces,
      cursors
    };
  }

  drawSel({
    rangePieces,
    cursors
  }) {
    if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {
      this.selectionLayer.textContent = "";

      for (let p of rangePieces) this.selectionLayer.appendChild(p.draw());

      this.rangePieces = rangePieces;
    }

    if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {
      let oldCursors = this.cursorLayer.children;

      if (oldCursors.length !== cursors.length) {
        this.cursorLayer.textContent = "";

        for (const c of cursors) this.cursorLayer.appendChild(c.draw());
      } else {
        cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
      }

      this.cursors = cursors;
    }
  }

  destroy() {
    this.selectionLayer.remove();
    this.cursorLayer.remove();
  }

});
const themeSpec = {
  ".cm-line": {
    "& ::selection": {
      backgroundColor: "transparent !important"
    },
    "&::selection": {
      backgroundColor: "transparent !important"
    }
  }
};
if (CanHidePrimary) themeSpec[".cm-line"].caretColor = "transparent !important";

const hideNativeSelection = /*@__PURE__*/_state.Prec.override( /*@__PURE__*/EditorView.theme(themeSpec));

function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
  return {
    left: left - view.scrollDOM.scrollLeft,
    top: rect.top - view.scrollDOM.scrollTop
  };
}

function wrappedLine(view, pos, inside) {
  let range = _state.EditorSelection.cursor(pos);

  return {
    from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),
    to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),
    type: BlockType.Text
  };
}

function blockAt(view, pos) {
  let line = view.visualLineAt(pos);
  if (Array.isArray(line.type)) for (let l of line.type) {
    if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text)) return l;
  }
  return line;
}

function measureRange(view, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];
  let from = Math.max(range.from, view.viewport.from),
      to = Math.min(range.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content = view.contentDOM,
      contentRect = content.getBoundingClientRect(),
      base = getBase(view);
  let lineStyle = window.getComputedStyle(content.firstChild);
  let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft);
  let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
  let startBlock = blockAt(view, from),
      endBlock = blockAt(view, to);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;

  if (view.lineWrapping) {
    if (visualStart) visualStart = wrappedLine(view, from, visualStart);
    if (visualEnd) visualEnd = wrappedLine(view, to, visualEnd);
  }

  if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
    return pieces(drawForLine(range.from, range.to, visualStart));
  } else {
    let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
    let between = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1) between.push(piece(leftSide, top.bottom, rightSide, bottom.top));else if (top.bottom < bottom.top && blockAt(view, (top.bottom + bottom.top) / 2).type == BlockType.Text) top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
    return pieces(top).concat(between).concat(pieces(bottom));
  }

  function piece(left, top, right, bottom) {
    return new Piece(left - base.left, top - base.top, right - left, bottom - top, "cm-selectionBackground");
  }

  function pieces({
    top,
    bottom,
    horizontal
  }) {
    let pieces = [];

    for (let i = 0; i < horizontal.length; i += 2) pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));

    return pieces;
  } // Gets passed from/to in line-local positions


  function drawForLine(from, to, line) {
    let top = 1e9,
        bottom = -1e9,
        horizontal = [];

    function addSpan(from, fromOpen, to, toOpen, dir) {
      // Passing 2/-2 is a kludge to force the view to return
      // coordinates on the proper side of block widgets, since
      // normalizing the side there, though appropriate for most
      // coordsAtPos queries, would break selection drawing.
      let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);
      top = Math.min(fromCoords.top, toCoords.top, top);
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
      if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }

    let start = from !== null && from !== void 0 ? from : line.from,
        end = to !== null && to !== void 0 ? to : line.to; // Split the range by visible range and document line

    for (let r of view.visibleRanges) if (r.to > start && r.from < end) {
      for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {
        let docLine = view.state.doc.lineAt(pos);

        for (let span of view.bidiSpans(docLine)) {
          let spanFrom = span.from + docLine.from,
              spanTo = span.to + docLine.from;
          if (spanFrom >= endPos) break;
          if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);
        }

        pos = docLine.to + 1;
        if (pos >= endPos) break;
      }
    }

    if (horizontal.length == 0) addSpan(start, from == null, end, to == null, view.textDirection);
    return {
      top,
      bottom,
      horizontal
    };
  }

  function drawForWidget(block, top) {
    let y = contentRect.top + (top ? block.top : block.bottom);
    return {
      top: y,
      bottom: y,
      horizontal: []
    };
  }
}

function measureCursor(view, cursor, primary) {
  let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);
  if (!pos) return null;
  let base = getBase(view);
  return new Piece(pos.left - base.left, pos.top - base.top, -1, pos.bottom - pos.top, primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
}

function iterMatches(doc, re, from, to, f) {
  re.lastIndex = 0;

  for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
    if (!cursor.lineBreak) while (m = re.exec(cursor.value)) f(pos + m.index, pos + m.index + m[0].length, m);
  }
}
/**
Helper class used to make it easier to maintain decorations on
visible code that matches a given regular expression. To be used
in a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object
represent a matching configuration.
*/


class MatchDecorator {
  /**
  Create a decorator.
  */
  constructor(config) {
    let {
      regexp,
      decoration,
      boundary
    } = config;
    if (!regexp.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    this.getDeco = typeof decoration == "function" ? decoration : () => decoration;
    this.boundary = boundary;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */


  createDeco(view) {
    let build = new _rangeset.RangeSetBuilder();

    for (let {
      from,
      to
    } of view.visibleRanges) iterMatches(view.state.doc, this.regexp, from, to, (a, b, m) => build.add(a, b, this.getDeco(m, view, a)));

    return build.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */


  updateDeco(update, deco) {
    let changeFrom = 1e9,
        changeTo = -1;
    if (update.docChanged) update.changes.iterChanges((_f, _t, from, to) => {
      if (to > update.view.viewport.from && from < update.view.viewport.to) {
        changeFrom = Math.min(from, changeFrom);
        changeTo = Math.max(to, changeTo);
      }
    });
    if (update.viewportChanged || changeTo - changeFrom > 1000) return this.createDeco(update.view);
    if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
    return deco;
  }

  updateRange(view, deco, updateFrom, updateTo) {
    for (let r of view.visibleRanges) {
      let from = Math.max(r.from, updateFrom),
          to = Math.min(r.to, updateTo);

      if (to > from) {
        let fromLine = view.state.doc.lineAt(from),
            toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
        let start = Math.max(r.from, fromLine.from),
            end = Math.min(r.to, toLine.to);

        if (this.boundary) {
          for (; from > fromLine.from; from--) if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
            start = from;
            break;
          }

          for (; to < toLine.to; to++) if (this.boundary.test(toLine.text[to - toLine.from])) {
            end = to;
            break;
          }
        }

        let ranges = [],
            m;

        if (fromLine == toLine) {
          this.regexp.lastIndex = start - fromLine.from;

          while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) {
            let pos = m.index + fromLine.from;
            ranges.push(this.getDeco(m, view, pos).range(pos, pos + m[0].length));
          }
        } else {
          iterMatches(view.state.doc, this.regexp, start, end, (from, to, m) => ranges.push(this.getDeco(m, view, from).range(from, to)));
        }

        deco = deco.update({
          filterFrom: start,
          filterTo: end,
          filter: (from, to) => from < start || to > end,
          add: ranges
        });
      }
    }

    return deco;
  }

}

exports.MatchDecorator = MatchDecorator;
const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
const Specials = /*@__PURE__*/new RegExp("[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]", UnicodeRegexpSupport);
const Names = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let _supportsTabSize = null;

function supportsTabSize() {
  var _a;

  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles = document.body.style;
    _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
  }

  return _supportsTabSize || false;
}

const specialCharConfig = /*@__PURE__*/_state.Facet.define({
  combine(configs) {
    let config = (0, _state.combineConfig)(configs, {
      render: null,
      specialChars: Specials,
      addSpecialChars: null
    });
    if (config.replaceTabs = !supportsTabSize()) config.specialChars = new RegExp("\t|" + config.specialChars.source, UnicodeRegexpSupport);
    if (config.addSpecialChars) config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
    return config;
  }

});
/**
Returns an extension that installs highlighting of special
characters.
*/


function highlightSpecialChars(
/**
Configuration options.
*/
config = {}) {
  return [specialCharConfig.of(config), specialCharPlugin()];
}

let _plugin = null;

function specialCharPlugin() {
  return _plugin || (_plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = Decoration.none;
      this.decorationCache = Object.create(null);
      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
      this.decorations = this.decorator.createDeco(view);
    }

    makeDecorator(conf) {
      return new MatchDecorator({
        regexp: conf.specialChars,
        decoration: (m, view, pos) => {
          let {
            doc
          } = view.state;
          let code = (0, _text.codePointAt)(m[0], 0);

          if (code == 9) {
            let line = doc.lineAt(pos);
            let size = view.state.tabSize,
                col = (0, _text.countColumn)(line.text, size, pos - line.from);
            return Decoration.replace({
              widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth)
            });
          }

          return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({
            widget: new SpecialCharWidget(conf, code)
          }));
        },
        boundary: conf.replaceTabs ? undefined : /[^]/
      });
    }

    update(update) {
      let conf = update.state.facet(specialCharConfig);

      if (update.startState.facet(specialCharConfig) != conf) {
        this.decorator = this.makeDecorator(conf);
        this.decorations = this.decorator.createDeco(update.view);
      } else {
        this.decorations = this.decorator.updateDeco(update, this.decorations);
      }
    }

  }, {
    decorations: v => v.decorations
  }));
}

const DefaultPlaceholder = "\u2022"; // Assigns placeholder characters from the Control Pictures block to
// ASCII control characters

function placeholder$1(code) {
  if (code >= 32) return DefaultPlaceholder;
  if (code == 10) return "\u2424";
  return String.fromCharCode(9216 + code);
}

class SpecialCharWidget extends WidgetType {
  constructor(options, code) {
    super();
    this.options = options;
    this.code = code;
  }

  eq(other) {
    return other.code == this.code;
  }

  toDOM(view) {
    let ph = placeholder$1(this.code);
    let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
    let custom = this.options.render && this.options.render(this.code, desc, ph);
    if (custom) return custom;
    let span = document.createElement("span");
    span.textContent = ph;
    span.title = desc;
    span.setAttribute("aria-label", desc);
    span.className = "cm-specialChar";
    return span;
  }

  ignoreEvent() {
    return false;
  }

}

class TabWidget extends WidgetType {
  constructor(width) {
    super();
    this.width = width;
  }

  eq(other) {
    return other.width == this.width;
  }

  toDOM() {
    let span = document.createElement("span");
    span.textContent = "\t";
    span.className = "cm-tab";
    span.style.width = this.width + "px";
    return span;
  }

  ignoreEvent() {
    return false;
  }

}

const plugin = /*@__PURE__*/ViewPlugin.fromClass(class {
  constructor(view) {
    this.height = -1;
    this.measure = {
      read: view => Math.max(0, view.scrollDOM.clientHeight - view.defaultLineHeight),
      write: (value, view) => {
        if (Math.abs(value - this.height) > 1) {
          this.height = value;
          view.contentDOM.style.paddingBottom = value + "px";
        }
      }
    };
    view.requestMeasure(this.measure);
  }

  update(update) {
    if (update.geometryChanged) update.view.requestMeasure(this.measure);
  }

});
/**
Returns a plugin that makes sure the content has a bottom margin
equivalent to the height of the editor, minus one line height, so
that every line in the document can be scrolled to the top of the
editor.

This is only meaningful when the editor is scrollable, and should
not be enabled in editors that take the size of their content.
*/

function scrollPastEnd() {
  return plugin;
}
/**
Mark lines that have a cursor on them with the `"cm-activeLine"`
DOM class.
*/


function highlightActiveLine() {
  return activeLineHighlighter;
}

const lineDeco = /*@__PURE__*/Decoration.line({
  attributes: {
    class: "cm-activeLine"
  }
});
const activeLineHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }

  update(update) {
    if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);
  }

  getDeco(view) {
    let lastLineStart = -1,
        deco = [];

    for (let r of view.state.selection.ranges) {
      if (!r.empty) return Decoration.none;
      let line = view.visualLineAt(r.head);

      if (line.from > lastLineStart) {
        deco.push(lineDeco.range(line.from));
        lastLineStart = line.from;
      }
    }

    return Decoration.set(deco);
  }

}, {
  decorations: v => v.decorations
});

class Placeholder extends WidgetType {
  constructor(content) {
    super();
    this.content = content;
  }

  toDOM() {
    let wrap = document.createElement("span");
    wrap.className = "cm-placeholder";
    wrap.style.pointerEvents = "none";
    wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content);
    if (typeof this.content == "string") wrap.setAttribute("aria-label", "placeholder " + this.content);else wrap.setAttribute("aria-hidden", "true");
    return wrap;
  }

  ignoreEvent() {
    return false;
  }

}
/**
Extension that enables a placeholder—a piece of example content
to show when the editor is empty.
*/


function placeholder(content) {
  return ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.placeholder = Decoration.set([Decoration.widget({
        widget: new Placeholder(content),
        side: 1
      }).range(0)]);
    }

    get decorations() {
      return this.view.state.doc.length ? Decoration.none : this.placeholder;
    }

  }, {
    decorations: v => v.decorations
  });
}
/**
@internal
*/


const __test = {
  HeightMap,
  HeightOracle,
  MeasuredHeights,
  QueryType,
  ChangedRange,
  computeOrder,
  moveVisually
};
exports.__test = __test;
},{"@codemirror/state":"node_modules/@codemirror/state/dist/index.js","style-mod":"node_modules/style-mod/src/style-mod.js","@codemirror/rangeset":"node_modules/@codemirror/rangeset/dist/index.js","@codemirror/text":"node_modules/@codemirror/text/dist/index.js","w3c-keyname":"node_modules/w3c-keyname/index.es.js"}],"node_modules/@codemirror/history/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.history = history;
exports.undoSelection = exports.undoDepth = exports.undo = exports.redoSelection = exports.redoDepth = exports.redo = exports.isolateHistory = exports.invertedEffects = exports.historyKeymap = exports.historyField = void 0;

var _state = require("@codemirror/state");

var _view = require("@codemirror/view");

const fromHistory = /*@__PURE__*/_state.Annotation.define();
/**
Transaction annotation that will prevent that transaction from
being combined with other transactions in the undo history. Given
`"before"`, it'll prevent merging with previous transactions. With
`"after"`, subsequent transactions won't be combined with this
one. With `"full"`, the transaction is isolated on both sides.
*/


const isolateHistory = /*@__PURE__*/_state.Annotation.define();
/**
This facet provides a way to register functions that, given a
transaction, provide a set of effects that the history should
store when inverting the transaction. This can be used to
integrate some kinds of effects in the history, so that they can
be undone (and redone again).
*/


exports.isolateHistory = isolateHistory;

const invertedEffects = /*@__PURE__*/_state.Facet.define();

exports.invertedEffects = invertedEffects;

const historyConfig = /*@__PURE__*/_state.Facet.define({
  combine(configs) {
    return (0, _state.combineConfig)(configs, {
      minDepth: 100,
      newGroupDelay: 500
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min
    });
  }

});

const historyField_ = /*@__PURE__*/_state.StateField.define({
  create() {
    return HistoryState.empty;
  },

  update(state, tr) {
    let config = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);

    if (fromHist) {
      let item = HistEvent.fromTransaction(tr),
          from = fromHist.side;
      let other = from == 0
      /* Done */
      ? state.undone : state.done;
      if (item) other = updateBranch(other, other.length, config.minDepth, item);else other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0
      /* Done */
      ? fromHist.rest : other, from == 0
      /* Done */
      ? other : fromHist.rest);
    }

    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before") state = state.isolate();
    if (tr.annotation(_state.Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr);
    let time = tr.annotation(_state.Transaction.time),
        userEvent = tr.annotation(_state.Transaction.userEvent);
    if (event) state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
    if (isolate == "full" || isolate == "after") state = state.isolate();
    return state;
  },

  toJSON(value) {
    return {
      done: value.done.map(e => e.toJSON()),
      undone: value.undone.map(e => e.toJSON())
    };
  },

  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
  }

});
/**
Create a history extension with the given configuration.
*/


function history(config = {}) {
  return [historyField_, historyConfig.of(config), _view.EditorView.domEventHandlers({
    beforeinput(e, view) {
      if (e.inputType == "historyUndo") return undo(view);
      if (e.inputType == "historyRedo") return redo(view);
      return false;
    }

  })];
}
/**
The state field used to store the history data. Should probably
only be used when you want to
[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or
[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way
that preserves history.
*/


const historyField = historyField_;
exports.historyField = historyField;

function cmd(side, selection) {
  return function ({
    state,
    dispatch
  }) {
    let historyState = state.field(historyField_, false);
    if (!historyState) return false;
    let tr = historyState.pop(side, state, selection);
    if (!tr) return false;
    dispatch(tr);
    return true;
  };
}
/**
Undo a single group of history events. Returns false if no group
was available.
*/


const undo = /*@__PURE__*/cmd(0
/* Done */
, false);
/**
Redo a group of history events. Returns false if no group was
available.
*/

exports.undo = undo;
const redo = /*@__PURE__*/cmd(1
/* Undone */
, false);
/**
Undo a selection change.
*/

exports.redo = redo;
const undoSelection = /*@__PURE__*/cmd(0
/* Done */
, true);
/**
Redo a selection change.
*/

exports.undoSelection = undoSelection;
const redoSelection = /*@__PURE__*/cmd(1
/* Undone */
, true);
exports.redoSelection = redoSelection;

function depth(side) {
  return function (state) {
    let histState = state.field(historyField_, false);
    if (!histState) return 0;
    let branch = side == 0
    /* Done */
    ? histState.done : histState.undone;
    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
  };
}
/**
The amount of undoable change events available in a given state.
*/


const undoDepth = /*@__PURE__*/depth(0
/* Done */
);
/**
The amount of redoable change events available in a given state.
*/

exports.undoDepth = undoDepth;
const redoDepth = /*@__PURE__*/depth(1
/* Undone */
); // History events store groups of changes or effects that need to be
// undone/redone together.

exports.redoDepth = redoDepth;

class HistEvent {
  constructor( // The changes in this event. Normal events hold at least one
  // change or effect. But it may be necessary to store selection
  // events before the first change, in which case a special type of
  // instance is created which doesn't hold any changes, with
  // changes == startSelection == undefined
  changes, // The effects associated with this event
  effects, mapped, // The selection before this event
  startSelection, // Stores selection changes after this event, to be used for
  // selection undo/redo.
  selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }

  setSelAfter(after) {
    return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }

  toJSON() {
    var _a, _b, _c;

    return {
      changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map(s => s.toJSON())
    };
  }

  static fromJSON(json) {
    return new HistEvent(json.changes && _state.ChangeSet.fromJSON(json.changes), [], json.mapped && _state.ChangeDesc.fromJSON(json.mapped), json.startSelection && _state.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_state.EditorSelection.fromJSON));
  } // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.


  static fromTransaction(tr) {
    let effects = none;

    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr);
      if (result.length) effects = effects.concat(result);
    }

    if (!effects.length && tr.changes.empty) return null;
    return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, tr.startState.selection, none);
  }

  static selection(selections) {
    return new HistEvent(undefined, none, undefined, undefined, selections);
  }

}

function updateBranch(branch, to, maxLen, newEvent) {
  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to);
  newBranch.push(newEvent);
  return newBranch;
}

function isAdjacent(a, b) {
  let ranges = [],
      isAdjacent = false;
  a.iterChangedRanges((f, t) => ranges.push(f, t));
  b.iterChangedRanges((_f, _t, f, t) => {
    for (let i = 0; i < ranges.length;) {
      let from = ranges[i++],
          to = ranges[i++];
      if (t >= from && f <= to) isAdjacent = true;
    }
  });
  return isAdjacent;
}

function eqSelectionShape(a, b) {
  return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}

function conc(a, b) {
  return !a.length ? b : !b.length ? a : a.concat(b);
}

const none = [];
const MaxSelectionsPerEvent = 200;

function addSelection(branch, selection) {
  if (!branch.length) {
    return [HistEvent.selection([selection])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection)) return branch;
    sels.push(selection);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
} // Assumes the top item has one or more selectionAfter values


function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
} // Add a mapping to the top event in the given branch. If this maps
// away all the changes and effects in that item, drop it and
// propagate the mapping to the next item.


function addMappingToBranch(branch, mapping) {
  if (!branch.length) return branch;
  let length = branch.length,
      selections = none;

  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);

    if (event.changes && !event.changes.empty || event.effects.length) {
      // Event survived mapping
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      // Drop this event, since there's no changes or effects left
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }

  return selections.length ? [HistEvent.selection(selections)] : none;
}

function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections); // Change-less events don't store mappings (they are always the last event in a branch)

  if (!event.changes) return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping),
      before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, _state.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}

class HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }

  isolate() {
    return this.prevTime ? new HistoryState(this.done, this.undone) : this;
  }

  addChanges(event, time, userEvent, newGroupDelay, maxLen) {
    let done = this.done,
        lastEvent = done[done.length - 1];

    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes) || // For compose (but not compose.start) events, always join with previous event
    userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
    } else {
      done = updateBranch(done, done.length, maxLen, event);
    }

    return new HistoryState(done, none, time, userEvent);
  }

  addSelection(selection, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;
    return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
  }

  addMapping(mapping) {
    return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }

  pop(side, state, selection) {
    let branch = side == 0
    /* Done */
    ? this.done : this.undone;
    if (branch.length == 0) return null;
    let event = branch[branch.length - 1];

    if (selection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({
          side,
          rest: popSelection(branch)
        }),
        userEvent: side == 0
        /* Done */
        ? "select.undo" : "select.redo"
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
      if (event.mapped) rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({
          side,
          rest
        }),
        filter: false,
        userEvent: side == 0
        /* Done */
        ? "undo" : "redo"
      });
    }
  }

}

HistoryState.empty = /*@__PURE__*/new HistoryState(none, none);
/**
Default key bindings for the undo history.

- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#history.undo).
- Mod-y (Mod-Shift-z on macOS): [`redo`](https://codemirror.net/6/docs/ref/#history.redo).
- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#history.undoSelection).
- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#history.redoSelection).
*/

const historyKeymap = [{
  key: "Mod-z",
  run: undo,
  preventDefault: true
}, {
  key: "Mod-y",
  mac: "Mod-Shift-z",
  run: redo,
  preventDefault: true
}, {
  key: "Mod-u",
  run: undoSelection,
  preventDefault: true
}, {
  key: "Alt-u",
  mac: "Mod-Shift-u",
  run: redoSelection,
  preventDefault: true
}];
exports.historyKeymap = historyKeymap;
},{"@codemirror/state":"node_modules/@codemirror/state/dist/index.js","@codemirror/view":"node_modules/@codemirror/view/dist/index.js"}],"node_modules/@lezer/common/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMixed = parseMixed;
exports.TreeFragment = exports.TreeCursor = exports.TreeBuffer = exports.Tree = exports.Parser = exports.NodeType = exports.NodeSet = exports.NodeProp = exports.MountedTree = exports.DefaultBufferLength = void 0;
// FIXME profile adding a per-Tree TreeNode cache, validating it by
// parent pointer
/// The default maximum length of a `TreeBuffer` node (1024).
const DefaultBufferLength = 1024;
exports.DefaultBufferLength = DefaultBufferLength;
let nextPropID = 0;

class Range {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }

} /// Each [node type](#common.NodeType) or [individual tree](#common.Tree)
/// can have metadata associated with it in props. Instances of this
/// class represent prop names.


class NodeProp {
  /// Create a new node prop type.
  constructor(config = {}) {
    this.id = nextPropID++;
    this.perNode = !!config.perNode;

    this.deserialize = config.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  } /// This is meant to be used with
  /// [`NodeSet.extend`](#common.NodeSet.extend) or
  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
  /// prop values for each node type in the set. Takes a [match
  /// object](#common.NodeType^match) or function that returns undefined
  /// if the node type doesn't get this prop, and the prop's value if
  /// it does.


  add(match) {
    if (this.perNode) throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function") match = NodeType.match(match);
    return type => {
      let result = match(type);
      return result === undefined ? null : [this, result];
    };
  }

} /// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.


exports.NodeProp = NodeProp;
NodeProp.closedBy = new NodeProp({
  deserialize: str => str.split(" ")
}); /// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.

NodeProp.openedBy = new NodeProp({
  deserialize: str => str.split(" ")
}); /// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).

NodeProp.group = new NodeProp({
  deserialize: str => str.split(" ")
}); /// The hash of the [context](#lr.ContextTracker.constructor)
/// that the node was parsed in, if any. Used to limit reuse of
/// contextual nodes.

NodeProp.contextHash = new NodeProp({
  perNode: true
}); /// The distance beyond the end of the node that the tokenizer
/// looked ahead for any of the tokens inside the node. (The LR
/// parser only stores this when it is larger than 25, for
/// efficiency reasons.)

NodeProp.lookAhead = new NodeProp({
  perNode: true
}); /// This per-node prop is used to replace a given node, or part of a
/// node, with another tree. This is useful to include trees from
/// different languages.

NodeProp.mounted = new NodeProp({
  perNode: true
}); /// A mounted tree, which can be [stored](#common.NodeProp^mounted) on
/// a tree node to indicate that parts of its content are
/// represented by another tree.

class MountedTree {
  constructor( /// The inner tree.
  tree, /// If this is null, this tree replaces the entire node (it will
  /// be included in the regular iteration instead of its host
  /// node). If not, only the given ranges are considered to be
  /// covered by this tree. This is used for trees that are mixed in
  /// a way that isn't strictly hierarchical. Such mounted trees are
  /// only entered by [`resolveInner`](#common.Tree.resolveInner)
  /// and [`enter`](#common.SyntaxNode.enter).
  overlay, /// The parser used to create this subtree.
  parser) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser;
  }

}

exports.MountedTree = MountedTree;
const noProps = Object.create(null); /// Each node in a syntax tree has a node type associated with it.

class NodeType {
  /// @internal
  constructor( /// The name of the node type. Not necessarily unique, but if the
  /// grammar was written properly, different node types with the
  /// same name within a node set should play the same semantic
  /// role.
  name, /// @internal
  props, /// The id of this node in its set. Corresponds to the term ids
  /// used in the parser.
  id, /// @internal
  flags = 0) {
    this.name = name;
    this.props = props;
    this.id = id;
    this.flags = flags;
  }

  static define(spec) {
    let props = spec.props && spec.props.length ? Object.create(null) : noProps;
    let flags = (spec.top ? 1
    /* Top */
    : 0) | (spec.skipped ? 2
    /* Skipped */
    : 0) | (spec.error ? 4
    /* Error */
    : 0) | (spec.name == null ? 8
    /* Anonymous */
    : 0);
    let type = new NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props) for (let src of spec.props) {
      if (!Array.isArray(src)) src = src(type);

      if (src) {
        if (src[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
        props[src[0].id] = src[1];
      }
    }
    return type;
  } /// Retrieves a node prop for this type. Will return `undefined` if
  /// the prop isn't present on this node.


  prop(prop) {
    return this.props[prop.id];
  } /// True when this is the top node of a grammar.


  get isTop() {
    return (this.flags & 1
    /* Top */
    ) > 0;
  } /// True when this node is produced by a skip rule.


  get isSkipped() {
    return (this.flags & 2
    /* Skipped */
    ) > 0;
  } /// Indicates whether this is an error node.


  get isError() {
    return (this.flags & 4
    /* Error */
    ) > 0;
  } /// When true, this node type doesn't correspond to a user-declared
  /// named node, for example because it is used to cache repetition.


  get isAnonymous() {
    return (this.flags & 8
    /* Anonymous */
    ) > 0;
  } /// Returns true when this node's name or one of its
  /// [groups](#common.NodeProp^group) matches the given string.


  is(name) {
    if (typeof name == 'string') {
      if (this.name == name) return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name) > -1 : false;
    }

    return this.id == name;
  } /// Create a function from node types to arbitrary values by
  /// specifying an object whose property names are node or
  /// [group](#common.NodeProp^group) names. Often useful with
  /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  /// names, separated by spaces, in a single property name to map
  /// multiple node names to a single value.


  static match(map) {
    let direct = Object.create(null);

    for (let prop in map) for (let name of prop.split(" ")) direct[name] = map[prop];

    return node => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found) return found;
      }
    };
  }

} /// An empty dummy node type to use when no actual type is available.


exports.NodeType = NodeType;
NodeType.none = new NodeType("", Object.create(null), 0, 8
/* Anonymous */
); /// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a numeric array. Each parser
/// [has](#lr.LRParser.nodeSet) a node set, and [tree
/// buffers](#common.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536) node
/// types in it, so that the ids fit into 16-bit typed array slots.

class NodeSet {
  /// Create a set with the given types. The `id` property of each
  /// type should correspond to its position within the array.
  constructor( /// The node types in this set, by id.
  types) {
    this.types = types;

    for (let i = 0; i < types.length; i++) if (types[i].id != i) throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  } /// Create a copy of this set with some node properties added. The
  /// arguments to this method should be created with
  /// [`NodeProp.add`](#common.NodeProp.add).


  extend(...props) {
    let newTypes = [];

    for (let type of this.types) {
      let newProps = null;

      for (let source of props) {
        let add = source(type);

        if (add) {
          if (!newProps) newProps = Object.assign({}, type.props);
          newProps[add[0].id] = add[1];
        }
      }

      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }

    return new NodeSet(newTypes);
  }

}

exports.NodeSet = NodeSet;
const CachedNode = new WeakMap(); /// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the [`TreeCursor`](#common.TreeCursor) or
/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
/// a view on some part of this data structure, and can be used to
/// move around to adjacent nodes.

class Tree {
  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  constructor( /// The type of the top node.
  type, /// This node's child nodes.
  children, /// The positions (offsets relative to the start of this tree) of
  /// the children.
  positions, /// The total length of this tree
  length, /// Per-node [node props](#common.NodeProp) to associate with this node.
  props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length; /// @internal

    this.props = null;

    if (props && props.length) {
      this.props = Object.create(null);

      for (let [prop, value] of props) this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  } /// @internal


  toString() {
    let mounted = this.prop(NodeProp.mounted);
    if (mounted && !mounted.overlay) return mounted.tree.toString();
    let children = "";

    for (let ch of this.children) {
      let str = ch.toString();

      if (str) {
        if (children) children += ",";
        children += str;
      }
    }

    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  } /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When
  /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)
  /// to the given position and side.


  cursor(pos, side = 0) {
    let scope = pos != null && CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);

    if (pos != null) {
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
    }

    return cursor;
  } /// Get a [tree cursor](#common.TreeCursor) that, unlike regular
  /// cursors, doesn't skip through
  /// [anonymous](#common.NodeType.isAnonymous) nodes.


  fullCursor() {
    return new TreeCursor(this.topNode, 1
    /* Full */
    );
  } /// Get a [syntax node](#common.SyntaxNode) object for the top of the
  /// tree.


  get topNode() {
    return new TreeNode(this, 0, 0, null);
  } /// Get the [syntax node](#common.SyntaxNode) at the given position.
  /// If `side` is -1, this will move into nodes that end at the
  /// position. If 1, it'll move into nodes that start at the
  /// position. With 0, it'll only enter nodes that cover the position
  /// from both sides.


  resolve(pos, side = 0) {
    return this.cursor(pos, side).node;
  } /// Like [`resolve`](#common.Tree.resolve), but will enter
  /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  /// pointing into the innermost overlaid tree at the given position
  /// (with parent links going through all parent structure, including
  /// the host trees).


  resolveInner(pos, side = 0) {
    let result = this.topNode;

    for (;;) {
      let inner = result.enter(pos, side);
      if (!inner) return result;
      result = inner;
    }
  } /// Iterate over the tree and its children, calling `enter` for any
  /// node that touches the `from`/`to` region (if given) before
  /// running over such a node's children, and `leave` (if given) when
  /// leaving the node. When `enter` returns `false`, that node will
  /// not have its children iterated over (or `leave` called).


  iterate(spec) {
    let {
      enter,
      leave,
      from = 0,
      to = this.length
    } = spec;

    for (let c = this.cursor(), get = () => c.node;;) {
      let mustLeave = false;

      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {
        if (c.firstChild()) continue;
        if (!c.type.isAnonymous) mustLeave = true;
      }

      for (;;) {
        if (mustLeave && leave) leave(c.type, c.from, c.to, get);
        mustLeave = c.type.isAnonymous;
        if (c.nextSibling()) break;
        if (!c.parent()) return;
        mustLeave = true;
      }
    }
  } /// Get the value of the given [node prop](#common.NodeProp) for this
  /// node. Works with both per-node and per-type props.


  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
  } /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
  /// format that can be passed to the [`Tree`](#common.Tree)
  /// constructor.


  get propValues() {
    let result = [];
    if (this.props) for (let id in this.props) result.push([+id, this.props[id]]);
    return result;
  } /// Balance the direct children of this tree, producing a copy of
  /// which may have children grouped into subtrees with type
  /// [`NodeType.none`](#common.NodeType^none).


  balance(config = {}) {
    return this.children.length <= 8
    /* BranchFactor */
    ? this : balanceRange(this.type, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
  } /// Build a tree from a postfix-ordered buffer of node information,
  /// or a cursor over such a buffer.


  static build(data) {
    return buildTree(data);
  }

} /// The empty tree


exports.Tree = Tree;
Tree.empty = new Tree(NodeType.none, [], [], 0);

class FlatBufferCursor {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }

  get id() {
    return this.buffer[this.index - 4];
  }

  get start() {
    return this.buffer[this.index - 3];
  }

  get end() {
    return this.buffer[this.index - 2];
  }

  get size() {
    return this.buffer[this.index - 1];
  }

  get pos() {
    return this.index;
  }

  next() {
    this.index -= 4;
  }

  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }

} /// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)


class TreeBuffer {
  /// Create a tree buffer.
  constructor( /// The buffer's content.
  buffer, /// The total length of the group of nodes in the buffer.
  length, /// The node set used in this buffer.
  set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  } /// @internal


  get type() {
    return NodeType.none;
  } /// @internal


  toString() {
    let result = [];

    for (let index = 0; index < this.buffer.length;) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }

    return result.join(",");
  } /// @internal


  childString(index) {
    let id = this.buffer[index],
        endIndex = this.buffer[index + 3];
    let type = this.set.types[id],
        result = type.name;
    if (/\W/.test(result) && !type.isError) result = JSON.stringify(result);
    index += 4;
    if (endIndex == index) return result;
    let children = [];

    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }

    return result + "(" + children.join(",") + ")";
  } /// @internal


  findChild(startIndex, endIndex, dir, pos, side) {
    let {
      buffer
    } = this,
        pick = -1;

    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0) break;
      }
    }

    return pick;
  } /// @internal


  slice(startI, endI, from, to) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI);

    for (let i = startI, j = 0; i < endI;) {
      copy[j++] = b[i++];
      copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - startI;
    }

    return new TreeBuffer(copy, to - from, this.set);
  }

}

exports.TreeBuffer = TreeBuffer;

function checkSide(side, pos, from, to) {
  switch (side) {
    case -2
    /* Before */
    :
      return from < pos;

    case -1
    /* AtOrBefore */
    :
      return to >= pos && from < pos;

    case 0
    /* Around */
    :
      return from < pos && to > pos;

    case 1
    /* AtOrAfter */
    :
      return from <= pos && to > pos;

    case 2
    /* After */
    :
      return to > pos;

    case 4
    /* DontCare */
    :
      return true;
  }
}

function enterUnfinishedNodesBefore(node, pos) {
  let scan = node.childBefore(pos);

  while (scan) {
    let last = scan.lastChild;
    if (!last || last.to != scan.to) break;

    if (last.type.isError && last.from == last.to) {
      node = scan;
      scan = last.prevSibling;
    } else {
      scan = last;
    }
  }

  return node;
}

class TreeNode {
  constructor(node, _from, // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
  index, _parent) {
    this.node = node;
    this._from = _from;
    this.index = index;
    this._parent = _parent;
  }

  get type() {
    return this.node.type;
  }

  get name() {
    return this.node.type.name;
  }

  get from() {
    return this._from;
  }

  get to() {
    return this._from + this.node.length;
  }

  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this;;) {
      for (let {
        children,
        positions
      } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i],
            start = positions[i] + parent._from;
        if (!checkSide(side, pos, start, start + next.length)) continue;

        if (next instanceof TreeBuffer) {
          if (mode & 2
          /* NoEnterBuffer */
          ) continue;
          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);
        } else if (mode & 1
        /* Full */
        || !next.type.isAnonymous || hasChild(next)) {
          let mounted;
          if (next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);
          let inner = new TreeNode(next, start, i, parent);
          return mode & 1
          /* Full */
          || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }

      if (mode & 1
      /* Full */
      || !parent.type.isAnonymous) return null;
      if (parent.index >= 0) i = parent.index + dir;else i = dir < 0 ? -1 : parent._parent.node.children.length;
      parent = parent._parent;
      if (!parent) return null;
    }
  }

  get firstChild() {
    return this.nextChild(0, 1, 0, 4
    /* DontCare */
    );
  }

  get lastChild() {
    return this.nextChild(this.node.children.length - 1, -1, 0, 4
    /* DontCare */
    );
  }

  childAfter(pos) {
    return this.nextChild(0, 1, pos, 2
    /* After */
    );
  }

  childBefore(pos) {
    return this.nextChild(this.node.children.length - 1, -1, pos, -2
    /* Before */
    );
  }

  enter(pos, side, overlays = true, buffers = true) {
    let mounted;

    if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {
      let rPos = pos - this.from;

      for (let {
        from,
        to
      } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }

    return this.nextChild(0, 1, pos, side, buffers ? 0 : 2
    /* NoEnterBuffer */
    );
  }

  nextSignificantParent() {
    let val = this;

    while (val.type.isAnonymous && val._parent) val = val._parent;

    return val;
  }

  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }

  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4
    /* DontCare */
    ) : null;
  }

  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4
    /* DontCare */
    ) : null;
  }

  get cursor() {
    return new TreeCursor(this);
  }

  get tree() {
    return this.node;
  }

  toTree() {
    return this.node;
  }

  resolve(pos, side = 0) {
    return this.cursor.moveTo(pos, side).node;
  }

  enterUnfinishedNodesBefore(pos) {
    return enterUnfinishedNodesBefore(this, pos);
  }

  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }

  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  } /// @internal


  toString() {
    return this.node.toString();
  }

}

function getChildren(node, type, before, after) {
  let cur = node.cursor,
      result = [];
  if (!cur.firstChild()) return result;
  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result;

  for (;;) {
    if (after != null && cur.type.is(after)) return result;
    if (cur.type.is(type)) result.push(cur.node);
    if (!cur.nextSibling()) return after == null ? result : [];
  }
}

class BufferContext {
  constructor(parent, buffer, index, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  }

}

class BufferNode {
  constructor(context, _parent, index) {
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }

  get name() {
    return this.type.name;
  }

  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }

  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }

  child(dir, pos, side) {
    let {
      buffer
    } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }

  get firstChild() {
    return this.child(1, 0, 4
    /* DontCare */
    );
  }

  get lastChild() {
    return this.child(-1, 0, 4
    /* DontCare */
    );
  }

  childAfter(pos) {
    return this.child(1, pos, 2
    /* After */
    );
  }

  childBefore(pos) {
    return this.child(-1, pos, -2
    /* Before */
    );
  }

  enter(pos, side, overlays, buffers = true) {
    if (!buffers) return null;
    let {
      buffer
    } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }

  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }

  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4
    /* DontCare */
    );
  }

  get nextSibling() {
    let {
      buffer
    } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }

  get prevSibling() {
    let {
      buffer
    } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart) return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4
    /* DontCare */
    ));
  }

  get cursor() {
    return new TreeCursor(this);
  }

  get tree() {
    return null;
  }

  toTree() {
    let children = [],
        positions = [];
    let {
      buffer
    } = this.context;
    let startI = this.index + 4,
        endI = buffer.buffer[this.index + 3];

    if (endI > startI) {
      let from = buffer.buffer[this.index + 1],
          to = buffer.buffer[this.index + 2];
      children.push(buffer.slice(startI, endI, from, to));
      positions.push(0);
    }

    return new Tree(this.type, children, positions, this.to - this.from);
  }

  resolve(pos, side = 0) {
    return this.cursor.moveTo(pos, side).node;
  }

  enterUnfinishedNodesBefore(pos) {
    return enterUnfinishedNodesBefore(this, pos);
  } /// @internal


  toString() {
    return this.context.buffer.childString(this.index);
  }

  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }

  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }

} /// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.


class TreeCursor {
  /// @internal
  constructor(node, /// @internal
  mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;

    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;

      for (let n = node._parent; n; n = n._parent) this.stack.unshift(n.index);

      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  } /// Shorthand for `.type.name`.


  get name() {
    return this.type.name;
  }

  yieldNode(node) {
    if (!node) return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }

  yieldBuf(index, type) {
    this.index = index;
    let {
      start,
      buffer
    } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index]];
    this.from = start + buffer.buffer[index + 1];
    this.to = start + buffer.buffer[index + 2];
    return true;
  }

  yield(node) {
    if (!node) return false;

    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }

    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  } /// @internal


  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  } /// @internal


  enterChild(dir, pos, side) {
    if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));
    let {
      buffer
    } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index < 0) return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  } /// Move the cursor to this node's first child. When this returns
  /// false, the node has no child, and the cursor has not been moved.


  firstChild() {
    return this.enterChild(1, 0, 4
    /* DontCare */
    );
  } /// Move the cursor to this node's last child.


  lastChild() {
    return this.enterChild(-1, 0, 4
    /* DontCare */
    );
  } /// Move the cursor to the first child that ends after `pos`.


  childAfter(pos) {
    return this.enterChild(1, pos, 2
    /* After */
    );
  } /// Move to the last child that starts before `pos`.


  childBefore(pos) {
    return this.enterChild(-1, pos, -2
    /* Before */
    );
  } /// Move the cursor to the child around `pos`. If side is -1 the
  /// child may end at that position, when 1 it may start there. This
  /// will also enter [overlaid](#common.MountedTree.overlay)
  /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  /// set to false.


  enter(pos, side, overlays = true, buffers = true) {
    if (!this.buffer) return this.yield(this._tree.enter(pos, side, overlays, buffers));
    return buffers ? this.enterChild(1, pos, side) : false;
  } /// Move the node's parent node, if this isn't the top node.


  parent() {
    if (!this.buffer) return this.yieldNode(this.mode & 1
    /* Full */
    ? this._tree._parent : this._tree.parent);
    if (this.stack.length) return this.yieldBuf(this.stack.pop());
    let parent = this.mode & 1
    /* Full */
    ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  } /// @internal


  sibling(dir) {
    if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4
    /* DontCare */
    , this.mode));
    let {
      buffer
    } = this.buffer,
        d = this.stack.length - 1;

    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4
      /* DontCare */
      ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);
    }

    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4
    /* DontCare */
    , this.mode)) : false;
  } /// Move to this node's next sibling, if any.


  nextSibling() {
    return this.sibling(1);
  } /// Move to this node's previous sibling, if any.


  prevSibling() {
    return this.sibling(-1);
  }

  atLastNode(dir) {
    let index,
        parent,
        {
      buffer
    } = this;

    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length) return false;
      } else {
        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false;
      }

      ({
        index,
        parent
      } = buffer);
    } else {
      ({
        index,
        _parent: parent
      } = this._tree);
    }

    for (; parent; ({
      index,
      _parent: parent
    } = parent)) {
      if (index > -1) for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
        let child = parent.node.children[i];
        if (this.mode & 1
        /* Full */
        || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;
      }
    }

    return true;
  }

  move(dir, enter) {
    if (enter && this.enterChild(dir, 0, 4
    /* DontCare */
    )) return true;

    for (;;) {
      if (this.sibling(dir)) return true;
      if (this.atLastNode(dir) || !this.parent()) return false;
    }
  } /// Move to the next node in a
  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
  /// traversal, going from a node to its first child or, if the
  /// current node is empty or `enter` is false, its next sibling or
  /// the next sibling of the first parent node that has one.


  next(enter = true) {
    return this.move(1, enter);
  } /// Move to the next node in a last-to-first pre-order traveral. A
  /// node is followed by its last child or, if it has none, its
  /// previous sibling or the previous sibling of the first parent
  /// node that has one.


  prev(enter = true) {
    return this.move(-1, enter);
  } /// Move the cursor to the innermost node that covers `pos`. If
  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  /// it will enter nodes that start at `pos`.


  moveTo(pos, side = 0) {
    // Move up to a node that actually holds the position, if possible
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break; // Then scan down into child nodes as far as possible


    while (this.enterChild(1, pos, side)) {}

    return this;
  } /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
  /// position.


  get node() {
    if (!this.buffer) return this._tree;
    let cache = this.bufferNode,
        result = null,
        depth = 0;

    if (cache && cache.context == this.buffer) {
      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
        for (let c = cache; c; c = c._parent) if (c.index == index) {
          if (index == this.index) return c;
          result = c;
          depth = d + 1;
          break scan;
        }

        index = this.stack[--d];
      }
    }

    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i]);

    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  } /// Get the [tree](#common.Tree) that represents the current node, if
  /// any. Will return null when the node is in a [tree
  /// buffer](#common.TreeBuffer).


  get tree() {
    return this.buffer ? null : this._tree.node;
  }

}

exports.TreeCursor = TreeCursor;

function hasChild(tree) {
  return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}

function buildTree(data) {
  var _a;

  let {
    buffer,
    nodeSet,
    maxBufferLength = DefaultBufferLength,
    reused = [],
    minRepeatType = nodeSet.types.length
  } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types = nodeSet.types;
  let contextHash = 0,
      lookAhead = 0;

  function takeNode(parentStart, minPos, children, positions, inRepeat) {
    let {
      id,
      start,
      end,
      size
    } = cursor;
    let lookAheadAtStart = lookAhead;

    while (size < 0) {
      cursor.next();

      if (size == -1
      /* Reuse */
      ) {
          let node = reused[id];
          children.push(node);
          positions.push(start - parentStart);
          return;
        } else if (size == -3
      /* ContextChange */
      ) {
          // Context change
          contextHash = id;
          return;
        } else if (size == -4
      /* LookAhead */
      ) {
          lookAhead = id;
          return;
        } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }

    let type = types[id],
        node,
        buffer;
    let startPos = start - parentStart;

    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
      // Small enough for a buffer, and no reused nodes inside
      let data = new Uint16Array(buffer.size - buffer.skip);
      let endPos = cursor.pos - buffer.size,
          index = data.length;

      while (cursor.pos > endPos) index = copyToBuffer(buffer.start, data, index);

      node = new TreeBuffer(data, end - buffer.start, nodeSet);
      startPos = buffer.start - parentStart;
    } else {
      // Make it a node
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [],
          localPositions = [];
      let localInRepeat = id >= minRepeatType ? id : -1;
      let lastGroup = 0,
          lastEnd = end;

      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }

          cursor.next();
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat);
        }
      }

      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
      localChildren.reverse();
      localPositions.reverse();

      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
      }
    }

    children.push(node);
    positions.push(startPos);
  }

  function makeBalanced(type) {
    return (children, positions, length) => {
      let lookAhead = 0,
          lastI = children.length - 1,
          last,
          lookAheadProp;

      if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length) return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;
      }

      return makeTree(type, children, positions, length, lookAhead);
    };
  }

  function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
    let localChildren = [],
        localPositions = [];

    while (children.length > i) {
      localChildren.push(children.pop());
      localPositions.push(positions.pop() + base - from);
    }

    children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
    positions.push(from - base);
  }

  function makeTree(type, children, positions, length, lookAhead = 0, props) {
    if (contextHash) {
      let pair = [NodeProp.contextHash, contextHash];
      props = props ? [pair].concat(props) : [pair];
    }

    if (lookAhead > 25) {
      let pair = [NodeProp.lookAhead, lookAhead];
      props = props ? [pair].concat(props) : [pair];
    }

    return new Tree(type, children, positions, length, props);
  }

  function findBufferSize(maxSize, inRepeat) {
    // Scan through the buffer to find previous siblings that fit
    // together in a TreeBuffer, and don't contain any reused nodes
    // (which can't be stored in a buffer).
    // If `inRepeat` is > -1, ignore node boundaries of that type for
    // nesting, but make sure the end falls either at the start
    // (`maxSize`) or before such a node.
    let fork = cursor.fork();
    let size = 0,
        start = 0,
        skip = 0,
        minStart = fork.end - maxBufferLength;
    let result = {
      size: 0,
      start: 0,
      skip: 0
    };

    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
      let nodeSize = fork.size; // Pretend nested repeat nodes of the same type don't exist

      if (fork.id == inRepeat && nodeSize >= 0) {
        // Except that we store the current state as a valid return
        // value.
        result.size = size;
        result.start = start;
        result.skip = skip;
        skip += 4;
        size += 4;
        fork.next();
        continue;
      }

      let startPos = fork.pos - nodeSize;
      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;
      let localSkipped = fork.id >= minRepeatType ? 4 : 0;
      let nodeStart = fork.start;
      fork.next();

      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3
          /* ContextChange */
          ) localSkipped += 4;else break scan;
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4;
        }

        fork.next();
      }

      start = nodeStart;
      size += nodeSize;
      skip += localSkipped;
    }

    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }

    return result.size > 4 ? result : undefined;
  }

  function copyToBuffer(bufferStart, buffer, index) {
    let {
      id,
      start,
      end,
      size
    } = cursor;
    cursor.next();

    if (size >= 0 && id < minRepeatType) {
      let startIndex = index;

      if (size > 4) {
        let endPos = cursor.pos - (size - 4);

        while (cursor.pos > endPos) index = copyToBuffer(bufferStart, buffer, index);
      }

      buffer[--index] = startIndex;
      buffer[--index] = end - bufferStart;
      buffer[--index] = start - bufferStart;
      buffer[--index] = id;
    } else if (size == -3
    /* ContextChange */
    ) {
        contextHash = id;
      } else if (size == -4
    /* LookAhead */
    ) {
        lookAhead = id;
      }

    return index;
  }

  let children = [],
      positions = [];

  while (cursor.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);

  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}

const nodeSizeCache = new WeakMap();

function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;
  let size = nodeSizeCache.get(node);

  if (size == null) {
    size = node.children.reduce((s, ch) => s + nodeSize(balanceType, ch), 1);
    nodeSizeCache.set(node, size);
  }

  return size;
}

function balanceRange( // The type to tag the resulting tree with. Will also be used for
// internal nodes when it is an anonymous type
type, // The direct children and their positions
children, positions, // The index range in children/positions to use
from, to, // The start position of the nodes, relative to their parent.
start, // Length of the outer node
length, // Function to build the top node of the balanced tree
mkTop, // Function to build internal nodes for the balanced tree
mkTree) {
  let total = 0;

  for (let i = from; i < to; i++) total += nodeSize(type, children[i]);

  let maxChild = Math.ceil(total * 1.5 / 8
  /* BranchFactor */
  );
  let localChildren = [],
      localPositions = [];

  function divide(children, positions, from, to, offset) {
    for (let i = from; i < to;) {
      let groupFrom = i,
          groupStart = positions[i],
          groupSize = nodeSize(type, children[i]);
      i++;

      for (; i < to; i++) {
        let nextSize = nodeSize(type, children[i]);
        if (groupSize + nextSize >= maxChild) break;
        groupSize += nextSize;
      }

      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
          continue;
        }

        localChildren.push(children[groupFrom]);
      } else {
        let length = positions[i - 1] + children[i - 1].length - groupStart;
        localChildren.push(balanceRange(type, children, positions, groupFrom, i, groupStart, length, null, mkTree));
      }

      localPositions.push(groupStart + offset - start);
    }
  }

  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
} /// Tree fragments are used during [incremental
/// parsing](#common.Parser.startParse) to track parts of old trees
/// that can be reused in a new parse. An array of fragments is used
/// to track regions of an old tree whose nodes might be reused in new
/// parses. Use the static
/// [`applyChanges`](#common.TreeFragment^applyChanges) method to
/// update fragments for document changes.


class TreeFragment {
  /// Construct a tree fragment.
  constructor( /// The start of the unchanged range pointed to by this fragment.
  /// This refers to an offset in the _updated_ document (as opposed
  /// to the original tree).
  from, /// The end of the unchanged range.
  to, /// The tree that this fragment is based on.
  tree, /// The offset between the fragment's tree and the document that
  /// this fragment can be used against. Add this when going from
  /// document to tree positions, subtract it to go from tree to
  /// document positions.
  offset, openStart = false, openEnd = false) {
    this.from = from;
    this.to = to;
    this.tree = tree;
    this.offset = offset;
    this.open = (openStart ? 1
    /* Start */
    : 0) | (openEnd ? 2
    /* End */
    : 0);
  } /// Whether the start of the fragment represents the start of a
  /// parse, or the end of a change. (In the second case, it may not
  /// be safe to reuse some nodes at the start, depending on the
  /// parsing algorithm.)


  get openStart() {
    return (this.open & 1
    /* Start */
    ) > 0;
  } /// Whether the end of the fragment represents the end of a
  /// full-document parse, or the start of a change.


  get openEnd() {
    return (this.open & 2
    /* End */
    ) > 0;
  } /// Create a set of fragments from a freshly parsed tree, or update
  /// an existing set of fragments by replacing the ones that overlap
  /// with a tree with content from the new tree. When `partial` is
  /// true, the parse is treated as incomplete, and the resulting
  /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  /// true.


  static addTree(tree, fragments = [], partial = false) {
    let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];

    for (let f of fragments) if (f.to > tree.length) result.push(f);

    return result;
  } /// Apply a set of edits to an array of fragments, removing or
  /// splitting fragments as necessary to remove edited ranges, and
  /// adjusting offsets for fragments that moved.


  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length) return fragments;
    let result = [];
    let fI = 1,
        nextF = fragments.length ? fragments[0] : null;

    for (let cI = 0, pos = 0, off = 0;; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {
        let cut = nextF;

        if (pos >= cut.from || nextPos <= cut.to || off) {
          let fFrom = Math.max(cut.from, pos) - off,
              fTo = Math.min(cut.to, nextPos) - off;
          cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
        }

        if (cut) result.push(cut);
        if (nextF.to > nextPos) break;
        nextF = fI < fragments.length ? fragments[fI++] : null;
      }
      if (!nextC) break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }

    return result;
  }

} /// A superclass that parsers should extend.


exports.TreeFragment = TreeFragment;

class Parser {
  /// Start a parse, returning a [partial parse](#common.PartialParse)
  /// object. [`fragments`](#common.TreeFragment) can be passed in to
  /// make the parse incremental.
  ///
  /// By default, the entire input is parsed. You can pass `ranges`,
  /// which should be a sorted array of non-empty, non-overlapping
  /// ranges, to parse only those ranges. The tree returned in that
  /// case will start at `ranges[0].from`.
  startParse(input, fragments, ranges) {
    if (typeof input == "string") input = new StringInput(input);
    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  } /// Run a full parse, returning the resulting tree.


  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);

    for (;;) {
      let done = parse.advance();
      if (done) return done;
    }
  }

}

exports.Parser = Parser;

class StringInput {
  constructor(string) {
    this.string = string;
  }

  get length() {
    return this.string.length;
  }

  chunk(from) {
    return this.string.slice(from);
  }

  get lineChunks() {
    return false;
  }

  read(from, to) {
    return this.string.slice(from, to);
  }

} /// Create a parse wrapper that, after the inner parse completes,
/// scans its tree for mixed language regions with the `nest`
/// function, runs the resulting [inner parses](#common.NestedParse),
/// and then [mounts](#common.NodeProp^mounted) their results onto the
/// tree.
///
/// The nesting function is passed a cursor to provide context for a
/// node, but _should not_ move that cursor, only inspect its
/// properties and optionally access its
/// [node object](#common.TreeCursor.node).


function parseMixed(nest) {
  return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}

class InnerParse {
  constructor(parser, parse, overlay, target) {
    this.parser = parser;
    this.parse = parse;
    this.overlay = overlay;
    this.target = target;
  }

}

class ActiveOverlay {
  constructor(parser, predicate, mounts, index, start, target, prev) {
    this.parser = parser;
    this.predicate = predicate;
    this.mounts = mounts;
    this.index = index;
    this.start = start;
    this.target = target;
    this.prev = prev;
    this.depth = 0;
    this.ranges = [];
  }

}

class MixedParse {
  constructor(base, nest, input, fragments, ranges) {
    this.nest = nest;
    this.input = input;
    this.fragments = fragments;
    this.ranges = ranges;
    this.inner = [];
    this.innerDone = 0;
    this.baseTree = null;
    this.stoppedAt = null;
    this.baseParse = base;
  }

  advance() {
    if (this.baseParse) {
      let done = this.baseParse.advance();
      if (!done) return null;
      this.baseParse = null;
      this.baseTree = done;
      this.startInner();
    }

    if (this.innerDone == this.inner.length) return this.baseTree;
    let inner = this.inner[this.innerDone],
        done = inner.parse.advance();

    if (done) {
      this.innerDone++; // This is a somewhat dodgy but super helpful hack where we
      // patch up nodes created by the inner parse (and thus
      // presumably not aliased anywhere else) to hold the information
      // about the inner parse.

      let props = Object.assign(Object.create(null), inner.target.props);
      props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
      inner.target.props = props;
    }

    return null;
  }

  get parsedPos() {
    if (this.baseParse) return 0;
    let next = this.inner[this.innerDone];
    return next ? next.parse.parsedPos : this.input.length;
  }

  stopAt(pos) {
    this.stoppedAt = pos;
    if (this.baseParse) this.baseParse.stopAt(pos);else for (let i = this.innerDone; i < this.inner.length; i++) this.inner[i].parse.stopAt(pos);
  }

  startInner() {
    let fragmentCursor = new FragmentCursor(this.fragments);
    let overlay = null;
    let covered = null;

    scan: for (let cursor = this.baseTree.fullCursor(), nest, isCovered;;) {
      let enter = true,
          range;

      if (fragmentCursor.hasNode(cursor)) {
        if (overlay) {
          let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
          if (match) for (let r of match.mount.overlay) {
            let from = r.from + match.pos,
                to = r.to + match.pos;
            if (from >= cursor.from && to <= cursor.to) overlay.ranges.push({
              from,
              to
            });
          }
        }

        enter = false;
      } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
        enter = isCovered != 2
        /* Full */
        ;
      } else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
        if (!cursor.tree) materialize(cursor);
        let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);

        if (typeof nest.overlay == "function") {
          overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
        } else {
          let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);
          if (ranges.length) this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree));
          if (!nest.overlay) enter = false;else if (ranges.length) covered = {
            ranges,
            depth: 0,
            prev: covered
          };
        }
      } else if (overlay && (range = overlay.predicate(cursor))) {
        if (range === true) range = new Range(cursor.from, cursor.to);
        if (range.from < range.to) overlay.ranges.push(range);
      }

      if (enter && cursor.firstChild()) {
        if (overlay) overlay.depth++;
        if (covered) covered.depth++;
      } else {
        for (;;) {
          if (cursor.nextSibling()) break;
          if (!cursor.parent()) break scan;

          if (overlay && ! --overlay.depth) {
            let ranges = punchRanges(this.ranges, overlay.ranges);
            if (ranges.length) this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target));
            overlay = overlay.prev;
          }

          if (covered && ! --covered.depth) covered = covered.prev;
        }
      }
    }
  }

}

function checkCover(covered, from, to) {
  for (let range of covered) {
    if (range.from >= to) break;
    if (range.to > from) return range.from <= from && range.to >= to ? 2
    /* Full */
    : 1
    /* Partial */
    ;
  }

  return 0
  /* None */
  ;
} // Take a piece of buffer and convert it into a stand-alone
// TreeBuffer.


function sliceBuf(buf, startI, endI, nodes, positions, off) {
  if (startI < endI) {
    let from = buf.buffer[startI + 1],
        to = buf.buffer[endI - 2];
    nodes.push(buf.slice(startI, endI, from, to));
    positions.push(from - off);
  }
} // This function takes a node that's in a buffer, and converts it, and
// its parent buffer nodes, into a Tree. This is again acting on the
// assumption that the trees and buffers have been constructed by the
// parse that was ran via the mix parser, and thus aren't shared with
// any other code, making violations of the immutability safe.


function materialize(cursor) {
  let {
    node
  } = cursor,
      depth = 0; // Scan up to the nearest tree

  do {
    cursor.parent();
    depth++;
  } while (!cursor.tree); // Find the index of the buffer in that tree


  let i = 0,
      base = cursor.tree,
      off = 0;

  for (;; i++) {
    off = base.positions[i] + cursor.from;
    if (off <= node.from && off + base.children[i].length >= node.to) break;
  }

  let buf = base.children[i],
      b = buf.buffer; // Split a level in the buffer, putting the nodes before and after
  // the child that contains `node` into new buffers.

  function split(startI, endI, type, innerOffset) {
    let i = startI;

    while (b[i + 2] + off <= node.from) i = b[i + 3];

    let children = [],
        positions = [];
    sliceBuf(buf, startI, i, children, positions, innerOffset);
    let isTarget = b[i + 1] + off == node.from && b[i + 2] + off == node.to && b[i] == node.type.id;
    children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], b[i + 1]));
    positions.push(b[i + 1] - innerOffset);
    sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);
    let last = children.length - 1;
    return new Tree(type, children, positions, positions[last] + children[last].length);
  }

  base.children[i] = split(0, b.length, NodeType.none, 0); // Move the cursor back to the target node

  for (let d = 0; d <= depth; d++) cursor.childAfter(node.from);
}

class StructureCursor {
  constructor(root, offset) {
    this.offset = offset;
    this.done = false;
    this.cursor = root.fullCursor();
  } // Move to the first node (in pre-order) that starts at or after `pos`.


  moveTo(pos) {
    let {
      cursor
    } = this,
        p = pos - this.offset;

    while (!this.done && cursor.from < p) {
      if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;else if (!cursor.next(false)) this.done = true;
    }
  }

  hasNode(cursor) {
    this.moveTo(cursor.from);

    if (!this.done && this.cursor.from + this.offset == cursor.from) {
      for (let tree = this.cursor.tree;;) {
        if (tree == cursor.tree) return true;
        if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];else break;
      }
    }

    return false;
  }

}

class FragmentCursor {
  constructor(fragments) {
    this.fragments = fragments;
    this.fragI = 0;

    if (fragments.length) {
      let first = this.curFrag = fragments[0];
      this.inner = new StructureCursor(first.tree, -first.offset);
    } else {
      this.curFrag = this.inner = null;
    }
  }

  hasNode(node) {
    while (this.curFrag && node.from >= this.curFrag.to) this.nextFrag();

    return this.curFrag && this.curFrag.from <= node.from && this.curFrag.to >= node.to && this.inner.hasNode(node);
  }

  nextFrag() {
    this.fragI++;

    if (this.fragI == this.fragments.length) {
      this.curFrag = this.inner = null;
    } else {
      let frag = this.curFrag = this.fragments[this.fragI];
      this.inner = new StructureCursor(frag.tree, -frag.offset);
    }
  }

  findMounts(pos, parser) {
    var _a;

    let result = [];

    if (this.inner) {
      this.inner.cursor.moveTo(pos, 1);

      for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
        let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);

        if (mount && mount.parser == parser) {
          for (let i = this.fragI; i < this.fragments.length; i++) {
            let frag = this.fragments[i];
            if (frag.from >= pos.to) break;
            if (frag.tree == this.curFrag.tree) result.push({
              frag,
              pos: pos.from - frag.offset,
              mount
            });
          }
        }
      }
    }

    return result;
  }

}

function punchRanges(outer, ranges) {
  let copy = null,
      current = ranges;

  for (let i = 1, j = 0; i < outer.length; i++) {
    let gapFrom = outer[i - 1].to,
        gapTo = outer[i].from;

    for (; j < current.length; j++) {
      let r = current[j];
      if (r.from >= gapTo) break;
      if (r.to <= gapFrom) continue;
      if (!copy) current = copy = ranges.slice();

      if (r.from < gapFrom) {
        copy[j] = new Range(r.from, gapFrom);
        if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));
      } else if (r.to > gapTo) {
        copy[j--] = new Range(gapTo, r.to);
      } else {
        copy.splice(j--, 1);
      }
    }
  }

  return current;
}

function findCoverChanges(a, b, from, to) {
  let iA = 0,
      iB = 0,
      inA = false,
      inB = false,
      pos = -1e9;
  let result = [];

  for (;;) {
    let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
    let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;

    if (inA != inB) {
      let start = Math.max(pos, from),
          end = Math.min(nextA, nextB, to);
      if (start < end) result.push(new Range(start, end));
    }

    pos = Math.min(nextA, nextB);
    if (pos == 1e9) break;

    if (nextA == pos) {
      if (!inA) inA = true;else {
        inA = false;
        iA++;
      }
    }

    if (nextB == pos) {
      if (!inB) inB = true;else {
        inB = false;
        iB++;
      }
    }
  }

  return result;
} // Given a number of fragments for the outer tree, and a set of ranges
// to parse, find fragments for inner trees mounted around those
// ranges, if any.


function enterFragments(mounts, ranges) {
  let result = [];

  for (let {
    pos,
    mount,
    frag
  } of mounts) {
    let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0),
        endPos = startPos + mount.tree.length;
    let from = Math.max(frag.from, startPos),
        to = Math.min(frag.to, endPos);

    if (mount.overlay) {
      let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
      let changes = findCoverChanges(ranges, overlay, from, to);

      for (let i = 0, pos = from;; i++) {
        let last = i == changes.length,
            end = last ? to : changes[i].from;
        if (end > pos) result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));
        if (last) break;
        pos = changes[i].to;
      }
    } else {
      result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));
    }
  }

  return result;
}
},{}],"node_modules/@codemirror/language/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.continuedIndent = continuedIndent;
exports.defineLanguageFacet = defineLanguageFacet;
exports.delimitedIndent = delimitedIndent;
exports.ensureSyntaxTree = ensureSyntaxTree;
exports.foldInside = foldInside;
exports.foldable = foldable;
exports.getIndentUnit = getIndentUnit;
exports.getIndentation = getIndentation;
exports.indentOnInput = indentOnInput;
exports.indentString = indentString;
exports.syntaxTree = syntaxTree;
exports.languageDataProp = exports.language = exports.indentUnit = exports.indentService = exports.indentNodeProp = exports.foldService = exports.foldNodeProp = exports.flatIndent = exports.TreeIndentContext = exports.ParseContext = exports.LanguageSupport = exports.LanguageDescription = exports.Language = exports.LRLanguage = exports.IndentContext = void 0;

var _common = require("@lezer/common");

var _state = require("@codemirror/state");

var _view = require("@codemirror/view");

var _text = require("@codemirror/text");

/**
Node prop stored in a grammar's top syntax node to provide the
facet that stores language data for that language.
*/
const languageDataProp = /*@__PURE__*/new _common.NodeProp();
/**
Helper function to define a facet (to be added to the top syntax
node(s) for a language via
[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be
used to associate language data with the language. You
probably only need this when subclassing
[`Language`](https://codemirror.net/6/docs/ref/#language.Language).
*/

exports.languageDataProp = languageDataProp;

function defineLanguageFacet(baseData) {
  return _state.Facet.define({
    combine: baseData ? values => values.concat(baseData) : undefined
  });
}
/**
A language object manages parsing and per-language
[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is
managed as a [Lezer](https://lezer.codemirror.net) tree. You'll
want to subclass this class for custom parsers, or use the
[`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage) or
[`StreamLanguage`](https://codemirror.net/6/docs/ref/#stream-parser.StreamLanguage) abstractions for
[Lezer](https://lezer.codemirror.net/) or stream parsers.
*/


class Language {
  /**
  Construct a language object. You usually don't need to invoke
  this directly. But when you do, make sure you use
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet) to create
  the first argument.
  */
  constructor(
  /**
  The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) data
  facet used for this language.
  */
  data, parser,
  /**
  The node type of the top node of trees produced by this parser.
  */
  topNode, extraExtensions = []) {
    this.data = data;
    this.topNode = topNode; // Kludge to define EditorState.tree as a debugging helper,
    // without the EditorState package actually knowing about
    // languages and lezer trees.

    if (!_state.EditorState.prototype.hasOwnProperty("tree")) Object.defineProperty(_state.EditorState.prototype, "tree", {
      get() {
        return syntaxTree(this);
      }

    });
    this.parser = parser;
    this.extension = [language.of(this), _state.EditorState.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))].concat(extraExtensions);
  }
  /**
  Query whether this language is active at the given position.
  */


  isActiveAt(state, pos, side = -1) {
    return languageDataFacetAt(state, pos, side) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */


  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [{
      from: 0,
      to: state.doc.length
    }];
    if (!lang || !lang.allowsNesting) return [];
    let result = [];

    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({
          from,
          to: from + tree.length
        });
        return;
      }

      let mount = tree.prop(_common.NodeProp.mounted);

      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay) for (let r of mount.overlay) result.push({
            from: r.from + from,
            to: r.to + from
          });else result.push({
            from: from,
            to: from + tree.length
          });
          return;
        } else if (mount.overlay) {
          let size = result.length;
          explore(mount.tree, mount.overlay[0].from + from);
          if (result.length > size) return;
        }
      }

      for (let i = 0; i < tree.children.length; i++) {
        let ch = tree.children[i];
        if (ch instanceof _common.Tree) explore(ch, tree.positions[i] + from);
      }
    };

    explore(syntaxTree(state), 0);
    return result;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */


  get allowsNesting() {
    return true;
  }

}
/**
@internal
*/


exports.Language = Language;
Language.setState = /*@__PURE__*/_state.StateEffect.define();

function languageDataFacetAt(state, pos, side) {
  let topLang = state.facet(language);
  if (!topLang) return null;
  let facet = topLang.data;

  if (topLang.allowsNesting) {
    for (let node = syntaxTree(state).topNode; node; node = node.enter(pos, side, true, false)) facet = node.type.prop(languageDataProp) || facet;
  }

  return facet;
}
/**
A subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer
[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)
parsers.
*/


class LRLanguage extends Language {
  constructor(data, parser) {
    super(data, parser, parser.topNode);
    this.parser = parser;
  }
  /**
  Define a language from a parser.
  */


  static define(spec) {
    let data = defineLanguageFacet(spec.languageData);
    return new LRLanguage(data, spec.parser.configure({
      props: [languageDataProp.add(type => type.isTop ? data : undefined)]
    }));
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser.
  */


  configure(options) {
    return new LRLanguage(this.data, this.parser.configure(options));
  }

  get allowsNesting() {
    return this.parser.wrappers.length > 0;
  } // FIXME


}
/**
Get the syntax tree for a state, which is the current (possibly
incomplete) parse tree of active [language](https://codemirror.net/6/docs/ref/#language.Language),
or the empty tree if there is no language available.
*/


exports.LRLanguage = LRLanguage;

function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : _common.Tree.empty;
}
/**
Try to get a parse tree that spans at least up to `upto`. The
method will do at most `timeout` milliseconds of work to parse
up to that point if the tree isn't already available.
*/


function ensureSyntaxTree(state, upto, timeout = 50) {
  var _a;

  let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;
  return !parse ? null : parse.treeLen >= upto || parse.work(timeout, upto) ? parse.tree : null;
} // Lezer-style Input object for a Text document.


class DocInput {
  constructor(doc, length = doc.length) {
    this.doc = doc;
    this.length = length;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc.iter();
  }

  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }

  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }

  get lineChunks() {
    return true;
  }

  read(from, to) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);else return this.string.slice(from - stringStart, to - stringStart);
  }

}

let currentContext = null;
/**
A parse context provided to parsers working on the editor content.
*/

class ParseContext {
  /**
  @internal
  */
  constructor(parser,
  /**
  The current editor state.
  */
  state,
  /**
  Tree fragments that can be reused by incremental re-parses.
  */
  fragments = [],
  /**
  @internal
  */
  tree, treeLen,
  /**
  The current editor viewport (or some overapproximation
  thereof). Intended to be used for opportunistically avoiding
  work (in which case
  [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)
  should be called to make sure the parser is restarted when the
  skipped region becomes visible).
  */
  viewport,
  /**
  @internal
  */
  skipped,
  /**
  This is where skipping parsers can register a promise that,
  when resolved, will schedule a new parse. It is cleared when
  the parse worker picks up the promise. @internal
  */
  scheduleOn) {
    this.parser = parser;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    /**
    @internal
    */

    this.tempSkipped = [];
  }

  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  /**
  @internal
  */


  work(time, upto) {
    if (upto != null && upto >= this.state.doc.length) upto = undefined;

    if (this.tree != _common.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }

    return this.withContext(() => {
      var _a;

      if (!this.parse) this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);
      let endTime = Date.now() + time;

      for (;;) {
        let done = this.parse.advance();

        if (done) {
          this.fragments = this.withoutTempSkipped(_common.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();else return true;
        }

        if (Date.now() > endTime) return false;
      }
    });
  }
  /**
  @internal
  */


  takeTree() {
    let pos, tree;

    if (this.parse && (pos = this.parse.parsedPos) > this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {}
      });
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(_common.TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }

  withContext(f) {
    let prev = currentContext;
    currentContext = this;

    try {
      return f();
    } finally {
      currentContext = prev;
    }
  }

  withoutTempSkipped(fragments) {
    for (let r; r = this.tempSkipped.pop();) fragments = cutFragments(fragments, r.from, r.to);

    return fragments;
  }
  /**
  @internal
  */


  changes(changes, newState) {
    let {
      fragments,
      tree,
      treeLen,
      viewport,
      skipped
    } = this;
    this.takeTree();

    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({
        fromA,
        toA,
        fromB,
        toB
      }));
      fragments = _common.TreeFragment.applyChanges(fragments, ranges);
      tree = _common.Tree.empty;
      treeLen = 0;
      viewport = {
        from: changes.mapPos(viewport.from, -1),
        to: changes.mapPos(viewport.to, 1)
      };

      if (this.skipped.length) {
        skipped = [];

        for (let r of this.skipped) {
          let from = changes.mapPos(r.from, 1),
              to = changes.mapPos(r.to, -1);
          if (from < to) skipped.push({
            from,
            to
          });
        }
      }
    }

    return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
  }
  /**
  @internal
  */


  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;

    for (let i = 0; i < this.skipped.length; i++) {
      let {
        from,
        to
      } = this.skipped[i];

      if (from < viewport.to && to > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to);
        this.skipped.splice(i--, 1);
      }
    }

    if (this.skipped.length >= startLen) return false;
    this.reset();
    return true;
  }
  /**
  @internal
  */


  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */


  skipUntilInView(from, to) {
    this.skipped.push({
      from,
      to
    });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */


  static getSkippingParser(until) {
    return new class extends _common.Parser {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from,
            to = ranges[ranges.length - 1].to;
        let parser = {
          parsedPos: from,

          advance() {
            let cx = currentContext;

            if (cx) {
              for (let r of ranges) cx.tempSkipped.push(r);

              if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
            }

            this.parsedPos = to;
            return new _common.Tree(_common.NodeType.none, [], [], to - from);
          },

          stoppedAt: null,

          stopAt() {}

        };
        return parser;
      }

    }();
  }
  /**
  @internal
  */


  movedPast(pos) {
    return this.treeLen < pos && this.parse && this.parse.parsedPos >= pos;
  }
  /**
  @internal
  */


  isDone(upto) {
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */


  static get() {
    return currentContext;
  }

}

exports.ParseContext = ParseContext;

function cutFragments(fragments, from, to) {
  return _common.TreeFragment.applyChanges(fragments, [{
    fromA: from,
    toA: to,
    fromB: from,
    toB: to
  }]);
}

class LanguageState {
  constructor( // A mutable parse state that is used to preserve work done during
  // the lifetime of a state when moving to the next state.
  context) {
    this.context = context;
    this.tree = context.tree;
  }

  apply(tr) {
    if (!tr.docChanged) return this;
    let newCx = this.context.changes(tr.changes, tr.state); // If the previous parse wasn't done, go forward only up to its
    // end position or the end of the viewport, to avoid slowing down
    // state updates with parse work beyond the viewport.

    let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(25
    /* Apply */
    , upto)) newCx.takeTree();
    return new LanguageState(newCx);
  }

  static init(state) {
    let parseState = new ParseContext(state.facet(language).parser, state, [], _common.Tree.empty, 0, {
      from: 0,
      to: state.doc.length
    }, [], null);
    if (!parseState.work(25
    /* Apply */
    )) parseState.takeTree();
    return new LanguageState(parseState);
  }

}

Language.state = /*@__PURE__*/_state.StateField.define({
  create: LanguageState.init,

  update(value, tr) {
    for (let e of tr.effects) if (e.is(Language.setState)) return e.value;

    if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);
    return value.apply(tr);
  }

});

let requestIdle = typeof window != "undefined" && window.requestIdleCallback || ((callback, {
  timeout
}) => setTimeout(callback, timeout));

let cancelIdle = typeof window != "undefined" && window.cancelIdleCallback || clearTimeout;

const parseWorker = /*@__PURE__*/_view.ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = -1; // End of the current time chunk

    this.chunkEnd = -1; // Milliseconds of budget left for this chunk

    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }

  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();

    if (update.docChanged) {
      if (this.view.hasFocus) this.chunkBudget += 50
      /* ChangeBonus */
      ;
      this.scheduleWork();
    }

    this.checkAsyncSchedule(cx);
  }

  scheduleWork() {
    if (this.working > -1) return;
    let {
      state
    } = this.view,
        field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work, {
      timeout: 500
      /* Pause */

    });
  }

  work(deadline) {
    this.working = -1;
    let now = Date.now();

    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      // Start a new chunk
      this.chunkEnd = now + 30000
      /* ChunkTime */
      ;
      this.chunkBudget = 3000
      /* ChunkBudget */
      ;
    }

    if (this.chunkBudget <= 0) return; // No more budget

    let {
      state,
      viewport: {
        to: vpTo
      }
    } = this.view,
        field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.treeLen >= vpTo + 1000000
    /* MaxParseAhead */
    ) return;
    let time = Math.min(this.chunkBudget, deadline ? Math.max(25
    /* MinSlice */
    , deadline.timeRemaining()) : 100
    /* Slice */
    );
    let done = field.context.work(time, vpTo + 1000000
    /* MaxParseAhead */
    );
    this.chunkBudget -= Date.now() - now;

    if (done || this.chunkBudget <= 0 || field.context.movedPast(vpTo)) {
      field.context.takeTree();
      this.view.dispatch({
        effects: Language.setState.of(new LanguageState(field.context))
      });
    }

    if (!done && this.chunkBudget > 0) this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }

  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      cx.scheduleOn.then(() => this.scheduleWork());
      cx.scheduleOn = null;
    }
  }

  destroy() {
    if (this.working >= 0) cancelIdle(this.working);
  }

}, {
  eventHandlers: {
    focus() {
      this.scheduleWork();
    }

  }
});
/**
The facet used to associate a language with an editor state.
*/


const language = /*@__PURE__*/_state.Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },

  enables: [Language.state, parseWorker]
});
/**
This class bundles a [language object](https://codemirror.net/6/docs/ref/#language.Language) with an
optional set of supporting extensions. Language packages are
encouraged to export a function that optionally takes a
configuration object and returns a `LanguageSupport` instance, as
the main way for client code to use the package.
*/


exports.language = language;

class LanguageSupport {
  /**
  Create a support object.
  */
  constructor(
  /**
  The language object.
  */
  language,
  /**
  An optional set of supporting extensions. When nesting a
  language in another language, the outer language is encouraged
  to include the supporting extensions for its inner languages
  in its own set of support extensions.
  */
  support = []) {
    this.language = language;
    this.support = support;
    this.extension = [language, support];
  }

}
/**
Language descriptions are used to store metadata about languages
and to dynamically load them. Their main role is finding the
appropriate language for a filename or dynamically loading nested
parsers.
*/


exports.LanguageSupport = LanguageSupport;

class LanguageDescription {
  constructor(
  /**
  The name of this language.
  */
  name,
  /**
  Alternative names for the mode (lowercased, includes `this.name`).
  */
  alias,
  /**
  File extensions associated with this language.
  */
  extensions,
  /**
  Optional filename pattern that should be associated with this
  language.
  */
  filename, loadFunc) {
    this.name = name;
    this.alias = alias;
    this.extensions = extensions;
    this.filename = filename;
    this.loadFunc = loadFunc;
    /**
    If the language has been loaded, this will hold its value.
    */

    this.support = undefined;
    this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */


  load() {
    return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => {
      this.loading = null;
      throw err;
    }));
  }
  /**
  Create a language description.
  */


  static of(spec) {
    return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, spec.load);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */


  static matchFilename(descs, filename) {
    for (let d of descs) if (d.filename && d.filename.test(filename)) return d;

    let ext = /\.([^.]+)$/.exec(filename);
    if (ext) for (let d of descs) if (d.extensions.indexOf(ext[1]) > -1) return d;
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */


  static matchLanguageName(descs, name, fuzzy = true) {
    name = name.toLowerCase();

    for (let d of descs) if (d.alias.some(a => a == name)) return d;

    if (fuzzy) for (let d of descs) for (let a of d.alias) {
      let found = name.indexOf(a);
      if (found > -1 && (a.length > 2 || !/\w/.test(name[found - 1]) && !/\w/.test(name[found + a.length]))) return d;
    }
    return null;
  }

}
/**
Facet that defines a way to provide a function that computes the
appropriate indentation depth at the start of a given line, or
`null` to indicate no appropriate indentation could be determined.
*/


exports.LanguageDescription = LanguageDescription;

const indentService = /*@__PURE__*/_state.Facet.define();
/**
Facet for overriding the unit by which indentation happens.
Should be a string consisting either entirely of spaces or
entirely of tabs. When not set, this defaults to 2 spaces.
*/


exports.indentService = indentService;

const indentUnit = /*@__PURE__*/_state.Facet.define({
  combine: values => {
    if (!values.length) return "  ";
    if (!/^(?: +|\t+)$/.test(values[0])) throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
    return values[0];
  }
});
/**
Return the _column width_ of an indent unit in the state.
Determined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)
facet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that
contains tabs.
*/


exports.indentUnit = indentUnit;

function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
/**
Create an indentation string that covers columns 0 to `cols`.
Will use tabs for as much of the columns as possible when the
[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains
tabs.
*/


function indentString(state, cols) {
  let result = "",
      ts = state.tabSize;
  if (state.facet(indentUnit).charCodeAt(0) == 9) while (cols >= ts) {
    result += "\t";
    cols -= ts;
  }

  for (let i = 0; i < cols; i++) result += " ";

  return result;
}
/**
Get the indentation at the given position. Will first consult any
[indent services](https://codemirror.net/6/docs/ref/#language.indentService) that are registered,
and if none of those return an indentation, this will check the
syntax tree for the [indent node prop](https://codemirror.net/6/docs/ref/#language.indentNodeProp)
and use that if found. Returns a number when an indentation could
be determined, and null otherwise.
*/


function getIndentation(context, pos) {
  if (context instanceof _state.EditorState) context = new IndentContext(context);

  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos);
    if (result != null) return result;
  }

  let tree = syntaxTree(context.state);
  return tree ? syntaxIndentation(context, tree, pos) : null;
}
/**
Indentation contexts are used when calling [indentation
services](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities
useful in indentation logic, and can selectively override the
indentation reported for some lines.
*/


class IndentContext {
  /**
  Create an indent context.
  */
  constructor(
  /**
  The editor state.
  */
  state,
  /**
  @internal
  */
  options = {}) {
    this.state = state;
    this.options = options;
    this.unit = getIndentUnit(state);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */


  lineAt(pos, bias = 1) {
    let line = this.state.doc.lineAt(pos);
    let {
      simulateBreak
    } = this.options;

    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
      if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {
        text: line.text.slice(simulateBreak - line.from),
        from: simulateBreak
      };else return {
        text: line.text.slice(0, simulateBreak - line.from),
        from: line.from
      };
    }

    return line;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */


  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return "";
    let {
      text,
      from
    } = this.lineAt(pos, bias);
    return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
  }
  /**
  Find the column for the given position.
  */


  column(pos, bias = 1) {
    let {
      text,
      from
    } = this.lineAt(pos, bias);
    let result = this.countColumn(text, pos - from);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
    if (override > -1) result += override - this.countColumn(text, text.search(/\S|$/));
    return result;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */


  countColumn(line, pos = line.length) {
    return (0, _text.countColumn)(line, this.state.tabSize, pos);
  }
  /**
  Find the indentation column of the line at the given point.
  */


  lineIndent(pos, bias = 1) {
    let {
      text,
      from
    } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;

    if (override) {
      let overriden = override(from);
      if (overriden > -1) return overriden;
    }

    return this.countColumn(text, text.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */


  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }

}
/**
A syntax tree node prop used to associate indentation strategies
with node types. Such a strategy is a function from an indentation
context to a column number or null, where null indicates that no
definitive indentation can be determined.
*/


exports.IndentContext = IndentContext;
const indentNodeProp = /*@__PURE__*/new _common.NodeProp(); // Compute the indentation for a given position from the syntax tree.

exports.indentNodeProp = indentNodeProp;

function syntaxIndentation(cx, ast, pos) {
  return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
}

function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}

function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy) return strategy;
  let first = tree.firstChild,
      close;

  if (first && (close = first.type.prop(_common.NodeProp.closedBy))) {
    let last = tree.lastChild,
        closed = last && close.indexOf(last.name) > -1;
    return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);
  }

  return tree.parent == null ? topIndent : null;
}

function indentFrom(node, pos, base) {
  for (; node; node = node.parent) {
    let strategy = indentStrategy(node);
    if (strategy) return strategy(new TreeIndentContext(base, pos, node));
  }

  return null;
}

function topIndent() {
  return 0;
}
/**
Objects of this type provide context information and helper
methods to indentation functions.
*/


class TreeIndentContext extends IndentContext {
  /**
  @internal
  */
  constructor(base,
  /**
  The position at which indentation is being computed.
  */
  pos,
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  node) {
    super(base.state, base.options);
    this.base = base;
    this.pos = pos;
    this.node = node;
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */


  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */


  get baseIndent() {
    let line = this.state.doc.lineAt(this.node.from); // Skip line starts that are covered by a sibling (or cousin, etc)

    for (;;) {
      let atBreak = this.node.resolve(line.from);

      while (atBreak.parent && atBreak.parent.from == atBreak.from) atBreak = atBreak.parent;

      if (isParent(atBreak, this.node)) break;
      line = this.state.doc.lineAt(atBreak.from);
    }

    return this.lineIndent(line.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */


  continue() {
    let parent = this.node.parent;
    return parent ? indentFrom(parent, this.pos, this.base) : 0;
  }

}

exports.TreeIndentContext = TreeIndentContext;

function isParent(parent, of) {
  for (let cur = of; cur; cur = cur.parent) if (parent == cur) return true;

  return false;
} // Check whether a delimited node is aligned (meaning there are
// non-skipped nodes on the same line as the opening delimiter). And
// if so, return the opening token.


function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from),
      last = tree.lastChild;
  if (!openToken) return null;
  let sim = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);

  for (let pos = openToken.to;;) {
    let next = tree.childAfter(pos);
    if (!next || next == last) return null;
    if (!next.type.isSkipped) return next.from < lineEnd ? openToken : null;
    pos = next.to;
  }
}
/**
An indentation strategy for delimited (usually bracketed) nodes.
Will, by default, indent one unit more than the parent's base
indent unless the line starts with a closing token. When `align`
is true and there are non-skipped nodes on the node's opening
line, the content of the node will be aligned with the end of the
opening node, like this:

    foo(bar,
        baz)
*/


function delimitedIndent({
  closing,
  align = true,
  units = 1
}) {
  return context => delimitedStrategy(context, align, units, closing);
}

function delimitedStrategy(context, align, units, closing, closedAt) {
  let after = context.textAfter,
      space = after.match(/^\s*/)[0].length;
  let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
/**
An indentation strategy that aligns a node's content to its base
indentation.
*/


const flatIndent = context => context.baseIndent;
/**
Creates an indentation strategy that, by default, indents
continued lines one unit more than the node's base indentation.
You can provide `except` to prevent indentation of lines that
match a pattern (for example `/^else\b/` in `if`/`else`
constructs), and you can change the amount of units used with the
`units` option.
*/


exports.flatIndent = flatIndent;

function continuedIndent({
  except,
  units = 1
} = {}) {
  return context => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}

const DontIndentBeyond = 200;
/**
Enables reindentation on input. When a language defines an
`indentOnInput` field in its [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular
expression, the line at the cursor will be reindented whenever new
text is typed and the input from the start of the line up to the
cursor matches that regexp.

To avoid unneccesary reindents, it is recommended to start the
regexp with `^` (usually followed by `\s*`), and end it with `$`.
For example, `/^\s*\}$/` will reindent when a closing brace is
added at the start of a line.
*/

function indentOnInput() {
  return _state.EditorState.transactionFilter.of(tr => {
    if (!tr.docChanged || !tr.isUserEvent("input.type")) return tr;
    let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
    if (!rules.length) return tr;
    let doc = tr.newDoc,
        {
      head
    } = tr.newSelection.main,
        line = doc.lineAt(head);
    if (head > line.from + DontIndentBeyond) return tr;
    let lineStart = doc.sliceString(line.from, head);
    if (!rules.some(r => r.test(lineStart))) return tr;
    let {
      state
    } = tr,
        last = -1,
        changes = [];

    for (let {
      head
    } of state.selection.ranges) {
      let line = state.doc.lineAt(head);
      if (line.from == last) continue;
      last = line.from;
      let indent = getIndentation(state, line.from);
      if (indent == null) continue;
      let cur = /^\s*/.exec(line.text)[0];
      let norm = indentString(state, indent);
      if (cur != norm) changes.push({
        from: line.from,
        to: line.from + cur.length,
        insert: norm
      });
    }

    return changes.length ? [tr, {
      changes,
      sequential: true
    }] : tr;
  });
}
/**
A facet that registers a code folding service. When called with
the extent of a line, such a function should return a foldable
range that starts on that line (but continues beyond it), if one
can be found.
*/


const foldService = /*@__PURE__*/_state.Facet.define();
/**
This node prop is used to associate folding information with
syntax node types. Given a syntax node, it should check whether
that tree is foldable and return the range that can be collapsed
when it is.
*/


exports.foldService = foldService;
const foldNodeProp = /*@__PURE__*/new _common.NodeProp();
/**
[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but
the first and the last child of a syntax node. Useful for nodes
that start and end with delimiters.
*/

exports.foldNodeProp = foldNodeProp;

function foldInside(node) {
  let first = node.firstChild,
      last = node.lastChild;
  return first && first.to < last.from ? {
    from: first.to,
    to: last.type.isError ? node.to : last.from
  } : null;
}

function syntaxFolding(state, start, end) {
  let tree = syntaxTree(state);
  if (tree.length == 0) return null;
  let inner = tree.resolveInner(end);
  let found = null;

  for (let cur = inner; cur; cur = cur.parent) {
    if (cur.to <= end || cur.from > end) continue;
    if (found && cur.from < start) break;
    let prop = cur.type.prop(foldNodeProp);

    if (prop) {
      let value = prop(cur, state);
      if (value && value.from <= end && value.from >= start && value.to > end) found = value;
    }
  }

  return found;
}
/**
Check whether the given line is foldable. First asks any fold
services registered through
[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return
a result, tries to query the [fold node
prop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end
of the line.
*/


function foldable(state, lineStart, lineEnd) {
  for (let service of state.facet(foldService)) {
    let result = service(state, lineStart, lineEnd);
    if (result) return result;
  }

  return syntaxFolding(state, lineStart, lineEnd);
}
},{"@lezer/common":"node_modules/@lezer/common/dist/index.js","@codemirror/state":"node_modules/@codemirror/state/dist/index.js","@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/text":"node_modules/@codemirror/text/dist/index.js"}],"node_modules/@codemirror/gutter/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gutter = gutter;
exports.gutters = gutters;
exports.highlightActiveLineGutter = highlightActiveLineGutter;
exports.lineNumbers = lineNumbers;
exports.lineNumberMarkers = exports.gutterLineClass = exports.GutterMarker = void 0;

var _view2 = require("@codemirror/view");

var _rangeset = require("@codemirror/rangeset");

var _state = require("@codemirror/state");

/**
A gutter marker represents a bit of information attached to a line
in a specific gutter. Your own custom markers have to extend this
class.
*/
class GutterMarker extends _rangeset.RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  Compare this marker to another marker of the same type.
  */


  eq(other) {
    return false;
  }

}

exports.GutterMarker = GutterMarker;
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = undefined;
GutterMarker.prototype.mapMode = _state.MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
/**
Facet used to add a class to all gutter elements for a given line.
Markers given to this facet should _only_ define an
[`elementclass`](https://codemirror.net/6/docs/ref/#gutter.GutterMarker.elementClass), not a
[`toDOM`](https://codemirror.net/6/docs/ref/#gutter.GutterMarker.toDOM) (or the marker will appear
in all gutters for the line).
*/

const gutterLineClass = /*@__PURE__*/_state.Facet.define();

exports.gutterLineClass = gutterLineClass;
const defaults = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => _rangeset.RangeSet.empty,
  lineMarker: () => null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};

const activeGutters = /*@__PURE__*/_state.Facet.define();
/**
Define an editor gutter. The order in which the gutters appear is
determined by their extension priority.
*/


function gutter(config) {
  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
}

const baseTheme = /*@__PURE__*/_view2.EditorView.baseTheme({
  ".cm-gutters": {
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#999",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    height: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  }
});

const unfixGutters = /*@__PURE__*/_state.Facet.define({
  combine: values => values.some(x => x)
});
/**
The gutter-drawing plugin is automatically enabled when you add a
gutter, but you can use this function to explicitly configure it.

Unless `fixed` is explicitly set to `false`, the gutters are
fixed, meaning they don't scroll along with the content
horizontally (except on Internet Explorer, which doesn't support
CSS [`position:
sticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).
*/


function gutters(config) {
  let result = [gutterView, baseTheme];
  if (config && config.fixed === false) result.push(unfixGutters.of(true));
  return result;
}

const gutterView = /*@__PURE__*/_view2.ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters";
    this.dom.setAttribute("aria-hidden", "true");
    this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));

    for (let gutter of this.gutters) this.dom.appendChild(gutter.dom);

    this.fixed = !view.state.facet(unfixGutters);

    if (this.fixed) {
      // FIXME IE11 fallback, which doesn't support position: sticky,
      // by using position: relative + event handlers that realign the
      // gutter (or just force fixed=false on IE11?)
      this.dom.style.position = "sticky";
    }

    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    this.syncGutters();
  }

  update(update) {
    if (this.updateGutters(update)) this.syncGutters();
  }

  syncGutters() {
    let lineClasses = _rangeset.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);

    let classSet = [];
    let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport));
    this.view.viewportLines(line => {
      let text;

      if (Array.isArray(line.type)) {
        for (let b of line.type) if (b.type == _view2.BlockType.Text) {
          text = b;
          break;
        }
      } else {
        text = line.type == _view2.BlockType.Text ? line : undefined;
      }

      if (!text) return;
      if (classSet.length) classSet = [];
      advanceCursor(lineClasses, classSet, line.from);

      for (let cx of contexts) cx.line(this.view, text, classSet);
    }, 0);

    for (let cx of contexts) cx.finish();

    this.dom.style.minHeight = this.view.contentHeight + "px";

    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
    }
  }

  updateGutters(update) {
    let prev = update.startState.facet(activeGutters),
        cur = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged || !_rangeset.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);

    if (prev == cur) {
      for (let gutter of this.gutters) if (gutter.update(update)) change = true;
    } else {
      change = true;
      let gutters = [];

      for (let conf of cur) {
        let known = prev.indexOf(conf);

        if (known < 0) {
          gutters.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters.push(this.gutters[known]);
        }
      }

      for (let g of this.gutters) g.dom.remove();

      for (let g of gutters) this.dom.appendChild(g.dom);

      this.gutters = gutters;
    }

    return change;
  }

  destroy() {
    this.dom.remove();
  }

}, {
  provide: /*@__PURE__*/_view2.PluginField.scrollMargins.from(value => {
    if (value.gutters.length == 0 || !value.fixed) return null;
    return value.view.textDirection == _view2.Direction.LTR ? {
      left: value.dom.offsetWidth
    } : {
      right: value.dom.offsetWidth
    };
  })
});

function asArray(val) {
  return Array.isArray(val) ? val : [val];
}

function advanceCursor(cursor, collect, pos) {
  while (cursor.value && cursor.from <= pos) {
    if (cursor.from == pos) collect.push(cursor.value);
    cursor.next();
  }
}

class UpdateContext {
  constructor(gutter, viewport) {
    this.gutter = gutter;
    this.localMarkers = [];
    this.i = 0;
    this.height = 0;
    this.cursor = _rangeset.RangeSet.iter(gutter.markers, viewport.from);
  }

  line(view, line, extraMarkers) {
    if (this.localMarkers.length) this.localMarkers = [];
    advanceCursor(this.cursor, this.localMarkers, line.from);
    let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine) localMarkers.unshift(forLine);
    let gutter = this.gutter;
    if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;
    let above = line.top - this.height;

    if (this.i == gutter.elements.length) {
      let newElt = new GutterElement(view, line.height, above, localMarkers);
      gutter.elements.push(newElt);
      gutter.dom.appendChild(newElt.dom);
    } else {
      let elt = gutter.elements[this.i];
      if (sameMarkers(localMarkers, elt.markers)) localMarkers = elt.markers;
      elt.update(view, line.height, above, localMarkers);
    }

    this.height = line.bottom;
    this.i++;
  }

  finish() {
    let gutter = this.gutter;

    while (gutter.elements.length > this.i) gutter.dom.removeChild(gutter.elements.pop().dom);
  }

}

class SingleGutterView {
  constructor(view, config) {
    this.view = view;
    this.config = config;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");

    for (let prop in config.domEventHandlers) {
      this.dom.addEventListener(prop, event => {
        let line = view.visualLineAtHeight(event.clientY, view.contentDOM.getBoundingClientRect().top);
        if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();
      });
    }

    this.markers = asArray(config.markers(view));

    if (config.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }

  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray(this.config.markers(update.view));

    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [updated]);
    }

    let vp = update.view.viewport;
    return !_rangeset.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to);
  }

}

class GutterElement {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.dom = document.createElement("div");
    this.update(view, height, above, markers);
  }

  update(view, height, above, markers) {
    if (this.height != height) this.dom.style.height = (this.height = height) + "px";
    if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + "px" : "";

    if (this.markers != markers) {
      this.markers = markers;

      for (let ch; ch = this.dom.lastChild;) ch.remove();

      let cls = "cm-gutterElement";

      for (let m of markers) {
        if (m.toDOM) this.dom.appendChild(m.toDOM(view));
        let c = m.elementClass;
        if (c) cls += " " + c;
      }

      this.dom.className = cls;
    }
  }

}

function sameMarkers(a, b) {
  if (a.length != b.length) return false;

  for (let i = 0; i < a.length; i++) if (!a[i].compare(b[i])) return false;

  return true;
}
/**
Facet used to provide markers to the line number gutter.
*/


const lineNumberMarkers = /*@__PURE__*/_state.Facet.define();

exports.lineNumberMarkers = lineNumberMarkers;

const lineNumberConfig = /*@__PURE__*/_state.Facet.define({
  combine(values) {
    return (0, _state.combineConfig)(values, {
      formatNumber: String,
      domEventHandlers: {}
    }, {
      domEventHandlers(a, b) {
        let result = Object.assign({}, a);

        for (let event in b) {
          let exists = result[event],
              add = b[event];
          result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;
        }

        return result;
      }

    });
  }

});

class NumberMarker extends GutterMarker {
  constructor(number) {
    super();
    this.number = number;
  }

  eq(other) {
    return this.number == other.number;
  }

  toDOM(_view) {
    return document.createTextNode(this.number);
  }

}

function formatNumber(view, number) {
  return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
}

const lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,

  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },

  lineMarker(view, line, others) {
    if (others.some(m => m.toDOM)) return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },

  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },

  updateSpacer(spacer, update) {
    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max == spacer.number ? spacer : new NumberMarker(max);
  },

  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
/**
Create a line number gutter extension.
*/

function lineNumbers(config = {}) {
  return [lineNumberConfig.of(config), gutters(), lineNumberGutter];
}

function maxLineNumber(lines) {
  let last = 9;

  while (last < lines) last = last * 10 + 9;

  return last;
}

const activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }

}();
const activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute(["selection"], state => {
  let marks = [],
      last = -1;

  for (let range of state.selection.ranges) if (range.empty) {
    let linePos = state.doc.lineAt(range.head).from;

    if (linePos > last) {
      last = linePos;
      marks.push(activeLineGutterMarker.range(linePos));
    }
  }

  return _rangeset.RangeSet.of(marks);
});
/**
Returns an extension that adds a `cm-activeLineGutter` class to
all gutter elements on the [active
line](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).
*/

function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}
},{"@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/rangeset":"node_modules/@codemirror/rangeset/dist/index.js","@codemirror/state":"node_modules/@codemirror/state/dist/index.js"}],"node_modules/@codemirror/fold/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.codeFolding = codeFolding;
exports.foldGutter = foldGutter;
exports.foldedRanges = foldedRanges;
exports.unfoldEffect = exports.unfoldCode = exports.unfoldAll = exports.foldKeymap = exports.foldEffect = exports.foldCode = exports.foldAll = void 0;

var _state = require("@codemirror/state");

var _view = require("@codemirror/view");

var _language = require("@codemirror/language");

var _gutter = require("@codemirror/gutter");

var _rangeset = require("@codemirror/rangeset");

function mapRange(range, mapping) {
  let from = mapping.mapPos(range.from, 1),
      to = mapping.mapPos(range.to, -1);
  return from >= to ? undefined : {
    from,
    to
  };
}
/**
State effect that can be attached to a transaction to fold the
given range. (You probably only need this in exceptional
circumstances—usually you'll just want to let
[`foldCode`](https://codemirror.net/6/docs/ref/#fold.foldCode) and the [fold
gutter](https://codemirror.net/6/docs/ref/#fold.foldGutter) create the transactions.)
*/


const foldEffect = /*@__PURE__*/_state.StateEffect.define({
  map: mapRange
});
/**
State effect that unfolds the given range (if it was folded).
*/


exports.foldEffect = foldEffect;

const unfoldEffect = /*@__PURE__*/_state.StateEffect.define({
  map: mapRange
});

exports.unfoldEffect = unfoldEffect;

function selectedLines(view) {
  let lines = [];

  for (let {
    head
  } of view.state.selection.ranges) {
    if (lines.some(l => l.from <= head && l.to >= head)) continue;
    lines.push(view.visualLineAt(head));
  }

  return lines;
}

const foldState = /*@__PURE__*/_state.StateField.define({
  create() {
    return _view.Decoration.none;
  },

  update(folded, tr) {
    folded = folded.map(tr.changes);

    for (let e of tr.effects) {
      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) folded = folded.update({
        add: [foldWidget.range(e.value.from, e.value.to)]
      });else if (e.is(unfoldEffect)) folded = folded.update({
        filter: (from, to) => e.value.from != from || e.value.to != to,
        filterFrom: e.value.from,
        filterTo: e.value.to
      });
    } // Clear folded ranges that cover the selection head


    if (tr.selection) {
      let onSelection = false,
          {
        head
      } = tr.selection.main;
      folded.between(head, head, (a, b) => {
        if (a < head && b > head) onSelection = true;
      });
      if (onSelection) folded = folded.update({
        filterFrom: head,
        filterTo: head,
        filter: (a, b) => b <= head || a >= head
      });
    }

    return folded;
  },

  provide: f => _view.EditorView.decorations.from(f)
});
/**
Get a [range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) containing the folded ranges
in the given state.
*/


function foldedRanges(state) {
  return state.field(foldState, false) || _rangeset.RangeSet.empty;
}

function foldInside(state, from, to) {
  var _a;

  let found = null;
  (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {
    if (!found || found.from > from) found = {
      from,
      to
    };
  });
  return found;
}

function foldExists(folded, from, to) {
  let found = false;
  folded.between(from, from, (a, b) => {
    if (a == from && b == to) found = true;
  });
  return found;
}

function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(_state.StateEffect.appendConfig.of(codeFolding()));
}
/**
Fold the lines that are selected, if possible.
*/


const foldCode = view => {
  for (let line of selectedLines(view)) {
    let range = (0, _language.foldable)(view.state, line.from, line.to);

    if (range) {
      view.dispatch({
        effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)])
      });
      return true;
    }
  }

  return false;
};
/**
Unfold folded ranges on selected lines.
*/


exports.foldCode = foldCode;

const unfoldCode = view => {
  if (!view.state.field(foldState, false)) return false;
  let effects = [];

  for (let line of selectedLines(view)) {
    let folded = foldInside(view.state, line.from, line.to);
    if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
  }

  if (effects.length) view.dispatch({
    effects
  });
  return effects.length > 0;
};

exports.unfoldCode = unfoldCode;

function announceFold(view, range, fold = true) {
  let lineFrom = view.state.doc.lineAt(range.from).number,
      lineTo = view.state.doc.lineAt(range.to).number;
  return _view.EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
/**
Fold all top-level foldable ranges.
*/


const foldAll = view => {
  let {
    state
  } = view,
      effects = [];

  for (let pos = 0; pos < state.doc.length;) {
    let line = view.visualLineAt(pos),
        range = (0, _language.foldable)(state, line.from, line.to);
    if (range) effects.push(foldEffect.of(range));
    pos = (range ? view.visualLineAt(range.to) : line).to + 1;
  }

  if (effects.length) view.dispatch({
    effects: maybeEnable(view.state, effects)
  });
  return !!effects.length;
};
/**
Unfold all folded code.
*/


exports.foldAll = foldAll;

const unfoldAll = view => {
  let field = view.state.field(foldState, false);
  if (!field || !field.size) return false;
  let effects = [];
  field.between(0, view.state.doc.length, (from, to) => {
    effects.push(unfoldEffect.of({
      from,
      to
    }));
  });
  view.dispatch({
    effects
  });
  return true;
};
/**
Default fold-related key bindings.

 - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#fold.foldCode).
 - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#fold.unfoldCode).
 - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#fold.foldAll).
 - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#fold.unfoldAll).
*/


exports.unfoldAll = unfoldAll;
const foldKeymap = [{
  key: "Ctrl-Shift-[",
  mac: "Cmd-Alt-[",
  run: foldCode
}, {
  key: "Ctrl-Shift-]",
  mac: "Cmd-Alt-]",
  run: unfoldCode
}, {
  key: "Ctrl-Alt-[",
  run: foldAll
}, {
  key: "Ctrl-Alt-]",
  run: unfoldAll
}];
exports.foldKeymap = foldKeymap;
const defaultConfig = {
  placeholderDOM: null,
  placeholderText: "…"
};

const foldConfig = /*@__PURE__*/_state.Facet.define({
  combine(values) {
    return (0, _state.combineConfig)(values, defaultConfig);
  }

});
/**
Create an extension that configures code folding.
*/


function codeFolding(config) {
  let result = [foldState, baseTheme];
  if (config) result.push(foldConfig.of(config));
  return result;
}

const foldWidget = /*@__PURE__*/_view.Decoration.replace({
  widget: /*@__PURE__*/new class extends _view.WidgetType {
    ignoreEvents() {
      return false;
    }

    toDOM(view) {
      let {
        state
      } = view,
          conf = state.facet(foldConfig);
      if (conf.placeholderDOM) return conf.placeholderDOM();
      let element = document.createElement("span");
      element.textContent = conf.placeholderText;
      element.setAttribute("aria-label", state.phrase("folded code"));
      element.title = state.phrase("unfold");
      element.className = "cm-foldPlaceholder";

      element.onclick = event => {
        let line = view.visualLineAt(view.posAtDOM(event.target));
        let folded = foldInside(view.state, line.from, line.to);
        if (folded) view.dispatch({
          effects: unfoldEffect.of(folded)
        });
        event.preventDefault();
      };

      return element;
    }

  }()
});

const foldGutterDefaults = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null
};

class FoldMarker extends _gutter.GutterMarker {
  constructor(config, open) {
    super();
    this.config = config;
    this.open = open;
  }

  eq(other) {
    return this.config == other.config && this.open == other.open;
  }

  toDOM(view) {
    if (this.config.markerDOM) return this.config.markerDOM(this.open);
    let span = document.createElement("span");
    span.textContent = this.open ? this.config.openText : this.config.closedText;
    span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
    return span;
  }

}
/**
Create an extension that registers a fold gutter, which shows a
fold status indicator before foldable lines (which can be clicked
to fold or unfold the line).
*/


function foldGutter(config = {}) {
  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);
  let canFold = new FoldMarker(fullConfig, true),
      canUnfold = new FoldMarker(fullConfig, false);

  let markers = _view.ViewPlugin.fromClass(class {
    constructor(view) {
      this.from = view.viewport.from;
      this.markers = this.buildMarkers(view);
    }

    update(update) {
      if (update.docChanged || update.viewportChanged || update.startState.facet(_language.language) != update.state.facet(_language.language) || update.startState.field(foldState, false) != update.state.field(foldState, false)) this.markers = this.buildMarkers(update.view);
    }

    buildMarkers(view) {
      let builder = new _rangeset.RangeSetBuilder();
      view.viewportLines(line => {
        let mark = foldInside(view.state, line.from, line.to) ? canUnfold : (0, _language.foldable)(view.state, line.from, line.to) ? canFold : null;
        if (mark) builder.add(line.from, line.from, mark);
      });
      return builder.finish();
    }

  });

  return [markers, (0, _gutter.gutter)({
    class: "cm-foldGutter",

    markers(view) {
      var _a;

      return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _rangeset.RangeSet.empty;
    },

    initialSpacer() {
      return new FoldMarker(fullConfig, false);
    },

    domEventHandlers: {
      click: (view, line) => {
        let folded = foldInside(view.state, line.from, line.to);

        if (folded) {
          view.dispatch({
            effects: unfoldEffect.of(folded)
          });
          return true;
        }

        let range = (0, _language.foldable)(view.state, line.from, line.to);

        if (range) {
          view.dispatch({
            effects: foldEffect.of(range)
          });
          return true;
        }

        return false;
      }
    }
  }), codeFolding()];
}

const baseTheme = /*@__PURE__*/_view.EditorView.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter .cm-gutterElement": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
},{"@codemirror/state":"node_modules/@codemirror/state/dist/index.js","@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/language":"node_modules/@codemirror/language/dist/index.js","@codemirror/gutter":"node_modules/@codemirror/gutter/dist/index.js","@codemirror/rangeset":"node_modules/@codemirror/rangeset/dist/index.js"}],"node_modules/@codemirror/matchbrackets/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bracketMatching = bracketMatching;
exports.matchBrackets = matchBrackets;

var _state2 = require("@codemirror/state");

var _language = require("@codemirror/language");

var _view = require("@codemirror/view");

var _common = require("@lezer/common");

const baseTheme = /*@__PURE__*/_view.EditorView.baseTheme({
  ".cm-matchingBracket": {
    backgroundColor: "#328c8252"
  },
  ".cm-nonmatchingBracket": {
    backgroundColor: "#bb555544"
  }
});

const DefaultScanDist = 10000,
      DefaultBrackets = "()[]{}";

const bracketMatchingConfig = /*@__PURE__*/_state2.Facet.define({
  combine(configs) {
    return (0, _state2.combineConfig)(configs, {
      afterCursor: true,
      brackets: DefaultBrackets,
      maxScanDistance: DefaultScanDist
    });
  }

});

const matchingMark = /*@__PURE__*/_view.Decoration.mark({
  class: "cm-matchingBracket"
}),
      nonmatchingMark = /*@__PURE__*/_view.Decoration.mark({
  class: "cm-nonmatchingBracket"
});

const bracketMatchingState = /*@__PURE__*/_state2.StateField.define({
  create() {
    return _view.Decoration.none;
  },

  update(deco, tr) {
    if (!tr.docChanged && !tr.selection) return deco;
    let decorations = [];
    let config = tr.state.facet(bracketMatchingConfig);

    for (let range of tr.state.selection.ranges) {
      if (!range.empty) continue;
      let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));
      if (!match) continue;
      let mark = match.matched ? matchingMark : nonmatchingMark;
      decorations.push(mark.range(match.start.from, match.start.to));
      if (match.end) decorations.push(mark.range(match.end.from, match.end.to));
    }

    return _view.Decoration.set(decorations, true);
  },

  provide: f => _view.EditorView.decorations.from(f)
});

const bracketMatchingUnique = [bracketMatchingState, baseTheme];
/**
Create an extension that enables bracket matching. Whenever the
cursor is next to a bracket, that bracket and the one it matches
are highlighted. Or, when no matching bracket is found, another
highlighting style is used to indicate this.
*/

function bracketMatching(config = {}) {
  return [bracketMatchingConfig.of(config), bracketMatchingUnique];
}

function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? _common.NodeProp.openedBy : _common.NodeProp.closedBy);
  if (byProp) return byProp;

  if (node.name.length == 1) {
    let index = brackets.indexOf(node.name);
    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [brackets[index + dir]];
  }

  return null;
}
/**
Find the matching bracket for the token at `pos`, scanning
direction `dir`. Only the `brackets` and `maxScanDistance`
properties are used from `config`, if given. Returns null if no
bracket was found at `pos`, or a match result otherwise.
*/


function matchBrackets(state, pos, dir, config = {}) {
  let maxScanDistance = config.maxScanDistance || DefaultScanDist,
      brackets = config.brackets || DefaultBrackets;
  let tree = (0, _language.syntaxTree)(state),
      node = tree.resolveInner(pos, dir);

  for (let cur = node; cur; cur = cur.parent) {
    let matches = matchingNodes(cur.type, dir, brackets);
    if (matches) return matchMarkedBrackets(state, pos, dir, cur, matches, brackets);
  }

  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}

function matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {
  let parent = token.parent,
      firstToken = {
    from: token.from,
    to: token.to
  };
  let depth = 0,
      cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;
  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {
    if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
      if (depth == 0 && matching.indexOf(cursor.type.name) > -1) {
        return {
          start: firstToken,
          end: {
            from: cursor.from,
            to: cursor.to
          },
          matched: true
        };
      } else if (matchingNodes(cursor.type, dir, brackets)) {
        depth++;
      } else if (matchingNodes(cursor.type, -dir, brackets)) {
        depth--;
        if (depth == 0) return {
          start: firstToken,
          end: {
            from: cursor.from,
            to: cursor.to
          },
          matched: false
        };
      }
    }
  } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
  return {
    start: firstToken,
    matched: false
  };
}

function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket = brackets.indexOf(startCh);
  if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;
  let startToken = {
    from: dir < 0 ? pos - 1 : pos,
    to: dir > 0 ? pos + 1 : pos
  };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),
      depth = 0;

  for (let distance = 0; !iter.next().done && distance <= maxScanDistance;) {
    let text = iter.value;
    if (dir < 0) distance += text.length;
    let basePos = pos + distance * dir;

    for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {
      let found = brackets.indexOf(text[pos]);
      if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType) continue;

      if (found % 2 == 0 == dir > 0) {
        depth++;
      } else if (depth == 1) {
        // Closing
        return {
          start: startToken,
          end: {
            from: basePos + pos,
            to: basePos + pos + 1
          },
          matched: found >> 1 == bracket >> 1
        };
      } else {
        depth--;
      }
    }

    if (dir > 0) distance += text.length;
  }

  return iter.done ? {
    start: startToken,
    matched: false
  } : null;
}
},{"@codemirror/state":"node_modules/@codemirror/state/dist/index.js","@codemirror/language":"node_modules/@codemirror/language/dist/index.js","@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@lezer/common":"node_modules/@lezer/common/dist/index.js"}],"node_modules/@codemirror/commands/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transposeChars = exports.standardKeymap = exports.splitLine = exports.simplifySelection = exports.selectSyntaxRight = exports.selectSyntaxLeft = exports.selectSubwordForward = exports.selectSubwordBackward = exports.selectParentSyntax = exports.selectPageUp = exports.selectPageDown = exports.selectMatchingBracket = exports.selectLineUp = exports.selectLineStart = exports.selectLineEnd = exports.selectLineDown = exports.selectLineBoundaryForward = exports.selectLineBoundaryBackward = exports.selectLine = exports.selectGroupRight = exports.selectGroupLeft = exports.selectGroupForward = exports.selectGroupBackward = exports.selectDocStart = exports.selectDocEnd = exports.selectCharRight = exports.selectCharLeft = exports.selectCharForward = exports.selectCharBackward = exports.selectAll = exports.moveLineUp = exports.moveLineDown = exports.insertTab = exports.insertNewlineAndIndent = exports.insertNewline = exports.insertBlankLine = exports.indentWithTab = exports.indentSelection = exports.indentMore = exports.indentLess = exports.emacsStyleKeymap = exports.deleteTrailingWhitespace = exports.deleteToLineStart = exports.deleteToLineEnd = exports.deleteLine = exports.deleteGroupForward = exports.deleteGroupBackward = exports.deleteCharForward = exports.deleteCharBackward = exports.defaultKeymap = exports.cursorSyntaxRight = exports.cursorSyntaxLeft = exports.cursorSubwordForward = exports.cursorSubwordBackward = exports.cursorPageUp = exports.cursorPageDown = exports.cursorMatchingBracket = exports.cursorLineUp = exports.cursorLineStart = exports.cursorLineEnd = exports.cursorLineDown = exports.cursorLineBoundaryForward = exports.cursorLineBoundaryBackward = exports.cursorGroupRight = exports.cursorGroupLeft = exports.cursorGroupForward = exports.cursorGroupBackward = exports.cursorDocStart = exports.cursorDocEnd = exports.cursorCharRight = exports.cursorCharLeft = exports.cursorCharForward = exports.cursorCharBackward = exports.copyLineUp = exports.copyLineDown = void 0;

var _state = require("@codemirror/state");

var _text = require("@codemirror/text");

var _view = require("@codemirror/view");

var _matchbrackets = require("@codemirror/matchbrackets");

var _language = require("@codemirror/language");

var _common = require("@lezer/common");

function updateSel(sel, by) {
  return _state.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}

function setSel(state, selection) {
  return state.update({
    selection,
    scrollIntoView: true,
    userEvent: "select"
  });
}

function moveSel({
  state,
  dispatch
}, how) {
  let selection = updateSel(state.selection, how);
  if (selection.eq(state.selection)) return false;
  dispatch(setSel(state, selection));
  return true;
}

function rangeEnd(range, forward) {
  return _state.EditorSelection.cursor(forward ? range.to : range.from);
}

function cursorByChar(view, forward) {
  return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
/**
Move the selection one character to the left (which is backward in
left-to-right text, forward in right-to-left text).
*/


const cursorCharLeft = view => cursorByChar(view, view.textDirection != _view.Direction.LTR);
/**
Move the selection one character to the right.
*/


exports.cursorCharLeft = cursorCharLeft;

const cursorCharRight = view => cursorByChar(view, view.textDirection == _view.Direction.LTR);
/**
Move the selection one character forward.
*/


exports.cursorCharRight = cursorCharRight;

const cursorCharForward = view => cursorByChar(view, true);
/**
Move the selection one character backward.
*/


exports.cursorCharForward = cursorCharForward;

const cursorCharBackward = view => cursorByChar(view, false);

exports.cursorCharBackward = cursorCharBackward;

function cursorByGroup(view, forward) {
  return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
/**
Move the selection to the left across one group of word or
non-word (but also non-space) characters.
*/


const cursorGroupLeft = view => cursorByGroup(view, view.textDirection != _view.Direction.LTR);
/**
Move the selection one group to the right.
*/


exports.cursorGroupLeft = cursorGroupLeft;

const cursorGroupRight = view => cursorByGroup(view, view.textDirection == _view.Direction.LTR);
/**
Move the selection one group forward.
*/


exports.cursorGroupRight = cursorGroupRight;

const cursorGroupForward = view => cursorByGroup(view, true);
/**
Move the selection one group backward.
*/


exports.cursorGroupForward = cursorGroupForward;

const cursorGroupBackward = view => cursorByGroup(view, false);

exports.cursorGroupBackward = cursorGroupBackward;

function moveBySubword(view, range, forward) {
  let categorize = view.state.charCategorizer(range.from);
  return view.moveByChar(range, forward, start => {
    let cat = _state.CharCategory.Space,
        pos = range.from;
    let done = false,
        sawUpper = false,
        sawLower = false;

    let step = next => {
      if (done) return false;
      pos += forward ? next.length : -next.length;
      let nextCat = categorize(next),
          ahead;
      if (cat == _state.CharCategory.Space) cat = nextCat;
      if (cat != nextCat) return false;

      if (cat == _state.CharCategory.Word) {
        if (next.toLowerCase() == next) {
          if (!forward && sawUpper) return false;
          sawLower = true;
        } else if (sawLower) {
          if (forward) return false;
          done = true;
        } else {
          if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _state.CharCategory.Word && ahead.toLowerCase() == ahead) return false;
          sawUpper = true;
        }
      }

      return true;
    };

    step(start);
    return step;
  });
}

function cursorBySubword(view, forward) {
  return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));
}
/**
Move the selection one group or camel-case subword forward.
*/


const cursorSubwordForward = view => cursorBySubword(view, true);
/**
Move the selection one group or camel-case subword backward.
*/


exports.cursorSubwordForward = cursorSubwordForward;

const cursorSubwordBackward = view => cursorBySubword(view, false);

exports.cursorSubwordBackward = cursorSubwordBackward;

function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp)) return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}

function moveBySyntax(state, start, forward) {
  let pos = (0, _language.syntaxTree)(state).resolveInner(start.head);
  let bracketProp = forward ? _common.NodeProp.closedBy : _common.NodeProp.openedBy; // Scan forward through child nodes to see if there's an interesting
  // node ahead.

  for (let at = start.head;;) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next) break;
    if (interestingNode(state, next, bracketProp)) pos = next;else at = forward ? next.to : next.from;
  }

  let bracket = pos.type.prop(bracketProp),
      match,
      newPos;
  if (bracket && (match = forward ? (0, _matchbrackets.matchBrackets)(state, pos.from, 1) : (0, _matchbrackets.matchBrackets)(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;else newPos = forward ? pos.to : pos.from;
  return _state.EditorSelection.cursor(newPos, forward ? -1 : 1);
}
/**
Move the cursor over the next syntactic element to the left.
*/


const cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, view.textDirection != _view.Direction.LTR));
/**
Move the cursor over the next syntactic element to the right.
*/


exports.cursorSyntaxLeft = cursorSyntaxLeft;

const cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, view.textDirection == _view.Direction.LTR));

exports.cursorSyntaxRight = cursorSyntaxRight;

function cursorByLine(view, forward) {
  return moveSel(view, range => {
    if (!range.empty) return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
/**
Move the selection one line up.
*/


const cursorLineUp = view => cursorByLine(view, false);
/**
Move the selection one line down.
*/


exports.cursorLineUp = cursorLineUp;

const cursorLineDown = view => cursorByLine(view, true);

exports.cursorLineDown = cursorLineDown;

function cursorByPage(view, forward) {
  return moveSel(view, range => range.empty ? view.moveVertically(range, forward, view.dom.clientHeight) : rangeEnd(range, forward));
}
/**
Move the selection one page up.
*/


const cursorPageUp = view => cursorByPage(view, false);
/**
Move the selection one page down.
*/


exports.cursorPageUp = cursorPageUp;

const cursorPageDown = view => cursorByPage(view, true);

exports.cursorPageDown = cursorPageDown;

function moveByLineBoundary(view, start, forward) {
  let line = view.visualLineAt(start.head),
      moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);

  if (!forward && moved.head == line.from && line.length) {
    let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space && start.head != line.from + space) moved = _state.EditorSelection.cursor(line.from + space);
  }

  return moved;
}
/**
Move the selection to the next line wrap point, or to the end of
the line if there isn't one left on this line.
*/


const cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));
/**
Move the selection to previous line wrap point, or failing that to
the start of the line. If the line is indented, and the cursor
isn't already at the end of the indentation, this will move to the
end of the indentation instead of the start of the line.
*/


exports.cursorLineBoundaryForward = cursorLineBoundaryForward;

const cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));
/**
Move the selection to the start of the line.
*/


exports.cursorLineBoundaryBackward = cursorLineBoundaryBackward;

const cursorLineStart = view => moveSel(view, range => _state.EditorSelection.cursor(view.visualLineAt(range.head).from, 1));
/**
Move the selection to the end of the line.
*/


exports.cursorLineStart = cursorLineStart;

const cursorLineEnd = view => moveSel(view, range => _state.EditorSelection.cursor(view.visualLineAt(range.head).to, -1));

exports.cursorLineEnd = cursorLineEnd;

function toMatchingBracket(state, dispatch, extend) {
  let found = false,
      selection = updateSel(state.selection, range => {
    let matching = (0, _matchbrackets.matchBrackets)(state, range.head, -1) || (0, _matchbrackets.matchBrackets)(state, range.head, 1) || range.head > 0 && (0, _matchbrackets.matchBrackets)(state, range.head - 1, 1) || range.head < state.doc.length && (0, _matchbrackets.matchBrackets)(state, range.head + 1, -1);
    if (!matching || !matching.end) return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend ? _state.EditorSelection.range(range.anchor, head) : _state.EditorSelection.cursor(head);
  });
  if (!found) return false;
  dispatch(setSel(state, selection));
  return true;
}
/**
Move the selection to the bracket matching the one it is currently
on, if any.
*/


const cursorMatchingBracket = ({
  state,
  dispatch
}) => toMatchingBracket(state, dispatch, false);
/**
Extend the selection to the bracket matching the one the selection
head is currently on, if any.
*/


exports.cursorMatchingBracket = cursorMatchingBracket;

const selectMatchingBracket = ({
  state,
  dispatch
}) => toMatchingBracket(state, dispatch, true);

exports.selectMatchingBracket = selectMatchingBracket;

function extendSel(view, how) {
  let selection = updateSel(view.state.selection, range => {
    let head = how(range);
    return _state.EditorSelection.range(range.anchor, head.head, head.goalColumn);
  });
  if (selection.eq(view.state.selection)) return false;
  view.dispatch(setSel(view.state, selection));
  return true;
}

function selectByChar(view, forward) {
  return extendSel(view, range => view.moveByChar(range, forward));
}
/**
Move the selection head one character to the left, while leaving
the anchor in place.
*/


const selectCharLeft = view => selectByChar(view, view.textDirection != _view.Direction.LTR);
/**
Move the selection head one character to the right.
*/


exports.selectCharLeft = selectCharLeft;

const selectCharRight = view => selectByChar(view, view.textDirection == _view.Direction.LTR);
/**
Move the selection head one character forward.
*/


exports.selectCharRight = selectCharRight;

const selectCharForward = view => selectByChar(view, true);
/**
Move the selection head one character backward.
*/


exports.selectCharForward = selectCharForward;

const selectCharBackward = view => selectByChar(view, false);

exports.selectCharBackward = selectCharBackward;

function selectByGroup(view, forward) {
  return extendSel(view, range => view.moveByGroup(range, forward));
}
/**
Move the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to
the left.
*/


const selectGroupLeft = view => selectByGroup(view, view.textDirection != _view.Direction.LTR);
/**
Move the selection head one group to the right.
*/


exports.selectGroupLeft = selectGroupLeft;

const selectGroupRight = view => selectByGroup(view, view.textDirection == _view.Direction.LTR);
/**
Move the selection head one group forward.
*/


exports.selectGroupRight = selectGroupRight;

const selectGroupForward = view => selectByGroup(view, true);
/**
Move the selection head one group backward.
*/


exports.selectGroupForward = selectGroupForward;

const selectGroupBackward = view => selectByGroup(view, false);

exports.selectGroupBackward = selectGroupBackward;

function selectBySubword(view, forward) {
  return extendSel(view, range => moveBySubword(view, range, forward));
}
/**
Move the selection head one group or camel-case subword forward.
*/


const selectSubwordForward = view => selectBySubword(view, true);
/**
Move the selection head one group or subword backward.
*/


exports.selectSubwordForward = selectSubwordForward;

const selectSubwordBackward = view => selectBySubword(view, false);
/**
Move the selection head over the next syntactic element to the left.
*/


exports.selectSubwordBackward = selectSubwordBackward;

const selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, view.textDirection != _view.Direction.LTR));
/**
Move the selection head over the next syntactic element to the right.
*/


exports.selectSyntaxLeft = selectSyntaxLeft;

const selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, view.textDirection == _view.Direction.LTR));

exports.selectSyntaxRight = selectSyntaxRight;

function selectByLine(view, forward) {
  return extendSel(view, range => view.moveVertically(range, forward));
}
/**
Move the selection head one line up.
*/


const selectLineUp = view => selectByLine(view, false);
/**
Move the selection head one line down.
*/


exports.selectLineUp = selectLineUp;

const selectLineDown = view => selectByLine(view, true);

exports.selectLineDown = selectLineDown;

function selectByPage(view, forward) {
  return extendSel(view, range => view.moveVertically(range, forward, view.dom.clientHeight));
}
/**
Move the selection head one page up.
*/


const selectPageUp = view => selectByPage(view, false);
/**
Move the selection head one page down.
*/


exports.selectPageUp = selectPageUp;

const selectPageDown = view => selectByPage(view, true);
/**
Move the selection head to the next line boundary.
*/


exports.selectPageDown = selectPageDown;

const selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));
/**
Move the selection head to the previous line boundary.
*/


exports.selectLineBoundaryForward = selectLineBoundaryForward;

const selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));
/**
Move the selection head to the start of the line.
*/


exports.selectLineBoundaryBackward = selectLineBoundaryBackward;

const selectLineStart = view => extendSel(view, range => _state.EditorSelection.cursor(view.visualLineAt(range.head).from));
/**
Move the selection head to the end of the line.
*/


exports.selectLineStart = selectLineStart;

const selectLineEnd = view => extendSel(view, range => _state.EditorSelection.cursor(view.visualLineAt(range.head).to));
/**
Move the selection to the start of the document.
*/


exports.selectLineEnd = selectLineEnd;

const cursorDocStart = ({
  state,
  dispatch
}) => {
  dispatch(setSel(state, {
    anchor: 0
  }));
  return true;
};
/**
Move the selection to the end of the document.
*/


exports.cursorDocStart = cursorDocStart;

const cursorDocEnd = ({
  state,
  dispatch
}) => {
  dispatch(setSel(state, {
    anchor: state.doc.length
  }));
  return true;
};
/**
Move the selection head to the start of the document.
*/


exports.cursorDocEnd = cursorDocEnd;

const selectDocStart = ({
  state,
  dispatch
}) => {
  dispatch(setSel(state, {
    anchor: state.selection.main.anchor,
    head: 0
  }));
  return true;
};
/**
Move the selection head to the end of the document.
*/


exports.selectDocStart = selectDocStart;

const selectDocEnd = ({
  state,
  dispatch
}) => {
  dispatch(setSel(state, {
    anchor: state.selection.main.anchor,
    head: state.doc.length
  }));
  return true;
};
/**
Select the entire document.
*/


exports.selectDocEnd = selectDocEnd;

const selectAll = ({
  state,
  dispatch
}) => {
  dispatch(state.update({
    selection: {
      anchor: 0,
      head: state.doc.length
    },
    userEvent: "select"
  }));
  return true;
};
/**
Expand the selection to cover entire lines.
*/


exports.selectAll = selectAll;

const selectLine = ({
  state,
  dispatch
}) => {
  let ranges = selectedLineBlocks(state).map(({
    from,
    to
  }) => _state.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({
    selection: _state.EditorSelection.create(ranges),
    userEvent: "select"
  }));
  return true;
};
/**
Select the next syntactic construct that is larger than the
selection. Note that this will only work insofar as the language
[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full
syntax tree.
*/


exports.selectLine = selectLine;

const selectParentSyntax = ({
  state,
  dispatch
}) => {
  let selection = updateSel(state.selection, range => {
    var _a;

    let context = (0, _language.syntaxTree)(state).resolveInner(range.head, 1);

    while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent))) context = context.parent;

    return _state.EditorSelection.range(context.to, context.from);
  });
  dispatch(setSel(state, selection));
  return true;
};
/**
Simplify the current selection. When multiple ranges are selected,
reduce it to its main range. Otherwise, if the selection is
non-empty, convert it to a cursor selection.
*/


exports.selectParentSyntax = selectParentSyntax;

const simplifySelection = ({
  state,
  dispatch
}) => {
  let cur = state.selection,
      selection = null;
  if (cur.ranges.length > 1) selection = _state.EditorSelection.create([cur.main]);else if (!cur.main.empty) selection = _state.EditorSelection.create([_state.EditorSelection.cursor(cur.main.head)]);
  if (!selection) return false;
  dispatch(setSel(state, selection));
  return true;
};

exports.simplifySelection = simplifySelection;

function deleteBy({
  state,
  dispatch
}, by) {
  if (state.readOnly) return false;
  let event = "delete.selection";
  let changes = state.changeByRange(range => {
    let {
      from,
      to
    } = range;

    if (from == to) {
      let towards = by(from);
      if (towards < from) event = "delete.backward";else if (towards > from) event = "delete.forward";
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    }

    return from == to ? {
      range
    } : {
      changes: {
        from,
        to
      },
      range: _state.EditorSelection.cursor(from)
    };
  });
  if (changes.changes.empty) return false;
  dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event
  }));
  return true;
}

function skipAtomic(target, pos, forward) {
  if (target instanceof _view.EditorView) for (let ranges of target.pluginField(_view.PluginField.atomicRanges)) ranges.between(pos, pos, (from, to) => {
    if (from < pos && to > pos) pos = forward ? to : from;
  });
  return pos;
}

const deleteByChar = (target, forward) => deleteBy(target, pos => {
  let {
    state
  } = target,
      line = state.doc.lineAt(pos),
      before,
      targetPos;

  if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "\t") return pos - 1;
    let col = (0, _text.countColumn)(before, state.tabSize),
        drop = col % (0, _language.getIndentUnit)(state) || (0, _language.getIndentUnit)(state);

    for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++) pos--;

    targetPos = pos;
  } else {
    targetPos = (0, _text.findClusterBreak)(line.text, pos - line.from, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;
  }

  return skipAtomic(target, targetPos, forward);
});
/**
Delete the selection, or, for cursor selections, the character
before the cursor.
*/


const deleteCharBackward = view => deleteByChar(view, false);
/**
Delete the selection or the character after the cursor.
*/


exports.deleteCharBackward = deleteCharBackward;

const deleteCharForward = view => deleteByChar(view, true);

exports.deleteCharForward = deleteCharForward;

const deleteByGroup = (target, forward) => deleteBy(target, start => {
  let pos = start,
      {
    state
  } = target,
      line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);

  for (let cat = null;;) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == start && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;
      break;
    }

    let next = (0, _text.findClusterBreak)(line.text, pos - line.from, forward) + line.from;
    let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar);
    if (cat != null && nextCat != cat) break;
    if (nextChar != " " || pos != start) cat = nextCat;
    pos = next;
  }

  return skipAtomic(target, pos, forward);
});
/**
Delete the selection or backward until the end of the next
[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of
whitespace when they consist of a single space.
*/


const deleteGroupBackward = target => deleteByGroup(target, false);
/**
Delete the selection or forward until the end of the next group.
*/


exports.deleteGroupBackward = deleteGroupBackward;

const deleteGroupForward = target => deleteByGroup(target, true);
/**
Delete the selection, or, if it is a cursor selection, delete to
the end of the line. If the cursor is directly at the end of the
line, delete the line break after it.
*/


exports.deleteGroupForward = deleteGroupForward;

const deleteToLineEnd = view => deleteBy(view, pos => {
  let lineEnd = view.visualLineAt(pos).to;
  return skipAtomic(view, pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1), true);
});
/**
Delete the selection, or, if it is a cursor selection, delete to
the start of the line. If the cursor is directly at the start of the
line, delete the line break before it.
*/


exports.deleteToLineEnd = deleteToLineEnd;

const deleteToLineStart = view => deleteBy(view, pos => {
  let lineStart = view.visualLineAt(pos).from;
  return skipAtomic(view, pos > lineStart ? lineStart : Math.max(0, pos - 1), false);
});
/**
Delete all whitespace directly before a line end from the
document.
*/


exports.deleteToLineStart = deleteToLineStart;

const deleteTrailingWhitespace = ({
  state,
  dispatch
}) => {
  if (state.readOnly) return false;
  let changes = [];

  for (let pos = 0, prev = "", iter = state.doc.iter();;) {
    iter.next();

    if (iter.lineBreak || iter.done) {
      let trailing = prev.search(/\s+$/);
      if (trailing > -1) changes.push({
        from: pos - (prev.length - trailing),
        to: pos
      });
      if (iter.done) break;
      prev = "";
    } else {
      prev = iter.value;
    }

    pos += iter.value.length;
  }

  if (!changes.length) return false;
  dispatch(state.update({
    changes,
    userEvent: "delete"
  }));
  return true;
};
/**
Replace each selection range with a line break, leaving the cursor
on the line before the break.
*/


exports.deleteTrailingWhitespace = deleteTrailingWhitespace;

const splitLine = ({
  state,
  dispatch
}) => {
  if (state.readOnly) return false;
  let changes = state.changeByRange(range => {
    return {
      changes: {
        from: range.from,
        to: range.to,
        insert: _text.Text.of(["", ""])
      },
      range: _state.EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: "input"
  }));
  return true;
};
/**
Flip the characters before and after the cursor(s).
*/


exports.splitLine = splitLine;

const transposeChars = ({
  state,
  dispatch
}) => {
  if (state.readOnly) return false;
  let changes = state.changeByRange(range => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length) return {
      range
    };
    let pos = range.from,
        line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : (0, _text.findClusterBreak)(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : (0, _text.findClusterBreak)(line.text, pos - line.from, true) + line.from;
    return {
      changes: {
        from,
        to,
        insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))
      },
      range: _state.EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty) return false;
  dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: "move.character"
  }));
  return true;
};

exports.transposeChars = transposeChars;

function selectedLineBlocks(state) {
  let blocks = [],
      upto = -1;

  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from),
        endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);

    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({
        from: startLine.from,
        to: endLine.to,
        ranges: [range]
      });
    }

    upto = endLine.number + 1;
  }

  return blocks;
}

function moveLine(state, dispatch, forward) {
  if (state.readOnly) return false;
  let changes = [],
      ranges = [];

  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0) continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;

    if (forward) {
      changes.push({
        from: block.to,
        to: nextLine.to
      }, {
        from: block.from,
        insert: nextLine.text + state.lineBreak
      });

      for (let r of block.ranges) ranges.push(_state.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
    } else {
      changes.push({
        from: nextLine.from,
        to: block.from
      }, {
        from: block.to,
        insert: state.lineBreak + nextLine.text
      });

      for (let r of block.ranges) ranges.push(_state.EditorSelection.range(r.anchor - size, r.head - size));
    }
  }

  if (!changes.length) return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: _state.EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
/**
Move the selected lines up one line.
*/


const moveLineUp = ({
  state,
  dispatch
}) => moveLine(state, dispatch, false);
/**
Move the selected lines down one line.
*/


exports.moveLineUp = moveLineUp;

const moveLineDown = ({
  state,
  dispatch
}) => moveLine(state, dispatch, true);

exports.moveLineDown = moveLineDown;

function copyLine(state, dispatch, forward) {
  if (state.readOnly) return false;
  let changes = [];

  for (let block of selectedLineBlocks(state)) {
    if (forward) changes.push({
      from: block.from,
      insert: state.doc.slice(block.from, block.to) + state.lineBreak
    });else changes.push({
      from: block.to,
      insert: state.lineBreak + state.doc.slice(block.from, block.to)
    });
  }

  dispatch(state.update({
    changes,
    scrollIntoView: true,
    userEvent: "input.copyline"
  }));
  return true;
}
/**
Create a copy of the selected lines. Keep the selection in the top copy.
*/


const copyLineUp = ({
  state,
  dispatch
}) => copyLine(state, dispatch, false);
/**
Create a copy of the selected lines. Keep the selection in the bottom copy.
*/


exports.copyLineUp = copyLineUp;

const copyLineDown = ({
  state,
  dispatch
}) => copyLine(state, dispatch, true);
/**
Delete selected lines.
*/


exports.copyLineDown = copyLineDown;

const deleteLine = view => {
  if (view.state.readOnly) return false;
  let {
    state
  } = view,
      changes = state.changes(selectedLineBlocks(state).map(({
    from,
    to
  }) => {
    if (from > 0) from--;else if (to < state.doc.length) to++;
    return {
      from,
      to
    };
  }));
  let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);
  view.dispatch({
    changes,
    selection,
    scrollIntoView: true,
    userEvent: "delete.line"
  });
  return true;
};
/**
Replace the selection with a newline.
*/


exports.deleteLine = deleteLine;

const insertNewline = ({
  state,
  dispatch
}) => {
  dispatch(state.update(state.replaceSelection(state.lineBreak), {
    scrollIntoView: true,
    userEvent: "input"
  }));
  return true;
};

exports.insertNewline = insertNewline;

function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {
    from: pos,
    to: pos
  };
  let context = (0, _language.syntaxTree)(state).resolveInner(pos);
  let before = context.childBefore(pos),
      after = context.childAfter(pos),
      closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(_common.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from) return {
    from: before.to,
    to: after.from
  };
  return null;
}
/**
Replace the selection with a newline and indent the newly created
line(s). If the current line consists only of whitespace, this
will also delete that whitespace. When the cursor is between
matching brackets, an additional newline will be inserted after
the cursor.
*/


const insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);
/**
Create a blank, indented line below the current line.
*/

exports.insertNewlineAndIndent = insertNewlineAndIndent;
const insertBlankLine = /*@__PURE__*/newlineAndIndent(true);
exports.insertBlankLine = insertBlankLine;

function newlineAndIndent(atEof) {
  return ({
    state,
    dispatch
  }) => {
    if (state.readOnly) return false;
    let changes = state.changeByRange(range => {
      let {
        from,
        to
      } = range,
          line = state.doc.lineAt(from);
      let explode = !atEof && from == to && isBetweenBrackets(state, from);
      if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new _language.IndentContext(state, {
        simulateBreak: from,
        simulateDoubleBreak: !!explode
      });
      let indent = (0, _language.getIndentation)(cx, from);
      if (indent == null) indent = /^\s*/.exec(state.doc.lineAt(from).text)[0].length;

      while (to < line.to && /\s/.test(line.text[to - line.from])) to++;

      if (explode) ({
        from,
        to
      } = explode);else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from))) from = line.from;
      let insert = ["", (0, _language.indentString)(state, indent)];
      if (explode) insert.push((0, _language.indentString)(state, cx.lineIndent(line.from, -1)));
      return {
        changes: {
          from,
          to,
          insert: _text.Text.of(insert)
        },
        range: _state.EditorSelection.cursor(from + 1 + insert[1].length)
      };
    });
    dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: "input"
    }));
    return true;
  };
}

function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange(range => {
    let changes = [];

    for (let pos = range.from; pos <= range.to;) {
      let line = state.doc.lineAt(pos);

      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f(line, changes, range);
        atLine = line.number;
      }

      pos = line.to + 1;
    }

    let changeSet = state.changes(changes);
    return {
      changes,
      range: _state.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
/**
Auto-indent the selected lines. This uses the [indentation service
facet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent
information.
*/


const indentSelection = ({
  state,
  dispatch
}) => {
  if (state.readOnly) return false;
  let updated = Object.create(null);
  let context = new _language.IndentContext(state, {
    overrideIndentation: start => {
      let found = updated[start];
      return found == null ? -1 : found;
    }
  });
  let changes = changeBySelectedLine(state, (line, changes, range) => {
    let indent = (0, _language.getIndentation)(context, line.from);
    if (indent == null) return;
    if (!/\S/.test(line.text)) indent = 0;
    let cur = /^\s*/.exec(line.text)[0];
    let norm = (0, _language.indentString)(state, indent);

    if (cur != norm || range.from < line.from + cur.length) {
      updated[line.from] = indent;
      changes.push({
        from: line.from,
        to: line.from + cur.length,
        insert: norm
      });
    }
  });
  if (!changes.changes.empty) dispatch(state.update(changes, {
    userEvent: "indent"
  }));
  return true;
};
/**
Add a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected
lines.
*/


exports.indentSelection = indentSelection;

const indentMore = ({
  state,
  dispatch
}) => {
  if (state.readOnly) return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({
      from: line.from,
      insert: state.facet(_language.indentUnit)
    });
  }), {
    userEvent: "input.indent"
  }));
  return true;
};
/**
Remove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all
selected lines.
*/


exports.indentMore = indentMore;

const indentLess = ({
  state,
  dispatch
}) => {
  if (state.readOnly) return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space = /^\s*/.exec(line.text)[0];
    if (!space) return;
    let col = (0, _text.countColumn)(space, state.tabSize),
        keep = 0;
    let insert = (0, _language.indentString)(state, Math.max(0, col - (0, _language.getIndentUnit)(state)));

    while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep)) keep++;

    changes.push({
      from: line.from + keep,
      to: line.from + space.length,
      insert: insert.slice(keep)
    });
  }), {
    userEvent: "delete.dedent"
  }));
  return true;
};
/**
Insert a tab character at the cursor or, if something is selected,
use [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire
selection.
*/


exports.indentLess = indentLess;

const insertTab = ({
  state,
  dispatch
}) => {
  if (state.selection.ranges.some(r => !r.empty)) return indentMore({
    state,
    dispatch
  });
  dispatch(state.update(state.replaceSelection("\t"), {
    scrollIntoView: true,
    userEvent: "input"
  }));
  return true;
};
/**
Array of key bindings containing the Emacs-style bindings that are
available on macOS by default.

 - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
 - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
 - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
 - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
 - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
 - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
 - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
 - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
 - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)
 - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
 - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)
 - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)
 - Alt-<: [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart)
 - Alt->: [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd)
 - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)
 - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)
*/


exports.insertTab = insertTab;
const emacsStyleKeymap = [{
  key: "Ctrl-b",
  run: cursorCharLeft,
  shift: selectCharLeft,
  preventDefault: true
}, {
  key: "Ctrl-f",
  run: cursorCharRight,
  shift: selectCharRight
}, {
  key: "Ctrl-p",
  run: cursorLineUp,
  shift: selectLineUp
}, {
  key: "Ctrl-n",
  run: cursorLineDown,
  shift: selectLineDown
}, {
  key: "Ctrl-a",
  run: cursorLineStart,
  shift: selectLineStart
}, {
  key: "Ctrl-e",
  run: cursorLineEnd,
  shift: selectLineEnd
}, {
  key: "Ctrl-d",
  run: deleteCharForward
}, {
  key: "Ctrl-h",
  run: deleteCharBackward
}, {
  key: "Ctrl-k",
  run: deleteToLineEnd
}, {
  key: "Ctrl-Alt-h",
  run: deleteGroupBackward
}, {
  key: "Ctrl-o",
  run: splitLine
}, {
  key: "Ctrl-t",
  run: transposeChars
}, {
  key: "Alt-<",
  run: cursorDocStart
}, {
  key: "Alt->",
  run: cursorDocEnd
}, {
  key: "Ctrl-v",
  run: cursorPageDown
}, {
  key: "Alt-v",
  run: cursorPageUp
}];
/**
An array of key bindings closely sticking to platform-standard or
widely used bindings. (This includes the bindings from
[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`
property changed to `mac`.)

 - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
 - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
 - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)
 - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)
 - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
 - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
 - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
 - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
 - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
 - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
 - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
 - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
 - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
 - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
 - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)
 - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)
 - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
 - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
 - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)
 - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)
 - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
 - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
 - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
 - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)
 - Cmd-Backspace (macOS): [`deleteToLineStart`](https://codemirror.net/6/docs/ref/#commands.deleteToLineStart).
 - Cmd-Delete (macOS): [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd).
*/

exports.emacsStyleKeymap = emacsStyleKeymap;
const standardKeymap = /*@__PURE__*/[{
  key: "ArrowLeft",
  run: cursorCharLeft,
  shift: selectCharLeft,
  preventDefault: true
}, {
  key: "Mod-ArrowLeft",
  mac: "Alt-ArrowLeft",
  run: cursorGroupLeft,
  shift: selectGroupLeft
}, {
  mac: "Cmd-ArrowLeft",
  run: cursorLineBoundaryBackward,
  shift: selectLineBoundaryBackward
}, {
  key: "ArrowRight",
  run: cursorCharRight,
  shift: selectCharRight,
  preventDefault: true
}, {
  key: "Mod-ArrowRight",
  mac: "Alt-ArrowRight",
  run: cursorGroupRight,
  shift: selectGroupRight
}, {
  mac: "Cmd-ArrowRight",
  run: cursorLineBoundaryForward,
  shift: selectLineBoundaryForward
}, {
  key: "ArrowUp",
  run: cursorLineUp,
  shift: selectLineUp,
  preventDefault: true
}, {
  mac: "Cmd-ArrowUp",
  run: cursorDocStart,
  shift: selectDocStart
}, {
  mac: "Ctrl-ArrowUp",
  run: cursorPageUp,
  shift: selectPageUp
}, {
  key: "ArrowDown",
  run: cursorLineDown,
  shift: selectLineDown,
  preventDefault: true
}, {
  mac: "Cmd-ArrowDown",
  run: cursorDocEnd,
  shift: selectDocEnd
}, {
  mac: "Ctrl-ArrowDown",
  run: cursorPageDown,
  shift: selectPageDown
}, {
  key: "PageUp",
  run: cursorPageUp,
  shift: selectPageUp
}, {
  key: "PageDown",
  run: cursorPageDown,
  shift: selectPageDown
}, {
  key: "Home",
  run: cursorLineBoundaryBackward,
  shift: selectLineBoundaryBackward
}, {
  key: "Mod-Home",
  run: cursorDocStart,
  shift: selectDocStart
}, {
  key: "End",
  run: cursorLineBoundaryForward,
  shift: selectLineBoundaryForward
}, {
  key: "Mod-End",
  run: cursorDocEnd,
  shift: selectDocEnd
}, {
  key: "Enter",
  run: insertNewlineAndIndent
}, {
  key: "Mod-a",
  run: selectAll
}, {
  key: "Backspace",
  run: deleteCharBackward,
  shift: deleteCharBackward
}, {
  key: "Delete",
  run: deleteCharForward,
  shift: deleteCharForward
}, {
  key: "Mod-Backspace",
  mac: "Alt-Backspace",
  run: deleteGroupBackward
}, {
  key: "Mod-Delete",
  mac: "Alt-Delete",
  run: deleteGroupForward
}, {
  mac: "Mod-Backspace",
  run: deleteToLineStart
}, {
  mac: "Mod-Delete",
  run: deleteToLineEnd
}].concat( /*@__PURE__*/emacsStyleKeymap.map(b => ({
  mac: b.key,
  run: b.run,
  shift: b.shift
})));
/**
The default keymap. Includes all bindings from
[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:

- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)
- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)
- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)
- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)
- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)
- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)
- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)
- Ctrl-Enter (Comd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)
- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)
- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)
- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)
- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)
- Ctrl-Alt-\\ (Cmd-Alt-\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)
- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)
- Shift-Ctrl-\\ (Shift-Cmd-\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)
*/

exports.standardKeymap = standardKeymap;
const defaultKeymap = /*@__PURE__*/[{
  key: "Alt-ArrowLeft",
  mac: "Ctrl-ArrowLeft",
  run: cursorSyntaxLeft,
  shift: selectSyntaxLeft
}, {
  key: "Alt-ArrowRight",
  mac: "Ctrl-ArrowRight",
  run: cursorSyntaxRight,
  shift: selectSyntaxRight
}, {
  key: "Alt-ArrowUp",
  run: moveLineUp
}, {
  key: "Shift-Alt-ArrowUp",
  run: copyLineUp
}, {
  key: "Alt-ArrowDown",
  run: moveLineDown
}, {
  key: "Shift-Alt-ArrowDown",
  run: copyLineDown
}, {
  key: "Escape",
  run: simplifySelection
}, {
  key: "Mod-Enter",
  run: insertBlankLine
}, {
  key: "Alt-l",
  mac: "Ctrl-l",
  run: selectLine
}, {
  key: "Mod-i",
  run: selectParentSyntax,
  preventDefault: true
}, {
  key: "Mod-[",
  run: indentLess
}, {
  key: "Mod-]",
  run: indentMore
}, {
  key: "Mod-Alt-\\",
  run: indentSelection
}, {
  key: "Shift-Mod-k",
  run: deleteLine
}, {
  key: "Shift-Mod-\\",
  run: cursorMatchingBracket
}].concat(standardKeymap);
/**
A binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and
Shift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).
Please see the [Tab example](../../examples/tab/) before using
this.
*/

exports.defaultKeymap = defaultKeymap;
const indentWithTab = {
  key: "Tab",
  run: indentMore,
  shift: indentLess
};
exports.indentWithTab = indentWithTab;
},{"@codemirror/state":"node_modules/@codemirror/state/dist/index.js","@codemirror/text":"node_modules/@codemirror/text/dist/index.js","@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/matchbrackets":"node_modules/@codemirror/matchbrackets/dist/index.js","@codemirror/language":"node_modules/@codemirror/language/dist/index.js","@lezer/common":"node_modules/@lezer/common/dist/index.js"}],"node_modules/@codemirror/closebrackets/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.closeBrackets = closeBrackets;
exports.insertBracket = insertBracket;
exports.deleteBracketPair = exports.closeBracketsKeymap = void 0;

var _view = require("@codemirror/view");

var _state = require("@codemirror/state");

var _rangeset = require("@codemirror/rangeset");

var _text = require("@codemirror/text");

var _language = require("@codemirror/language");

const defaults = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}'\":;>"
};

const closeBracketEffect = /*@__PURE__*/_state.StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, _state.MapMode.TrackAfter);
    return mapped == null ? undefined : mapped;
  }

});

const skipBracketEffect = /*@__PURE__*/_state.StateEffect.define({
  map(value, mapping) {
    return mapping.mapPos(value);
  }

});

const closedBracket = /*@__PURE__*/new class extends _rangeset.RangeValue {}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;

const bracketState = /*@__PURE__*/_state.StateField.define({
  create() {
    return _rangeset.RangeSet.empty;
  },

  update(value, tr) {
    if (tr.selection) {
      let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
      let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
      if (lineStart != tr.changes.mapPos(prevLineStart, -1)) value = _rangeset.RangeSet.empty;
    }

    value = value.map(tr.changes);

    for (let effect of tr.effects) {
      if (effect.is(closeBracketEffect)) value = value.update({
        add: [closedBracket.range(effect.value, effect.value + 1)]
      });else if (effect.is(skipBracketEffect)) value = value.update({
        filter: from => from != effect.value
      });
    }

    return value;
  }

});
/**
Extension to enable bracket-closing behavior. When a closeable
bracket is typed, its closing bracket is immediately inserted
after the cursor. When closing a bracket directly in front of a
closing bracket inserted by the extension, the cursor moves over
that bracket.
*/


function closeBrackets() {
  return [_view.EditorView.inputHandler.of(handleInput), bracketState];
}

const definedClosing = "()[]{}<>";

function closing(ch) {
  for (let i = 0; i < definedClosing.length; i += 2) if (definedClosing.charCodeAt(i) == ch) return definedClosing.charAt(i + 1);

  return (0, _text.fromCodePoint)(ch < 128 ? ch : ch + 1);
}

function config(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults;
}

function handleInput(view, from, to, insert) {
  if (view.composing) return false;
  let sel = view.state.selection.main;
  if (insert.length > 2 || insert.length == 2 && (0, _text.codePointSize)((0, _text.codePointAt)(insert, 0)) == 1 || from != sel.from || to != sel.to) return false;
  let tr = insertBracket(view.state, insert);
  if (!tr) return false;
  view.dispatch(tr);
  return true;
}
/**
Command that implements deleting a pair of matching brackets when
the cursor is between them.
*/


const deleteBracketPair = ({
  state,
  dispatch
}) => {
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults.brackets;
  let dont = null,
      changes = state.changeByRange(range => {
    if (range.empty) {
      let before = prevChar(state.doc, range.head);

      for (let token of tokens) {
        if (token == before && nextChar(state.doc, range.head) == closing((0, _text.codePointAt)(token, 0))) return {
          changes: {
            from: range.head - token.length,
            to: range.head + token.length
          },
          range: _state.EditorSelection.cursor(range.head - token.length),
          userEvent: "delete.backward"
        };
      }
    }

    return {
      range: dont = range
    };
  });
  if (!dont) dispatch(state.update(changes, {
    scrollIntoView: true
  }));
  return !dont;
};
/**
Close-brackets related key bindings. Binds Backspace to
[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#closebrackets.deleteBracketPair).
*/


exports.deleteBracketPair = deleteBracketPair;
const closeBracketsKeymap = [{
  key: "Backspace",
  run: deleteBracketPair
}];
/**
Implements the extension's behavior on text insertion. If the
given string counts as a bracket in the language around the
selection, and replacing the selection with it requires custom
behavior (inserting a closing version or skipping past a
previously-closed bracket), this function returns a transaction
representing that custom behavior. (You only need this if you want
to programmatically insert brackets—the
[`closeBrackets`](https://codemirror.net/6/docs/ref/#closebrackets.closeBrackets) extension will
take care of running this for user input.)
*/

exports.closeBracketsKeymap = closeBracketsKeymap;

function insertBracket(state, bracket) {
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults.brackets;

  for (let tok of tokens) {
    let closed = closing((0, _text.codePointAt)(tok, 0));
    if (bracket == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1) : handleOpen(state, tok, closed, conf.before || defaults.before);
    if (bracket == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);
  }

  return null;
}

function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, from => {
    if (from == pos) found = true;
  });
  return found;
}

function nextChar(doc, pos) {
  let next = doc.sliceString(pos, pos + 2);
  return next.slice(0, (0, _text.codePointSize)((0, _text.codePointAt)(next, 0)));
}

function prevChar(doc, pos) {
  let prev = doc.sliceString(pos - 2, pos);
  return (0, _text.codePointSize)((0, _text.codePointAt)(prev, 0)) == prev.length ? prev : prev.slice(1);
}

function handleOpen(state, open, close, closeBefore) {
  let dont = null,
      changes = state.changeByRange(range => {
    if (!range.empty) return {
      changes: [{
        insert: open,
        from: range.from
      }, {
        insert: close,
        from: range.to
      }],
      effects: closeBracketEffect.of(range.to + open.length),
      range: _state.EditorSelection.range(range.anchor + open.length, range.head + open.length)
    };
    let next = nextChar(state.doc, range.head);
    if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1) return {
      changes: {
        insert: open + close,
        from: range.head
      },
      effects: closeBracketEffect.of(range.head + open.length),
      range: _state.EditorSelection.cursor(range.head + open.length)
    };
    return {
      range: dont = range
    };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}

function handleClose(state, _open, close) {
  let dont = null,
      moved = state.selection.ranges.map(range => {
    if (range.empty && nextChar(state.doc, range.head) == close) return _state.EditorSelection.cursor(range.head + close.length);
    return dont = range;
  });
  return dont ? null : state.update({
    selection: _state.EditorSelection.create(moved, state.selection.mainIndex),
    scrollIntoView: true,
    effects: state.selection.ranges.map(({
      from
    }) => skipBracketEffect.of(from))
  });
} // Handles cases where the open and close token are the same, and
// possibly triple quotes (as in `"""abc"""`-style quoting).


function handleSame(state, token, allowTriple) {
  let dont = null,
      changes = state.changeByRange(range => {
    if (!range.empty) return {
      changes: [{
        insert: token,
        from: range.from
      }, {
        insert: token,
        from: range.to
      }],
      effects: closeBracketEffect.of(range.to + token.length),
      range: _state.EditorSelection.range(range.anchor + token.length, range.head + token.length)
    };
    let pos = range.head,
        next = nextChar(state.doc, pos);

    if (next == token) {
      if (nodeStart(state, pos)) {
        return {
          changes: {
            insert: token + token,
            from: pos
          },
          effects: closeBracketEffect.of(pos + token.length),
          range: _state.EditorSelection.cursor(pos + token.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
        return {
          range: _state.EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),
          effects: skipBracketEffect.of(pos)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && nodeStart(state, pos - 2 * token.length)) {
      return {
        changes: {
          insert: token + token + token + token,
          from: pos
        },
        effects: closeBracketEffect.of(pos + token.length),
        range: _state.EditorSelection.cursor(pos + token.length)
      };
    } else if (state.charCategorizer(pos)(next) != _state.CharCategory.Word) {
      let prev = state.sliceDoc(pos - 1, pos);
      if (prev != token && state.charCategorizer(pos)(prev) != _state.CharCategory.Word) return {
        changes: {
          insert: token + token,
          from: pos
        },
        effects: closeBracketEffect.of(pos + token.length),
        range: _state.EditorSelection.cursor(pos + token.length)
      };
    }

    return {
      range: dont = range
    };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}

function nodeStart(state, pos) {
  let tree = (0, _language.syntaxTree)(state).resolveInner(pos + 1);
  return tree.parent && tree.from == pos;
}
},{"@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/state":"node_modules/@codemirror/state/dist/index.js","@codemirror/rangeset":"node_modules/@codemirror/rangeset/dist/index.js","@codemirror/text":"node_modules/@codemirror/text/dist/index.js","@codemirror/language":"node_modules/@codemirror/language/dist/index.js"}],"node_modules/@codemirror/panel/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPanel = getPanel;
exports.panels = panels;
exports.showPanel = void 0;

var _view = require("@codemirror/view");

var _state = require("@codemirror/state");

const panelConfig = /*@__PURE__*/_state.Facet.define({
  combine(configs) {
    let topContainer, bottomContainer;

    for (let c of configs) {
      topContainer = topContainer || c.topContainer;
      bottomContainer = bottomContainer || c.bottomContainer;
    }

    return {
      topContainer,
      bottomContainer
    };
  }

});
/**
Configures the panel-managing extension.
*/


function panels(config) {
  return config ? [panelConfig.of(config)] : [];
}
/**
Get the active panel created by the given constructor, if any.
This can be useful when you need access to your panels' DOM
structure.
*/


function getPanel(view, panel) {
  let plugin = view.plugin(panelPlugin);
  let index = plugin ? plugin.specs.indexOf(panel) : -1;
  return index > -1 ? plugin.panels[index] : null;
}

const panelPlugin = /*@__PURE__*/_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter(s => s);
    this.panels = this.specs.map(spec => spec(view));
    let conf = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf.topContainer);
    this.bottom = new PanelGroup(view, false, conf.bottomContainer);
    this.top.sync(this.panels.filter(p => p.top));
    this.bottom.sync(this.panels.filter(p => !p.top));

    for (let p of this.panels) {
      p.dom.classList.add("cm-panel");
      if (p.mount) p.mount();
    }
  }

  update(update) {
    let conf = update.state.facet(panelConfig);

    if (this.top.container != conf.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update.view, true, conf.topContainer);
    }

    if (this.bottom.container != conf.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
    }

    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update.state.facet(showPanel);

    if (input != this.input) {
      let specs = input.filter(x => x);
      let panels = [],
          top = [],
          bottom = [],
          mount = [];

      for (let spec of specs) {
        let known = this.specs.indexOf(spec),
            panel;

        if (known < 0) {
          panel = spec(update.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update) panel.update(update);
        }

        panels.push(panel);
        (panel.top ? top : bottom).push(panel);
      }

      this.specs = specs;
      this.panels = panels;
      this.top.sync(top);
      this.bottom.sync(bottom);

      for (let p of mount) {
        p.dom.classList.add("cm-panel");
        if (p.mount) p.mount();
      }
    } else {
      for (let p of this.panels) if (p.update) p.update(update);
    }
  }

  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }

}, {
  provide: /*@__PURE__*/_view.PluginField.scrollMargins.from(value => ({
    top: value.top.scrollMargin(),
    bottom: value.bottom.scrollMargin()
  }))
});

class PanelGroup {
  constructor(view, top, container) {
    this.view = view;
    this.top = top;
    this.container = container;
    this.dom = undefined;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }

  sync(panels) {
    this.panels = panels;
    this.syncDOM();
  }

  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = undefined;
      }

      return;
    }

    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent = this.container || this.view.dom;
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
    }

    let curDOM = this.dom.firstChild;

    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom) curDOM = rm(curDOM);

        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }

    while (curDOM) curDOM = rm(curDOM);
  }

  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }

  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses) return;

    for (let cls of this.classes.split(" ")) if (cls) this.container.classList.remove(cls);

    for (let cls of (this.classes = this.view.themeClasses).split(" ")) if (cls) this.container.classList.add(cls);
  }

}

function rm(node) {
  let next = node.nextSibling;
  node.remove();
  return next;
}

const baseTheme = /*@__PURE__*/_view.EditorView.baseTheme({
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  }
});
/**
Opening a panel is done by providing a constructor function for
the panel through this facet. (The panel is closed again when its
constructor is no longer provided.) Values of `null` are ignored.
*/


const showPanel = /*@__PURE__*/_state.Facet.define({
  enables: [panelPlugin, baseTheme]
});

exports.showPanel = showPanel;
},{"@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/state":"node_modules/@codemirror/state/dist/index.js"}],"node_modules/crelt/index.es.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = crelt;

function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string") elt = document.createElement(elt);
  var i = 1,
      next = arguments[1];

  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
      var value = next[name];
      if (typeof value == "string") elt.setAttribute(name, value);else if (value != null) elt[name] = value;
    }

    i++;
  }

  for (; i < arguments.length; i++) add(elt, arguments[i]);

  return elt;
}

function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) {} else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add(elt, child[i]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}
},{}],"node_modules/@codemirror/search/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.highlightSelectionMatches = highlightSelectionMatches;
exports.searchConfig = searchConfig;
exports.selectSelectionMatches = exports.selectNextOccurrence = exports.selectMatches = exports.searchKeymap = exports.replaceNext = exports.replaceAll = exports.openSearchPanel = exports.gotoLine = exports.findPrevious = exports.findNext = exports.closeSearchPanel = exports.SearchCursor = exports.RegExpCursor = void 0;

var _view = require("@codemirror/view");

var _state = require("@codemirror/state");

var _panel = require("@codemirror/panel");

var _rangeset = require("@codemirror/rangeset");

var _crelt = _interopRequireDefault(require("crelt"));

var _text = require("@codemirror/text");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const basicNormalize = typeof String.prototype.normalize == "function" ? x => x.normalize("NFKD") : x => x;
/**
A search cursor provides an iterator over text matches in a
document.
*/

class SearchCursor {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(text, query, from = 0, to = text.length, normalize) {
    /**
    The current match (only holds a meaningful value after
    [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when
    `done` is false).
    */
    this.value = {
      from: 0,
      to: 0
    };
    /**
    Whether the end of the iterated region has been reached.
    */

    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text.iterRange(from, to);
    this.bufferStart = from;
    this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;
    this.query = this.normalize(query);
  }

  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done) return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }

    return (0, _text.codePointAt)(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */


  next() {
    while (this.matches.length) this.matches.pop();

    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */


  nextOverlapping() {
    for (;;) {
      let next = this.peek();

      if (next < 0) {
        this.done = true;
        return this;
      }

      let str = (0, _text.fromCodePoint)(next),
          start = this.bufferStart + this.bufferPos;
      this.bufferPos += (0, _text.codePointSize)(next);
      let norm = this.normalize(str);

      for (let i = 0, pos = start;; i++) {
        let code = norm.charCodeAt(i);
        let match = this.match(code, pos);

        if (match) {
          this.value = match;
          return this;
        }

        if (i == norm.length - 1) break;
        if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;
      }
    }
  }

  match(code, pos) {
    let match = null;

    for (let i = 0; i < this.matches.length; i += 2) {
      let index = this.matches[i],
          keep = false;

      if (this.query.charCodeAt(index) == code) {
        if (index == this.query.length - 1) {
          match = {
            from: this.matches[i + 1],
            to: pos + 1
          };
        } else {
          this.matches[i]++;
          keep = true;
        }
      }

      if (!keep) {
        this.matches.splice(i, 2);
        i -= 2;
      }
    }

    if (this.query.charCodeAt(0) == code) {
      if (this.query.length == 1) match = {
        from: pos,
        to: pos + 1
      };else this.matches.push(1, pos);
    }

    return match;
  }

}

exports.SearchCursor = SearchCursor;
const empty = {
  from: -1,
  to: -1,
  match: /*@__PURE__*/ /.*/.exec("")
};
const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
/**
This class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)
but searches for a regular expression pattern instead of a plain
string.
*/

class RegExpCursor {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(text, query, options, from = 0, to = text.length) {
    this.to = to;
    this.curLine = "";
    /**
    Set to `true` when the cursor has reached the end of the search
    range.
    */

    this.done = false;
    /**
    Will contain an object with the extent of the match and the
    match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)
    sucessfully finds a match.
    */

    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.iter = text.iter();
    let startLine = text.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = from;
    this.getLine(this.curLineStart);
  }

  getLine(skip) {
    this.iter.next(skip);

    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }

  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to) this.curLine = "";else this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */


  next() {
    for (let off = this.matchPos - this.curLineStart;;) {
      this.re.lastIndex = off;
      let match = this.matchPos <= this.to && this.re.exec(this.curLine);

      if (match) {
        let from = this.curLineStart + match.index,
            to = from + match[0].length;
        this.matchPos = to + (from == to ? 1 : 0);
        if (from == this.curLine.length) this.nextLine();

        if (from < to || from > this.value.to) {
          this.value = {
            from,
            to,
            match
          };
          return this;
        }

        off = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }

}

exports.RegExpCursor = RegExpCursor;
const flattened = /*@__PURE__*/new WeakMap(); // Reusable (partially) flattened document strings

class FlattenedDoc {
  constructor(from, text) {
    this.from = from;
    this.text = text;
  }

  get to() {
    return this.from + this.text.length;
  }

  static get(doc, from, to) {
    let cached = flattened.get(doc);

    if (!cached || cached.from >= to || cached.to <= from) {
      let flat = new FlattenedDoc(from, doc.sliceString(from, to));
      flattened.set(doc, flat);
      return flat;
    }

    if (cached.from == from && cached.to == to) return cached;
    let {
      text,
      from: cachedFrom
    } = cached;

    if (cachedFrom > from) {
      text = doc.sliceString(from, cachedFrom) + text;
      cachedFrom = from;
    }

    if (cached.to < to) text += doc.sliceString(cached.to, to);
    flattened.set(doc, new FlattenedDoc(cachedFrom, text));
    return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
  }

}

class MultilineRegExpCursor {
  constructor(text, query, options, from, to) {
    this.text = text;
    this.to = to;
    this.done = false;
    this.value = empty;
    this.matchPos = from;
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000
    /* Base */
    ));
  }

  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }

  next() {
    for (;;) {
      let off = this.re.lastIndex = this.matchPos - this.flat.from;
      let match = this.re.exec(this.flat.text); // Skip empty matches directly after the last match

      if (match && !match[0] && match.index == off) {
        this.re.lastIndex = off + 1;
        match = this.re.exec(this.flat.text);
      } // If a match goes almost to the end of a noncomplete chunk, try
      // again, since it'll likely be able to match more


      if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10) match = null;

      if (match) {
        let from = this.flat.from + match.index,
            to = from + match[0].length;
        this.value = {
          from,
          to,
          match
        };
        this.matchPos = to + (from == to ? 1 : 0);
        return this;
      } else {
        if (this.flat.to == this.to) {
          this.done = true;
          return this;
        } // Grow the flattened doc


        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  }

}

function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a) {
    return false;
  }
}

function createLineDialog(view) {
  let input = (0, _crelt.default)("input", {
    class: "cm-textfield",
    name: "line"
  });
  let dom = (0, _crelt.default)("form", {
    class: "cm-gotoLine",
    onkeydown: event => {
      if (event.keyCode == 27) {
        // Escape
        event.preventDefault();
        view.dispatch({
          effects: dialogEffect.of(false)
        });
        view.focus();
      } else if (event.keyCode == 13) {
        // Enter
        event.preventDefault();
        go();
      }
    },
    onsubmit: event => {
      event.preventDefault();
      go();
    }
  }, (0, _crelt.default)("label", view.state.phrase("Go to line"), ": ", input), " ", (0, _crelt.default)("button", {
    class: "cm-button",
    type: "submit"
  }, view.state.phrase("go")));

  function go() {
    let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match) return;
    let {
      state
    } = view,
        startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl, percent] = match;
    let col = cl ? +cl.slice(1) : 0;
    let line = ln ? +ln : startLine.number;

    if (ln && percent) {
      let pc = line / 100;
      if (sign) pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line = Math.round(state.doc.lines * pc);
    } else if (ln && sign) {
      line = line * (sign == "-" ? -1 : 1) + startLine.number;
    }

    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
    view.dispatch({
      effects: dialogEffect.of(false),
      selection: _state.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
      scrollIntoView: true
    });
    view.focus();
  }

  return {
    dom,
    pos: -10
  };
}

const dialogEffect = /*@__PURE__*/_state.StateEffect.define();

const dialogField = /*@__PURE__*/_state.StateField.define({
  create() {
    return true;
  },

  update(value, tr) {
    for (let e of tr.effects) if (e.is(dialogEffect)) value = e.value;

    return value;
  },

  provide: f => _panel.showPanel.from(f, val => val ? createLineDialog : null)
});
/**
Command that shows a dialog asking the user for a line number, and
when a valid position is provided, moves the cursor to that line.

Supports line numbers, relative line offsets prefixed with `+` or
`-`, document percentages suffixed with `%`, and an optional
column position by adding `:` and a second number after the line
number.

The dialog can be styled with the `panel.gotoLine` theme
selector.
*/


const gotoLine = view => {
  let panel = (0, _panel.getPanel)(view, createLineDialog);

  if (!panel) {
    let effects = [dialogEffect.of(true)];
    if (view.state.field(dialogField, false) == null) effects.push(_state.StateEffect.appendConfig.of([dialogField, baseTheme$1]));
    view.dispatch({
      effects
    });
    panel = (0, _panel.getPanel)(view, createLineDialog);
  }

  if (panel) panel.dom.querySelector("input").focus();
  return true;
};

exports.gotoLine = gotoLine;

const baseTheme$1 = /*@__PURE__*/_view.EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": {
      fontSize: "80%"
    }
  }
});

const defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100
};

const highlightConfig = /*@__PURE__*/_state.Facet.define({
  combine(options) {
    return (0, _state.combineConfig)(options, defaultHighlightOptions, {
      highlightWordAroundCursor: (a, b) => a || b,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }

});
/**
This extension highlights text that matches the selection. It uses
the `"cm-selectionMatch"` class for the highlighting. When
`highlightWordAroundCursor` is enabled, the word at the cursor
itself will be highlighted with `"cm-selectionMatch-main"`.
*/


function highlightSelectionMatches(options) {
  let ext = [defaultTheme, matchHighlighter];
  if (options) ext.push(highlightConfig.of(options));
  return ext;
}

const matchDeco = /*@__PURE__*/_view.Decoration.mark({
  class: "cm-selectionMatch"
});

const mainMatchDeco = /*@__PURE__*/_view.Decoration.mark({
  class: "cm-selectionMatch cm-selectionMatch-main"
});

const matchHighlighter = /*@__PURE__*/_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }

  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);
  }

  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let {
      state
    } = view,
        sel = state.selection;
    if (sel.ranges.length > 1) return _view.Decoration.none;
    let range = sel.main,
        query,
        check = null;

    if (range.empty) {
      if (!conf.highlightWordAroundCursor) return _view.Decoration.none;
      let word = state.wordAt(range.head);
      if (!word) return _view.Decoration.none;
      check = state.charCategorizer(range.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range.to - range.from;
      if (len < conf.minSelectionLength || len > 200) return _view.Decoration.none;
      query = state.sliceDoc(range.from, range.to).trim();
      if (!query) return _view.Decoration.none;
    }

    let deco = [];

    for (let part of view.visibleRanges) {
      let cursor = new SearchCursor(state.doc, query, part.from, part.to);

      while (!cursor.next().done) {
        let {
          from,
          to
        } = cursor.value;

        if (!check || (from == 0 || check(state.sliceDoc(from - 1, from)) != _state.CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _state.CharCategory.Word)) {
          if (check && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));
          if (deco.length > conf.maxMatches) return _view.Decoration.none;
        }
      }
    }

    return _view.Decoration.set(deco);
  }

}, {
  decorations: v => v.decorations
});

const defaultTheme = /*@__PURE__*/_view.EditorView.baseTheme({
  ".cm-selectionMatch": {
    backgroundColor: "#99ff7780"
  },
  ".cm-searchMatch .cm-selectionMatch": {
    backgroundColor: "transparent"
  }
}); // Select the words around the cursors.


const selectWord = ({
  state,
  dispatch
}) => {
  let {
    selection
  } = state;

  let newSel = _state.EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || _state.EditorSelection.cursor(range.head)), selection.mainIndex);

  if (newSel.eq(selection)) return false;
  dispatch(state.update({
    selection: newSel
  }));
  return true;
}; // Find next occurrence of query relative to last cursor. Wrap around
// the document if there are no more matches.


function findNextOccurrence(state, query) {
  let {
    main,
    ranges
  } = state.selection;
  let word = state.wordAt(main.head),
      fullWord = word && word.from == main.from && word.to == main.to;

  for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {
    cursor.next();

    if (cursor.done) {
      if (cycled) return null;
      cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some(r => r.from == cursor.value.from)) continue;

      if (fullWord) {
        let word = state.wordAt(cursor.value.from);
        if (!word || word.from != cursor.value.from || word.to != cursor.value.to) continue;
      }

      return cursor.value;
    }
  }
}
/**
Select next occurrence of the current selection.
Expand selection to the word when selection range is empty.
*/


const selectNextOccurrence = ({
  state,
  dispatch
}) => {
  let {
    ranges
  } = state.selection;
  if (ranges.some(sel => sel.from === sel.to)) return selectWord({
    state,
    dispatch
  });
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText)) return false;
  let range = findNextOccurrence(state, searchedText);
  if (!range) return false;
  dispatch(state.update({
    selection: state.selection.addRange(_state.EditorSelection.range(range.from, range.to), false),
    scrollIntoView: true
  }));
  return true;
};

exports.selectNextOccurrence = selectNextOccurrence;

const searchConfigFacet = /*@__PURE__*/_state.Facet.define({
  combine(configs) {
    let matchCase = configs.some(c => c.matchCase);
    return {
      top: configs.some(c => c.top),
      matchCase: matchCase === undefined ? true : matchCase
    };
  }

});
/**
Configure the behavior of the search extension.
*/


function searchConfig(config) {
  return searchConfigFacet.of(config);
}

class Query {
  constructor(search, replace, caseInsensitive) {
    this.search = search;
    this.replace = replace;
    this.caseInsensitive = caseInsensitive;
  }

  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseInsensitive == other.caseInsensitive && this.constructor == other.constructor;
  }

}

class StringQuery extends Query {
  constructor(search, replace, caseInsensitive) {
    super(search, replace, caseInsensitive);
    this.unquoted = search.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "\t" : "\\");
  }

  cursor(doc, from = 0, to = doc.length) {
    return new SearchCursor(doc, this.unquoted, from, to, this.caseInsensitive ? x => x.toLowerCase() : undefined);
  }

  nextMatch(doc, curFrom, curTo) {
    let cursor = this.cursor(doc, curTo).nextOverlapping();
    if (cursor.done) cursor = this.cursor(doc, 0, curFrom).nextOverlapping();
    return cursor.done ? null : cursor.value;
  } // Searching in reverse is, rather than implementing inverted search
  // cursor, done by scanning chunk after chunk forward.


  prevMatchInRange(doc, from, to) {
    for (let pos = to;;) {
      let start = Math.max(from, pos - 10000
      /* ChunkSize */
      - this.unquoted.length);
      let cursor = this.cursor(doc, start, pos),
          range = null;

      while (!cursor.nextOverlapping().done) range = cursor.value;

      if (range) return range;
      if (start == from) return null;
      pos -= 10000
      /* ChunkSize */
      ;
    }
  }

  prevMatch(doc, curFrom, curTo) {
    return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);
  }

  getReplacement(_result) {
    return this.replace;
  }

  matchAll(doc, limit) {
    let cursor = this.cursor(doc),
        ranges = [];

    while (!cursor.next().done) {
      if (ranges.length >= limit) return null;
      ranges.push(cursor.value);
    }

    return ranges;
  }

  highlight(doc, from, to, add) {
    let cursor = this.cursor(doc, Math.max(0, from - this.unquoted.length), Math.min(to + this.unquoted.length, doc.length));

    while (!cursor.next().done) add(cursor.value.from, cursor.value.to);
  }

  get valid() {
    return !!this.search;
  }

}

class RegExpQuery extends Query {
  constructor(search, replace, caseInsensitive) {
    super(search, replace, caseInsensitive);
    this.valid = !!search && validRegExp(search);
  }

  cursor(doc, from = 0, to = doc.length) {
    return new RegExpCursor(doc, this.search, this.caseInsensitive ? {
      ignoreCase: true
    } : undefined, from, to);
  }

  nextMatch(doc, curFrom, curTo) {
    let cursor = this.cursor(doc, curTo).next();
    if (cursor.done) cursor = this.cursor(doc, 0, curFrom).next();
    return cursor.done ? null : cursor.value;
  }

  prevMatchInRange(doc, from, to) {
    for (let size = 1;; size++) {
      let start = Math.max(from, to - size * 10000
      /* ChunkSize */
      );
      let cursor = this.cursor(doc, start, to),
          range = null;

      while (!cursor.next().done) range = cursor.value;

      if (range && (start == from || range.from > start + 10)) return range;
      if (start == from) return null;
    }
  }

  prevMatch(doc, curFrom, curTo) {
    return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);
  }

  getReplacement(result) {
    return this.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$" : i == "&" ? result.match[0] : i != "0" && +i < result.match.length ? result.match[i] : m);
  }

  matchAll(doc, limit) {
    let cursor = this.cursor(doc),
        ranges = [];

    while (!cursor.next().done) {
      if (ranges.length >= limit) return null;
      ranges.push(cursor.value);
    }

    return ranges;
  }

  highlight(doc, from, to, add) {
    let cursor = this.cursor(doc, Math.max(0, from - 250
    /* HighlightMargin */
    ), Math.min(to + 250
    /* HighlightMargin */
    , doc.length));

    while (!cursor.next().done) add(cursor.value.from, cursor.value.to);
  }

}

const setQuery = /*@__PURE__*/_state.StateEffect.define();

const togglePanel = /*@__PURE__*/_state.StateEffect.define();

const searchState = /*@__PURE__*/_state.StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state), createSearchPanel);
  },

  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setQuery)) value = new SearchState(effect.value, value.panel);else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);
    }

    return value;
  },

  provide: f => _panel.showPanel.from(f, val => val.panel)
});

class SearchState {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }

}

const matchMark = /*@__PURE__*/_view.Decoration.mark({
  class: "cm-searchMatch"
}),
      selectedMatchMark = /*@__PURE__*/_view.Decoration.mark({
  class: "cm-searchMatch cm-searchMatch-selected"
});

const searchHighlighter = /*@__PURE__*/_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }

  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet) this.decorations = this.highlight(state);
  }

  highlight({
    query,
    panel
  }) {
    if (!panel || !query.valid) return _view.Decoration.none;
    let {
      view
    } = this;
    let builder = new _rangeset.RangeSetBuilder();

    for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
      let {
        from,
        to
      } = ranges[i];

      while (i < l - 1 && to > ranges[i + 1].from - 2 * 250
      /* HighlightMargin */
      ) to = ranges[++i].to;

      query.highlight(view.state.doc, from, to, (from, to) => {
        let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);
        builder.add(from, to, selected ? selectedMatchMark : matchMark);
      });
    }

    return builder.finish();
  }

}, {
  decorations: v => v.decorations
});

function searchCommand(f) {
  return view => {
    let state = view.state.field(searchState, false);
    return state && state.query.valid ? f(view, state) : openSearchPanel(view);
  };
}
/**
Open the search panel if it isn't already open, and move the
selection to the first match after the current main selection.
Will wrap around to the start of the document when it reaches the
end.
*/


const findNext = /*@__PURE__*/searchCommand((view, {
  query
}) => {
  let {
    from,
    to
  } = view.state.selection.main;
  let next = query.nextMatch(view.state.doc, from, to);
  if (!next || next.from == from && next.to == to) return false;
  view.dispatch({
    selection: {
      anchor: next.from,
      head: next.to
    },
    scrollIntoView: true,
    effects: announceMatch(view, next)
  });
  return true;
});
/**
Move the selection to the previous instance of the search query,
before the current main selection. Will wrap past the start
of the document to start searching at the end again.
*/

exports.findNext = findNext;
const findPrevious = /*@__PURE__*/searchCommand((view, {
  query
}) => {
  let {
    state
  } = view,
      {
    from,
    to
  } = state.selection.main;
  let range = query.prevMatch(state.doc, from, to);
  if (!range) return false;
  view.dispatch({
    selection: {
      anchor: range.from,
      head: range.to
    },
    scrollIntoView: true,
    effects: announceMatch(view, range)
  });
  return true;
});
/**
Select all instances of the search query.
*/

exports.findPrevious = findPrevious;
const selectMatches = /*@__PURE__*/searchCommand((view, {
  query
}) => {
  let ranges = query.matchAll(view.state.doc, 1000);
  if (!ranges || !ranges.length) return false;
  view.dispatch({
    selection: _state.EditorSelection.create(ranges.map(r => _state.EditorSelection.range(r.from, r.to)))
  });
  return true;
});
/**
Select all instances of the currently selected text.
*/

exports.selectMatches = selectMatches;

const selectSelectionMatches = ({
  state,
  dispatch
}) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty) return false;
  let {
    from,
    to
  } = sel.main;
  let ranges = [],
      main = 0;

  for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {
    if (ranges.length > 1000) return false;
    if (cur.value.from == from) main = ranges.length;
    ranges.push(_state.EditorSelection.range(cur.value.from, cur.value.to));
  }

  dispatch(state.update({
    selection: _state.EditorSelection.create(ranges, main)
  }));
  return true;
};
/**
Replace the current match of the search query.
*/


exports.selectSelectionMatches = selectSelectionMatches;
const replaceNext = /*@__PURE__*/searchCommand((view, {
  query
}) => {
  let {
    state
  } = view,
      {
    from,
    to
  } = state.selection.main;
  if (state.readOnly) return false;
  let next = query.nextMatch(state.doc, from, from);
  if (!next) return false;
  let changes = [],
      selection,
      replacement;

  if (next.from == from && next.to == to) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({
      from: next.from,
      to: next.to,
      insert: replacement
    });
    next = query.nextMatch(state.doc, next.from, next.to);
  }

  if (next) {
    let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
    selection = {
      anchor: next.from - off,
      head: next.to - off
    };
  }

  view.dispatch({
    changes,
    selection,
    scrollIntoView: !!selection,
    effects: next ? announceMatch(view, next) : undefined
  });
  return true;
});
/**
Replace all instances of the search query with the given
replacement.
*/

exports.replaceNext = replaceNext;
const replaceAll = /*@__PURE__*/searchCommand((view, {
  query
}) => {
  if (view.state.readOnly) return false;
  let changes = query.matchAll(view.state.doc, 1e9).map(match => {
    let {
      from,
      to
    } = match;
    return {
      from,
      to,
      insert: query.getReplacement(match)
    };
  });
  if (!changes.length) return false;
  view.dispatch({
    changes
  });
  return true;
});
exports.replaceAll = replaceAll;

function createSearchPanel(view) {
  let {
    query
  } = view.state.field(searchState);
  return {
    dom: buildPanel({
      view,
      query,

      updateQuery(q) {
        if (!query.eq(q)) {
          query = q;
          view.dispatch({
            effects: setQuery.of(query)
          });
        }
      }

    }),

    mount() {
      this.dom.querySelector("[name=search]").select();
    },

    pos: 80,
    top: view.state.facet(searchConfigFacet).top
  };
}

function defaultQuery(state, fallback) {
  var _a;

  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  let caseInsensitive = (_a = fallback === null || fallback === void 0 ? void 0 : fallback.caseInsensitive) !== null && _a !== void 0 ? _a : !state.facet(searchConfigFacet).matchCase;
  return fallback && !selText ? fallback : new StringQuery(selText.replace(/\n/g, "\\n"), "", caseInsensitive);
}
/**
Make sure the search panel is open and focused.
*/


const openSearchPanel = view => {
  let state = view.state.field(searchState, false);

  if (state && state.panel) {
    let panel = (0, _panel.getPanel)(view, createSearchPanel);
    if (!panel) return false;
    let searchInput = panel.dom.querySelector("[name=search]");
    searchInput.focus();
    searchInput.select();
  } else {
    view.dispatch({
      effects: [togglePanel.of(true), state ? setQuery.of(defaultQuery(view.state, state.query)) : _state.StateEffect.appendConfig.of(searchExtensions)]
    });
  }

  return true;
};
/**
Close the search panel.
*/


exports.openSearchPanel = openSearchPanel;

const closeSearchPanel = view => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel) return false;
  let panel = (0, _panel.getPanel)(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement)) view.focus();
  view.dispatch({
    effects: togglePanel.of(false)
  });
  return true;
};
/**
Default search-related key bindings.

 - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)
 - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)
 - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)
 - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)
 - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)
*/


exports.closeSearchPanel = closeSearchPanel;
const searchKeymap = [{
  key: "Mod-f",
  run: openSearchPanel,
  scope: "editor search-panel"
}, {
  key: "F3",
  run: findNext,
  shift: findPrevious,
  scope: "editor search-panel"
}, {
  key: "Mod-g",
  run: findNext,
  shift: findPrevious,
  scope: "editor search-panel"
}, {
  key: "Escape",
  run: closeSearchPanel,
  scope: "editor search-panel"
}, {
  key: "Mod-Shift-l",
  run: selectSelectionMatches
}, {
  key: "Alt-g",
  run: gotoLine
}, {
  key: "Mod-d",
  run: selectNextOccurrence,
  preventDefault: true
}];
exports.searchKeymap = searchKeymap;

function buildPanel(conf) {
  function phrase(phrase) {
    return conf.view.state.phrase(phrase);
  }

  let searchField = (0, _crelt.default)("input", {
    value: conf.query.search,
    placeholder: phrase("Find"),
    "aria-label": phrase("Find"),
    class: "cm-textfield",
    name: "search",
    onchange: update,
    onkeyup: update
  });
  let replaceField = (0, _crelt.default)("input", {
    value: conf.query.replace,
    placeholder: phrase("Replace"),
    "aria-label": phrase("Replace"),
    class: "cm-textfield",
    name: "replace",
    onchange: update,
    onkeyup: update
  });
  let caseField = (0, _crelt.default)("input", {
    type: "checkbox",
    name: "case",
    checked: !conf.query.caseInsensitive,
    onchange: update
  });
  let reField = (0, _crelt.default)("input", {
    type: "checkbox",
    name: "re",
    checked: conf.query instanceof RegExpQuery,
    onchange: update
  });

  function update() {
    conf.updateQuery(new (reField.checked ? RegExpQuery : StringQuery)(searchField.value, replaceField.value, !caseField.checked));
  }

  function keydown(e) {
    if ((0, _view.runScopeHandlers)(conf.view, e, "search-panel")) {
      e.preventDefault();
    } else if (e.keyCode == 13 && e.target == searchField) {
      e.preventDefault();
      (e.shiftKey ? findPrevious : findNext)(conf.view);
    } else if (e.keyCode == 13 && e.target == replaceField) {
      e.preventDefault();
      replaceNext(conf.view);
    }
  }

  function button(name, onclick, content) {
    return (0, _crelt.default)("button", {
      class: "cm-button",
      name,
      onclick,
      type: "button"
    }, content);
  }

  let panel = (0, _crelt.default)("div", {
    onkeydown: keydown,
    class: "cm-search"
  }, [searchField, button("next", () => findNext(conf.view), [phrase("next")]), button("prev", () => findPrevious(conf.view), [phrase("previous")]), button("select", () => selectMatches(conf.view), [phrase("all")]), (0, _crelt.default)("label", null, [caseField, phrase("match case")]), (0, _crelt.default)("label", null, [reField, phrase("regexp")]), (0, _crelt.default)("br"), replaceField, button("replace", () => replaceNext(conf.view), [phrase("replace")]), button("replaceAll", () => replaceAll(conf.view), [phrase("replace all")]), (0, _crelt.default)("button", {
    name: "close",
    onclick: () => closeSearchPanel(conf.view),
    "aria-label": phrase("close"),
    type: "button"
  }, ["×"])]);
  return panel;
}

const AnnounceMargin = 30;
const Break = /[\s\.,:;?!]/;

function announceMatch(view, {
  from,
  to
}) {
  let lineStart = view.state.doc.lineAt(from).from,
      lineEnd = view.state.doc.lineAt(to).to;
  let start = Math.max(lineStart, from - AnnounceMargin),
      end = Math.min(lineEnd, to + AnnounceMargin);
  let text = view.state.sliceDoc(start, end);

  if (start != lineStart) {
    for (let i = 0; i < AnnounceMargin; i++) if (!Break.test(text[i + 1]) && Break.test(text[i])) {
      text = text.slice(i);
      break;
    }
  }

  if (end != lineEnd) {
    for (let i = text.length - 1; i > text.length - AnnounceMargin; i--) if (!Break.test(text[i - 1]) && Break.test(text[i])) {
      text = text.slice(0, i);
      break;
    }
  }

  return _view.EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${view.state.doc.lineAt(from).number}`);
}

const baseTheme = /*@__PURE__*/_view.EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": {
    backgroundColor: "#ffff0054"
  },
  "&dark .cm-searchMatch": {
    backgroundColor: "#00ffff8a"
  },
  "&light .cm-searchMatch-selected": {
    backgroundColor: "#ff6a0054"
  },
  "&dark .cm-searchMatch-selected": {
    backgroundColor: "#ff00ff8a"
  }
});

const searchExtensions = [searchState, /*@__PURE__*/_state.Prec.fallback(searchHighlighter), baseTheme];
},{"@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/state":"node_modules/@codemirror/state/dist/index.js","@codemirror/panel":"node_modules/@codemirror/panel/dist/index.js","@codemirror/rangeset":"node_modules/@codemirror/rangeset/dist/index.js","crelt":"node_modules/crelt/index.es.js","@codemirror/text":"node_modules/@codemirror/text/dist/index.js"}],"node_modules/@codemirror/tooltip/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hoverTooltip = hoverTooltip;
exports.tooltips = tooltips;
exports.showTooltip = void 0;

var _view = require("@codemirror/view");

var _state = require("@codemirror/state");

const ios = typeof navigator != "undefined" && ! /*@__PURE__*/ /Edge\/(\d+)/.exec(navigator.userAgent) && /*@__PURE__*/ /Apple Computer/.test(navigator.vendor) && ( /*@__PURE__*/ /Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
const Outside = "-10000px";

class TooltipViewManager {
  constructor(view, facet, createTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter(t => t);
    this.tooltipViews = this.tooltips.map(createTooltipView);
  }

  update(update) {
    let input = update.state.facet(this.facet);
    let tooltips = input.filter(x => x);

    if (input === this.input) {
      for (let t of this.tooltipViews) if (t.update) t.update(update);

      return {
        shouldMeasure: false
      };
    }

    let tooltipViews = [];

    for (let i = 0; i < tooltips.length; i++) {
      let tip = tooltips[i],
          known = -1;
      if (!tip) continue;

      for (let i = 0; i < this.tooltips.length; i++) {
        let other = this.tooltips[i];
        if (other && other.create == tip.create) known = i;
      }

      if (known < 0) {
        tooltipViews[i] = this.createTooltipView(tip);
      } else {
        let tooltipView = tooltipViews[i] = this.tooltipViews[known];
        if (tooltipView.update) tooltipView.update(update);
      }
    }

    for (let t of this.tooltipViews) if (tooltipViews.indexOf(t) < 0) t.dom.remove();

    this.input = input;
    this.tooltips = tooltips;
    this.tooltipViews = tooltipViews;
    return {
      shouldMeasure: true
    };
  }

}
/**
Return an extension that configures tooltip behavior.
*/


function tooltips(config = {}) {
  return config.position ? tooltipPositioning.of(config.position) : [];
}

const tooltipPositioning = /*@__PURE__*/_state.Facet.define({
  combine: values => ios ? "absolute" : values.length ? values[0] : "fixed"
});

const tooltipPlugin = /*@__PURE__*/_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.inView = true;
    this.position = view.state.facet(tooltipPositioning);
    this.measureReq = {
      read: this.readMeasure.bind(this),
      write: this.writeMeasure.bind(this),
      key: this
    };
    this.manager = new TooltipViewManager(view, showTooltip, t => this.createTooltip(t));
  }

  update(update) {
    let {
      shouldMeasure
    } = this.manager.update(update);
    let newPosition = update.state.facet(tooltipPositioning);

    if (newPosition != this.position) {
      this.position = newPosition;

      for (let t of this.manager.tooltipViews) t.dom.style.position = newPosition;

      shouldMeasure = true;
    }

    if (shouldMeasure) this.maybeMeasure();
  }

  createTooltip(tooltip) {
    let tooltipView = tooltip.create(this.view);
    tooltipView.dom.classList.add("cm-tooltip");
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    this.view.dom.appendChild(tooltipView.dom);
    if (tooltipView.mount) tooltipView.mount(this.view);
    return tooltipView;
  }

  destroy() {
    for (let {
      dom
    } of this.manager.tooltipViews) dom.remove();
  }

  readMeasure() {
    return {
      editor: this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map(t => this.view.coordsAtPos(t.pos)),
      size: this.manager.tooltipViews.map(({
        dom
      }) => dom.getBoundingClientRect()),
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight
    };
  }

  writeMeasure(measured) {
    let {
      editor
    } = measured;
    let others = [];

    for (let i = 0; i < this.manager.tooltips.length; i++) {
      let tooltip = this.manager.tooltips[i],
          tView = this.manager.tooltipViews[i],
          {
        dom
      } = tView;
      let pos = measured.pos[i],
          size = measured.size[i]; // Hide tooltips that are outside of the editor.

      if (!pos || pos.bottom <= editor.top || pos.top >= editor.bottom || pos.right <= editor.left || pos.left >= editor.right) {
        dom.style.top = Outside;
        continue;
      }

      let width = size.right - size.left,
          height = size.bottom - size.top;
      let left = this.view.textDirection == _view.Direction.LTR ? Math.min(pos.left, measured.innerWidth - width) : Math.max(0, pos.left - width);
      let above = !!tooltip.above;
      if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) < 0 : pos.bottom + (size.bottom - size.top) > measured.innerHeight)) above = !above;
      let top = above ? pos.top - height : pos.bottom,
          right = left + width;

      for (let r of others) if (r.left < right && r.right > left && r.top < top + height && r.bottom > top) top = above ? r.top - height : r.bottom;

      if (this.position == "absolute") {
        dom.style.top = top - editor.top + "px";
        dom.style.left = left - editor.left + "px";
      } else {
        dom.style.top = top + "px";
        dom.style.left = left + "px";
      }

      others.push({
        left,
        top,
        right,
        bottom: top + height
      });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned) tView.positioned();
    }
  }

  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView) this.view.requestMeasure(this.measureReq);

      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView) for (let tv of this.manager.tooltipViews) tv.dom.style.top = Outside;
      }
    }
  }

}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }

  }
});

const baseTheme = /*@__PURE__*/_view.EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 100
  },
  "&light .cm-tooltip": {
    border: "1px solid #ddd",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  }
});
/**
Behavior by which an extension can provide a tooltip to be shown.
*/


const showTooltip = /*@__PURE__*/_state.Facet.define({
  enables: [tooltipPlugin, baseTheme]
});

exports.showTooltip = showTooltip;

const showHoverTooltip = /*@__PURE__*/_state.Facet.define();

class HoverTooltipHost {
  constructor(view) {
    this.view = view;
    this.mounted = false;
    this.dom = document.createElement("div");
    this.dom.classList.add("cm-tooltip-hover");
    this.manager = new TooltipViewManager(view, showHoverTooltip, t => this.createHostedView(t));
  } // Needs to be static so that host tooltip instances always match


  static create(view) {
    return new HoverTooltipHost(view);
  }

  createHostedView(tooltip) {
    let hostedView = tooltip.create(this.view);
    hostedView.dom.classList.add("cm-tooltip-section");
    this.dom.appendChild(hostedView.dom);
    if (this.mounted && hostedView.mount) hostedView.mount(this.view);
    return hostedView;
  }

  mount(view) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.mount) hostedView.mount(view);
    }

    this.mounted = true;
  }

  positioned() {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.positioned) hostedView.positioned();
    }
  }

  update(update) {
    this.manager.update(update);
  }

}

const showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], state => {
  let tooltips = state.facet(showHoverTooltip).filter(t => t);
  if (tooltips.length === 0) return null;
  return {
    pos: Math.min(...tooltips.map(t => t.pos)),
    end: Math.max(...tooltips.filter(t => t.end != null).map(t => t.end)),
    create: HoverTooltipHost.create,
    above: tooltips[0].above
  };
});

class HoverPlugin {
  constructor(view, source, field, setHover, hoverTime) {
    this.view = view;
    this.source = source;
    this.field = field;
    this.setHover = setHover;
    this.hoverTime = hoverTime;
    this.lastMouseMove = null;
    this.lastMoveTime = 0;
    this.hoverTimeout = -1;
    this.restartTimeout = -1;
    this.pending = null;
    this.checkHover = this.checkHover.bind(this);
    view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
    view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }

  update() {
    if (this.pending) {
      this.pending = null;
      clearTimeout(this.restartTimeout);
      this.restartTimeout = setTimeout(() => this.startHover(), 20);
    }
  }

  get active() {
    return this.view.state.field(this.field);
  }

  checkHover() {
    this.hoverTimeout = -1;
    if (this.active) return;
    let hovered = Date.now() - this.lastMoveTime;
    if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);else this.startHover();
  }

  startHover() {
    var _a;

    clearTimeout(this.restartTimeout);
    let lastMove = this.lastMouseMove;
    let coords = {
      x: lastMove.clientX,
      y: lastMove.clientY
    };
    let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(coords) : null;
    if (pos == null) return;
    let posCoords = this.view.coordsAtPos(pos);
    if (posCoords == null || coords.y < posCoords.top || coords.y > posCoords.bottom || coords.x < posCoords.left - this.view.defaultCharacterWidth || coords.x > posCoords.right + this.view.defaultCharacterWidth) return;
    let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);
    let rtl = bidi && bidi.dir == _view.Direction.RTL ? -1 : 1;
    let open = this.source(this.view, pos, coords.x < posCoords.left ? -rtl : rtl);

    if ((_a = open) === null || _a === void 0 ? void 0 : _a.then) {
      let pending = this.pending = {
        pos
      };
      open.then(result => {
        if (this.pending == pending) {
          this.pending = null;
          if (result) this.view.dispatch({
            effects: this.setHover.of(result)
          });
        }
      }, e => (0, _view.logException)(this.view.state, e, "hover tooltip"));
    } else if (open) {
      this.view.dispatch({
        effects: this.setHover.of(open)
      });
    }
  }

  mousemove(event) {
    var _a;

    this.lastMouseMove = event;
    this.lastMoveTime = Date.now();
    if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
    let tooltip = this.active;

    if (tooltip && !isInTooltip(event.target) || this.pending) {
      let {
        pos
      } = tooltip || this.pending,
          end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;

      if (pos == end ? this.view.posAtCoords({
        x: event.clientX,
        y: event.clientY
      }) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6
      /* MaxDist */
      )) {
        this.view.dispatch({
          effects: this.setHover.of(null)
        });
        this.pending = null;
      }
    }
  }

  mouseleave() {
    clearTimeout(this.hoverTimeout);
    this.hoverTimeout = -1;
    if (this.active) this.view.dispatch({
      effects: this.setHover.of(null)
    });
  }

  destroy() {
    clearTimeout(this.hoverTimeout);
    this.view.dom.removeEventListener("mouseleave", this.mouseleave);
    this.view.dom.removeEventListener("mousemove", this.mousemove);
  }

}

function isInTooltip(elt) {
  for (let cur = elt; cur; cur = cur.parentNode) if (cur.nodeType == 1 && cur.classList.contains("cm-tooltip")) return true;

  return false;
}

function isOverRange(view, from, to, x, y, margin) {
  let range = document.createRange();
  let fromDOM = view.domAtPos(from),
      toDOM = view.domAtPos(to);
  range.setEnd(toDOM.node, toDOM.offset);
  range.setStart(fromDOM.node, fromDOM.offset);
  let rects = range.getClientRects();
  range.detach();

  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i];
    let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
    if (dist <= margin) return true;
  }

  return false;
}
/**
Enable a hover tooltip, which shows up when the pointer hovers
over ranges of text. The callback is called when the mouse hovers
over the document text. It should, if there is a tooltip
associated with position `pos` return the tooltip description
(either directly or in a promise). The `side` argument indicates
on which side of the position the pointer is—it will be -1 if the
pointer is before the position, 1 if after the position.

Note that all hover tooltips are hosted within a single tooltip
container element. This allows multiple tooltips over the same
range to be "merged" together without overlapping.
*/


function hoverTooltip(source, options = {}) {
  let setHover = _state.StateEffect.define();

  let hoverState = _state.StateField.define({
    create() {
      return null;
    },

    update(value, tr) {
      if (value && options.hideOnChange && (tr.docChanged || tr.selection)) return null;

      for (let effect of tr.effects) if (effect.is(setHover)) return effect.value;

      if (value && tr.docChanged) {
        let newPos = tr.changes.mapPos(value.pos, -1, _state.MapMode.TrackDel);
        if (newPos == null) return null;
        let copy = Object.assign(Object.create(null), value);
        copy.pos = newPos;
        if (value.end != null) copy.end = tr.changes.mapPos(value.end);
        return copy;
      }

      return value;
    },

    provide: f => showHoverTooltip.from(f)
  });

  let hoverTime = options.hoverTime || 750
  /* Time */
  ;
  return [hoverState, _view.ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, hoverTime)), showHoverTooltipHost];
}
},{"@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/state":"node_modules/@codemirror/state/dist/index.js"}],"node_modules/@codemirror/autocomplete/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autocompletion = autocompletion;
exports.completeFromList = completeFromList;
exports.completionStatus = completionStatus;
exports.currentCompletions = currentCompletions;
exports.ifIn = ifIn;
exports.ifNotIn = ifNotIn;
exports.moveCompletionSelection = moveCompletionSelection;
exports.snippet = snippet;
exports.snippetCompletion = snippetCompletion;
exports.startCompletion = exports.snippetKeymap = exports.prevSnippetField = exports.nextSnippetField = exports.completionKeymap = exports.completeAnyWord = exports.closeCompletion = exports.clearSnippet = exports.acceptCompletion = exports.CompletionContext = void 0;

var _state = require("@codemirror/state");

var _view = require("@codemirror/view");

var _tooltip = require("@codemirror/tooltip");

var _language = require("@codemirror/language");

var _text = require("@codemirror/text");

/**
An instance of this is passed to completion source functions.
*/
class CompletionContext {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(
  /**
  The editor state that the completion happens in.
  */
  state,
  /**
  The position at which the completion is happening.
  */
  pos,
  /**
  Indicates whether completion was activated explicitly, or
  implicitly by typing. The usual way to respond to this is to
  only return completions when either there is part of a
  completable entity before the cursor, or `explicit` is true.
  */
  explicit) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    /**
    @internal
    */

    this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */


  tokenBefore(types) {
    let token = (0, _language.syntaxTree)(this.state).resolveInner(this.pos, -1);

    while (token && types.indexOf(token.name) < 0) token = token.parent;

    return token ? {
      from: token.from,
      to: this.pos,
      text: this.state.sliceDoc(token.from, this.pos),
      type: token.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */


  matchBefore(expr) {
    let line = this.state.doc.lineAt(this.pos);
    let start = Math.max(line.from, this.pos - 250);
    let str = line.text.slice(start - line.from, this.pos - line.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : {
      from: start + found,
      to: this.pos,
      text: str.slice(found)
    };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */


  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */


  addEventListener(type, listener) {
    if (type == "abort" && this.abortListeners) this.abortListeners.push(listener);
  }

}

exports.CompletionContext = CompletionContext;

function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words = /\w/.test(flat);
  if (words) flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}

function prefixMatch(options) {
  let first = Object.create(null),
      rest = Object.create(null);

  for (let {
    label
  } of options) {
    first[label[0]] = true;

    for (let i = 1; i < label.length; i++) rest[label[i]] = true;
  }

  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
/**
Given a a fixed array of options, return an autocompleter that
completes them.
*/


function completeFromList(list) {
  let options = list.map(o => typeof o == "string" ? {
    label: o
  } : o);
  let [span, match] = options.every(o => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
  return context => {
    let token = context.matchBefore(match);
    return token || context.explicit ? {
      from: token ? token.from : context.pos,
      options,
      span
    } : null;
  };
}
/**
Wrap the given completion source so that it will only fire when the
cursor is in a syntax node with one of the given names.
*/


function ifIn(nodes, source) {
  return context => {
    for (let pos = (0, _language.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) if (nodes.indexOf(pos.name) > -1) return source(context);

    return null;
  };
}
/**
Wrap the given completion source so that it will not fire when the
cursor is in a syntax node with one of the given names.
*/


function ifNotIn(nodes, source) {
  return context => {
    for (let pos = (0, _language.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) if (nodes.indexOf(pos.name) > -1) return null;

    return source(context);
  };
}

class Option {
  constructor(completion, source, match) {
    this.completion = completion;
    this.source = source;
    this.match = match;
  }

}

function cur(state) {
  return state.selection.main.head;
} // Make sure the given regexp has a $ at its end and, if `start` is
// true, a ^ at its start.


function ensureAnchor(expr, start) {
  var _a;

  let {
    source
  } = expr;
  let addStart = start && source[0] != "^",
      addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd) return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? "i" : "");
}

function applyCompletion(view, option) {
  let apply = option.completion.apply || option.completion.label;
  let result = option.source;

  if (typeof apply == "string") {
    view.dispatch({
      changes: {
        from: result.from,
        to: result.to,
        insert: apply
      },
      selection: {
        anchor: result.from + apply.length
      },
      userEvent: "input.complete"
    });
  } else {
    apply(view, option.completion, result.from, result.to);
  }
}

const SourceCache = /*@__PURE__*/new WeakMap();

function asSource(source) {
  if (!Array.isArray(source)) return source;
  let known = SourceCache.get(source);
  if (!known) SourceCache.set(source, known = completeFromList(source));
  return known;
} // A pattern matcher for fuzzy completion matching. Create an instance
// once for a pattern, and then use that to match any number of
// completions.


class FuzzyMatcher {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = []; // Buffers reused by calls to `match` to track matched character
    // positions.

    this.any = [];
    this.precise = [];
    this.byWord = [];

    for (let p = 0; p < pattern.length;) {
      let char = (0, _text.codePointAt)(pattern, p),
          size = (0, _text.codePointSize)(char);
      this.chars.push(char);
      let part = pattern.slice(p, p + size),
          upper = part.toUpperCase();
      this.folded.push((0, _text.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));
      p += size;
    }

    this.astral = pattern.length != this.chars.length;
  } // Matches a given word (completion) against the pattern (input).
  // Will return null for no match, and otherwise an array that starts
  // with the match score, followed by any number of `from, to` pairs
  // indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.


  match(word) {
    if (this.pattern.length == 0) return [0];
    if (word.length < this.pattern.length) return null;
    let {
      chars,
      folded,
      any,
      precise,
      byWord
    } = this; // For single-character queries, only match when they occur right
    // at the start

    if (chars.length == 1) {
      let first = (0, _text.codePointAt)(word, 0);
      return first == chars[0] ? [0, 0, (0, _text.codePointSize)(first)] : first == folded[0] ? [-200
      /* CaseFold */
      , 0, (0, _text.codePointSize)(first)] : null;
    }

    let direct = word.indexOf(this.pattern);
    if (direct == 0) return [0, 0, this.pattern.length];
    let len = chars.length,
        anyTo = 0;

    if (direct < 0) {
      for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {
        let next = (0, _text.codePointAt)(word, i);
        if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;
        i += (0, _text.codePointSize)(next);
      } // No match, exit immediately


      if (anyTo < len) return null;
    } // This tracks the extent of the precise (non-folded, not
    // necessarily adjacent) match


    let preciseTo = 0; // Tracks whether there is a match that hits only characters that
    // appear to be starting words. `byWordFolded` is set to true when
    // a case folded character is encountered in such a match

    let byWordTo = 0,
        byWordFolded = false; // If we've found a partial adjacent match, these track its state

    let adjacentTo = 0,
        adjacentStart = -1,
        adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word); // Go over the option's text, scanning for the various kinds of matches

    for (let i = 0, e = Math.min(word.length, 200), prevType = 0
    /* NonWord */
    ; i < e && byWordTo < len;) {
      let next = (0, _text.codePointAt)(word, i);

      if (direct < 0) {
        if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i;

        if (adjacentTo < len) {
          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
            if (adjacentTo == 0) adjacentStart = i;
            adjacentEnd = i;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }

      let ch,
          type = next < 0xff ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2
      /* Lower */
      : next >= 65 && next <= 90 ? 1
      /* Upper */
      : 0
      /* NonWord */
      : (ch = (0, _text.fromCodePoint)(next)) != ch.toLowerCase() ? 1
      /* Upper */
      : ch != ch.toUpperCase() ? 2
      /* Lower */
      : 0
      /* NonWord */
      ;
      if ((type == 1
      /* Upper */
      && hasLower || prevType == 0
      /* NonWord */
      && type != 0
      /* NonWord */
      ) && (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))) byWord[byWordTo++] = i;
      prevType = type;
      i += (0, _text.codePointSize)(next);
    }

    if (byWordTo == len && byWord[0] == 0) return this.result(-100
    /* ByWord */
    + (byWordFolded ? -200
    /* CaseFold */
    : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0) return [-200
    /* CaseFold */
    , 0, adjacentEnd];
    if (direct > -1) return [-700
    /* NotStart */
    , direct, direct + this.pattern.length];
    if (adjacentTo == len) return [-200
    /* CaseFold */
    + -700
    /* NotStart */
    , adjacentStart, adjacentEnd];
    if (byWordTo == len) return this.result(-100
    /* ByWord */
    + (byWordFolded ? -200
    /* CaseFold */
    : 0) + -700
    /* NotStart */
    , byWord, word);
    return chars.length == 2 ? null : this.result((any[0] ? -700
    /* NotStart */
    : 0) + -200
    /* CaseFold */
    + -1100
    /* Gap */
    , any, word);
  }

  result(score, positions, word) {
    let result = [score],
        i = 1;

    for (let pos of positions) {
      let to = pos + (this.astral ? (0, _text.codePointSize)((0, _text.codePointAt)(word, pos)) : 1);
      if (i > 1 && result[i - 1] == pos) result[i - 1] = to;else {
        result[i++] = pos;
        result[i++] = to;
      }
    }

    return result;
  }

}

const completionConfig = /*@__PURE__*/_state.Facet.define({
  combine(configs) {
    return (0, _state.combineConfig)(configs, {
      activateOnTyping: true,
      override: null,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      optionClass: () => "",
      icons: true,
      addToOptions: []
    }, {
      defaultKeymap: (a, b) => a && b,
      icons: (a, b) => a && b,
      optionClass: (a, b) => c => joinClass(a(c), b(c)),
      addToOptions: (a, b) => a.concat(b)
    });
  }

});

function joinClass(a, b) {
  return a ? b ? a + " " + b : a : b;
}

const MaxInfoWidth = 300;

const baseTheme = /*@__PURE__*/_view.EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      maxHeight: "10em",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li": {
        cursor: "pointer",
        padding: "1px 1em 1px 3px",
        lineHeight: 1.2
      },
      "& > li[aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      }
    }
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: MaxInfoWidth + "px"
  },
  ".cm-completionInfo.cm-completionInfo-left": {
    right: "100%"
  },
  ".cm-completionInfo.cm-completionInfo-right": {
    left: "100%"
  },
  "&light .cm-snippetField": {
    backgroundColor: "#00000022"
  },
  "&dark .cm-snippetField": {
    backgroundColor: "#ffffff22"
  },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": {
      content: "'ƒ'"
    }
  },
  ".cm-completionIcon-class": {
    "&:after": {
      content: "'○'"
    }
  },
  ".cm-completionIcon-interface": {
    "&:after": {
      content: "'◌'"
    }
  },
  ".cm-completionIcon-variable": {
    "&:after": {
      content: "'𝑥'"
    }
  },
  ".cm-completionIcon-constant": {
    "&:after": {
      content: "'𝐶'"
    }
  },
  ".cm-completionIcon-type": {
    "&:after": {
      content: "'𝑡'"
    }
  },
  ".cm-completionIcon-enum": {
    "&:after": {
      content: "'∪'"
    }
  },
  ".cm-completionIcon-property": {
    "&:after": {
      content: "'□'"
    }
  },
  ".cm-completionIcon-keyword": {
    "&:after": {
      content: "'🔑\uFE0E'"
    } // Disable emoji rendering

  },
  ".cm-completionIcon-namespace": {
    "&:after": {
      content: "'▢'"
    }
  },
  ".cm-completionIcon-text": {
    "&:after": {
      content: "'abc'",
      fontSize: "50%",
      verticalAlign: "middle"
    }
  }
});

function optionContent(config) {
  let content = config.addToOptions.slice();
  if (config.icons) content.push({
    render(completion) {
      let icon = document.createElement("div");
      icon.classList.add("cm-completionIcon");
      if (completion.type) icon.classList.add(...completion.type.split(/\s+/g).map(cls => "cm-completionIcon-" + cls));
      icon.setAttribute("aria-hidden", "true");
      return icon;
    },

    position: 20
  });
  content.push({
    render(completion, _s, match) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let {
        label
      } = completion,
          off = 0;

      for (let j = 1; j < match.length;) {
        let from = match[j++],
            to = match[j++];
        if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from, to)));
        span.className = "cm-completionMatchedText";
        off = to;
      }

      if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));
      return labelElt;
    },

    position: 50
  }, {
    render(completion) {
      if (!completion.detail) return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },

    position: 80
  });
  return content.sort((a, b) => a.position - b.position).map(a => a.render);
}

function createInfoDialog(option, view) {
  let dom = document.createElement("div");
  dom.className = "cm-tooltip cm-completionInfo";
  let {
    info
  } = option.completion;

  if (typeof info == "string") {
    dom.textContent = info;
  } else {
    let content = info(option.completion);
    if (content.then) content.then(node => dom.appendChild(node), e => (0, _view.logException)(view.state, e, "completion info"));else dom.appendChild(content);
  }

  return dom;
}

function rangeAroundSelected(total, selected, max) {
  if (total <= max) return {
    from: 0,
    to: total
  };

  if (selected <= total >> 1) {
    let off = Math.floor(selected / max);
    return {
      from: off * max,
      to: (off + 1) * max
    };
  }

  let off = Math.floor((total - selected) / max);
  return {
    from: total - (off + 1) * max,
    to: total - off * max
  };
}

class CompletionTooltip {
  constructor(view, stateField) {
    this.view = view;
    this.stateField = stateField;
    this.info = null;
    this.placeInfo = {
      read: () => this.measureInfo(),
      write: pos => this.positionInfo(pos),
      key: this
    };
    let cState = view.state.field(stateField);
    let {
      options,
      selected
    } = cState.open;
    let config = view.state.facet(completionConfig);
    this.optionContent = optionContent(config);
    this.optionClass = config.optionClass;
    this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.dom.addEventListener("mousedown", e => {
      for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
        if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
          applyCompletion(view, options[+match[1]]);
          e.preventDefault();
          return;
        }
      }
    });
    this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info) this.view.requestMeasure(this.placeInfo);
    });
  }

  mount() {
    this.updateSel();
  }

  update(update) {
    if (update.state.field(this.stateField) != update.startState.field(this.stateField)) this.updateSel();
  }

  positioned() {
    if (this.info) this.view.requestMeasure(this.placeInfo);
  }

  updateSel() {
    let cState = this.view.state.field(this.stateField),
        open = cState.open;

    if (open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.list.remove();
      this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info) this.view.requestMeasure(this.placeInfo);
      });
    }

    if (this.updateSelectedOption(open.selected)) {
      if (this.info) {
        this.info.remove();
        this.info = null;
      }

      let option = open.options[open.selected];

      if (option.completion.info) {
        this.info = this.dom.appendChild(createInfoDialog(option, this.view));
        this.view.requestMeasure(this.placeInfo);
      }
    }
  }

  updateSelectedOption(selected) {
    let set = null;

    for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
      if (i == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected")) opt.removeAttribute("aria-selected");
      }
    }

    if (set) scrollIntoView(this.list, set);
    return set;
  }

  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel) return null;
    let rect = this.dom.getBoundingClientRect();
    let top = sel.getBoundingClientRect().top - rect.top;
    if (top < 0 || top > this.list.clientHeight - 10) return null;
    let left = this.view.textDirection == _view.Direction.RTL;
    let spaceLeft = rect.left,
        spaceRight = innerWidth - rect.right;
    if (left && spaceLeft < Math.min(MaxInfoWidth, spaceRight)) left = false;else if (!left && spaceRight < Math.min(MaxInfoWidth, spaceLeft)) left = true;
    return {
      top,
      left
    };
  }

  positionInfo(pos) {
    if (this.info && pos) {
      this.info.style.top = pos.top + "px";
      this.info.classList.toggle("cm-completionInfo-left", pos.left);
      this.info.classList.toggle("cm-completionInfo-right", !pos.left);
    }
  }

  createListBox(options, id, range) {
    const ul = document.createElement("ul");
    ul.id = id;
    ul.setAttribute("role", "listbox");

    for (let i = range.from; i < range.to; i++) {
      let {
        completion,
        match
      } = options[i];
      const li = ul.appendChild(document.createElement("li"));
      li.id = id + "-" + i;
      li.setAttribute("role", "option");
      let cls = this.optionClass(completion);
      if (cls) li.className = cls;

      for (let source of this.optionContent) {
        let node = source(completion, this.view.state, match);
        if (node) li.appendChild(node);
      }
    }

    if (range.from) ul.classList.add("cm-completionListIncompleteTop");
    if (range.to < options.length) ul.classList.add("cm-completionListIncompleteBottom");
    return ul;
  }

} // We allocate a new function instance every time the completion
// changes to force redrawing/repositioning of the tooltip


function completionTooltip(stateField) {
  return view => new CompletionTooltip(view, stateField);
}

function scrollIntoView(container, element) {
  let parent = container.getBoundingClientRect();
  let self = element.getBoundingClientRect();
  if (self.top < parent.top) container.scrollTop -= parent.top - self.top;else if (self.bottom > parent.bottom) container.scrollTop += self.bottom - parent.bottom;
}

const MaxOptions = 300; // Used to pick a preferred option when two options with the same
// label occur in the result.

function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}

function sortOptions(active, state) {
  let options = [],
      i = 0;

  for (let a of active) if (a.hasResult()) {
    if (a.result.filter === false) {
      for (let option of a.result.options) options.push(new Option(option, a, [1e9 - i++]));
    } else {
      let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)),
          match;

      for (let option of a.result.options) if (match = matcher.match(option.label)) {
        if (option.boost != null) match[0] += option.boost;
        options.push(new Option(option, a, match));
      }
    }
  }

  options.sort(cmpOption);
  let result = [],
      prev = null;

  for (let opt of options.sort(cmpOption)) {
    if (result.length == MaxOptions) break;
    if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail) result.push(opt);else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;
    prev = opt.completion;
  }

  return result;
}

class CompletionDialog {
  constructor(options, attrs, tooltip, timestamp, selected) {
    this.options = options;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
  }

  setSelected(selected, id) {
    return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);
  }

  static build(active, state, id, prev) {
    let options = sortOptions(active, state);
    if (!options.length) return null;
    let selected = 0;

    if (prev && prev.selected) {
      let selectedValue = prev.options[prev.selected].completion;

      for (let i = 0; i < options.length && !selected; i++) {
        if (options[i].completion == selectedValue) selected = i;
      }
    }

    return new CompletionDialog(options, makeAttrs(id, selected), {
      pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
      create: completionTooltip(completionState)
    }, prev ? prev.timestamp : Date.now(), selected);
  }

  map(changes) {
    return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {
      pos: changes.mapPos(this.tooltip.pos)
    }), this.timestamp, this.selected);
  }

}

class CompletionState {
  constructor(active, id, open) {
    this.active = active;
    this.id = id;
    this.open = open;
  }

  static start() {
    return new CompletionState(none, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }

  update(tr) {
    let {
      state
    } = tr,
        conf = state.facet(completionConfig);
    let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active = sources.map(source => {
      let value = this.active.find(s => s.source == source) || new ActiveSource(source, this.active.some(a => a.state != 0
      /* Inactive */
      ) ? 1
      /* Pending */
      : 0
      /* Inactive */
      );
      return value.update(tr, conf);
    });
    if (active.length == this.active.length && active.every((a, i) => a == this.active[i])) active = this.active;
    let open = tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;
    if (!open && active.every(a => a.state != 1
    /* Pending */
    ) && active.some(a => a.hasResult())) active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0
    /* Inactive */
    ) : a);

    for (let effect of tr.effects) if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);

    return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
  }

  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }

  get attrs() {
    return this.open ? this.open.attrs : baseAttrs;
  }

}

function sameResults(a, b) {
  if (a == b) return true;

  for (let iA = 0, iB = 0;;) {
    while (iA < a.length && !a[iA].hasResult) iA++;

    while (iB < b.length && !b[iB].hasResult) iB++;

    let endA = iA == a.length,
        endB = iB == b.length;
    if (endA || endB) return endA == endB;
    if (a[iA++].result != b[iB++].result) return false;
  }
}

const baseAttrs = {
  "aria-autocomplete": "list",
  "aria-expanded": "false"
};

function makeAttrs(id, selected) {
  return {
    "aria-autocomplete": "list",
    "aria-expanded": "true",
    "aria-activedescendant": id + "-" + selected,
    "aria-controls": id
  };
}

const none = [];

function cmpOption(a, b) {
  let dScore = b.match[0] - a.match[0];
  if (dScore) return dScore;
  return a.completion.label.localeCompare(b.completion.label);
}

function getUserEvent(tr) {
  return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
}

class ActiveSource {
  constructor(source, state, explicitPos = -1) {
    this.source = source;
    this.state = state;
    this.explicitPos = explicitPos;
  }

  hasResult() {
    return false;
  }

  update(tr, conf) {
    let event = getUserEvent(tr),
        value = this;
    if (event) value = value.handleUserEvent(tr, event, conf);else if (tr.docChanged) value = value.handleChange(tr);else if (tr.selection && value.state != 0
    /* Inactive */
    ) value = new ActiveSource(value.source, 0
      /* Inactive */
      );

    for (let effect of tr.effects) {
      if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1
      /* Pending */
      , effect.value ? cur(tr.state) : -1);else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0
      /* Inactive */
      );else if (effect.is(setActiveEffect)) for (let active of effect.value) if (active.source == value.source) value = active;
    }

    return value;
  }

  handleUserEvent(tr, type, conf) {
    return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1
    /* Pending */
    );
  }

  handleChange(tr) {
    return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0
    /* Inactive */
    ) : this.map(tr.changes);
  }

  map(changes) {
    return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
  }

}

class ActiveResult extends ActiveSource {
  constructor(source, explicitPos, result, from, to, span) {
    super(source, 2
    /* Result */
    , explicitPos);
    this.result = result;
    this.from = from;
    this.to = to;
    this.span = span;
  }

  hasResult() {
    return true;
  }

  handleUserEvent(tr, type, conf) {
    let from = tr.changes.mapPos(this.from),
        to = tr.changes.mapPos(this.to, 1);
    let pos = cur(tr.state);
    if ((this.explicitPos > -1 ? pos < from : pos <= from) || pos > to) return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1
    /* Pending */
    : 0
    /* Inactive */
    );
    let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos);
    if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to)))) return new ActiveResult(this.source, explicitPos, this.result, from, to, this.span);
    return new ActiveSource(this.source, 1
    /* Pending */
    , explicitPos);
  }

  handleChange(tr) {
    return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0
    /* Inactive */
    ) : this.map(tr.changes);
  }

  map(mapping) {
    return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);
  }

}

const startCompletionEffect = /*@__PURE__*/_state.StateEffect.define();

const closeCompletionEffect = /*@__PURE__*/_state.StateEffect.define();

const setActiveEffect = /*@__PURE__*/_state.StateEffect.define({
  map(sources, mapping) {
    return sources.map(s => s.map(mapping));
  }

});

const setSelectedEffect = /*@__PURE__*/_state.StateEffect.define();

const completionState = /*@__PURE__*/_state.StateField.define({
  create() {
    return CompletionState.start();
  },

  update(value, tr) {
    return value.update(tr);
  },

  provide: f => [_tooltip.showTooltip.from(f, val => val.tooltip), _view.EditorView.contentAttributes.from(f, state => state.attrs)]
});

const CompletionInteractMargin = 75;
/**
Returns a command that moves the completion selection forward or
backward by the given amount.
*/

function moveCompletionSelection(forward, by = "option") {
  return view => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin) return false;
    let step = 1,
        tooltip;
    if (by == "page" && (tooltip = view.dom.querySelector(".cm-tooltip-autocomplete"))) step = Math.max(2, Math.floor(tooltip.offsetHeight / tooltip.firstChild.offsetHeight));
    let selected = cState.open.selected + step * (forward ? 1 : -1),
        {
      length
    } = cState.open.options;
    if (selected < 0) selected = by == "page" ? 0 : length - 1;else if (selected >= length) selected = by == "page" ? length - 1 : 0;
    view.dispatch({
      effects: setSelectedEffect.of(selected)
    });
    return true;
  };
}
/**
Accept the current completion.
*/


const acceptCompletion = view => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin) return false;
  applyCompletion(view, cState.open.options[cState.open.selected]);
  return true;
};
/**
Explicitly start autocompletion.
*/


exports.acceptCompletion = acceptCompletion;

const startCompletion = view => {
  let cState = view.state.field(completionState, false);
  if (!cState) return false;
  view.dispatch({
    effects: startCompletionEffect.of(true)
  });
  return true;
};
/**
Close the currently active completion.
*/


exports.startCompletion = startCompletion;

const closeCompletion = view => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some(a => a.state != 0
  /* Inactive */
  )) return false;
  view.dispatch({
    effects: closeCompletionEffect.of(null)
  });
  return true;
};

exports.closeCompletion = closeCompletion;

class RunningQuery {
  constructor(active, context) {
    this.active = active;
    this.context = context;
    this.time = Date.now();
    this.updates = []; // Note that 'undefined' means 'not done yet', whereas 'null' means
    // 'query returned null'.

    this.done = undefined;
  }

}

const DebounceTime = 50,
      MaxUpdateCount = 50,
      MinAbortTime = 1000;

const completionPlugin = /*@__PURE__*/_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.debounceUpdate = -1;
    this.running = [];
    this.debounceAccept = -1;
    this.composing = 0
    /* None */
    ;

    for (let active of view.state.field(completionState).active) if (active.state == 1
    /* Pending */
    ) this.startQuery(active);
  }

  update(update) {
    let cState = update.state.field(completionState);
    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState) return;
    let doesReset = update.transactions.some(tr => {
      return (tr.selection || tr.docChanged) && !getUserEvent(tr);
    });

    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];

      if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && query.time - Date.now() > MinAbortTime) {
        for (let handler of query.context.abortListeners) {
          try {
            handler();
          } catch (e) {
            (0, _view.logException)(this.view.state, e);
          }
        }

        query.context.abortListeners = null;
        this.running.splice(i--, 1);
      } else {
        query.updates.push(...update.transactions);
      }
    }

    if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);
    this.debounceUpdate = cState.active.some(a => a.state == 1
    /* Pending */
    && !this.running.some(q => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
    if (this.composing != 0
    /* None */
    ) for (let tr of update.transactions) {
        if (getUserEvent(tr) == "input") this.composing = 2
        /* Changed */
        ;else if (this.composing == 2
        /* Changed */
        && tr.selection) this.composing = 3
        /* ChangedAndMoved */
        ;
      }
  }

  startUpdate() {
    this.debounceUpdate = -1;
    let {
      state
    } = this.view,
        cState = state.field(completionState);

    for (let active of cState.active) {
      if (active.state == 1
      /* Pending */
      && !this.running.some(r => r.active.source == active.source)) this.startQuery(active);
    }
  }

  startQuery(active) {
    let {
      state
    } = this.view,
        pos = cur(state);
    let context = new CompletionContext(state, pos, active.explicitPos == pos);
    let pending = new RunningQuery(active, context);
    this.running.push(pending);
    Promise.resolve(active.source(context)).then(result => {
      if (!pending.context.aborted) {
        pending.done = result || null;
        this.scheduleAccept();
      }
    }, err => {
      this.view.dispatch({
        effects: closeCompletionEffect.of(null)
      });
      (0, _view.logException)(this.view.state, err);
    });
  }

  scheduleAccept() {
    if (this.running.every(q => q.done !== undefined)) this.accept();else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
  } // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.


  accept() {
    var _a;

    if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);
    this.debounceAccept = -1;
    let updated = [];
    let conf = this.view.state.facet(completionConfig);

    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (query.done === undefined) continue;
      this.running.splice(i--, 1);

      if (query.done) {
        let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state), query.done.span && query.done.filter !== false ? ensureAnchor(query.done.span, true) : null); // Replay the transactions that happened since the start of
        // the request and see if that preserves the result

        for (let tr of query.updates) active = active.update(tr, conf);

        if (active.hasResult()) {
          updated.push(active);
          continue;
        }
      }

      let current = this.view.state.field(completionState).active.find(a => a.source == query.active.source);

      if (current && current.state == 1
      /* Pending */
      ) {
          if (query.done == null) {
            // Explicitly failed. Should clear the pending status if it
            // hasn't been re-set in the meantime.
            let active = new ActiveSource(query.active.source, 0
            /* Inactive */
            );

            for (let tr of query.updates) active = active.update(tr, conf);

            if (active.state != 1
            /* Pending */
            ) updated.push(active);
          } else {
            // Cleared by subsequent transactions. Restart.
            this.startQuery(current);
          }
        }
    }

    if (updated.length) this.view.dispatch({
      effects: setActiveEffect.of(updated)
    });
  }

}, {
  eventHandlers: {
    compositionstart() {
      this.composing = 1
      /* Started */
      ;
    },

    compositionend() {
      if (this.composing == 3
      /* ChangedAndMoved */
      ) {
          // Safari fires compositionend events synchronously, possibly
          // from inside an update, so dispatch asynchronously to avoid reentrancy
          setTimeout(() => this.view.dispatch({
            effects: startCompletionEffect.of(false)
          }), 20);
        }

      this.composing = 0
      /* None */
      ;
    }

  }
});

class FieldPos {
  constructor(field, line, from, to) {
    this.field = field;
    this.line = line;
    this.from = from;
    this.to = to;
  }

}

class FieldRange {
  constructor(field, from, to) {
    this.field = field;
    this.from = from;
    this.to = to;
  }

  map(changes) {
    return new FieldRange(this.field, changes.mapPos(this.from, -1), changes.mapPos(this.to, 1));
  }

}

class Snippet {
  constructor(lines, fieldPositions) {
    this.lines = lines;
    this.fieldPositions = fieldPositions;
  }

  instantiate(state, pos) {
    let text = [],
        lineStart = [pos];
    let lineObj = state.doc.lineAt(pos),
        baseIndent = /^\s*/.exec(lineObj.text)[0];

    for (let line of this.lines) {
      if (text.length) {
        let indent = baseIndent,
            tabs = /^\t*/.exec(line)[0].length;

        for (let i = 0; i < tabs; i++) indent += state.facet(_language.indentUnit);

        lineStart.push(pos + indent.length - tabs);
        line = indent + line.slice(tabs);
      }

      text.push(line);
      pos += line.length + 1;
    }

    let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));
    return {
      text,
      ranges
    };
  }

  static parse(template) {
    let fields = [];
    let lines = [],
        positions = [],
        m;

    for (let line of template.split(/\r\n?|\n/)) {
      while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line)) {
        let seq = m[1] ? +m[1] : null,
            name = m[2] || m[3],
            found = -1;

        for (let i = 0; i < fields.length; i++) {
          if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false) found = i;
        }

        if (found < 0) {
          let i = 0;

          while (i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq)) i++;

          fields.splice(i, 0, {
            seq,
            name: name || null
          });
          found = i;

          for (let pos of positions) if (pos.field >= found) pos.field++;
        }

        positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));
        line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);
      }

      lines.push(line);
    }

    return new Snippet(lines, positions);
  }

}

let fieldMarker = /*@__PURE__*/_view.Decoration.widget({
  widget: /*@__PURE__*/new class extends _view.WidgetType {
    toDOM() {
      let span = document.createElement("span");
      span.className = "cm-snippetFieldPosition";
      return span;
    }

    ignoreEvent() {
      return false;
    }

  }()
});

let fieldRange = /*@__PURE__*/_view.Decoration.mark({
  class: "cm-snippetField"
});

class ActiveSnippet {
  constructor(ranges, active) {
    this.ranges = ranges;
    this.active = active;
    this.deco = _view.Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
  }

  map(changes) {
    return new ActiveSnippet(this.ranges.map(r => r.map(changes)), this.active);
  }

  selectionInsideField(sel) {
    return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));
  }

}

const setActive = /*@__PURE__*/_state.StateEffect.define({
  map(value, changes) {
    return value && value.map(changes);
  }

});

const moveToField = /*@__PURE__*/_state.StateEffect.define();

const snippetState = /*@__PURE__*/_state.StateField.define({
  create() {
    return null;
  },

  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setActive)) return effect.value;
      if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);
    }

    if (value && tr.docChanged) value = value.map(tr.changes);
    if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;
    return value;
  },

  provide: f => _view.EditorView.decorations.from(f, val => val ? val.deco : _view.Decoration.none)
});

function fieldSelection(ranges, field) {
  return _state.EditorSelection.create(ranges.filter(r => r.field == field).map(r => _state.EditorSelection.range(r.from, r.to)));
}
/**
Convert a snippet template to a function that can apply it.
Snippets are written using syntax like this:

    "for (let ${index} = 0; ${index} < ${end}; ${index}++) {\n\t${}\n}"

Each `${}` placeholder (you may also use `#{}`) indicates a field
that the user can fill in. Its name, if any, will be the default
content for the field.

When the snippet is activated by calling the returned function,
the code is inserted at the given position. Newlines in the
template are indented by the indentation of the start line, plus
one [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after
the newline.

On activation, (all instances of) the first field are selected.
The user can move between fields with Tab and Shift-Tab as long as
the fields are active. Moving to the last field or moving the
cursor out of the current field deactivates the fields.

The order of fields defaults to textual order, but you can add
numbers to placeholders (`${1}` or `${1:defaultText}`) to provide
a custom order.
*/


function snippet(template) {
  let snippet = Snippet.parse(template);
  return (editor, _completion, from, to) => {
    let {
      text,
      ranges
    } = snippet.instantiate(editor.state, from);
    let spec = {
      changes: {
        from,
        to,
        insert: _state.Text.of(text)
      }
    };
    if (ranges.length) spec.selection = fieldSelection(ranges, 0);

    if (ranges.length > 1) {
      let active = new ActiveSnippet(ranges, 0);
      let effects = spec.effects = [setActive.of(active)];
      if (editor.state.field(snippetState, false) === undefined) effects.push(_state.StateEffect.appendConfig.of([snippetState.init(() => active), addSnippetKeymap, snippetPointerHandler, baseTheme]));
    }

    editor.dispatch(editor.state.update(spec));
  };
}

function moveField(dir) {
  return ({
    state,
    dispatch
  }) => {
    let active = state.field(snippetState, false);
    if (!active || dir < 0 && active.active == 0) return false;
    let next = active.active + dir,
        last = dir > 0 && !active.ranges.some(r => r.field == next + dir);
    dispatch(state.update({
      selection: fieldSelection(active.ranges, next),
      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))
    }));
    return true;
  };
}
/**
A command that clears the active snippet, if any.
*/


const clearSnippet = ({
  state,
  dispatch
}) => {
  let active = state.field(snippetState, false);
  if (!active) return false;
  dispatch(state.update({
    effects: setActive.of(null)
  }));
  return true;
};
/**
Move to the next snippet field, if available.
*/


exports.clearSnippet = clearSnippet;
const nextSnippetField = /*@__PURE__*/moveField(1);
/**
Move to the previous snippet field, if available.
*/

exports.nextSnippetField = nextSnippetField;
const prevSnippetField = /*@__PURE__*/moveField(-1);
exports.prevSnippetField = prevSnippetField;
const defaultSnippetKeymap = [{
  key: "Tab",
  run: nextSnippetField,
  shift: prevSnippetField
}, {
  key: "Escape",
  run: clearSnippet
}];
/**
A facet that can be used to configure the key bindings used by
snippets. The default binds Tab to
[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to
[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape
to [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).
*/

const snippetKeymap = /*@__PURE__*/_state.Facet.define({
  combine(maps) {
    return maps.length ? maps[0] : defaultSnippetKeymap;
  }

});

exports.snippetKeymap = snippetKeymap;

const addSnippetKeymap = /*@__PURE__*/_state.Prec.override( /*@__PURE__*/_view.keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));
/**
Create a completion from a snippet. Returns an object with the
properties from `completion`, plus an `apply` function that
applies the snippet.
*/


function snippetCompletion(template, completion) {
  return Object.assign(Object.assign({}, completion), {
    apply: snippet(template)
  });
}

const snippetPointerHandler = /*@__PURE__*/_view.EditorView.domEventHandlers({
  mousedown(event, view) {
    let active = view.state.field(snippetState, false),
        pos;
    if (!active || (pos = view.posAtCoords({
      x: event.clientX,
      y: event.clientY
    })) == null) return false;
    let match = active.ranges.find(r => r.from <= pos && r.to >= pos);
    if (!match || match.field == active.active) return false;
    view.dispatch({
      selection: fieldSelection(active.ranges, match.field),
      effects: setActive.of(active.ranges.some(r => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)
    });
    return true;
  }

});

function wordRE(wordChars) {
  let escaped = wordChars.replace(/[\\[.+*?(){|^$]/g, "\\$&");

  try {
    return new RegExp(`[\\p{Alphabetic}\\p{Number}_${escaped}]+`, "ug");
  } catch (_a) {
    return new RegExp(`[\w${escaped}]`, "g");
  }
}

function mapRE(re, f) {
  return new RegExp(f(re.source), re.unicode ? "u" : "");
}

const wordCaches = /*@__PURE__*/Object.create(null);

function wordCache(wordChars) {
  return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap());
}

function storeWords(doc, wordRE, result, seen, ignoreAt) {
  for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {
    let {
      value
    } = lines,
        m;
    wordRE.lastIndex = 0;

    while (m = wordRE.exec(value)) {
      if (!seen[m[0]] && pos + m.index != ignoreAt) {
        result.push({
          type: "text",
          label: m[0]
        });
        seen[m[0]] = true;
        if (result.length >= 2000
        /* MaxList */
        ) return;
      }
    }

    pos += value.length + 1;
  }
}

function collectWords(doc, cache, wordRE, to, ignoreAt) {
  let big = doc.length >= 1000
  /* MinCacheLen */
  ;
  let cached = big && cache.get(doc);
  if (cached) return cached;
  let result = [],
      seen = Object.create(null);

  if (doc.children) {
    let pos = 0;

    for (let ch of doc.children) {
      if (ch.length >= 1000
      /* MinCacheLen */
      ) {
          for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)) {
            if (!seen[c.label]) {
              seen[c.label] = true;
              result.push(c);
            }
          }
        } else {
        storeWords(ch, wordRE, result, seen, ignoreAt - pos);
      }

      pos += ch.length + 1;
    }
  } else {
    storeWords(doc, wordRE, result, seen, ignoreAt);
  }

  if (big && result.length < 2000
  /* MaxList */
  ) cache.set(doc, result);
  return result;
}
/**
A completion source that will scan the document for words (using a
[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and
return those as completions.
*/


const completeAnyWord = context => {
  let wordChars = context.state.languageDataAt("wordChars", context.pos).join("");
  let re = wordRE(wordChars);
  let token = context.matchBefore(mapRE(re, s => s + "$"));
  if (!token && !context.explicit) return null;
  let from = token ? token.from : context.pos;
  let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000
  /* Range */
  , from);
  return {
    from,
    options,
    span: mapRE(re, s => "^" + s)
  };
};
/**
Returns an extension that enables autocompletion.
*/


exports.completeAnyWord = completeAnyWord;

function autocompletion(config = {}) {
  return [completionState, completionConfig.of(config), completionPlugin, completionKeymapExt, baseTheme];
}
/**
Basic keybindings for autocompletion.

 - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)
 - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)
 - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`
 - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`
 - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
 - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
 - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)
*/


const completionKeymap = [{
  key: "Ctrl-Space",
  run: startCompletion
}, {
  key: "Escape",
  run: closeCompletion
}, {
  key: "ArrowDown",
  run: /*@__PURE__*/moveCompletionSelection(true)
}, {
  key: "ArrowUp",
  run: /*@__PURE__*/moveCompletionSelection(false)
}, {
  key: "PageDown",
  run: /*@__PURE__*/moveCompletionSelection(true, "page")
}, {
  key: "PageUp",
  run: /*@__PURE__*/moveCompletionSelection(false, "page")
}, {
  key: "Enter",
  run: acceptCompletion
}];
exports.completionKeymap = completionKeymap;

const completionKeymapExt = /*@__PURE__*/_state.Prec.override( /*@__PURE__*/_view.keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
/**
Get the current completion status. When completions are available,
this will return `"active"`. When completions are pending (in the
process of being queried), this returns `"pending"`. Otherwise, it
returns `null`.
*/


function completionStatus(state) {
  let cState = state.field(completionState, false);
  return cState && cState.active.some(a => a.state == 1
  /* Pending */
  ) ? "pending" : cState && cState.active.some(a => a.state != 0
  /* Inactive */
  ) ? "active" : null;
}
/**
Returns the available completions as an array.
*/


function currentCompletions(state) {
  var _a;

  let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
  return open ? open.options.map(o => o.completion) : [];
}
},{"@codemirror/state":"node_modules/@codemirror/state/dist/index.js","@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/tooltip":"node_modules/@codemirror/tooltip/dist/index.js","@codemirror/language":"node_modules/@codemirror/language/dist/index.js","@codemirror/text":"node_modules/@codemirror/text/dist/index.js"}],"node_modules/@codemirror/comment/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toggleLineComment = exports.toggleComment = exports.toggleBlockComment = exports.lineUncomment = exports.lineComment = exports.commentKeymap = exports.blockUncomment = exports.blockComment = void 0;

var _state = require("@codemirror/state");

/**
Comment or uncomment the current selection. Will use line comments
if available, otherwise falling back to block comments.
*/
const toggleComment = target => {
  let config = getConfig(target.state);
  return config.line ? toggleLineComment(target) : config.block ? toggleBlockComment(target) : false;
};

exports.toggleComment = toggleComment;

function command(f, option) {
  return ({
    state,
    dispatch
  }) => {
    let tr = f(option, state.selection.ranges, state);
    if (!tr) return false;
    dispatch(state.update(tr));
    return true;
  };
}
/**
Comment or uncomment the current selection using line comments.
The line comment syntax is taken from the
[`commentTokens`](https://codemirror.net/6/docs/ref/#comment.CommentTokens) [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
*/


const toggleLineComment = /*@__PURE__*/command(changeLineComment, 0
/* Toggle */
);
/**
Comment the current selection using line comments.
*/

exports.toggleLineComment = toggleLineComment;
const lineComment = /*@__PURE__*/command(changeLineComment, 1
/* Comment */
);
/**
Uncomment the current selection using line comments.
*/

exports.lineComment = lineComment;
const lineUncomment = /*@__PURE__*/command(changeLineComment, 2
/* Uncomment */
);
/**
Comment or uncomment the current selection using block comments.
The block comment syntax is taken from the
[`commentTokens`](https://codemirror.net/6/docs/ref/#comment.CommentTokens) [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
*/

exports.lineUncomment = lineUncomment;
const toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0
/* Toggle */
);
/**
Comment the current selection using block comments.
*/

exports.toggleBlockComment = toggleBlockComment;
const blockComment = /*@__PURE__*/command(changeBlockComment, 1
/* Comment */
);
/**
Uncomment the current selection using block comments.
*/

exports.blockComment = blockComment;
const blockUncomment = /*@__PURE__*/command(changeBlockComment, 2
/* Uncomment */
);
/**
Default key bindings for this package.

 - Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#comment.toggleComment).
 - Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#comment.toggleBlockComment).
*/

exports.blockUncomment = blockUncomment;
const commentKeymap = [{
  key: "Mod-/",
  run: toggleComment
}, {
  key: "Alt-A",
  run: toggleBlockComment
}];
exports.commentKeymap = commentKeymap;

function getConfig(state, pos = state.selection.main.head) {
  let data = state.languageDataAt("commentTokens", pos);
  return data.length ? data[0] : {};
}

const SearchMargin = 50;
/**
Determines if the given range is block-commented in the given
state.
*/

function findBlockComment(state, {
  open,
  close
}, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length,
      spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;

  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: {
        pos: from - spaceBefore,
        margin: spaceBefore && 1
      },
      close: {
        pos: to + spaceAfter,
        margin: spaceAfter && 1
      }
    };
  }

  let startText, endText;

  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }

  let startSpace = /^\s*/.exec(startText)[0].length,
      endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;

  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }

  return null;
} // Performs toggle, comment and uncomment of block comments in
// languages that support them.


function changeBlockComment(option, ranges, state) {
  let tokens = ranges.map(r => getConfig(state, r.from).block);
  if (!tokens.every(c => c)) return null;
  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));

  if (option != 2
  /* Uncomment */
  && !comments.every(c => c)) {
    let index = 0;
    return state.changeByRange(range => {
      let {
        open,
        close
      } = tokens[index++];
      if (comments[index]) return {
        range
      };
      let shift = open.length + 1;
      return {
        changes: [{
          from: range.from,
          insert: open + " "
        }, {
          from: range.to,
          insert: " " + close
        }],
        range: _state.EditorSelection.range(range.anchor + shift, range.head + shift)
      };
    });
  } else if (option != 1
  /* Comment */
  && comments.some(c => c)) {
    let changes = [];

    for (let i = 0, comment; i < comments.length; i++) if (comment = comments[i]) {
      let token = tokens[i],
          {
        open,
        close
      } = comment;
      changes.push({
        from: open.pos - token.open.length,
        to: open.pos + open.margin
      }, {
        from: close.pos - close.margin,
        to: close.pos + token.close.length
      });
    }

    return {
      changes
    };
  }

  return null;
} // Performs toggle, comment and uncomment of line comments.


function changeLineComment(option, ranges, state) {
  let lines = [];
  let prevLine = -1;

  for (let {
    from,
    to
  } of ranges) {
    let startI = lines.length,
        minIndent = 1e9;

    for (let pos = from; pos <= to;) {
      let line = state.doc.lineAt(pos);

      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let token = getConfig(state, pos).line;
        if (!token) continue;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty = indent == line.length;
        let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
        if (indent < line.text.length && indent < minIndent) minIndent = indent;
        lines.push({
          line,
          comment,
          token,
          indent,
          empty,
          single: false
        });
      }

      pos = line.to + 1;
    }

    if (minIndent < 1e9) for (let i = startI; i < lines.length; i++) if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;
    if (lines.length == startI + 1) lines[startI].single = true;
  }

  if (option != 2
  /* Uncomment */
  && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];

    for (let {
      line,
      token,
      indent,
      empty,
      single
    } of lines) if (single || !empty) changes.push({
      from: line.from + indent,
      insert: token + " "
    });

    let changeSet = state.changes(changes);
    return {
      changes: changeSet,
      selection: state.selection.map(changeSet, 1)
    };
  } else if (option != 1
  /* Comment */
  && lines.some(l => l.comment >= 0)) {
    let changes = [];

    for (let {
      line,
      comment,
      token
    } of lines) if (comment >= 0) {
      let from = line.from + comment,
          to = from + token.length;
      if (line.text[to - line.from] == " ") to++;
      changes.push({
        from,
        to
      });
    }

    return {
      changes
    };
  }

  return null;
}
},{"@codemirror/state":"node_modules/@codemirror/state/dist/index.js"}],"node_modules/@codemirror/rectangular-selection/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rectangularSelection = rectangularSelection;

var _state = require("@codemirror/state");

var _view = require("@codemirror/view");

var _text = require("@codemirror/text");

// Don't compute precise column positions for line offsets above this
// (since it could get expensive). Assume offset==column for them.
const MaxOff = 2000;

function rectangleFor(state, a, b) {
  let startLine = Math.min(a.line, b.line),
      endLine = Math.max(a.line, b.line);
  let ranges = [];

  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
    let startOff = Math.min(a.off, b.off),
        endOff = Math.max(a.off, b.off);

    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      if (line.length <= endOff) ranges.push(_state.EditorSelection.range(line.from + startOff, line.to + endOff));
    }
  } else {
    let startCol = Math.min(a.col, b.col),
        endCol = Math.max(a.col, b.col);

    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      let start = (0, _text.findColumn)(line.text, startCol, state.tabSize),
          end = (0, _text.findColumn)(line.text, endCol, state.tabSize);
      if (start < end) ranges.push(_state.EditorSelection.range(line.from + start, line.from + end));
    }
  }

  return ranges;
}

function absoluteColumn(view, x) {
  let ref = view.coordsAtPos(view.viewport.from);
  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}

function getPos(view, event) {
  let offset = view.posAtCoords({
    x: event.clientX,
    y: event.clientY
  }, false);
  let line = view.state.doc.lineAt(offset),
      off = offset - line.from;
  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : (0, _text.countColumn)(line.text, view.state.tabSize, offset - line.from);
  return {
    line: line.number,
    col,
    off
  };
}

function rectangleSelectionStyle(view, event) {
  let start = getPos(view, event),
      startSel = view.state.selection;
  if (!start) return null;
  return {
    update(update) {
      if (update.docChanged) {
        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
        let newLine = update.state.doc.lineAt(newStart);
        start = {
          line: newLine.number,
          col: start.col,
          off: Math.min(start.off, newLine.length)
        };
        startSel = startSel.map(update.changes);
      }
    },

    get(event, _extend, multiple) {
      let cur = getPos(view, event);
      if (!cur) return startSel;
      let ranges = rectangleFor(view.state, start, cur);
      if (!ranges.length) return startSel;
      if (multiple) return _state.EditorSelection.create(ranges.concat(startSel.ranges));else return _state.EditorSelection.create(ranges);
    }

  };
}
/**
Create an extension that enables rectangular selections. By
default, it will react to left mouse drag with the Alt key held
down. When such a selection occurs, the text within the rectangle
that was dragged over will be selected, as one selection
[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.
*/


function rectangularSelection(options) {
  let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);

  return _view.EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
},{"@codemirror/state":"node_modules/@codemirror/state/dist/index.js","@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/text":"node_modules/@codemirror/text/dist/index.js"}],"node_modules/@codemirror/highlight/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.highlightTree = highlightTree;
exports.styleTags = styleTags;
exports.tags = exports.defaultHighlightStyle = exports.classHighlightStyle = exports.Tag = exports.HighlightStyle = void 0;

var _common = require("@lezer/common");

var _styleMod = require("style-mod");

var _view = require("@codemirror/view");

var _state = require("@codemirror/state");

var _language = require("@codemirror/language");

var _rangeset = require("@codemirror/rangeset");

let nextTagID = 0;
/**
Highlighting tags are markers that denote a highlighting category.
They are [associated](https://codemirror.net/6/docs/ref/#highlight.styleTags) with parts of a syntax
tree by a language mode, and then mapped to an actual CSS style by
a [highlight style](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle).

Because syntax tree node types and highlight styles have to be
able to talk the same language, CodeMirror uses a mostly _closed_
[vocabulary](https://codemirror.net/6/docs/ref/#highlight.tags) of syntax tags (as opposed to
traditional open string-based systems, which make it hard for
highlighting themes to cover all the tokens produced by the
various languages).

It _is_ possible to [define](https://codemirror.net/6/docs/ref/#highlight.Tag^define) your own
highlighting tags for system-internal use (where you control both
the language package and the highlighter), but such tags will not
be picked up by regular highlighters (though you can derive them
from standard tags to allow highlighters to fall back to those).
*/

class Tag {
  /**
  @internal
  */
  constructor(
  /**
  The set of tags that match this tag, starting with this one
  itself, sorted in order of decreasing specificity. @internal
  */
  set,
  /**
  The base unmodified tag that this one is based on, if it's
  modified @internal
  */
  base,
  /**
  The modifiers applied to this.base @internal
  */
  modified) {
    this.set = set;
    this.base = base;
    this.modified = modified;
    /**
    @internal
    */

    this.id = nextTagID++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and [highlight
  styles](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle) that don't mention this tag
  will try to fall back to the parent tag (or grandparent tag,
  etc).
  */


  static define(parent) {
    if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error("Can not derive from a modified tag");
    let tag = new Tag([], null, []);
    tag.set.push(tag);
    if (parent) for (let t of parent.set) tag.set.push(t);
    return tag;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */


  static defineModifier() {
    let mod = new Modifier();
    return tag => {
      if (tag.modified.indexOf(mod) > -1) return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }

}

exports.Tag = Tag;
let nextModifierID = 0;

class Modifier {
  constructor() {
    this.instances = [];
    this.id = nextModifierID++;
  }

  static get(base, mods) {
    if (!mods.length) return base;
    let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));
    if (exists) return exists;
    let set = [],
        tag = new Tag(set, base, mods);

    for (let m of mods) m.instances.push(tag);

    let configs = permute(mods);

    for (let parent of base.set) for (let config of configs) set.push(Modifier.get(parent, config));

    return tag;
  }

}

function sameArray(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}

function permute(array) {
  let result = [array];

  for (let i = 0; i < array.length; i++) {
    for (let a of permute(array.slice(0, i).concat(array.slice(i + 1)))) result.push(a);
  }

  return result;
}
/**
This function is used to add a set of tags to a language syntax
via
[`LRParser.configure`](https://lezer.codemirror.net/docs/ref#lr.LRParser.configure).

The argument object maps node selectors to [highlighting
tags](https://codemirror.net/6/docs/ref/#highlight.Tag) or arrays of tags.

Node selectors may hold one or more (space-separated) node paths.
Such a path can be a [node
name](https://lezer.codemirror.net/docs/ref#common.NodeType.name),
or multiple node names (or `*` wildcards) separated by slash
characters, as in `"Block/Declaration/VariableName"`. Such a path
matches the final node but only if its direct parent nodes are the
other nodes mentioned. A `*` in such a path matches any parent,
but only a single level—wildcards that match multiple parents
aren't supported, both for efficiency reasons and because Lezer
trees make it rather hard to reason about what they would match.)

A path can be ended with `/...` to indicate that the tag assigned
to the node should also apply to all child nodes, even if they
match their own style (by default, only the innermost style is
used).

When a path ends in `!`, as in `Attribute!`, no further matching
happens for the node's child nodes, and the entire node gets the
given style.

In this notation, node names that contain `/`, `!`, `*`, or `...`
must be quoted as JSON strings.

For example:

```javascript
parser.withProps(
  styleTags({
    // Style Number and BigNumber nodes
    "Number BigNumber": tags.number,
    // Style Escape nodes whose parent is String
    "String/Escape": tags.escape,
    // Style anything inside Attributes nodes
    "Attributes!": tags.meta,
    // Add a style to all content inside Italic nodes
    "Italic/...": tags.emphasis,
    // Style InvalidString nodes as both `string` and `invalid`
    "InvalidString": [tags.string, tags.invalid],
    // Style the node named "/" as punctuation
    '"/"': tags.punctuation
  })
)
```
*/


function styleTags(spec) {
  let byName = Object.create(null);

  for (let prop in spec) {
    let tags = spec[prop];
    if (!Array.isArray(tags)) tags = [tags];

    for (let part of prop.split(" ")) if (part) {
      let pieces = [],
          mode = 2
      /* Normal */
      ,
          rest = part;

      for (let pos = 0;;) {
        if (rest == "..." && pos > 0 && pos + 3 == part.length) {
          mode = 1
          /* Inherit */
          ;
          break;
        }

        let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
        if (!m) throw new RangeError("Invalid path: " + part);
        pieces.push(m[0] == "*" ? null : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
        pos += m[0].length;
        if (pos == part.length) break;
        let next = part[pos++];

        if (pos == part.length && next == "!") {
          mode = 0
          /* Opaque */
          ;
          break;
        }

        if (next != "/") throw new RangeError("Invalid path: " + part);
        rest = part.slice(pos);
      }

      let last = pieces.length - 1,
          inner = pieces[last];
      if (!inner) throw new RangeError("Invalid path: " + part);
      let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);
      byName[inner] = rule.sort(byName[inner]);
    }
  }

  return ruleNodeProp.add(byName);
}

const ruleNodeProp = /*@__PURE__*/new _common.NodeProp();

const highlightStyle = /*@__PURE__*/_state.Facet.define({
  combine(stylings) {
    return stylings.length ? HighlightStyle.combinedMatch(stylings) : null;
  }

});

const fallbackHighlightStyle = /*@__PURE__*/_state.Facet.define({
  combine(values) {
    return values.length ? values[0].match : null;
  }

});

function getHighlightStyle(state) {
  return state.facet(highlightStyle) || state.facet(fallbackHighlightStyle);
}

class Rule {
  constructor(tags, mode, context, next) {
    this.tags = tags;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }

  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }

    other.next = this.sort(other.next);
    return other;
  }

  get depth() {
    return this.context ? this.context.length : 0;
  }

}
/**
A highlight style associates CSS styles with higlighting
[tags](https://codemirror.net/6/docs/ref/#highlight.Tag).
*/


class HighlightStyle {
  constructor(spec, options) {
    this.map = Object.create(null);
    let modSpec;

    function def(spec) {
      let cls = _styleMod.StyleModule.newName();

      (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
      return cls;
    }

    this.all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : null;

    for (let style of spec) {
      let cls = (style.class || def(Object.assign({}, style, {
        tag: null
      }))) + (this.all ? " " + this.all : "");
      let tags = style.tag;
      if (!Array.isArray(tags)) this.map[tags.id] = cls;else for (let tag of tags) this.map[tag.id] = cls;
    }

    this.module = modSpec ? new _styleMod.StyleModule(modSpec) : null;
    this.scope = options.scope || null;
    this.match = this.match.bind(this);
    let ext = [treeHighlighter];
    if (this.module) ext.push(_view.EditorView.styleModule.of(this.module));
    this.extension = ext.concat(highlightStyle.of(this));
    this.fallback = ext.concat(fallbackHighlightStyle.of(this));
  }
  /**
  Returns the CSS class associated with the given tag, if any.
  This method is bound to the instance by the constructor.
  */


  match(tag, scope) {
    if (this.scope && scope != this.scope) return null;

    for (let t of tag.set) {
      let match = this.map[t.id];

      if (match !== undefined) {
        if (t != tag) this.map[tag.id] = match;
        return match;
      }
    }

    return this.map[tag.id] = this.all;
  }
  /**
  Combines an array of highlight styles into a single match
  function that returns all of the classes assigned by the styles
  for a given tag.
  */


  static combinedMatch(styles) {
    if (styles.length == 1) return styles[0].match;
    let cache = styles.some(s => s.scope) ? undefined : Object.create(null);
    return (tag, scope) => {
      let cached = cache && cache[tag.id];
      if (cached !== undefined) return cached;
      let result = null;

      for (let style of styles) {
        let value = style.match(tag, scope);
        if (value) result = result ? result + " " + value : value;
      }

      if (cache) cache[tag.id] = result;
      return result;
    };
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The spec must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighters
  like [`classHighlightStyle`](https://codemirror.net/6/docs/ref/#highlight.classHighlightStyle)
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */


  static define(specs, options) {
    return new HighlightStyle(specs, options || {});
  }
  /**
  Returns the CSS classes (if any) that the highlight styles
  active in the given state would assign to the given a style
  [tag](https://codemirror.net/6/docs/ref/#highlight.Tag) and (optional) language
  [scope](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle^define^options.scope).
  */


  static get(state, tag, scope) {
    let style = getHighlightStyle(state);
    return style && style(tag, scope || _common.NodeType.none);
  }

}
/**
Run the tree highlighter over the given tree.
*/


exports.HighlightStyle = HighlightStyle;

function highlightTree(tree,
/**
Get the CSS classes used to style a given [tag](https://codemirror.net/6/docs/ref/#highlight.Tag),
or `null` if it isn't styled. (You'll often want to pass a
highlight style's [`match`](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle.match)
method here.)
*/
getStyle,
/**
Assign styling to a region of the text. Will be called, in order
of position, for any ranges where more than zero classes apply.
`classes` is a space separated string of CSS classes.
*/
putStyle,
/**
The start of the range to highlight.
*/
from = 0,
/**
The end of the range.
*/
to = tree.length) {
  highlightTreeRange(tree, from, to, getStyle, putStyle);
}

class TreeHighlighter {
  constructor(view) {
    this.markCache = Object.create(null);
    this.tree = (0, _language.syntaxTree)(view.state);
    this.decorations = this.buildDeco(view, getHighlightStyle(view.state));
  }

  update(update) {
    let tree = (0, _language.syntaxTree)(update.state),
        style = getHighlightStyle(update.state);
    let styleChange = style != update.startState.facet(highlightStyle);

    if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
      this.decorations = this.decorations.map(update.changes);
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, style);
    }
  }

  buildDeco(view, match) {
    if (!match || !this.tree.length) return _view.Decoration.none;
    let builder = new _rangeset.RangeSetBuilder();

    for (let {
      from,
      to
    } of view.visibleRanges) {
      highlightTreeRange(this.tree, from, to, match, (from, to, style) => {
        builder.add(from, to, this.markCache[style] || (this.markCache[style] = _view.Decoration.mark({
          class: style
        })));
      });
    }

    return builder.finish();
  }

} // This extension installs a highlighter that highlights based on the
// syntax tree and highlight style.


const treeHighlighter = /*@__PURE__*/_state.Prec.extend( /*@__PURE__*/_view.ViewPlugin.fromClass(TreeHighlighter, {
  decorations: v => v.decorations
}));

const nodeStack = [""];

class HighlightBuilder {
  constructor(at, style, span) {
    this.at = at;
    this.style = style;
    this.span = span;
    this.class = "";
  }

  startSpan(at, cls) {
    if (cls != this.class) {
      this.flush(at);
      if (at > this.at) this.at = at;
      this.class = cls;
    }
  }

  flush(to) {
    if (to > this.at && this.class) this.span(this.at, to, this.class);
  }

  highlightRange(cursor, from, to, inheritedClass, depth, scope) {
    let {
      type,
      from: start,
      to: end
    } = cursor;
    if (start >= to || end <= from) return;
    nodeStack[depth] = type.name;
    if (type.isTop) scope = type;
    let cls = inheritedClass;
    let rule = type.prop(ruleNodeProp),
        opaque = false;

    while (rule) {
      if (!rule.context || matchContext(rule.context, nodeStack, depth)) {
        for (let tag of rule.tags) {
          let st = this.style(tag, scope);

          if (st) {
            if (cls) cls += " ";
            cls += st;
            if (rule.mode == 1
            /* Inherit */
            ) inheritedClass += (inheritedClass ? " " : "") + st;else if (rule.mode == 0
            /* Opaque */
            ) opaque = true;
          }
        }

        break;
      }

      rule = rule.next;
    }

    this.startSpan(cursor.from, cls);
    if (opaque) return;
    let mounted = cursor.tree && cursor.tree.prop(_common.NodeProp.mounted);

    if (mounted && mounted.overlay) {
      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
      let hasChild = cursor.firstChild();

      for (let i = 0, pos = start;; i++) {
        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom = Math.max(from, pos),
            rangeTo = Math.min(to, nextPos);

        if (rangeFrom < rangeTo && hasChild) {
          while (cursor.from < rangeTo) {
            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, depth + 1, scope);
            this.startSpan(Math.min(to, cursor.to), cls);
            if (cursor.to >= nextPos || !cursor.nextSibling()) break;
          }
        }

        if (!next || nextPos > to) break;
        pos = next.to + start;

        if (pos > from) {
          this.highlightRange(inner.cursor, Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, depth, mounted.tree.type);
          this.startSpan(pos, cls);
        }
      }

      if (hasChild) cursor.parent();
    } else if (cursor.firstChild()) {
      do {
        if (cursor.to <= from) continue;
        if (cursor.from >= to) break;
        this.highlightRange(cursor, from, to, inheritedClass, depth + 1, scope);
        this.startSpan(Math.min(to, cursor.to), cls);
      } while (cursor.nextSibling());

      cursor.parent();
    }
  }

}

function highlightTreeRange(tree, from, to, style, span) {
  let builder = new HighlightBuilder(from, style, span);
  builder.highlightRange(tree.cursor(), from, to, "", 0, tree.type);
  builder.flush(to);
}

function matchContext(context, stack, depth) {
  if (context.length > depth - 1) return false;

  for (let d = depth - 1, i = context.length - 1; i >= 0; i--, d--) {
    let check = context[i];
    if (check && check != stack[d]) return false;
  }

  return true;
}

const t = Tag.define;
const comment = /*@__PURE__*/t(),
      name = /*@__PURE__*/t(),
      typeName = /*@__PURE__*/t(name),
      propertyName = /*@__PURE__*/t(name),
      literal = /*@__PURE__*/t(),
      string = /*@__PURE__*/t(literal),
      number = /*@__PURE__*/t(literal),
      content = /*@__PURE__*/t(),
      heading = /*@__PURE__*/t(content),
      keyword = /*@__PURE__*/t(),
      operator = /*@__PURE__*/t(),
      punctuation = /*@__PURE__*/t(),
      bracket = /*@__PURE__*/t(punctuation),
      meta = /*@__PURE__*/t();
/**
The default set of highlighting [tags](https://codemirror.net/6/docs/ref/#highlight.Tag^define) used
by regular language packages and themes.

This collection is heavily biased towards programming languages,
and necessarily incomplete. A full ontology of syntactic
constructs would fill a stack of books, and be impractical to
write themes for. So try to make do with this set. If all else
fails, [open an
issue](https://github.com/codemirror/codemirror.next) to propose a
new tag, or [define](https://codemirror.net/6/docs/ref/#highlight.Tag^define) a local custom tag for
your use case.

Note that it is not obligatory to always attach the most specific
tag possible to an element—if your grammar can't easily
distinguish a certain type of element (such as a local variable),
it is okay to style it as its more general variant (a variable).

For tags that extend some parent tag, the documentation links to
the parent.
*/

const tags = {
  /**
  A comment.
  */
  comment,

  /**
  A line [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).
  */
  lineComment: /*@__PURE__*/t(comment),

  /**
  A block [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).
  */
  blockComment: /*@__PURE__*/t(comment),

  /**
  A documentation [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).
  */
  docComment: /*@__PURE__*/t(comment),

  /**
  Any kind of identifier.
  */
  name,

  /**
  The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a variable.
  */
  variableName: /*@__PURE__*/t(name),

  /**
  A type [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).
  */
  typeName: typeName,

  /**
  A tag name (subtag of [`typeName`](https://codemirror.net/6/docs/ref/#highlight.tags.typeName)).
  */
  tagName: /*@__PURE__*/t(typeName),

  /**
  A property or field [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).
  */
  propertyName: propertyName,

  /**
  An attribute name (subtag of [`propertyName`](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName)).
  */
  attributeName: /*@__PURE__*/t(propertyName),

  /**
  The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a class.
  */
  className: /*@__PURE__*/t(name),

  /**
  A label [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).
  */
  labelName: /*@__PURE__*/t(name),

  /**
  A namespace [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).
  */
  namespace: /*@__PURE__*/t(name),

  /**
  The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a macro.
  */
  macroName: /*@__PURE__*/t(name),

  /**
  A literal value.
  */
  literal,

  /**
  A string [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).
  */
  string,

  /**
  A documentation [string](https://codemirror.net/6/docs/ref/#highlight.tags.string).
  */
  docString: /*@__PURE__*/t(string),

  /**
  A character literal (subtag of [string](https://codemirror.net/6/docs/ref/#highlight.tags.string)).
  */
  character: /*@__PURE__*/t(string),

  /**
  An attribute value (subtag of [string](https://codemirror.net/6/docs/ref/#highlight.tags.string)).
  */
  attributeValue: /*@__PURE__*/t(string),

  /**
  A number [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).
  */
  number,

  /**
  An integer [number](https://codemirror.net/6/docs/ref/#highlight.tags.number) literal.
  */
  integer: /*@__PURE__*/t(number),

  /**
  A floating-point [number](https://codemirror.net/6/docs/ref/#highlight.tags.number) literal.
  */
  float: /*@__PURE__*/t(number),

  /**
  A boolean [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).
  */
  bool: /*@__PURE__*/t(literal),

  /**
  Regular expression [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).
  */
  regexp: /*@__PURE__*/t(literal),

  /**
  An escape [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: /*@__PURE__*/t(literal),

  /**
  A color [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).
  */
  color: /*@__PURE__*/t(literal),

  /**
  A URL [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).
  */
  url: /*@__PURE__*/t(literal),

  /**
  A language keyword.
  */
  keyword,

  /**
  The [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) for the self or this
  object.
  */
  self: /*@__PURE__*/t(keyword),

  /**
  The [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) for null.
  */
  null: /*@__PURE__*/t(keyword),

  /**
  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) denoting some atomic value.
  */
  atom: /*@__PURE__*/t(keyword),

  /**
  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that represents a unit.
  */
  unit: /*@__PURE__*/t(keyword),

  /**
  A modifier [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword).
  */
  modifier: /*@__PURE__*/t(keyword),

  /**
  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: /*@__PURE__*/t(keyword),

  /**
  A control-flow related [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword).
  */
  controlKeyword: /*@__PURE__*/t(keyword),

  /**
  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: /*@__PURE__*/t(keyword),

  /**
  An operator.
  */
  operator,

  /**
  An [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that defines something.
  */
  derefOperator: /*@__PURE__*/t(operator),

  /**
  Arithmetic-related [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).
  */
  arithmeticOperator: /*@__PURE__*/t(operator),

  /**
  Logical [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).
  */
  logicOperator: /*@__PURE__*/t(operator),

  /**
  Bit [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).
  */
  bitwiseOperator: /*@__PURE__*/t(operator),

  /**
  Comparison [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).
  */
  compareOperator: /*@__PURE__*/t(operator),

  /**
  [Operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that updates its operand.
  */
  updateOperator: /*@__PURE__*/t(operator),

  /**
  [Operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that defines something.
  */
  definitionOperator: /*@__PURE__*/t(operator),

  /**
  Type-related [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).
  */
  typeOperator: /*@__PURE__*/t(operator),

  /**
  Control-flow [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).
  */
  controlOperator: /*@__PURE__*/t(operator),

  /**
  Program or markup punctuation.
  */
  punctuation,

  /**
  [Punctuation](https://codemirror.net/6/docs/ref/#highlight.tags.punctuation) that separates
  things.
  */
  separator: /*@__PURE__*/t(punctuation),

  /**
  Bracket-style [punctuation](https://codemirror.net/6/docs/ref/#highlight.tags.punctuation).
  */
  bracket,

  /**
  Angle [brackets](https://codemirror.net/6/docs/ref/#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: /*@__PURE__*/t(bracket),

  /**
  Square [brackets](https://codemirror.net/6/docs/ref/#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: /*@__PURE__*/t(bracket),

  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](https://codemirror.net/6/docs/ref/#highlight.tags.bracket).
  */
  paren: /*@__PURE__*/t(bracket),

  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](https://codemirror.net/6/docs/ref/#highlight.tags.bracket).
  */
  brace: /*@__PURE__*/t(bracket),

  /**
  Content, for example plain text in XML or markup documents.
  */
  content,

  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a heading.
  */
  heading,

  /**
  A level 1 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).
  */
  heading1: /*@__PURE__*/t(heading),

  /**
  A level 2 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).
  */
  heading2: /*@__PURE__*/t(heading),

  /**
  A level 3 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).
  */
  heading3: /*@__PURE__*/t(heading),

  /**
  A level 4 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).
  */
  heading4: /*@__PURE__*/t(heading),

  /**
  A level 5 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).
  */
  heading5: /*@__PURE__*/t(heading),

  /**
  A level 6 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).
  */
  heading6: /*@__PURE__*/t(heading),

  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: /*@__PURE__*/t(content),

  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a list.
  */
  list: /*@__PURE__*/t(content),

  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a quote.
  */
  quote: /*@__PURE__*/t(content),

  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is emphasized.
  */
  emphasis: /*@__PURE__*/t(content),

  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is styled strong.
  */
  strong: /*@__PURE__*/t(content),

  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is part of a link.
  */
  link: /*@__PURE__*/t(content),

  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: /*@__PURE__*/t(content),

  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: /*@__PURE__*/t(content),

  /**
  Inserted text in a change-tracking format.
  */
  inserted: /*@__PURE__*/t(),

  /**
  Deleted text.
  */
  deleted: /*@__PURE__*/t(),

  /**
  Changed text.
  */
  changed: /*@__PURE__*/t(),

  /**
  An invalid or unsyntactic element.
  */
  invalid: /*@__PURE__*/t(),

  /**
  Metadata or meta-instruction.
  */
  meta,

  /**
  [Metadata](https://codemirror.net/6/docs/ref/#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: /*@__PURE__*/t(meta),

  /**
  [Metadata](https://codemirror.net/6/docs/ref/#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: /*@__PURE__*/t(meta),

  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](https://codemirror.net/6/docs/ref/#highlight.tags.meta).
  */
  processingInstruction: /*@__PURE__*/t(meta),

  /**
  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) tags.
  */
  definition: /*@__PURE__*/Tag.defineModifier(),

  /**
  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](https://codemirror.net/6/docs/ref/#highlight.tags.variableName).
  */
  constant: /*@__PURE__*/Tag.defineModifier(),

  /**
  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) used to indicate that
  a [variable](https://codemirror.net/6/docs/ref/#highlight.tags.variableName) or [property
  name](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: /*@__PURE__*/Tag.defineModifier(),

  /**
  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that can be applied to
  [names](https://codemirror.net/6/docs/ref/#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: /*@__PURE__*/Tag.defineModifier(),

  /**
  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates a given
  [names](https://codemirror.net/6/docs/ref/#highlight.tags.name) is local to some scope.
  */
  local: /*@__PURE__*/Tag.defineModifier(),

  /**
  A generic variant [modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](https://codemirror.net/6/docs/ref/#highlight.tags.string) and
  [variable name](https://codemirror.net/6/docs/ref/#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: /*@__PURE__*/Tag.defineModifier()
};
/**
A default highlight style (works well with light themes).
*/

exports.tags = tags;
const defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([{
  tag: tags.link,
  textDecoration: "underline"
}, {
  tag: tags.heading,
  textDecoration: "underline",
  fontWeight: "bold"
}, {
  tag: tags.emphasis,
  fontStyle: "italic"
}, {
  tag: tags.strong,
  fontWeight: "bold"
}, {
  tag: tags.strikethrough,
  textDecoration: "line-through"
}, {
  tag: tags.keyword,
  color: "#708"
}, {
  tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
  color: "#219"
}, {
  tag: [tags.literal, tags.inserted],
  color: "#164"
}, {
  tag: [tags.string, tags.deleted],
  color: "#a11"
}, {
  tag: [tags.regexp, tags.escape, /*@__PURE__*/tags.special(tags.string)],
  color: "#e40"
}, {
  tag: /*@__PURE__*/tags.definition(tags.variableName),
  color: "#00f"
}, {
  tag: /*@__PURE__*/tags.local(tags.variableName),
  color: "#30a"
}, {
  tag: [tags.typeName, tags.namespace],
  color: "#085"
}, {
  tag: tags.className,
  color: "#167"
}, {
  tag: [/*@__PURE__*/tags.special(tags.variableName), tags.macroName],
  color: "#256"
}, {
  tag: /*@__PURE__*/tags.definition(tags.propertyName),
  color: "#00c"
}, {
  tag: tags.comment,
  color: "#940"
}, {
  tag: tags.meta,
  color: "#7a757a"
}, {
  tag: tags.invalid,
  color: "#f00"
}]);
/**
This is a highlight style that adds stable, predictable classes to
tokens, for styling with external CSS.

These tags are mapped to their name prefixed with `"cmt-"` (for
example `"cmt-comment"`):

* [`link`](https://codemirror.net/6/docs/ref/#highlight.tags.link)
* [`heading`](https://codemirror.net/6/docs/ref/#highlight.tags.heading)
* [`emphasis`](https://codemirror.net/6/docs/ref/#highlight.tags.emphasis)
* [`strong`](https://codemirror.net/6/docs/ref/#highlight.tags.strong)
* [`keyword`](https://codemirror.net/6/docs/ref/#highlight.tags.keyword)
* [`atom`](https://codemirror.net/6/docs/ref/#highlight.tags.atom) [`bool`](https://codemirror.net/6/docs/ref/#highlight.tags.bool)
* [`url`](https://codemirror.net/6/docs/ref/#highlight.tags.url)
* [`labelName`](https://codemirror.net/6/docs/ref/#highlight.tags.labelName)
* [`inserted`](https://codemirror.net/6/docs/ref/#highlight.tags.inserted)
* [`deleted`](https://codemirror.net/6/docs/ref/#highlight.tags.deleted)
* [`literal`](https://codemirror.net/6/docs/ref/#highlight.tags.literal)
* [`string`](https://codemirror.net/6/docs/ref/#highlight.tags.string)
* [`number`](https://codemirror.net/6/docs/ref/#highlight.tags.number)
* [`variableName`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)
* [`typeName`](https://codemirror.net/6/docs/ref/#highlight.tags.typeName)
* [`namespace`](https://codemirror.net/6/docs/ref/#highlight.tags.namespace)
* [`macroName`](https://codemirror.net/6/docs/ref/#highlight.tags.macroName)
* [`propertyName`](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName)
* [`operator`](https://codemirror.net/6/docs/ref/#highlight.tags.operator)
* [`comment`](https://codemirror.net/6/docs/ref/#highlight.tags.comment)
* [`meta`](https://codemirror.net/6/docs/ref/#highlight.tags.meta)
* [`punctuation`](https://codemirror.net/6/docs/ref/#highlight.tags.puncutation)
* [`invalid`](https://codemirror.net/6/docs/ref/#highlight.tags.invalid)

In addition, these mappings are provided:

* [`regexp`](https://codemirror.net/6/docs/ref/#highlight.tags.regexp),
  [`escape`](https://codemirror.net/6/docs/ref/#highlight.tags.escape), and
  [`special`](https://codemirror.net/6/docs/ref/#highlight.tags.special)[`(string)`](https://codemirror.net/6/docs/ref/#highlight.tags.string)
  are mapped to `"cmt-string2"`
* [`special`](https://codemirror.net/6/docs/ref/#highlight.tags.special)[`(variableName)`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)
  to `"cmt-variableName2"`
* [`local`](https://codemirror.net/6/docs/ref/#highlight.tags.local)[`(variableName)`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)
  to `"cmt-variableName cmt-local"`
* [`definition`](https://codemirror.net/6/docs/ref/#highlight.tags.definition)[`(variableName)`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)
  to `"cmt-variableName cmt-definition"`
*/

exports.defaultHighlightStyle = defaultHighlightStyle;
const classHighlightStyle = /*@__PURE__*/HighlightStyle.define([{
  tag: tags.link,
  class: "cmt-link"
}, {
  tag: tags.heading,
  class: "cmt-heading"
}, {
  tag: tags.emphasis,
  class: "cmt-emphasis"
}, {
  tag: tags.strong,
  class: "cmt-strong"
}, {
  tag: tags.keyword,
  class: "cmt-keyword"
}, {
  tag: tags.atom,
  class: "cmt-atom"
}, {
  tag: tags.bool,
  class: "cmt-bool"
}, {
  tag: tags.url,
  class: "cmt-url"
}, {
  tag: tags.labelName,
  class: "cmt-labelName"
}, {
  tag: tags.inserted,
  class: "cmt-inserted"
}, {
  tag: tags.deleted,
  class: "cmt-deleted"
}, {
  tag: tags.literal,
  class: "cmt-literal"
}, {
  tag: tags.string,
  class: "cmt-string"
}, {
  tag: tags.number,
  class: "cmt-number"
}, {
  tag: [tags.regexp, tags.escape, /*@__PURE__*/tags.special(tags.string)],
  class: "cmt-string2"
}, {
  tag: tags.variableName,
  class: "cmt-variableName"
}, {
  tag: /*@__PURE__*/tags.local(tags.variableName),
  class: "cmt-variableName cmt-local"
}, {
  tag: /*@__PURE__*/tags.definition(tags.variableName),
  class: "cmt-variableName cmt-definition"
}, {
  tag: /*@__PURE__*/tags.special(tags.variableName),
  class: "cmt-variableName2"
}, {
  tag: tags.typeName,
  class: "cmt-typeName"
}, {
  tag: tags.namespace,
  class: "cmt-namespace"
}, {
  tag: tags.macroName,
  class: "cmt-macroName"
}, {
  tag: tags.propertyName,
  class: "cmt-propertyName"
}, {
  tag: tags.operator,
  class: "cmt-operator"
}, {
  tag: tags.comment,
  class: "cmt-comment"
}, {
  tag: tags.meta,
  class: "cmt-meta"
}, {
  tag: tags.invalid,
  class: "cmt-invalid"
}, {
  tag: tags.punctuation,
  class: "cmt-punctuation"
}]);
exports.classHighlightStyle = classHighlightStyle;
},{"@lezer/common":"node_modules/@lezer/common/dist/index.js","style-mod":"node_modules/style-mod/src/style-mod.js","@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/state":"node_modules/@codemirror/state/dist/index.js","@codemirror/language":"node_modules/@codemirror/language/dist/index.js","@codemirror/rangeset":"node_modules/@codemirror/rangeset/dist/index.js"}],"node_modules/@codemirror/lint/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.diagnosticCount = diagnosticCount;
exports.forceLinting = forceLinting;
exports.linter = linter;
exports.setDiagnostics = setDiagnostics;
exports.openLintPanel = exports.nextDiagnostic = exports.lintKeymap = exports.closeLintPanel = void 0;

var _view = require("@codemirror/view");

var _state = require("@codemirror/state");

var _tooltip = require("@codemirror/tooltip");

var _panel = require("@codemirror/panel");

var _crelt = _interopRequireDefault(require("crelt"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class SelectedDiagnostic {
  constructor(from, to, diagnostic) {
    this.from = from;
    this.to = to;
    this.diagnostic = diagnostic;
  }

}

class LintState {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }

  static init(diagnostics, panel, state) {
    let ranges = _view.Decoration.set(diagnostics.map(d => {
      // For zero-length ranges or ranges covering only a line break, create a widget
      return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? _view.Decoration.widget({
        widget: new DiagnosticWidget(d),
        diagnostic: d
      }).range(d.from) : _view.Decoration.mark({
        attributes: {
          class: "cm-lintRange cm-lintRange-" + d.severity
        },
        diagnostic: d
      }).range(d.from, d.to);
    }), true);

    return new LintState(ranges, panel, findDiagnostic(ranges));
  }

}

function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from, to, {
    spec
  }) => {
    if (diagnostic && spec.diagnostic != diagnostic) return;
    found = new SelectedDiagnostic(from, to, spec.diagnostic);
    return false;
  });
  return found;
}

function maybeEnableLint(state, effects, getState) {
  return state.field(lintState, false) ? effects : effects.concat(_state.StateEffect.appendConfig.of([lintState.init(getState), _view.EditorView.decorations.compute([lintState], state => {
    let {
      selected,
      panel
    } = state.field(lintState);
    return !selected || !panel || selected.from == selected.to ? _view.Decoration.none : _view.Decoration.set([activeMark.range(selected.from, selected.to)]);
  }), (0, _tooltip.hoverTooltip)(lintTooltip), baseTheme]));
}
/**
Returns a transaction spec which updates the current set of
diagnostics.
*/


function setDiagnostics(state, diagnostics) {
  return {
    effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)], () => LintState.init(diagnostics, null, state))
  };
}

const setDiagnosticsEffect = /*@__PURE__*/_state.StateEffect.define();

const togglePanel = /*@__PURE__*/_state.StateEffect.define();

const movePanelSelection = /*@__PURE__*/_state.StateEffect.define();

const lintState = /*@__PURE__*/_state.StateField.define({
  create() {
    return new LintState(_view.Decoration.none, null, null);
  },

  update(value, tr) {
    if (tr.docChanged) {
      let mapped = value.diagnostics.map(tr.changes),
          selected = null;

      if (value.selected) {
        let selPos = tr.changes.mapPos(value.selected.from, 1);
        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }

      value = new LintState(mapped, value.panel, selected);
    }

    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        value = LintState.init(effect.value, value.panel, tr.state);
      } else if (effect.is(togglePanel)) {
        value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
      } else if (effect.is(movePanelSelection)) {
        value = new LintState(value.diagnostics, value.panel, effect.value);
      }
    }

    return value;
  },

  provide: f => [_panel.showPanel.from(f, val => val.panel), _view.EditorView.decorations.from(f, s => s.diagnostics)]
});
/**
Returns the number of active lint diagnostics in the given state.
*/


function diagnosticCount(state) {
  let lint = state.field(lintState, false);
  return lint ? lint.diagnostics.size : 0;
}

const activeMark = /*@__PURE__*/_view.Decoration.mark({
  class: "cm-lintRange cm-lintRange-active"
});

function lintTooltip(view, pos, side) {
  let {
    diagnostics
  } = view.state.field(lintState);
  let found = [],
      stackStart = 2e8,
      stackEnd = 0;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, {
    spec
  }) => {
    if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
      found.push(spec.diagnostic);
      stackStart = Math.min(from, stackStart);
      stackEnd = Math.max(to, stackEnd);
    }
  });
  if (!found.length) return null;
  return {
    pos: stackStart,
    end: stackEnd,
    above: view.state.doc.lineAt(stackStart).to < stackEnd,

    create() {
      return {
        dom: (0, _crelt.default)("ul", {
          class: "cm-tooltip-lint"
        }, found.map(d => renderDiagnostic(view, d, false)))
      };
    }

  };
}
/**
Command to open and focus the lint panel.
*/


const openLintPanel = view => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel) view.dispatch({
    effects: maybeEnableLint(view.state, [togglePanel.of(true)], () => LintState.init([], LintPanel.open, view.state))
  });
  let panel = (0, _panel.getPanel)(view, LintPanel.open);
  if (panel) panel.dom.querySelector(".cm-panel-lint ul").focus();
  return true;
};
/**
Command to close the lint panel, when open.
*/


exports.openLintPanel = openLintPanel;

const closeLintPanel = view => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel) return false;
  view.dispatch({
    effects: togglePanel.of(false)
  });
  return true;
};
/**
Move the selection to the next diagnostic.
*/


exports.closeLintPanel = closeLintPanel;

const nextDiagnostic = view => {
  let field = view.state.field(lintState, false);
  if (!field) return false;
  let sel = view.state.selection.main,
      next = field.diagnostics.iter(sel.to + 1);

  if (!next.value) {
    next = field.diagnostics.iter(0);
    if (!next.value || next.from == sel.from && next.to == sel.to) return false;
  }

  view.dispatch({
    selection: {
      anchor: next.from,
      head: next.to
    },
    scrollIntoView: true
  });
  return true;
};
/**
A set of default key bindings for the lint functionality.

- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)
- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)
*/


exports.nextDiagnostic = nextDiagnostic;
const lintKeymap = [{
  key: "Mod-Shift-m",
  run: openLintPanel
}, {
  key: "F8",
  run: nextDiagnostic
}];
exports.lintKeymap = lintKeymap;

const lintPlugin = /*@__PURE__*/_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.timeout = -1;
    this.set = true;
    let {
      delay
    } = view.state.facet(lintSource);
    this.lintTime = Date.now() + delay;
    this.run = this.run.bind(this);
    this.timeout = setTimeout(this.run, delay);
  }

  run() {
    let now = Date.now();

    if (now < this.lintTime - 10) {
      setTimeout(this.run, this.lintTime - now);
    } else {
      this.set = false;
      let {
        state
      } = this.view,
          {
        sources
      } = state.facet(lintSource);
      Promise.all(sources.map(source => Promise.resolve(source(this.view)))).then(annotations => {
        var _a, _b;

        let all = annotations.reduce((a, b) => a.concat(b));
        if (this.view.state.doc == state.doc && (all.length || ((_b = (_a = this.view.state.field(lintState, false)) === null || _a === void 0 ? void 0 : _a.diagnostics) === null || _b === void 0 ? void 0 : _b.size))) this.view.dispatch(setDiagnostics(this.view.state, all));
      }, error => {
        (0, _view.logException)(this.view.state, error);
      });
    }
  }

  update(update) {
    if (update.docChanged) {
      let {
        delay
      } = update.state.facet(lintSource);
      this.lintTime = Date.now() + delay;

      if (!this.set) {
        this.set = true;
        this.timeout = setTimeout(this.run, delay);
      }
    }
  }

  force() {
    if (this.set) {
      this.lintTime = Date.now();
      this.run();
    }
  }

  destroy() {
    clearTimeout(this.timeout);
  }

});

const lintSource = /*@__PURE__*/_state.Facet.define({
  combine(input) {
    return {
      sources: input.map(i => i.source),
      delay: input.length ? Math.max(...input.map(i => i.delay)) : 750
    };
  },

  enables: lintPlugin
});
/**
Given a diagnostic source, this function returns an extension that
enables linting with that source. It will be called whenever the
editor is idle (after its content changed).
*/


function linter(source, config = {}) {
  var _a;

  return lintSource.of({
    source,
    delay: (_a = config.delay) !== null && _a !== void 0 ? _a : 750
  });
}
/**
Forces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the
editor is idle to run right away.
*/


function forceLinting(view) {
  let plugin = view.plugin(lintPlugin);
  if (plugin) plugin.force();
}

function assignKeys(actions) {
  let assigned = [];
  if (actions) actions: for (let {
    name
  } of actions) {
    for (let i = 0; i < name.length; i++) {
      let ch = name[i];

      if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {
        assigned.push(ch);
        continue actions;
      }
    }

    assigned.push("");
  }
  return assigned;
}

function renderDiagnostic(view, diagnostic, inPanel) {
  var _a;

  let keys = inPanel ? assignKeys(diagnostic.actions) : [];
  return (0, _crelt.default)("li", {
    class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity
  }, (0, _crelt.default)("span", {
    class: "cm-diagnosticText"
  }, diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {
    let click = e => {
      e.preventDefault();
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found) action.apply(view, found.from, found.to);
    };

    let {
      name
    } = action,
        keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;
    let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex), (0, _crelt.default)("u", name.slice(keyIndex, keyIndex + 1)), name.slice(keyIndex + 1)];
    return (0, _crelt.default)("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name}${keyIndex < 0 ? "" : ` (access key "${keys[i]})"`}.`
    }, nameElt);
  }), diagnostic.source && (0, _crelt.default)("div", {
    class: "cm-diagnosticSource"
  }, diagnostic.source));
}

class DiagnosticWidget extends _view.WidgetType {
  constructor(diagnostic) {
    super();
    this.diagnostic = diagnostic;
  }

  eq(other) {
    return other.diagnostic == this.diagnostic;
  }

  toDOM() {
    return (0, _crelt.default)("span", {
      class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity
    });
  }

}

class PanelItem {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 0xffffffff).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }

}

class LintPanel {
  constructor(view) {
    this.view = view;
    this.items = [];

    let onkeydown = event => {
      if (event.keyCode == 27) {
        // Escape
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event.keyCode == 38 || event.keyCode == 33) {
        // ArrowUp, PageUp
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event.keyCode == 40 || event.keyCode == 34) {
        // ArrowDown, PageDown
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event.keyCode == 36) {
        // Home
        this.moveSelection(0);
      } else if (event.keyCode == 35) {
        // End
        this.moveSelection(this.items.length - 1);
      } else if (event.keyCode == 13) {
        // Enter
        this.view.focus();
      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
        // A-Z
        let {
          diagnostic
        } = this.items[this.selectedIndex],
            keys = assignKeys(diagnostic.actions);

        for (let i = 0; i < keys.length; i++) if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
          let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
          if (found) diagnostic.actions[i].apply(view, found.from, found.to);
        }
      } else {
        return;
      }

      event.preventDefault();
    };

    let onclick = event => {
      for (let i = 0; i < this.items.length; i++) {
        if (this.items[i].dom.contains(event.target)) this.moveSelection(i);
      }
    };

    this.list = (0, _crelt.default)("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = (0, _crelt.default)("div", {
      class: "cm-panel-lint"
    }, this.list, (0, _crelt.default)("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, "×"));
    this.update();
  }

  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected) return -1;

    for (let i = 0; i < this.items.length; i++) if (this.items[i].diagnostic == selected.diagnostic) return i;

    return -1;
  }

  update() {
    let {
      diagnostics,
      selected
    } = this.view.state.field(lintState);
    let i = 0,
        needsSync = false,
        newSelectedItem = null;
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, {
      spec
    }) => {
      let found = -1,
          item;

      for (let j = i; j < this.items.length; j++) if (this.items[j].diagnostic == spec.diagnostic) {
        found = j;
        break;
      }

      if (found < 0) {
        item = new PanelItem(this.view, spec.diagnostic);
        this.items.splice(i, 0, item);
        needsSync = true;
      } else {
        item = this.items[found];

        if (found > i) {
          this.items.splice(i, found - i);
          needsSync = true;
        }
      }

      if (selected && item.diagnostic == selected.diagnostic) {
        if (!item.dom.hasAttribute("aria-selected")) {
          item.dom.setAttribute("aria-selected", "true");
          newSelectedItem = item;
        }
      } else if (item.dom.hasAttribute("aria-selected")) {
        item.dom.removeAttribute("aria-selected");
      }

      i++;
    });

    while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }

    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }

    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({
          sel: newSelectedItem.dom.getBoundingClientRect(),
          panel: this.list.getBoundingClientRect()
        }),
        write: ({
          sel,
          panel
        }) => {
          if (sel.top < panel.top) this.list.scrollTop -= panel.top - sel.top;else if (sel.bottom > panel.bottom) this.list.scrollTop += sel.bottom - panel.bottom;
        }
      });
    } else if (this.selectedIndex < 0) {
      this.list.removeAttribute("aria-activedescendant");
    }

    if (needsSync) this.sync();
  }

  sync() {
    let domPos = this.list.firstChild;

    function rm() {
      let prev = domPos;
      domPos = prev.nextSibling;
      prev.remove();
    }

    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom) rm();

        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }

    while (domPos) rm();
  }

  moveSelection(selectedIndex) {
    if (this.selectedIndex < 0) return;
    let field = this.view.state.field(lintState);
    let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection) return;
    this.view.dispatch({
      selection: {
        anchor: selection.from,
        head: selection.to
      },
      scrollIntoView: true,
      effects: movePanelSelection.of(selection)
    });
  }

  static open(view) {
    return new LintPanel(view);
  }

}

function underline(color) {
  if (typeof btoa != "function") return "none";
  let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="6" height="3">
    <path d="m0 3 l2 -2 l1 0 l2 2 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>
  </svg>`;
  return `url('data:image/svg+xml;base64,${btoa(svg)}')`;
}

const baseTheme = /*@__PURE__*/_view.EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": {
    borderLeft: "5px solid #d11"
  },
  ".cm-diagnostic-warning": {
    borderLeft: "5px solid orange"
  },
  ".cm-diagnostic-info": {
    borderLeft: "5px solid #999"
  },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: .7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x"
  },
  ".cm-lintRange-error": {
    backgroundImage: /*@__PURE__*/underline("#d11")
  },
  ".cm-lintRange-warning": {
    backgroundImage: /*@__PURE__*/underline("orange")
  },
  ".cm-lintRange-info": {
    backgroundImage: /*@__PURE__*/underline("#999")
  },
  ".cm-lintRange-active": {
    backgroundColor: "#ffdd9980"
  },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": {
      borderBottomColor: "orange"
    }
  },
  ".cm-lintPoint-info": {
    "&:after": {
      borderBottomColor: "#999"
    }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": {
          textDecoration: "underline"
        }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": {
        textDecoration: "none"
      },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
},{"@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/state":"node_modules/@codemirror/state/dist/index.js","@codemirror/tooltip":"node_modules/@codemirror/tooltip/dist/index.js","@codemirror/panel":"node_modules/@codemirror/panel/dist/index.js","crelt":"node_modules/crelt/index.es.js"}],"node_modules/@codemirror/basic-setup/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "EditorView", {
  enumerable: true,
  get: function () {
    return _view.EditorView;
  }
});
Object.defineProperty(exports, "EditorState", {
  enumerable: true,
  get: function () {
    return _state.EditorState;
  }
});
exports.basicSetup = void 0;

var _view = require("@codemirror/view");

var _state = require("@codemirror/state");

var _history = require("@codemirror/history");

var _fold = require("@codemirror/fold");

var _language = require("@codemirror/language");

var _gutter = require("@codemirror/gutter");

var _commands = require("@codemirror/commands");

var _matchbrackets = require("@codemirror/matchbrackets");

var _closebrackets = require("@codemirror/closebrackets");

var _search = require("@codemirror/search");

var _autocomplete = require("@codemirror/autocomplete");

var _comment = require("@codemirror/comment");

var _rectangularSelection = require("@codemirror/rectangular-selection");

var _highlight = require("@codemirror/highlight");

var _lint = require("@codemirror/lint");

/**
This is an extension value that just pulls together a whole lot of
extensions that you might want in a basic editor. It is meant as a
convenient helper to quickly set up CodeMirror without installing
and importing a lot of packages.

Specifically, it includes...

 - [the default command bindings](https://codemirror.net/6/docs/ref/#commands.defaultKeymap)
 - [line numbers](https://codemirror.net/6/docs/ref/#gutter.lineNumbers)
 - [special character highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars)
 - [the undo history](https://codemirror.net/6/docs/ref/#history.history)
 - [a fold gutter](https://codemirror.net/6/docs/ref/#fold.foldGutter)
 - [custom selection drawing](https://codemirror.net/6/docs/ref/#view.drawSelection)
 - [multiple selections](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
 - [reindentation on input](https://codemirror.net/6/docs/ref/#language.indentOnInput)
 - [the default highlight style](https://codemirror.net/6/docs/ref/#highlight.defaultHighlightStyle) (as fallback)
 - [bracket matching](https://codemirror.net/6/docs/ref/#matchbrackets.bracketMatching)
 - [bracket closing](https://codemirror.net/6/docs/ref/#closebrackets.closeBrackets)
 - [autocompletion](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion)
 - [rectangular selection](https://codemirror.net/6/docs/ref/#rectangular-selection.rectangularSelection)
 - [active line highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLine)
 - [active line gutter highlighting](https://codemirror.net/6/docs/ref/#gutter.highlightActiveLineGutter)
 - [selection match highlighting](https://codemirror.net/6/docs/ref/#search.highlightSelectionMatches)
 - [search](https://codemirror.net/6/docs/ref/#search.searchKeymap)
 - [commenting](https://codemirror.net/6/docs/ref/#comment.commentKeymap)
 - [linting](https://codemirror.net/6/docs/ref/#lint.lintKeymap)

(You'll probably want to add some language package to your setup
too.)

This package does not allow customization. The idea is that, once
you decide you want to configure your editor more precisely, you
take this package's source (which is just a bunch of imports and
an array literal), copy it into your own code, and adjust it as
desired.
*/
const basicSetup = [/*@__PURE__*/(0, _gutter.lineNumbers)(), /*@__PURE__*/(0, _gutter.highlightActiveLineGutter)(), /*@__PURE__*/(0, _view.highlightSpecialChars)(), /*@__PURE__*/(0, _history.history)(), /*@__PURE__*/(0, _fold.foldGutter)(), /*@__PURE__*/(0, _view.drawSelection)(), /*@__PURE__*/_state.EditorState.allowMultipleSelections.of(true), /*@__PURE__*/(0, _language.indentOnInput)(), _highlight.defaultHighlightStyle.fallback, /*@__PURE__*/(0, _matchbrackets.bracketMatching)(), /*@__PURE__*/(0, _closebrackets.closeBrackets)(), /*@__PURE__*/(0, _autocomplete.autocompletion)(), /*@__PURE__*/(0, _rectangularSelection.rectangularSelection)(), /*@__PURE__*/(0, _view.highlightActiveLine)(), /*@__PURE__*/(0, _search.highlightSelectionMatches)(), /*@__PURE__*/_view.keymap.of([..._closebrackets.closeBracketsKeymap, ..._commands.defaultKeymap, ..._search.searchKeymap, ..._history.historyKeymap, ..._fold.foldKeymap, ..._comment.commentKeymap, ..._autocomplete.completionKeymap, ..._lint.lintKeymap])];
exports.basicSetup = basicSetup;
},{"@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/state":"node_modules/@codemirror/state/dist/index.js","@codemirror/history":"node_modules/@codemirror/history/dist/index.js","@codemirror/fold":"node_modules/@codemirror/fold/dist/index.js","@codemirror/language":"node_modules/@codemirror/language/dist/index.js","@codemirror/gutter":"node_modules/@codemirror/gutter/dist/index.js","@codemirror/commands":"node_modules/@codemirror/commands/dist/index.js","@codemirror/matchbrackets":"node_modules/@codemirror/matchbrackets/dist/index.js","@codemirror/closebrackets":"node_modules/@codemirror/closebrackets/dist/index.js","@codemirror/search":"node_modules/@codemirror/search/dist/index.js","@codemirror/autocomplete":"node_modules/@codemirror/autocomplete/dist/index.js","@codemirror/comment":"node_modules/@codemirror/comment/dist/index.js","@codemirror/rectangular-selection":"node_modules/@codemirror/rectangular-selection/dist/index.js","@codemirror/highlight":"node_modules/@codemirror/highlight/dist/index.js","@codemirror/lint":"node_modules/@codemirror/lint/dist/index.js"}],"node_modules/@lezer/lr/dist/index.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Stack = exports.LRParser = exports.InputStream = exports.ExternalTokenizer = exports.ContextTracker = void 0;

var _common = require("@lezer/common");

/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
  /// @internal
  constructor( /// The parse that this stack is part of @internal
  p, /// Holds state, input pos, buffer index triplets for all but the
  /// top state @internal
  stack, /// The current parse state @internal
  state, // The position at which the next reduce should take place. This
  // can be less than `this.pos` when skipped expressions have been
  // added to the stack (which should be moved outside of the next
  // reduction)
  /// @internal
  reducePos, /// The input position up to which this stack has parsed.
  pos, /// The dynamic score of the stack, including dynamic precedence
  /// and error-recovery penalties
  /// @internal
  score, // The output buffer. Holds (type, start, end, size) quads
  // representing nodes created by the parser, where `size` is
  // amount of buffer array entries covered by this node.
  /// @internal
  buffer, // The base offset of the buffer. When stacks are split, the split
  // instance shared the buffer history with its parent up to
  // `bufferBase`, which is the absolute offset (including the
  // offset of previous splits) into the buffer at which this stack
  // starts writing.
  /// @internal
  bufferBase, /// @internal
  curContext, /// @internal
  lookAhead = 0, // A parent stack from which this was split off, if any. This is
  // set up so that it always points to a stack that has some
  // additional buffer content, never to a stack with an equal
  // `bufferBase`.
  /// @internal
  parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  } /// @internal


  toString() {
    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  } // Start an empty stack
  /// @internal


  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  } /// The stack's current [context](#lr.ContextTracker) value, if
  /// any. Its type will depend on the context tracker's type
  /// parameter, or it will be `null` if there is no context
  /// tracker.


  get context() {
    return this.curContext ? this.curContext.context : null;
  } // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /// @internal


  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  } // Apply a reduce action
  /// @internal


  reduce(action) {
    let depth = action >> 19
    /* ReduceDepthShift */
    ,
        type = action & 65535
    /* ValueMask */
    ;
    let {
      parser
    } = this.p;
    let dPrec = parser.dynamicPrecedence(type);
    if (dPrec) this.score += dPrec;

    if (depth == 0) {
      // Zero-depth reductions are a special case—they add stuff to
      // the stack without popping anything off.
      if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true);
      this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
      this.reduceContext(type, this.reducePos);
      return;
    } // Find the base index into `this.stack`, content after which will
    // be dropped. Note that with `StayFlag` reductions we need to
    // consume two extra frames (the dummy parent node for the skipped
    // expression and the state that we'll be staying in, which should
    // be moved to `this.state`).


    let base = this.stack.length - (depth - 1) * 3 - (action & 262144
    /* StayFlag */
    ? 6 : 0);
    let start = this.stack[base - 2];
    let bufferBase = this.stack[base - 1],
        count = this.bufferBase + this.buffer.length - bufferBase; // Store normal terms or `R -> R R` repeat reductions

    if (type < parser.minRepeatTerm || action & 131072
    /* RepeatFlag */
    ) {
      let pos = parser.stateFlag(this.state, 1
      /* Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }

    if (action & 262144
    /* StayFlag */
    ) {
        this.state = this.stack[base];
      } else {
      let baseStateID = this.stack[base - 3];
      this.state = parser.getGoto(baseStateID, type, true);
    }

    while (this.stack.length > base) this.stack.pop();

    this.reduceContext(type, start);
  } // Shift a value into the buffer
  /// @internal


  storeNode(term, start, end, size = 4, isReduce = false) {
    if (term == 0
    /* Err */
    ) {
        // Try to omit/merge adjacent error nodes
        let cur = this,
            top = this.buffer.length;

        if (top == 0 && cur.parent) {
          top = cur.bufferBase - cur.parent.bufferBase;
          cur = cur.parent;
        }

        if (top > 0 && cur.buffer[top - 4] == 0
        /* Err */
        && cur.buffer[top - 1] > -1) {
          if (start == end) return;

          if (cur.buffer[top - 2] >= start) {
            cur.buffer[top - 2] = end;
            return;
          }
        }
      }

    if (!isReduce || this.pos == end) {
      // Simple case, just append
      this.buffer.push(term, start, end, size);
    } else {
      // There may be skipped nodes that have to be moved forward
      let index = this.buffer.length;
      if (index > 0 && this.buffer[index - 4] != 0
      /* Err */
      ) while (index > 0 && this.buffer[index - 2] > end) {
          // Move this record forward
          this.buffer[index] = this.buffer[index - 4];
          this.buffer[index + 1] = this.buffer[index - 3];
          this.buffer[index + 2] = this.buffer[index - 2];
          this.buffer[index + 3] = this.buffer[index - 1];
          index -= 4;
          if (size > 4) size -= 4;
        }
      this.buffer[index] = term;
      this.buffer[index + 1] = start;
      this.buffer[index + 2] = end;
      this.buffer[index + 3] = size;
    }
  } // Apply a shift action
  /// @internal


  shift(action, next, nextEnd) {
    let start = this.pos;

    if (action & 131072
    /* GotoFlag */
    ) {
        this.pushState(action & 65535
        /* ValueMask */
        , this.pos);
      } else if ((action & 262144
    /* StayFlag */
    ) == 0) {
      // Regular shift
      let nextState = action,
          {
        parser
      } = this.p;

      if (nextEnd > this.pos || next <= parser.maxNode) {
        this.pos = nextEnd;
        if (!parser.stateFlag(nextState, 1
        /* Skipped */
        )) this.reducePos = nextEnd;
      }

      this.pushState(nextState, start);
      this.shiftContext(next, start);
      if (next <= parser.maxNode) this.buffer.push(next, start, nextEnd, 4);
    } else {
      // Shift-and-stay, which means this is a skipped token
      this.pos = nextEnd;
      this.shiftContext(next, start);
      if (next <= this.p.parser.maxNode) this.buffer.push(next, start, nextEnd, 4);
    }
  } // Apply an action
  /// @internal


  apply(action, next, nextEnd) {
    if (action & 65536
    /* ReduceFlag */
    ) this.reduce(action);else this.shift(action, next, nextEnd);
  } // Add a prebuilt (reused) node into the buffer. @internal


  useNode(value, next) {
    let index = this.p.reused.length - 1;

    if (index < 0 || this.p.reused[index] != value) {
      this.p.reused.push(value);
      index++;
    }

    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(index, start, this.reducePos, -1
    /* size == -1 means this is a reused value */
    );
    if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  } // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /// @internal


  split() {
    let parent = this;
    let off = parent.buffer.length; // Because the top of the buffer (after this.pos) may be mutated
    // to reorder reductions and skipped tokens, and shared buffers
    // should be immutable, this copies any outstanding skipped tokens
    // to the new buffer, and puts the base pointer before them.

    while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4;

    let buffer = parent.buffer.slice(off),
        base = parent.bufferBase + off; // Make sure parent points to an actual parent with content, if there is such a parent.

    while (parent && base == parent.bufferBase) parent = parent.parent;

    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
  } // Try to recover from an error by 'deleting' (ignoring) one token.
  /// @internal


  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode) this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0
    /* Err */
    , this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190
    /* Delete */
    ;
  } /// Check if the given term would be able to be shifted (optionally
  /// after some reductions) on this stack. This can be useful for
  /// external tokenizers that want to make sure they only provide a
  /// given token when it applies.


  canShift(term) {
    for (let sim = new SimulatedStack(this);;) {
      let action = this.p.parser.stateSlot(sim.state, 4
      /* DefaultReduce */
      ) || this.p.parser.hasAction(sim.state, term);
      if ((action & 65536
      /* ReduceFlag */
      ) == 0) return true;
      if (action == 0) return false;
      sim.reduce(action);
    }
  } // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /// @internal


  recoverByInsert(next) {
    if (this.stack.length >= 300
    /* MaxInsertStackDepth */
    ) return [];
    let nextStates = this.p.parser.nextStates(this.state);

    if (nextStates.length > 4
    /* MaxNext */
    << 1 || this.stack.length >= 120
    /* DampenInsertStackDepth */
    ) {
        let best = [];

        for (let i = 0, s; i < nextStates.length; i += 2) {
          if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next)) best.push(nextStates[i], s);
        }

        if (this.stack.length < 120
        /* DampenInsertStackDepth */
        ) for (let i = 0; best.length < 4
          /* MaxNext */
          << 1 && i < nextStates.length; i += 2) {
            let s = nextStates[i + 1];
            if (!best.some((v, i) => i & 1 && v == s)) best.push(nextStates[i], s);
          }
        nextStates = best;
      }

    let result = [];

    for (let i = 0; i < nextStates.length && result.length < 4
    /* MaxNext */
    ; i += 2) {
      let s = nextStates[i + 1];
      if (s == this.state) continue;
      let stack = this.split();
      stack.storeNode(0
      /* Err */
      , stack.pos, stack.pos, 4, true);
      stack.pushState(s, this.pos);
      stack.shiftContext(nextStates[i], this.pos);
      stack.score -= 200
      /* Insert */
      ;
      result.push(stack);
    }

    return result;
  } // Force a reduce, if possible. Return false if that can't
  // be done.
  /// @internal


  forceReduce() {
    let reduce = this.p.parser.stateSlot(this.state, 5
    /* ForcedReduce */
    );
    if ((reduce & 65536
    /* ReduceFlag */
    ) == 0) return false;
    let {
      parser
    } = this.p;

    if (!parser.validAction(this.state, reduce)) {
      let depth = reduce >> 19
      /* ReduceDepthShift */
      ,
          term = reduce & 65535
      /* ValueMask */
      ;
      let target = this.stack.length - depth * 3;
      if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) return false;
      this.storeNode(0
      /* Err */
      , this.reducePos, this.reducePos, 4, true);
      this.score -= 100
      /* Reduce */
      ;
    }

    this.reduce(reduce);
    return true;
  } /// @internal


  forceAll() {
    while (!this.p.parser.stateFlag(this.state, 2
    /* Accepting */
    ) && this.forceReduce()) {}

    return this;
  } /// Check whether this state has no further actions (assumed to be a direct descendant of the
  /// top state, since any other states must be able to continue
  /// somehow). @internal


  get deadEnd() {
    if (this.stack.length != 3) return false;
    let {
      parser
    } = this.p;
    return parser.data[parser.stateSlot(this.state, 1
    /* Actions */
    )] == 65535
    /* End */
    && !parser.stateSlot(this.state, 4
    /* DefaultReduce */
    );
  } /// Restart the stack (put it back in its start state). Only safe
  /// when this.stack.length == 3 (state is directly below the top
  /// state). @internal


  restart() {
    this.state = this.stack[0];
    this.stack.length = 0;
  } /// @internal


  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length) return false;

    for (let i = 0; i < this.stack.length; i += 3) if (this.stack[i] != other.stack[i]) return false;

    return true;
  } /// Get the parser used by this stack.


  get parser() {
    return this.p.parser;
  } /// Test whether a given dialect (by numeric ID, as exported from
  /// the terms file) is enabled.


  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }

  shiftContext(term, start) {
    if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }

  reduceContext(term, start) {
    if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  } /// @internal


  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3) this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
  } /// @internal


  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4) this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
  }

  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash) this.emitContext();
      this.curContext = newCx;
    }
  } /// @internal


  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  } /// @internal


  close() {
    if (this.curContext && this.curContext.tracker.strict) this.emitContext();
    if (this.lookAhead > 0) this.emitLookAhead();
  }

}

exports.Stack = Stack;

class StackContext {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }

}

var Recover;

(function (Recover) {
  Recover[Recover["Insert"] = 200] = "Insert";
  Recover[Recover["Delete"] = 190] = "Delete";
  Recover[Recover["Reduce"] = 100] = "Reduce";
  Recover[Recover["MaxNext"] = 4] = "MaxNext";
  Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
  Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {})); // Used to cheaply run some reductions to scan ahead without mutating
// an entire stack


class SimulatedStack {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }

  reduce(action) {
    let term = action & 65535
    /* ValueMask */
    ,
        depth = action >> 19
    /* ReduceDepthShift */
    ;

    if (depth == 0) {
      if (this.stack == this.start.stack) this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }

    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }

} // This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.


class StackBufferCursor {
  constructor(stack, pos, index) {
    this.stack = stack;
    this.pos = pos;
    this.index = index;
    this.buffer = stack.buffer;
    if (this.index == 0) this.maybeNext();
  }

  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }

  maybeNext() {
    let next = this.stack.parent;

    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }

  get id() {
    return this.buffer[this.index - 4];
  }

  get start() {
    return this.buffer[this.index - 3];
  }

  get end() {
    return this.buffer[this.index - 2];
  }

  get size() {
    return this.buffer[this.index - 1];
  }

  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0) this.maybeNext();
  }

  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }

}

class CachedToken {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }

}

const nullToken = new CachedToken(); /// [Tokenizers](#lr.ExternalTokenizer) interact with the input
/// through this interface. It presents the input as a stream of
/// characters, tracking lookahead and hiding the complexity of
/// [ranges](#common.Parser.parse^ranges) from tokenizer code.

class InputStream {
  /// @internal
  constructor( /// @internal
  input, /// @internal
  ranges) {
    this.input = input;
    this.ranges = ranges; /// @internal

    this.chunk = ""; /// @internal

    this.chunkOff = 0; /// Backup chunk

    this.chunk2 = "";
    this.chunk2Pos = 0; /// The character code of the next code unit in the input, or -1
    /// when the stream is at the end of the input.

    this.next = -1; /// @internal

    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }

  resolveOffset(offset, assoc) {
    let range = this.range,
        index = this.rangeIndex;
    let pos = this.pos + offset;

    while (pos < range.from) {
      if (!index) return null;
      let next = this.ranges[--index];
      pos -= range.from - next.to;
      range = next;
    }

    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index == this.ranges.length - 1) return null;
      let next = this.ranges[++index];
      pos += next.from - range.to;
      range = next;
    }

    return pos;
  } /// Look at a code unit near the stream position. `.peek(0)` equals
  /// `.next`, `.peek(-1)` gives you the previous character, and so
  /// on.
  ///
  /// Note that looking around during tokenizing creates dependencies
  /// on potentially far-away content, which may reduce the
  /// effectiveness incremental parsing—when looking forward—or even
  /// cause invalid reparses when looking backward more than 25 code
  /// units, since the library does not track lookbehind.


  peek(offset) {
    let idx = this.chunkOff + offset,
        pos,
        result;

    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null) return -1;
      pos = resolved;

      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i = this.rangeIndex,
            range = this.range;

        while (range.to <= pos) range = this.ranges[++i];

        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to) this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }

    if (pos > this.token.lookAhead) this.token.lookAhead = pos;
    return result;
  } /// Accept a token. By default, the end of the token is set to the
  /// current stream position, but you can pass an offset (relative to
  /// the stream position) to change that.


  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start) throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }

  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let {
        chunk,
        chunkPos
      } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }

  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length) return this.next = -1;
    }

    return this.next = this.chunk.charCodeAt(this.chunkOff);
  } /// Move the stream forward N (defaults to 1) code units. Returns
  /// the new value of [`next`](#lr.InputStream.next).


  advance(n = 1) {
    this.chunkOff += n;

    while (this.pos + n >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1) return this.setDone();
      n -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }

    this.pos += n;
    if (this.pos > this.token.lookAhead) this.token.lookAhead = this.pos;
    return this.readNext();
  }

  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  } /// @internal


  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = token.lookAhead = pos;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }

    if (this.pos != pos) {
      this.pos = pos;

      if (pos == this.end) {
        this.setDone();
        return this;
      }

      while (pos < this.range.from) this.range = this.ranges[--this.rangeIndex];

      while (pos >= this.range.to) this.range = this.ranges[++this.rangeIndex];

      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }

      this.readNext();
    }

    return this;
  } /// @internal


  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length) return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.range.from && to <= this.range.to) return this.input.read(from, to);
    let result = "";

    for (let r of this.ranges) {
      if (r.from >= to) break;
      if (r.to > from) result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
    }

    return result;
  }

} /// @internal


exports.InputStream = InputStream;

class TokenGroup {
  constructor(data, id) {
    this.data = data;
    this.id = id;
  }

  token(input, stack) {
    readToken(this.data, input, stack, this.id);
  }

}

TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false; /// `@external tokens` declarations in the grammar should resolve to
/// an instance of this class.

class ExternalTokenizer {
  /// Create a tokenizer. The first argument is the function that,
  /// given an input stream, scans for the types of tokens it
  /// recognizes at the stream's position, and calls
  /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  /// one.
  constructor( /// @internal
  token, options = {}) {
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }

} // Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.


exports.ExternalTokenizer = ExternalTokenizer;

function readToken(data, input, stack, group) {
  let state = 0,
      groupMask = 1 << group,
      {
    parser
  } = stack.p,
      {
    dialect
  } = parser;

  scan: for (;;) {
    if ((groupMask & data[state]) == 0) break;
    let accEnd = data[state + 1]; // Check whether this state can lead to a token in the current group
    // Accept tokens in this state, possibly overwriting
    // lower-precedence / shorter tokens

    for (let i = state + 3; i < accEnd; i += 2) if ((data[i + 1] & groupMask) > 0) {
      let term = data[i];

      if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {
        input.acceptToken(term);
        break;
      }
    } // Do a binary search on the state's edges


    for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {
      let mid = low + high >> 1;
      let index = accEnd + mid + (mid << 1);
      let from = data[index],
          to = data[index + 1];
      if (next < from) high = mid;else if (next >= to) low = mid + 1;else {
        state = data[index + 2];
        input.advance();
        continue scan;
      }
    }

    break;
  }
} // See lezer-generator/src/encode.ts for comments about the encoding
// used here


function decodeArray(input, Type = Uint16Array) {
  if (typeof input != "string") return input;
  let array = null;

  for (let pos = 0, out = 0; pos < input.length;) {
    let value = 0;

    for (;;) {
      let next = input.charCodeAt(pos++),
          stop = false;

      if (next == 126
      /* BigValCode */
      ) {
          value = 65535
          /* BigVal */
          ;
          break;
        }

      if (next >= 92
      /* Gap2 */
      ) next--;
      if (next >= 34
      /* Gap1 */
      ) next--;
      let digit = next - 32
      /* Start */
      ;

      if (digit >= 46
      /* Base */
      ) {
          digit -= 46
          /* Base */
          ;
          stop = true;
        }

      value += digit;
      if (stop) break;
      value *= 46
      /* Base */
      ;
    }

    if (array) array[out++] = value;else array = new Type(value);
  }

  return array;
} // FIXME find some way to reduce recovery work done when the input
// doesn't match the grammar at all.
// Environment variable used to control console output


const verbose = typeof process != "undefined" && /\bparse\b/.test(undefined);
let stackIDs = null;
var Safety;

(function (Safety) {
  Safety[Safety["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));

function cutAt(tree, pos, side) {
  let cursor = tree.fullCursor();
  cursor.moveTo(pos);

  for (;;) {
    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for (;;) {
      if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25
      /* Margin */
      )) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25
      /* Margin */
      ));
      if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;
      if (!cursor.parent()) return side < 0 ? 0 : tree.length;
    }
  }
}

class FragmentCursor {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }

  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];

    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;

      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }

      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  } // `pos` must be >= any previously given `pos` for this cursor


  nodeAt(pos) {
    if (pos < this.nextStart) return null;

    while (this.fragment && this.safeTo <= pos) this.nextFragment();

    if (!this.fragment) return null;

    for (;;) {
      let last = this.trees.length - 1;

      if (last < 0) {
        // End of tree
        this.nextFragment();
        return null;
      }

      let top = this.trees[last],
          index = this.index[last];

      if (index == top.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }

      let next = top.children[index];
      let start = this.start[last] + top.positions[index];

      if (start > pos) {
        this.nextStart = start;
        return null;
      }

      if (next instanceof _common.Tree) {
        if (start == pos) {
          if (start < this.safeFrom) return null;
          let end = start + next.length;

          if (end <= this.safeTo) {
            let lookAhead = next.prop(_common.NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to) return next;
          }
        }

        this.index[last]++;

        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          // Enter this node
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next.length;
      }
    }
  }

}

class TokenCache {
  constructor(parser, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser.tokenizers.map(_ => new CachedToken());
  }

  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let {
      parser
    } = stack.p,
        {
      tokenizers
    } = parser;
    let mask = parser.stateSlot(stack.state, 3
    /* TokenizerMask */
    );
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;

    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0) continue;
      let tokenizer = tokenizers[i],
          token = this.tokens[i];
      if (main && !tokenizer.fallback) continue;

      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }

      if (token.lookAhead > token.end + 25
      /* Margin */
      ) lookAhead = Math.max(token.lookAhead, lookAhead);

      if (token.value != 0
      /* Err */
      ) {
          let startIndex = actionIndex;
          if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
          actionIndex = this.addActions(stack, token.value, token.end, actionIndex);

          if (!tokenizer.extend) {
            main = token;
            if (actionIndex > startIndex) break;
          }
        }
    }

    while (this.actions.length > actionIndex) this.actions.pop();

    if (lookAhead) stack.setLookAhead(lookAhead);

    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }

    this.mainToken = main;
    return this.actions;
  }

  getMainToken(stack) {
    if (this.mainToken) return this.mainToken;
    let main = new CachedToken(),
        {
      pos,
      p
    } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p.stream.end);
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0
    /* Err */
    ;
    return main;
  }

  updateCachedToken(token, tokenizer, stack) {
    tokenizer.token(this.stream.reset(stack.pos, token), stack);

    if (token.value > -1) {
      let {
        parser
      } = stack.p;

      for (let i = 0; i < parser.specialized.length; i++) if (parser.specialized[i] == token.value) {
        let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);

        if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
          if ((result & 1) == 0
          /* Specialize */
          ) token.value = result >> 1;else token.extended = result >> 1;
          break;
        }
      }
    } else {
      token.value = 0
      /* Err */
      ;
      token.end = Math.min(stack.p.stream.end, stack.pos + 1);
    }
  }

  putAction(action, token, end, index) {
    // Don't add duplicate actions
    for (let i = 0; i < index; i += 3) if (this.actions[i] == action) return index;

    this.actions[index++] = action;
    this.actions[index++] = token;
    this.actions[index++] = end;
    return index;
  }

  addActions(stack, token, end, index) {
    let {
      state
    } = stack,
        {
      parser
    } = stack.p,
        {
      data
    } = parser;

    for (let set = 0; set < 2; set++) {
      for (let i = parser.stateSlot(state, set ? 2
      /* Skip */
      : 1
      /* Actions */
      );; i += 3) {
        if (data[i] == 65535
        /* End */
        ) {
            if (data[i + 1] == 1
            /* Next */
            ) {
                i = pair(data, i + 2);
              } else {
              if (index == 0 && data[i + 1] == 2
              /* Other */
              ) index = this.putAction(pair(data, i + 1), token, end, index);
              break;
            }
          }

        if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index);
      }
    }

    return index;
  }

}

var Rec;

(function (Rec) {
  Rec[Rec["Distance"] = 5] = "Distance";
  Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
  Rec[Rec["MinBufferLengthPrune"] = 200] = "MinBufferLengthPrune";
  Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
})(Rec || (Rec = {}));

class Parse {
  constructor(parser, input, fragments, ranges) {
    this.parser = parser;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 0x2654;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser, this.stream);
    this.topTerm = parser.top[1];
    let {
      from
    } = ranges[0];
    this.stacks = [Stack.start(this, parser.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4 ? new FragmentCursor(fragments, parser.nodeSet) : null;
  }

  get parsedPos() {
    return this.minStackPos;
  } // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.


  advance() {
    let stacks = this.stacks,
        pos = this.minStackPos; // This will hold stacks beyond `pos`.

    let newStacks = this.stacks = [];
    let stopped, stoppedTokens; // Keep advancing any stacks at `pos` until they either move
    // forward or can't be advanced. Gather stacks that can't be
    // advanced further in `stopped`.

    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i];

      for (;;) {
        this.tokens.mainToken = null;

        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }

          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }

        break;
      }
    }

    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) return this.stackToTree(finished);

      if (this.parser.strict) {
        if (verbose && stopped) console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }

      if (!this.recovering) this.recovering = 5
      /* Distance */
      ;
    }

    if (this.recovering && stopped) {
      let finished = this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) return this.stackToTree(finished.forceAll());
    }

    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3
      /* MaxRemainingPerStep */
      ;

      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);

        while (newStacks.length > maxRemaining) newStacks.pop();
      }

      if (newStacks.some(s => s.reducePos > pos)) this.recovering--;
    } else if (newStacks.length > 1) {
      // Prune stacks that are in the same state, or that have been
      // running without splitting for a while, to avoid getting stuck
      // with multiple successful stacks running endlessly on.
      outer: for (let i = 0; i < newStacks.length - 1; i++) {
        let stack = newStacks[i];

        for (let j = i + 1; j < newStacks.length; j++) {
          let other = newStacks[j];

          if (stack.sameState(other) || stack.buffer.length > 200
          /* MinBufferLengthPrune */
          && other.buffer.length > 200
          /* MinBufferLengthPrune */
          ) {
              if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j--, 1);
              } else {
                newStacks.splice(i--, 1);
                continue outer;
              }
            }
        }
      }
    }

    this.minStackPos = newStacks[0].pos;

    for (let i = 1; i < newStacks.length; i++) if (newStacks[i].pos < this.minStackPos) this.minStackPos = newStacks[i].pos;

    return null;
  }

  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  } // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.


  advanceStack(stack, stacks, split) {
    let start = stack.pos,
        {
      parser
    } = this;
    let base = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null;

    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict,
          cxHash = strictCx ? stack.curContext.hash : 0;

      for (let cached = this.fragments.nodeAt(start); cached;) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;

        if (match > -1 && cached.length && (!strictCx || (cached.prop(_common.NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose) console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
          return true;
        }

        if (!(cached instanceof _common.Tree) || cached.children.length == 0 || cached.positions[0] > 0) break;
        let inner = cached.children[0];
        if (inner instanceof _common.Tree && cached.positions[0] == 0) cached = inner;else break;
      }
    }

    let defaultReduce = parser.stateSlot(stack.state, 4
    /* DefaultReduce */
    );

    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose) console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535
      /* ValueMask */
      )})`);
      return true;
    }

    let actions = this.tokens.getActions(stack);

    for (let i = 0; i < actions.length;) {
      let action = actions[i++],
          term = actions[i++],
          end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      localStack.apply(action, term, end);
      if (verbose) console.log(base + this.stackID(localStack) + ` (via ${(action & 65536
      /* ReduceFlag */
      ) == 0 ? "shift" : `reduce of ${parser.getName(action & 65535
      /* ValueMask */
      )}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last) return true;else if (localStack.pos > start) stacks.push(localStack);else split.push(localStack);
    }

    return false;
  } // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.


  advanceFully(stack, newStacks) {
    let pos = stack.pos;

    for (;;) {
      if (!this.advanceStack(stack, null, null)) return false;

      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }

  runRecovery(stacks, tokens, newStacks) {
    let finished = null,
        restarted = false;

    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i],
          token = tokens[i << 1],
          tokenEnd = tokens[(i << 1) + 1];
      let base = verbose ? this.stackID(stack) + " -> " : "";

      if (stack.deadEnd) {
        if (restarted) continue;
        restarted = true;
        stack.restart();
        if (verbose) console.log(base + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done) continue;
      }

      let force = stack.split(),
          forceBase = base;

      for (let j = 0; force.forceReduce() && j < 10
      /* ForceReduceLimit */
      ; j++) {
        if (verbose) console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done) break;
        if (verbose) forceBase = this.stackID(force) + " -> ";
      }

      for (let insert of stack.recoverByInsert(token)) {
        if (verbose) console.log(base + this.stackID(insert) + " (via recover-insert)");
        this.advanceFully(insert, newStacks);
      }

      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0
          /* Err */
          ;
        }

        stack.recoverByDelete(token, tokenEnd);
        if (verbose) console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }

    return finished;
  } // Convert the stack's buffer to a syntax tree.


  stackToTree(stack) {
    stack.close();
    return _common.Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }

  stackID(stack) {
    let id = (stackIDs || (stackIDs = new WeakMap())).get(stack);
    if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
    return id + stack;
  }

}

function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];

    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score) newStacks[i] = stack;
      return;
    }
  }

  newStacks.push(stack);
}

class Dialect {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }

  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }

}

const id = x => x; /// Context trackers are used to track stateful context (such as
/// indentation in the Python grammar, or parent elements in the XML
/// grammar) needed by external tokenizers. You declare them in a
/// grammar file as `@context exportName from "module"`.
///
/// Context values should be immutable, and can be updated (replaced)
/// on shift or reduce actions.
///
/// The export used in a `@context` declaration should be of this
/// type.


class ContextTracker {
  /// Define a context tracker.
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id;
    this.reduce = spec.reduce || id;
    this.reuse = spec.reuse || id;

    this.hash = spec.hash || (() => 0);

    this.strict = spec.strict !== false;
  }

} /// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.


exports.ContextTracker = ContextTracker;

class LRParser extends _common.Parser {
  /// @internal
  constructor(spec) {
    super(); /// @internal

    this.wrappers = [];
    if (spec.version != 13
    /* Version */
    ) throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13
      /* Version */
      })`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;

    for (let i = 0; i < spec.repeatNodeCount; i++) nodeNames.push("");

    let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
    let nodeProps = [];

    for (let i = 0; i < nodeNames.length; i++) nodeProps.push([]);

    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }

    if (spec.nodeProps) for (let propSpec of spec.nodeProps) {
      let prop = propSpec[0];

      for (let i = 1; i < propSpec.length;) {
        let next = propSpec[i++];

        if (next >= 0) {
          setProp(next, prop, propSpec[i++]);
        } else {
          let value = propSpec[i + -next];

          for (let j = -next; j > 0; j--) setProp(propSpec[i++], prop, value);

          i++;
        }
      }
    }
    this.nodeSet = new _common.NodeSet(nodeNames.map((name, i) => _common.NodeType.define({
      name: i >= this.minRepeatTerm ? undefined : name,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    this.strict = false;
    this.bufferLength = _common.DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
    this.specializers = [];
    if (spec.specialized) for (let i = 0; i < spec.specialized.length; i++) {
      this.specialized[i] = spec.specialized[i].term;
      this.specializers[i] = spec.specialized[i].get;
    }
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }

  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);

    for (let w of this.wrappers) parse = w(parse, input, fragments, ranges);

    return parse;
  } /// Get a goto table entry @internal


  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0]) return -1;

    for (let pos = table[term + 1];;) {
      let groupTag = table[pos++],
          last = groupTag & 1;
      let target = table[pos++];
      if (last && loose) return target;

      for (let end = pos + (groupTag >> 1); pos < end; pos++) if (table[pos] == state) return target;

      if (last) return -1;
    }
  } /// Check if this state has an action for a given terminal @internal


  hasAction(state, terminal) {
    let data = this.data;

    for (let set = 0; set < 2; set++) {
      for (let i = this.stateSlot(state, set ? 2
      /* Skip */
      : 1
      /* Actions */
      ), next;; i += 3) {
        if ((next = data[i]) == 65535
        /* End */
        ) {
            if (data[i + 1] == 1
            /* Next */
            ) next = data[i = pair(data, i + 2)];else if (data[i + 1] == 2
            /* Other */
            ) return pair(data, i + 2);else break;
          }

        if (next == terminal || next == 0
        /* Err */
        ) return pair(data, i + 1);
      }
    }

    return 0;
  } /// @internal


  stateSlot(state, slot) {
    return this.states[state * 6
    /* Size */
    + slot];
  } /// @internal


  stateFlag(state, flag) {
    return (this.stateSlot(state, 0
    /* Flags */
    ) & flag) > 0;
  } /// @internal


  validAction(state, action) {
    if (action == this.stateSlot(state, 4
    /* DefaultReduce */
    )) return true;

    for (let i = this.stateSlot(state, 1
    /* Actions */
    );; i += 3) {
      if (this.data[i] == 65535
      /* End */
      ) {
          if (this.data[i + 1] == 1
          /* Next */
          ) i = pair(this.data, i + 2);else return false;
        }

      if (action == pair(this.data, i + 1)) return true;
    }
  } /// Get the states that can follow this one through shift actions or
  /// goto jumps. @internal


  nextStates(state) {
    let result = [];

    for (let i = this.stateSlot(state, 1
    /* Actions */
    );; i += 3) {
      if (this.data[i] == 65535
      /* End */
      ) {
          if (this.data[i + 1] == 1
          /* Next */
          ) i = pair(this.data, i + 2);else break;
        }

      if ((this.data[i + 2] & 65536
      /* ReduceFlag */
      >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i) => i & 1 && v == value)) result.push(this.data[i], value);
      }
    }

    return result;
  } /// @internal


  overrides(token, prev) {
    let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
  } /// Configure the parser. Returns a new parser instance that has the
  /// given settings modified. Settings not provided in `config` are
  /// kept from the original parser.


  configure(config) {
    // Hideous reflection-based kludge to make it easy to create a
    // slightly modified copy of a parser.
    let copy = Object.assign(Object.create(LRParser.prototype), this);
    if (config.props) copy.nodeSet = this.nodeSet.extend(...config.props);

    if (config.top) {
      let info = this.topRules[config.top];
      if (!info) throw new RangeError(`Invalid top rule name ${config.top}`);
      copy.top = info;
    }

    if (config.tokenizers) copy.tokenizers = this.tokenizers.map(t => {
      let found = config.tokenizers.find(r => r.from == t);
      return found ? found.to : t;
    });
    if (config.contextTracker) copy.context = config.contextTracker;
    if (config.dialect) copy.dialect = this.parseDialect(config.dialect);
    if (config.strict != null) copy.strict = config.strict;
    if (config.wrap) copy.wrappers = copy.wrappers.concat(config.wrap);
    if (config.bufferLength != null) copy.bufferLength = config.bufferLength;
    return copy;
  } /// Returns the name associated with a given term. This will only
  /// work for all terms when the parser was generated with the
  /// `--names` option. By default, only the names of tagged terms are
  /// stored.


  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  } /// The eof term id is always allocated directly after the node
  /// types. @internal


  get eofTerm() {
    return this.maxNode + 1;
  } /// The type of top node produced by the parser.


  get topNode() {
    return this.nodeSet.types[this.top[1]];
  } /// @internal


  dynamicPrecedence(term) {
    let prec = this.dynamicPrecedences;
    return prec == null ? 0 : prec[term] || 0;
  } /// @internal


  parseDialect(dialect) {
    let values = Object.keys(this.dialects),
        flags = values.map(() => false);
    if (dialect) for (let part of dialect.split(" ")) {
      let id = values.indexOf(part);
      if (id >= 0) flags[id] = true;
    }
    let disabled = null;

    for (let i = 0; i < values.length; i++) if (!flags[i]) {
      for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535
      /* End */
      ;) (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
    }

    return new Dialect(dialect, flags, disabled);
  } /// (used by the output of the parser generator) @internal


  static deserialize(spec) {
    return new LRParser(spec);
  }

}

exports.LRParser = LRParser;

function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}

function findOffset(data, start, term) {
  for (let i = start, next; (next = data[i]) != 65535
  /* End */
  ; i++) if (next == term) return i - start;

  return -1;
}

function findFinished(stacks) {
  let best = null;

  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2
    /* Accepting */
    ) && (!best || best.score < stack.score)) best = stack;
  }

  return best;
}
},{"@lezer/common":"node_modules/@lezer/common/dist/index.js","process":"node_modules/process/browser.js"}],"node_modules/@lezer/javascript/dist/index.es.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parser = void 0;

var _lr = require("@lezer/lr");

var _common = require("@lezer/common");

// This file was generated by lezer-generator. You probably shouldn't edit it.
const noSemi = 271,
      incdec = 1,
      incdecPrefix = 2,
      templateContent = 272,
      templateDollarBrace = 273,
      templateEnd = 274,
      insertSemi = 275,
      TSExtends = 3,
      spaces = 277,
      newline = 278,
      LineComment = 4,
      BlockComment = 5,
      Dialect_ts = 1;
/* Hand-written tokenizers for JavaScript tokens that can't be
   expressed by lezer's built-in tokenizer. */

const space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288];
const braceR = 125,
      braceL = 123,
      semicolon = 59,
      slash = 47,
      star = 42,
      plus = 43,
      minus = 45,
      dollar = 36,
      backtick = 96,
      backslash = 92;
const trackNewline = new _lr.ContextTracker({
  start: false,

  shift(context, term) {
    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline;
  },

  strict: false
});
const insertSemicolon = new _lr.ExternalTokenizer((input, stack) => {
  let {
    next
  } = input;
  if ((next == braceR || next == -1 || stack.context) && stack.canShift(insertSemi)) input.acceptToken(insertSemi);
}, {
  contextual: true,
  fallback: true
});
const noSemicolon = new _lr.ExternalTokenizer((input, stack) => {
  let {
    next
  } = input,
      after;
  if (space.indexOf(next) > -1) return;
  if (next == slash && ((after = input.peek(1)) == slash || after == star)) return;
  if (next != braceR && next != semicolon && next != -1 && !stack.context && stack.canShift(noSemi)) input.acceptToken(noSemi);
}, {
  contextual: true
});
const incdecToken = new _lr.ExternalTokenizer((input, stack) => {
  let {
    next
  } = input;

  if (next == plus || next == minus) {
    input.advance();

    if (next == input.next) {
      input.advance();
      let mayPostfix = !stack.context && stack.canShift(incdec);
      input.acceptToken(mayPostfix ? incdec : incdecPrefix);
    }
  }
}, {
  contextual: true
});
const template = new _lr.ExternalTokenizer(input => {
  for (let afterDollar = false, i = 0;; i++) {
    let {
      next
    } = input;

    if (next < 0) {
      if (i) input.acceptToken(templateContent);
      break;
    } else if (next == backtick) {
      if (i) input.acceptToken(templateContent);else input.acceptToken(templateEnd, 1);
      break;
    } else if (next == braceL && afterDollar) {
      if (i == 1) input.acceptToken(templateDollarBrace, 1);else input.acceptToken(templateContent, -1);
      break;
    } else if (next == 10
    /* "\n" */
    && i) {
      // Break up template strings on lines, to avoid huge tokens
      input.advance();
      input.acceptToken(templateContent);
      break;
    } else if (next == backslash) {
      input.advance();
    }

    afterDollar = next == dollar;
    input.advance();
  }
});

function tsExtends(value, stack) {
  return value == "extends" && stack.dialectEnabled(Dialect_ts) ? TSExtends : -1;
} // This file was generated by lezer-generator. You probably shouldn't edit it.


const spec_identifier = {
  __proto__: null,
  export: 16,
  as: 21,
  from: 25,
  default: 30,
  async: 35,
  function: 36,
  this: 46,
  true: 54,
  false: 54,
  void: 60,
  typeof: 64,
  null: 78,
  super: 80,
  new: 114,
  await: 131,
  yield: 133,
  delete: 134,
  class: 144,
  extends: 146,
  public: 183,
  private: 183,
  protected: 183,
  readonly: 185,
  in: 204,
  instanceof: 206,
  const: 208,
  import: 240,
  keyof: 291,
  unique: 295,
  infer: 301,
  is: 335,
  abstract: 355,
  implements: 357,
  type: 359,
  let: 362,
  var: 364,
  interface: 371,
  enum: 375,
  namespace: 381,
  module: 383,
  declare: 387,
  global: 391,
  for: 412,
  of: 421,
  while: 424,
  with: 428,
  do: 432,
  if: 436,
  else: 438,
  switch: 442,
  case: 448,
  try: 454,
  catch: 456,
  finally: 458,
  return: 462,
  throw: 466,
  break: 470,
  continue: 474,
  debugger: 478
};
const spec_word = {
  __proto__: null,
  async: 101,
  get: 103,
  set: 105,
  public: 153,
  private: 153,
  protected: 153,
  static: 155,
  abstract: 157,
  readonly: 161,
  new: 339
};
const spec_LessThan = {
  __proto__: null,
  "<": 121
};

const parser = _lr.LRParser.deserialize({
  version: 13,
  states: "$-tO`QYOOO&}Q!LdO'#CgO'UOSO'#DSO)^QYO'#DXO)nQYO'#DdO)uQYO'#DnO-lQYO'#DtOOQO'#EU'#EUO.PQWO'#ETO.UQWO'#ETO0TQ!LdO'#ImO2kQ!LdO'#InO3XQWO'#ErO3^QpO'#FXOOQ!LS'#Ez'#EzO3fO!bO'#EzO3tQWO'#F`O5RQWO'#F_OOQ!LS'#In'#InOOQ!LQ'#Im'#ImOOQQ'#JV'#JVO5WQWO'#HfO5]Q!LYO'#HgOOQQ'#I_'#I_OOQQ'#Hh'#HhQ`QYOOO)uQYO'#DfO5eQWO'#GSO5jQ#tO'#ClO5xQWO'#ESO6TQ#tO'#EyO6oQWO'#GSO6tQWO'#GWO7PQWO'#GWO7_QWO'#GZO7_QWO'#G[O7_QWO'#G^O5eQWO'#GaO8OQWO'#GdO9^QWO'#CcO9nQWO'#GqO9vQWO'#GwO9vQWO'#GyO`QYO'#G{O9vQWO'#G}O9vQWO'#HQO9{QWO'#HWO:QQ!LZO'#H[O)uQYO'#H^O:]Q!LZO'#H`O:hQ!LZO'#HbO5]Q!LYO'#HdO)uQYO'#IoOOOS'#Hj'#HjO:sOSO,59nOOQ!LS,59n,59nO=UQbO'#CgO=`QYO'#HkO=mQWO'#IpO?lQbO'#IpO'aQYO'#IpO?sQWO,59sO@ZQ&jO'#D^OASQWO'#EUOAaQWO'#IzOAlQWO'#IyOAtQWO,5:rOAyQWO'#IxOBQQWO'#DuO5jQ#tO'#ESOB`QWO'#ESOBkQ`O'#EyOOQ!LS,5:O,5:OOBsQYO,5:OODqQ!LdO,5:YOE_QWO,5:`OExQ!LYO'#IwO6tQWO'#IvOFPQWO'#IvOFXQWO,5:qOF^QWO'#IvOFlQYO,5:oOHiQWO'#EQOIsQWO,5:oOKSQWO'#DhOKZQYO'#DmOKeQ&jO,5:xO)uQYO,5:xOOQQ'#Ej'#EjOOQQ'#El'#ElO)uQYO,5:yO)uQYO,5:yO)uQYO,5:yO)uQYO,5:yO)uQYO,5:yO)uQYO,5:yO)uQYO,5:yO)uQYO,5:yO)uQYO,5:yO)uQYO,5:yO)uQYO,5:yOOQQ'#Ep'#EpOKjQYO,5;ZOOQ!LS,5;`,5;`OOQ!LS,5;a,5;aOMgQWO,5;aOOQ!LS,5;b,5;bO)uQYO'#HuOMlQ!LYO,5;{ONWQWO,5:yO)uQYO,5;^ONpQpO'#JOON_QpO'#JOONwQpO'#JOO! YQpO,5;iOOQO,5;s,5;sO! hQYO'#FZOOOO'#Ht'#HtO3fO!bO,5;fO! oQpO'#F]OOQ!LS,5;f,5;fO!!]Q,UO'#CqOOQ!LS'#Ct'#CtO!!pQWO'#CtO!!uOSO'#CxO!#cQ#tO,5;xO!#jQWO,5;zO!$vQWO'#FjO!%TQWO'#FkO!%YQWO'#FoO!&[Q&jO'#FsO!&}Q,UO'#IhOOQ!LS'#Ih'#IhO!'XQWO'#IgO!'gQWO'#IfOOQ!LS'#Cr'#CrOOQ!LS'#Cy'#CyO!'oQWO'#C{OIxQWO'#FbOIxQWO'#FdO!'tQWO'#FfO!'yQWO'#FgO!(OQWO'#FmOIxQWO'#FrO!(TQWO'#EVO!(lQWO,5;yO`QYO,5>QOOQQ'#Ib'#IbOOQQ,5>R,5>ROOQQ-E;f-E;fO!*hQ!LdO,5:QOOQ!LQ'#Co'#CoO!+XQ#tO,5<nOOQO'#Ce'#CeO!+jQWO'#CpO!+rQ!LYO'#IcO5RQWO'#IcO9{QWO,59WO!,QQpO,59WO!,YQ#tO,59WO5jQ#tO,59WO!,eQWO,5:oO!,mQWO'#GpO!,uQWO'#JZO)uQYO,5;cOKeQ&jO,5;eO!,}QWO,5=ZO!-SQWO,5=ZO!-XQWO,5=ZO5]Q!LYO,5=ZO5eQWO,5<nO!-gQWO'#EWO!-xQ&jO'#EXOOQ!LQ'#Ix'#IxO!.ZQ!LYO'#JWO5]Q!LYO,5<rO7_QWO,5<xOOQO'#Cq'#CqO!.fQpO,5<uO!.nQ#tO,5<vO!.yQWO,5<xO!/OQ`O,5<{O9{QWO'#GfO5eQWO'#GhO!/WQWO'#GhO5jQ#tO'#GkO!/]QWO'#GkOOQQ,5=O,5=OO!/bQWO'#GlO!/jQWO'#ClO!/oQWO,58}O!/yQWO,58}O!1xQYO,58}OOQQ,58},58}O!2VQ!LYO,58}O)uQYO,58}O!2bQYO'#GsOOQQ'#Gt'#GtOOQQ'#Gu'#GuO`QYO,5=]O!2rQWO,5=]O)uQYO'#DtO`QYO,5=cO`QYO,5=eO!2wQWO,5=gO`QYO,5=iO!2|QWO,5=lO!3RQYO,5=rOOQQ,5=v,5=vO)uQYO,5=vO5]Q!LYO,5=xOOQQ,5=z,5=zO!7PQWO,5=zOOQQ,5=|,5=|O!7PQWO,5=|OOQQ,5>O,5>OO!7UQ`O,5?ZOOOS-E;h-E;hOOQ!LS1G/Y1G/YO!7ZQbO,5>VO)uQYO,5>VOOQO-E;i-E;iO!7eQWO,5?[O!7mQbO,5?[O!7tQWO,5?eOOQ!LS1G/_1G/_O!7|QpO'#DQOOQO'#Ir'#IrO)uQYO'#IrO!8kQpO'#IrO!9YQpO'#D_O!9kQ&jO'#D_O!;sQYO'#D_O!;zQWO'#IqO!<SQWO,59xO!<XQWO'#EYO!<gQWO'#I{O!<oQWO,5:sO!=VQ&jO'#D_O)uQYO,5?fO!=aQWO'#HpO!7tQWO,5?eOOQ!LQ1G0^1G0^O!>gQ&jO'#DxOOQ!LS,5:a,5:aO)uQYO,5:aOHiQWO,5:aO!>nQWO,5:aO9{QWO,5:nO!,QQpO,5:nO!,YQ#tO,5:nO5jQ#tO,5:nOOQ!LS1G/j1G/jOOQ!LS1G/z1G/zOOQ!LQ'#EP'#EPO)uQYO,5?cO!>yQ!LYO,5?cO!?[Q!LYO,5?cO!?cQWO,5?bO!?kQWO'#HrO!?cQWO,5?bOOQ!LQ1G0]1G0]O6tQWO,5?bOOQ!LS1G0Z1G0ZO!@VQ!LdO1G0ZO!@vQ!LbO,5:lOOQ!LS'#Fi'#FiO!AdQ!LdO'#IhOFlQYO1G0ZO!CcQ#tO'#IsO!CmQWO,5:SO!CrQbO'#ItO)uQYO'#ItO!C|QWO,5:XOOQ!LS'#DQ'#DQOOQ!LS1G0d1G0dO!DRQWO1G0dO!FdQ!LdO1G0eO!FkQ!LdO1G0eO!IOQ!LdO1G0eO!IVQ!LdO1G0eO!K^Q!LdO1G0eO!KqQ!LdO1G0eO!NbQ!LdO1G0eO!NiQ!LdO1G0eO#!|Q!LdO1G0eO##TQ!LdO1G0eO#$xQ!LdO1G0eO#'rQ7^O'#CgO#)mQ7^O1G0uO#+hQ7^O'#InOOQ!LS1G0{1G0{O#+{Q!LdO,5>aOOQ!LQ-E;s-E;sO#,lQ!LdO1G0eOOQ!LS1G0e1G0eO#.nQ!LdO1G0xO#/_QpO,5;kO#/dQpO,5;lO#/iQpO'#FSO#/}QWO'#FROOQO'#JP'#JPOOQO'#Hs'#HsO#0SQpO1G1TOOQ!LS1G1T1G1TOOQO1G1^1G1^O#0bQ7^O'#ImO#0lQWO,5;uOKjQYO,5;uOOOO-E;r-E;rOOQ!LS1G1Q1G1QOOQ!LS,5;w,5;wO#0qQpO,5;wOOQ!LS,59`,59`OHiQWO'#IjOOOS'#Hi'#HiO#0vOSO,59dOOQ!LS,59d,59dO)uQYO1G1dOKeQ&jO'#HwO#1RQWO,5<]OOQ!LS,5<Y,5<YOOQO'#F}'#F}OIxQWO,5<hOOQO'#GP'#GPOIxQWO,5<jOIxQWO,5<lOOQO1G1f1G1fO#1^Q`O'#CoO#1qQ`O,5<UO#1xQWO'#JSO5eQWO'#JSO#2WQWO,5<WOIxQWO,5<VO#2]Q`O'#FiO#2jQ`O'#JTO#2tQWO'#JTOHiQWO'#JTO#2yQWO,5<ZOOQ!LQ'#Dc'#DcO#3OQWO'#FlO#3ZQpO'#FtO!&VQ&jO'#FtO!&VQ&jO'#FvO#3lQWO'#FwO!(OQWO'#FzOOQO'#Hy'#HyO#3qQ&jO,5<_OOQ!LS,5<_,5<_O#3xQ&jO'#FtO#4WQ&jO'#FuO#4`Q&jO'#FuOOQ!LS,5<m,5<mOIxQWO,5?ROIxQWO,5?RO#4eQWO'#HzO#4pQWO,5?QOOQ!LS'#Cg'#CgO#5dQ#tO,59gOOQ!LS,59g,59gO#6VQ#tO,5;|O#6xQ#tO,5<OO#7SQWO,5<QOOQ!LS,5<R,5<RO#7XQWO,5<XO#7^Q#tO,5<^OFlQYO1G1eO#7nQWO1G1eOOQQ1G3l1G3lOOQ!LS1G/l1G/lOMgQWO1G/lOOQQ1G2Y1G2YOHiQWO1G2YO)uQYO1G2YOHiQWO1G2YO#7sQWO1G2YO#8RQWO,59[O#9[QWO'#EQOOQ!LQ,5>},5>}O#9fQ!LYO,5>}OOQQ1G.r1G.rO9{QWO1G.rO!,QQpO1G.rO!,YQ#tO1G.rO#9tQWO1G0ZO#9yQWO'#CgO#:UQWO'#J[O#:^QWO,5=[O#:cQWO'#J[O#:hQWO'#ISO#:vQWO,5?uO#;OQbO1G0}OOQ!LS1G1P1G1PO5eQWO1G2uO#;VQWO1G2uO#;[QWO1G2uO#;aQWO1G2uOOQQ1G2u1G2uO#;fQ#tO1G2YO6tQWO'#IyO6tQWO'#EYO6tQWO'#H|O#;wQ!LYO,5?rOOQQ1G2^1G2^O!.yQWO1G2dOHiQWO1G2aO#<SQWO1G2aOOQQ1G2b1G2bOHiQWO1G2bO#<XQWO1G2bO#<aQ&jO'#G`OOQQ1G2d1G2dO!&VQ&jO'#IOO!/OQ`O1G2gOOQQ1G2g1G2gOOQQ,5=Q,5=QO#<iQ#tO,5=SO5eQWO,5=SO#3lQWO,5=VO5RQWO,5=VO!,QQpO,5=VO!,YQ#tO,5=VO5jQ#tO,5=VO#<zQWO'#JYO#=VQWO,5=WOOQQ1G.i1G.iO#=[Q!LYO1G.iO#=gQWO1G.iO!'oQWO1G.iO5]Q!LYO1G.iO#=lQbO,5?wO#=vQWO,5?wO#>RQYO,5=_O#>YQWO,5=_O6tQWO,5?wOOQQ1G2w1G2wO`QYO1G2wOOQQ1G2}1G2}OOQQ1G3P1G3PO9vQWO1G3RO#>_QYO1G3TO#BVQYO'#HSOOQQ1G3W1G3WO9{QWO1G3^O#BdQWO1G3^O5]Q!LYO1G3bOOQQ1G3d1G3dOOQ!LQ'#Fp'#FpO5]Q!LYO1G3fO5]Q!LYO1G3hOOOS1G4u1G4uO#BlQ`O,5;{O#BtQbO1G3qO#COQWO1G4vO#CWQWO1G5PO#C`QWO,5?^OKjQYO,5:tO6tQWO,5:tO9{QWO,59yOKjQYO,59yO!,QQpO,59yO#CeQ7^O,59yOOQO,5:t,5:tO#CoQ&jO'#HlO#DVQWO,5?]OOQ!LS1G/d1G/dO#D_Q&jO'#HqO#DsQWO,5?gOOQ!LQ1G0_1G0_O!9kQ&jO,59yO#D{QbO1G5QOOQO,5>[,5>[O6tQWO,5>[OOQO-E;n-E;nO#EVQ!LrO'#D}O!&VQ&jO'#DyOOQO'#Ho'#HoO#EqQ&jO,5:dOOQ!LS,5:d,5:dO#ExQ&jO'#DyO#FWQ&jO'#D}O#FlQ&jO'#D}O!&VQ&jO'#D}O#FvQWO1G/{O#F{Q`O1G/{OOQ!LS1G/{1G/{O)uQYO1G/{OHiQWO1G/{OOQ!LS1G0Y1G0YO9{QWO1G0YO!,QQpO1G0YO!,YQ#tO1G0YO#GSQ!LdO1G4}O)uQYO1G4}O#GdQ!LYO1G4}O#GuQWO1G4|O6tQWO,5>^OOQO,5>^,5>^O#G}QWO,5>^OOQO-E;p-E;pO#GuQWO1G4|O#H]Q!LdO,59gO#J[Q!LdO,5;|O#L^Q!LdO,5<OO#N`Q!LdO,5<^OOQ!LS7+%u7+%uO$!hQ!LdO7+%uO$#XQWO'#HmO$#cQWO,5?_OOQ!LS1G/n1G/nO$#kQYO'#HnO$#xQWO,5?`O$$QQbO,5?`OOQ!LS1G/s1G/sOOQ!LS7+&O7+&OO$$[Q7^O,5:YO)uQYO7+&aO$$fQ7^O,5:QOOQO1G1V1G1VOOQO1G1W1G1WO$$sQMhO,5;nOKjQYO,5;mOOQO-E;q-E;qOOQ!LS7+&o7+&oOOQO7+&x7+&xOOOO1G1a1G1aO$%OQWO1G1aOOQ!LS1G1c1G1cO$%TQ`O,5?UOOOS-E;g-E;gOOQ!LS1G/O1G/OO$%[Q!LdO7+'OOOQ!LS,5>c,5>cO$%{QWO,5>cOOQ!LS1G1w1G1wP$&QQWO'#HwPOQ!LS-E;u-E;uO$&qQ#tO1G2SO$'dQ#tO1G2UO$'nQ#tO1G2WOOQ!LS1G1p1G1pO$'uQWO'#HvO$(TQWO,5?nO$(TQWO,5?nO$(]QWO,5?nO$(hQWO,5?nOOQO1G1r1G1rO$(vQ#tO1G1qO$)WQWO'#HxO$)hQWO,5?oOHiQWO,5?oO$)pQ`O,5?oOOQ!LS1G1u1G1uO5]Q!LYO,5<`O5]Q!LYO,5<aO$)zQWO,5<aO#3gQWO,5<aO!,QQpO,5<`O$*PQWO,5<bO5]Q!LYO,5<cO$)zQWO,5<fOOQO-E;w-E;wOOQ!LS1G1y1G1yO!&VQ&jO,5<`O$*XQWO,5<aO!&VQ&jO,5<bO!&VQ&jO,5<aO$*dQ#tO1G4mO$*nQ#tO1G4mOOQO,5>f,5>fOOQO-E;x-E;xOKeQ&jO,59iO)uQYO,59iO$*{QWO1G1lOIxQWO1G1sO$+QQ!LdO7+'POOQ!LS7+'P7+'POFlQYO7+'POOQ!LS7+%W7+%WO$+qQ`O'#JUO#FvQWO7+'tO$+{QWO7+'tO$,TQ`O7+'tOOQQ7+'t7+'tOHiQWO7+'tO)uQYO7+'tOHiQWO7+'tOOQO1G.v1G.vO$,_Q!LbO'#CgO$,oQ!LbO,5<dO$-^QWO,5<dOOQ!LQ1G4i1G4iOOQQ7+$^7+$^O9{QWO7+$^O!,QQpO7+$^OFlQYO7+%uO$-cQWO'#IRO$-nQWO,5?vOOQO1G2v1G2vO5eQWO,5?vOOQO,5>n,5>nOOQO-E<Q-E<QOOQ!LS7+&i7+&iO$-vQWO7+(aO5]Q!LYO7+(aO5eQWO7+(aO$-{QWO7+(aO$.QQWO7+'tOOQ!LQ,5>h,5>hOOQ!LQ-E;z-E;zOOQQ7+(O7+(OO$.`Q!LbO7+'{OHiQWO7+'{O$.jQ`O7+'|OOQQ7+'|7+'|OHiQWO7+'|O$.qQWO'#JXO$.|QWO,5<zOOQO,5>j,5>jOOQO-E;|-E;|OOQQ7+(R7+(RO$/sQ&jO'#GiOOQQ1G2n1G2nOHiQWO1G2nO)uQYO1G2nOHiQWO1G2nO$/zQWO1G2nO$0YQ#tO1G2nO5]Q!LYO1G2qO#3lQWO1G2qO5RQWO1G2qO!,QQpO1G2qO!,YQ#tO1G2qO$0kQWO'#IQO$0vQWO,5?tO$1OQ&jO,5?tOOQ!LQ1G2r1G2rOOQQ7+$T7+$TO$1TQWO7+$TO5]Q!LYO7+$TO$1YQWO7+$TO)uQYO1G5cO)uQYO1G5dO$1_QYO1G2yO$1fQWO1G2yO$1kQYO1G2yO$1rQ!LYO1G5cOOQQ7+(c7+(cO5]Q!LYO7+(mO`QYO7+(oOOQQ'#J_'#J_OOQQ'#IT'#ITO$1|QYO,5=nOOQQ,5=n,5=nO)uQYO'#HTO$2ZQWO'#HVOOQQ7+(x7+(xO$2`QYO7+(xO6tQWO7+(xOOQQ7+(|7+(|OOQQ7+)Q7+)QOOQQ7+)S7+)SOOQO1G4x1G4xO$6ZQ7^O1G0`O$6eQWO1G0`OOQO1G/e1G/eO$6pQ7^O1G/eO9{QWO1G/eOKjQYO'#D_OOQO,5>W,5>WOOQO-E;j-E;jOOQO,5>],5>]OOQO-E;o-E;oO!,QQpO1G/eOOQO1G3v1G3vO9{QWO,5:eOOQO,5:i,5:iO)uQYO,5:iO$6zQ!LYO,5:iO$7VQ!LYO,5:iO!,QQpO,5:eOOQO-E;m-E;mOOQ!LS1G0O1G0OO!&VQ&jO,5:eO$7eQ!LrO,5:iO$8PQ&jO,5:eO!&VQ&jO,5:iO$8_Q&jO,5:iO$8sQ!LYO,5:iOOQ!LS7+%g7+%gO#FvQWO7+%gO#F{Q`O7+%gOOQ!LS7+%t7+%tO9{QWO7+%tO!,QQpO7+%tO$9XQ!LdO7+*iO)uQYO7+*iOOQO1G3x1G3xO6tQWO1G3xO$9iQWO7+*hO$9qQ!LdO1G2SO$;sQ!LdO1G2UO$=uQ!LdO1G1qO$?}Q#tO,5>XOOQO-E;k-E;kO$@XQbO,5>YO)uQYO,5>YOOQO-E;l-E;lO$@cQWO1G4zO$@kQ7^O1G0ZO$BrQ7^O1G0eO$ByQ7^O1G0eO$DzQ7^O1G0eO$ERQ7^O1G0eO$FvQ7^O1G0eO$GZQ7^O1G0eO$IhQ7^O1G0eO$IoQ7^O1G0eO$KpQ7^O1G0eO$KwQ7^O1G0eO$MlQ7^O1G0eO$NPQ!LdO<<I{O$NpQ7^O1G0eO%!`Q7^O'#IhO%$]Q7^O1G0xOKjQYO'#FUOOQO'#JQ'#JQOOQO1G1Y1G1YO%$jQWO1G1XO%$oQ7^O,5>aOOOO7+&{7+&{OOOS1G4p1G4pOOQ!LS1G3}1G3}OIxQWO7+'rO%$yQWO,5>bO5eQWO,5>bOOQO-E;t-E;tO%%XQWO1G5YO%%XQWO1G5YO%%aQWO1G5YO%%lQ`O,5>dO%%vQWO,5>dOHiQWO,5>dOOQO-E;v-E;vO%%{Q`O1G5ZO%&VQWO1G5ZOOQO1G1z1G1zOOQO1G1{1G1{O5]Q!LYO1G1{O$)zQWO1G1{O5]Q!LYO1G1zO%&_QWO1G1|OHiQWO1G1|OOQO1G1}1G1}O5]Q!LYO1G2QO!,QQpO1G1zO#3gQWO1G1{O%&dQWO1G1|O%&lQWO1G1{OIxQWO7+*XOOQ!LS1G/T1G/TO%&wQWO1G/TOOQ!LS7+'W7+'WO%&|Q#tO7+'_O%'^Q!LdO<<JkOOQ!LS<<Jk<<JkOHiQWO'#H{O%'}QWO,5?pOOQQ<<K`<<K`OHiQWO<<K`O#FvQWO<<K`O%(VQWO<<K`O%(_Q`O<<K`OHiQWO1G2OOOQQ<<Gx<<GxO9{QWO<<GxO%(iQ!LdO<<IaOOQ!LS<<Ia<<IaOOQO,5>m,5>mO%)YQWO,5>mOOQO-E<P-E<PO%)_QWO1G5bO%)gQWO<<K{OOQQ<<K{<<K{O%)lQWO<<K{O5]Q!LYO<<K{O)uQYO<<K`OHiQWO<<K`OOQQ<<Kg<<KgO$.`Q!LbO<<KgOOQQ<<Kh<<KhO$.jQ`O<<KhO%)qQ&jO'#H}O%)|QWO,5?sOKjQYO,5?sOOQQ1G2f1G2fO#EVQ!LrO'#D}O!&VQ&jO'#GjOOQO'#IP'#IPO%*UQ&jO,5=TOOQQ,5=T,5=TO#4WQ&jO'#D}O%*]Q&jO'#D}O%*qQ&jO'#D}O%*{Q&jO'#GjO%+ZQWO7+(YO%+`QWO7+(YO%+hQ`O7+(YOOQQ7+(Y7+(YOHiQWO7+(YO)uQYO7+(YOHiQWO7+(YO%+rQWO7+(YOOQQ7+(]7+(]O5]Q!LYO7+(]O#3lQWO7+(]O5RQWO7+(]O!,QQpO7+(]O%,QQWO,5>lOOQO-E<O-E<OOOQO'#Gm'#GmO%,]QWO1G5`O5]Q!LYO<<GoOOQQ<<Go<<GoO%,eQWO<<GoO%,jQWO7+*}O%,oQWO7++OOOQQ7+(e7+(eO%,tQWO7+(eO%,yQYO7+(eO%-QQWO7+(eO)uQYO7+*}O)uQYO7++OOOQQ<<LX<<LXOOQQ<<LZ<<LZOOQQ-E<R-E<ROOQQ1G3Y1G3YO%-VQWO,5=oOOQQ,5=q,5=qO9{QWO<<LdO%-[QWO<<LdOKjQYO7+%zOOQO7+%P7+%PO%-aQ7^O1G5QO9{QWO7+%POOQO1G0P1G0PO%-kQ!LdO1G0TOOQO1G0T1G0TO)uQYO1G0TO%-uQ!LYO1G0TO9{QWO1G0PO!,QQpO1G0PO%.QQ!LYO1G0TO!&VQ&jO1G0PO%.`Q!LYO1G0TO%.tQ!LrO1G0TO%/OQ&jO1G0PO!&VQ&jO1G0TOOQ!LS<<IR<<IROOQ!LS<<I`<<I`O9{QWO<<I`O%/^Q!LdO<<NTOOQO7+)d7+)dO%/nQ!LdO7+'_O%1vQbO1G3tO%2QQ7^O7+%uO%2_Q7^O,59gO%4[Q7^O,5;|O%6XQ7^O,5<OO%8UQ7^O,5<^O%9tQ7^O7+'OO%:RQ7^O7+'PO%:`QWO,5;pOOQO7+&s7+&sO%:eQ#tO<<K^OOQO1G3|1G3|O%:uQWO1G3|O%;QQWO1G3|O%;`QWO7+*tO%;`QWO7+*tOHiQWO1G4OO%;hQ`O1G4OO%;rQWO7+*uOOQO7+'g7+'gO5]Q!LYO7+'gOOQO7+'f7+'fO$)zQWO7+'hO%;zQ`O7+'hOOQO7+'l7+'lO5]Q!LYO7+'fO$)zQWO7+'gO%<RQWO7+'hOHiQWO7+'hO#3gQWO7+'gO%<WQ#tO<<MsOOQ!LS7+$o7+$oO%<bQ`O,5>gOOQO-E;y-E;yO#FvQWOAN@zOOQQAN@zAN@zOHiQWOAN@zO%<lQ!LbO7+'jOOQQAN=dAN=dO5eQWO1G4XO%<yQWO7+*|O5]Q!LYOANAgO%=RQWOANAgOOQQANAgANAgO%=WQWOAN@zO%=`Q`OAN@zOOQQANARANAROOQQANASANASO%=jQWO,5>iOOQO-E;{-E;{O%=uQ7^O1G5_O#3lQWO,5=UO5RQWO,5=UO!,QQpO,5=UOOQO-E;}-E;}OOQQ1G2o1G2oO$7eQ!LrO,5:iO!&VQ&jO,5=UO%>PQ&jO,5=UO%>_Q&jO,5:iOOQQ<<Kt<<KtOHiQWO<<KtO%+ZQWO<<KtO%>sQWO<<KtO%>{Q`O<<KtO)uQYO<<KtOHiQWO<<KtOOQQ<<Kw<<KwO5]Q!LYO<<KwO#3lQWO<<KwO5RQWO<<KwO%?VQ&jO1G4WO%?[QWO7+*zOOQQAN=ZAN=ZO5]Q!LYOAN=ZOOQQ<<Ni<<NiOOQQ<<Nj<<NjOOQQ<<LP<<LPO%?dQWO<<LPO%?iQYO<<LPO%?pQWO<<NiO%?uQWO<<NjOOQQ1G3Z1G3ZOOQQANBOANBOO9{QWOANBOO%?zQ7^O<<IfOOQO<<Hk<<HkOOQO7+%o7+%oO%-kQ!LdO7+%oO)uQYO7+%oOOQO7+%k7+%kO9{QWO7+%kO%@UQ!LYO7+%oO!,QQpO7+%kO%@aQ!LYO7+%oO!&VQ&jO7+%kO%@oQ!LYO7+%oOOQ!LSAN>zAN>zO%ATQ!LdO<<K^O%C]Q7^O<<I{O%CjQ7^O1G1qO%EYQ7^O1G2SO%GVQ7^O1G2UO%ISQ7^O<<JkO%IaQ7^O<<IaOOQO1G1[1G1[OOQO7+)h7+)hO%InQWO7+)hO%IyQWO<<N`O%JRQ`O7+)jOOQO<<KR<<KRO5]Q!LYO<<KSO$)zQWO<<KSOOQO<<KQ<<KQO5]Q!LYO<<KRO%J]Q`O<<KSO$)zQWO<<KROOQQG26fG26fO#FvQWOG26fOOQO7+)s7+)sOOQQG27RG27RO5]Q!LYOG27ROHiQWOG26fOKjQYO1G4TO%JdQWO7+*yO5]Q!LYO1G2pO#3lQWO1G2pO5RQWO1G2pO!,QQpO1G2pO!&VQ&jO1G2pO%.tQ!LrO1G0TO%JlQ&jO1G2pO%+ZQWOANA`OOQQANA`ANA`OHiQWOANA`O%JzQWOANA`O%KSQ`OANA`OOQQANAcANAcO5]Q!LYOANAcO#3lQWOANAcOOQO'#Gn'#GnOOQO7+)r7+)rOOQQG22uG22uOOQQANAkANAkO%K^QWOANAkOOQQANDTANDTOOQQANDUANDUO%KcQYOG27jOOQO<<IZ<<IZO%-kQ!LdO<<IZOOQO<<IV<<IVO)uQYO<<IZO9{QWO<<IVO& ^Q!LYO<<IZO!,QQpO<<IVO& iQ!LYO<<IZO& wQ7^O7+'_OOQO<<MS<<MSOOQOAN@nAN@nO5]Q!LYOAN@nOOQOAN@mAN@mO$)zQWOAN@nO5]Q!LYOAN@mOOQQLD,QLD,QOOQQLD,mLD,mO#FvQWOLD,QO&#gQ7^O7+)oOOQO7+([7+([O5]Q!LYO7+([O#3lQWO7+([O5RQWO7+([O!,QQpO7+([O!&VQ&jO7+([OOQQG26zG26zO%+ZQWOG26zOHiQWOG26zOOQQG26}G26}O5]Q!LYOG26}OOQQG27VG27VO9{QWOLD-UOOQOAN>uAN>uO%-kQ!LdOAN>uOOQOAN>qAN>qO)uQYOAN>uO9{QWOAN>qO&#qQ!LYOAN>uO&#|Q7^O<<K^OOQOG26YG26YO5]Q!LYOG26YOOQOG26XG26XOOQQ!$( l!$( lOOQO<<Kv<<KvO5]Q!LYO<<KvO#3lQWO<<KvO5RQWO<<KvO!,QQpO<<KvOOQQLD,fLD,fO%+ZQWOLD,fOOQQLD,iLD,iOOQQ!$(!p!$(!pOOQOG24aG24aO%-kQ!LdOG24aOOQOG24]G24]O)uQYOG24aOOQOLD+tLD+tOOQOANAbANAbO5]Q!LYOANAbO#3lQWOANAbO5RQWOANAbOOQQ!$(!Q!$(!QOOQOLD){LD){O%-kQ!LdOLD){OOQOG26|G26|O5]Q!LYOG26|O#3lQWOG26|OOQO!$'Mg!$'MgOOQOLD,hLD,hO5]Q!LYOLD,hOOQO!$(!S!$(!SOKjQYO'#DnO&%lQbO'#ImOKjQYO'#DfO&%sQ!LdO'#CgO&&^QbO'#CgO&&nQYO,5:oOKjQYO,5:yOKjQYO,5:yOKjQYO,5:yOKjQYO,5:yOKjQYO,5:yOKjQYO,5:yOKjQYO,5:yOKjQYO,5:yOKjQYO,5:yOKjQYO,5:yOKjQYO,5:yOKjQYO'#HuO&(kQWO,5;{O&)}QWO,5:yOKjQYO,5;^O!'oQWO'#C{O!'oQWO'#C{OHiQWO'#FbO&(sQWO'#FbOHiQWO'#FdO&(sQWO'#FdOHiQWO'#FrO&(sQWO'#FrOKjQYO,5?fO&&nQYO1G0ZO&*UQ7^O'#CgOKjQYO1G1dOHiQWO,5<hO&(sQWO,5<hOHiQWO,5<jO&(sQWO,5<jOHiQWO,5<VO&(sQWO,5<VO&&nQYO1G1eOKjQYO7+&aOHiQWO1G1sO&(sQWO1G1sO&&nQYO7+'PO&&nQYO7+%uOHiQWO7+'rO&(sQWO7+'rO&*`QWO'#ETO&*eQWO'#ETO&*mQWO'#ErO&*rQWO'#IzO&*}QWO'#IxO&+YQWO,5:oO&+_Q#tO,5;xO&+fQWO'#FkO&+kQWO'#FkO&+pQWO,5;yO&+xQWO,5:oO&,QQ7^O1G0uO&,XQWO,5<XO&,^QWO,5<XO&,cQWO1G1eO&,hQWO1G0ZO&,mQ#tO1G2WO&,tQ#tO1G2WO3tQWO'#F`O5RQWO'#F_OB`QWO'#ESOKjQYO,5;ZO!(OQWO'#FmO!(OQWO'#FmOIxQWO,5<lOIxQWO,5<l",
  stateData: "&-p~O'POS'QOSSOSTOS~OPTOQTOWwO]bO^gOamOblOgbOiTOjbOkbOnTOpTOuROwbOxbOybO!PSO!ZjO!`UO!cTO!dTO!eTO!fTO!gTO!jkO#[qO#lnO#p]O$woO$yrO${pO$|pO%PsO%RtO%UuO%VuO%XvO%fxO%lyO%nzO%p{O%r|O%u}O%{!OO&P!PO&R!QO&T!RO&V!SO&X!TO'SPO']QO'u`O~OPZXYZX^ZXiZXrZXsZXuZX}ZX!]ZX!^ZX!`ZX!fZX!uZX#PcX#SZX#TZX#UZX#VZX#WZX#XZX#YZX#ZZX#]ZX#_ZX#aZX#bZX#gZX&}ZX']ZX'iZX'pZX'qZX~O!X$dX~P$wO&z!VO&{!UO&|!XO~OPTOQTO]bOa!hOb!gOgbOiTOjbOkbOnTOpTOuROwbOxbOybO!P!`O!ZjO!`UO!cTO!dTO!eTO!fTO!gTO!j!fO#l!iO#p]O'S!YO']QO'u`O~O|!^O}!ZOz'dPz'mP~P'aO!O!jO~P`OPTOQTO]bOa!hOb!gOgbOiTOjbOkbOnTOpTOuROwbOxbOybO!P!`O!ZjO!`UO!cTO!dTO!eTO!fTO!gTO!j!fO#l!iO#p]O'S8lO']QO'u`O~OPTOQTO]bOa!hOb!gOgbOiTOjbOkbOnTOpTOuROwbOxbOybO!P!`O!ZjO!`UO!cTO!dTO!eTO!fTO!gTO!j!fO#l!iO#p]O']QO'u`O~O|!oO!}!rO#O!oO'S8mO!_'jP~P+rO#P!sO~O!X!tO#P!sO~OP#ZOY#aOi#OOr!xOs!xOu!yO}#_O!]#QO!^!vO!`!wO!f#ZO#S!|O#T!}O#U!}O#V!}O#W#PO#X#QO#Y#QO#Z#QO#]#RO#_#TO#a#VO#b#WO']QO'i#XO'p!zO'q!{O~O^'aX&}'aX!_'aXz'aX!P'aX$x'aX!X'aX~P.^O!u#bO#g#bOP'bXY'bX^'bXi'bXr'bXs'bXu'bX}'bX!]'bX!^'bX!`'bX!f'bX#S'bX#T'bX#U'bX#V'bX#W'bX#X'bX#Z'bX#]'bX#_'bX#a'bX#b'bX']'bX'i'bX'p'bX'q'bX~O#Y'bX&}'bXz'bX!_'bX'_'bX!P'bX$x'bX!X'bX~P0nO!u#bO~O#r#cO#y#gO~O!P#hO#p]O#|#iO$O#kO~O]#nOg#{Oi#oOj#nOk#nOn#|Op#}Ou#uO!P#vO!Z$SO!`#sO#O$TO#l$QO$V$OO$X$PO$[$RO'S#mO']#pO'W'YP~O!`$UO~O!X$WO~O^$XO&}$XO~O'S$]O~O!`$UO'S$]O'T$_O'X$`O~Ob$fO!`$UO'S$]O~O]$oOr$kO!P$hO!`$jO$y$nO'S$]O'T$_O['}P~O!j$pO~Ou$qO!P$rO'S$]O~Ou$qO!P$rO%R$vO'S$]O~O'S$wO~O#[qO$yrO${pO$|pO%PsO%RtO%UuO%VuO~Oa%QOb%PO!j$}O$w%OO%Z$|O~P7dOa%TOblO!P%SO!jkO#[qO$woO${pO$|pO%PsO%RtO%UuO%VuO%XvO~O_%WO!u%ZO$y%UO'T$_O~P8cO!`%[O!c%`O~O!`%aO~O!PSO~O^$XO&y%iO&}$XO~O^$XO&y%lO&}$XO~O^$XO&y%nO&}$XO~O&z!VO&{!UO&|%rO~OPZXYZXiZXrZXsZXuZX}ZX}cX!]ZX!^ZX!`ZX!fZX!uZX!ucX#PcX#SZX#TZX#UZX#VZX#WZX#XZX#YZX#ZZX#]ZX#_ZX#aZX#bZX#gZX']ZX'iZX'pZX'qZX~OzZXzcX~P;OO|%tOz&_X}&_X~P)uO}!ZOz'dX~OP#ZOY#aOi#OOr!xOs!xOu!yO}!ZO!]#QO!^!vO!`!wO!f#ZO#S!|O#T!}O#U!}O#V!}O#W#PO#X#QO#Y#QO#Z#QO#]#RO#_#TO#a#VO#b#WO']QO'i#XO'p!zO'q!{O~Oz'dX~P=uOz%yO~Ou%|O!S&WO!T&PO!U&PO'T$_O~O]%}Oj%}O|&QO'`%zO!O'eP!O'oP~P?xOz'lX}'lX!X'lX!_'lX'i'lX~O!u'lX#P!xX!O'lX~P@qO!u&XOz'nX}'nX~O}&YOz'mX~Oz&[O~O!u#bO~P@qOR&`O!P&]O!k&_O'S$]O~Ob&eO!`$UO'S$]O~Or$kO!`$jO~O!O&fO~P`Or!xOs!xOu!yO!^!vO!`!wO']QOP!baY!bai!ba}!ba!]!ba!f!ba#S!ba#T!ba#U!ba#V!ba#W!ba#X!ba#Y!ba#Z!ba#]!ba#_!ba#a!ba#b!ba'i!ba'p!ba'q!ba~O^!ba&}!baz!ba!_!ba'_!ba!P!ba$x!ba!X!ba~PBzO!_&gO~O!X!tO!u&iO'i&hO}'kX^'kX&}'kX~O!_'kX~PEdO}&mO!_'jX~O!_&oO~Ou$qO!P$rO#O&pO'S$]O~OPTOQTO]bOa!hOb!gOgbOiTOjbOkbOnTOpTOuROwbOxbOybO!PSO!ZjO!`UO!cTO!dTO!eTO!fTO!gTO!j!fO#l!iO#p]O'S8lO']QO'u`O~O]#nOg#{Oi#oOj#nOk#nOn#|Op9OOu#uO!P#vO!Z:QO!`#sO#O9UO#l$QO$V9QO$X9SO$[$RO'S&tO']#pO~O#P&vO~O]#nOg#{Oi#oOj#nOk#nOn#|Op#}Ou#uO!P#vO!Z$SO!`#sO#O$TO#l$QO$V$OO$X$PO$[$RO'S&tO']#pO~O'W'gP~PIxO|&zO!_'hP~P)uO'`&|O~OP8iOQ8iO]bOa:OOb!gOgbOi8iOjbOkbOn8iOp8iOuROwbOxbOybO!P!`O!Z8kO!`UO!c8iO!d8iO!e8iO!f8iO!g8iO!j!fO#l!iO#p]O'S'[O']QO'u9|O~O!`!wO~O}#_O^$Ta&}$Ta!_$Taz$Ta!P$Ta$x$Ta!X$Ta~O#['cO~PHiO!X'eO!P'rX#o'rX#r'rX#y'rX~Or'fO~PN_Or'fO!P'rX#o'rX#r'rX#y'rX~O!P'hO#o'lO#r'gO#y'mO~O|'pO~PKjO#r#cO#y'sO~Or$]Xu$]X!^$]X'i$]X'p$]X'q$]X~OReX}eX!ueX'WeX'W$]X~P! wOj'uO~O&z'wO&{'vO&|'yO~Or'{Ou'|O'i#XO'p(OO'q(QO~O'W'zO~P!#QO'W(TO~O]#nOg#{Oi#oOj#nOk#nOn#|Op9OOu#uO!P#vO!Z:QO!`#sO#O9UO#l$QO$V9QO$X9SO$[$RO']#pO~O|(XO'S(UO!_'vP~P!#oO#P(ZO~O|(_O'S([Oz'wP~P!#oO^(hOi(mOu(eO!S(kO!T(dO!U(dO!`(bO!r(lO$o(gO'T$_O'`(aO~O!O(jO~P!%gO!^!vOr'[Xu'[X'i'[X'p'[X'q'[X}'[X!u'[X~O'W'[X#e'[X~P!&cOR(pO!u(oO}'ZX'W'ZX~O}(qO'W'YX~O'S(sO~O!`(xO~O'S&tO~O!`(bO~Ou$qO|!oO!P$rO!}!rO#O!oO'S$]O!_'jP~O!X!tO#P(|O~OP#ZOY#aOi#OOr!xOs!xOu!yO!]#QO!^!vO!`!wO!f#ZO#S!|O#T!}O#U!}O#V!}O#W#PO#X#QO#Y#QO#Z#QO#]#RO#_#TO#a#VO#b#WO']QO'i#XO'p!zO'q!{O~O^!Ya}!Ya&}!Yaz!Ya!_!Ya'_!Ya!P!Ya$x!Ya!X!Ya~P!(tOR)UO!P&]O!k)TO$x)SO'X$`O~O'S$wO'W'YP~O!X)XO!P'VX^'VX&}'VX~O!`$UO'X$`O~O!`$UO'S$]O'X$`O~O!X!tO#P&vO~O'S)aO!O(OP~O})eO['}X~OY)iO~O[)jO~O!P$hO'S$]O'T$_O['}P~Ou$qO|)oO!P$rO'S$]Oz'mP~O]&TOj&TO|)pO'`&|O!O'oP~O})qO^'zX&}'zX~O!u)uO'X$`O~OR)xO!P#vO'X$`O~O!P)zO~Or)|O!PSO~O!j*RO~Ob*WO~O'S(sO!O'|P~Ob$fO~O$yrO'S$wO~P8cOY*^O[*]O~OPTOQTO]bOamOblOgbOiTOjbOkbOnTOpTOuROwbOxbOybO!ZjO!`UO!cTO!dTO!eTO!fTO!gTO!jkO#p]O$woO']QO'u`O~O!P!`O#l!iO'S8lO~P!0RO[*]O^$XO&}$XO~O^*bO#[*dO${*dO$|*dO~P)uO!`%[O~O%l*iO~O!P*kO~O%|*nO%}*mOP%zaQ%zaW%za]%za^%zaa%zab%zag%zai%zaj%zak%zan%zap%zau%zaw%zax%zay%za!P%za!Z%za!`%za!c%za!d%za!e%za!f%za!g%za!j%za#[%za#l%za#p%za$w%za$y%za${%za$|%za%P%za%R%za%U%za%V%za%X%za%f%za%l%za%n%za%p%za%r%za%u%za%{%za&P%za&R%za&T%za&V%za&X%za&x%za'S%za']%za'u%za!O%za%s%za_%za%x%za~O'S*qO~O'_*tO~Oz&_a}&_a~P!(tO}!ZOz'da~Oz'da~P=uO}&YOz'ma~O}tX}!VX!OtX!O!VX!XtX!X!VX!`!VX!utX'X!VX~O!X*{O!u*zO}!|X}'fX!O!|X!O'fX!X'fX!`'fX'X'fX~O!X*}O!`$UO'X$`O}!RX!O!RX~O]%{Oj%{Ou%|O'`(aO~OP8iOQ8iO]bOa:OOb!gOgbOi8iOjbOkbOn8iOp8iOuROwbOxbOybO!P!`O!Z8kO!`UO!c8iO!d8iO!e8iO!f8iO!g8iO!j!fO#l!iO#p]O']QO'u9|O~O'S9YO~P!9yO}+RO!O'eX~O!O+TO~O!X*{O!u*zO}!|X!O!|X~O}+UO!O'oX~O!O+WO~O]%{Oj%{Ou%|O'T$_O'`(aO~O!T+XO!U+XO~P!<tOu$qO|+[O!P$rO'S$]Oz&dX}&dX~O^+`O!S+cO!T+_O!U+_O!n+eO!o+dO!p+dO!r+fO'T$_O'`(aO~O!O+bO~P!=uOR+kO!P&]O!k+jO~O!u+qO}'ka!_'ka^'ka&}'ka~O!X!tO~P!>yO}&mO!_'ja~Ou$qO|+tO!P$rO!}+vO#O+tO'S$]O}&fX!_&fX~O^!wi}!wi&}!wiz!wi!_!wi'_!wi!P!wi$x!wi!X!wi~P!(tO#P!ta}!ta!_!ta!u!ta!P!ta^!ta&}!taz!ta~P!#QO#P'[XP'[XY'[X^'[Xi'[Xs'[X!]'[X!`'[X!f'[X#S'[X#T'[X#U'[X#V'[X#W'[X#X'[X#Y'[X#Z'[X#]'[X#_'[X#a'[X#b'[X&}'[X']'[X!_'[Xz'[X!P'[X'_'[X$x'[X!X'[X~P!&cO},PO'W'gX~P!#QO'W,RO~O},SO!_'hX~P!(tO!_,VO~Oz,WO~OP#ZOr!xOs!xOu!yO!^!vO!`!wO!f#ZO']QOY#Ri^#Rii#Ri}#Ri!]#Ri#T#Ri#U#Ri#V#Ri#W#Ri#X#Ri#Y#Ri#Z#Ri#]#Ri#_#Ri#a#Ri#b#Ri&}#Ri'i#Ri'p#Ri'q#Riz#Ri!_#Ri'_#Ri!P#Ri$x#Ri!X#Ri~O#S#Ri~P!DWO#S!|O~P!DWOP#ZOr!xOs!xOu!yO!^!vO!`!wO!f#ZO#S!|O#T!}O#U!}O#V!}O']QOY#Ri^#Ri}#Ri!]#Ri#W#Ri#X#Ri#Y#Ri#Z#Ri#]#Ri#_#Ri#a#Ri#b#Ri&}#Ri'i#Ri'p#Ri'q#Riz#Ri!_#Ri'_#Ri!P#Ri$x#Ri!X#Ri~Oi#Ri~P!FrOi#OO~P!FrOP#ZOi#OOr!xOs!xOu!yO!^!vO!`!wO!f#ZO#S!|O#T!}O#U!}O#V!}O#W#PO']QO^#Ri}#Ri#]#Ri#_#Ri#a#Ri#b#Ri&}#Ri'i#Ri'p#Ri'q#Riz#Ri!_#Ri'_#Ri!P#Ri$x#Ri!X#Ri~OY#Ri!]#Ri#X#Ri#Y#Ri#Z#Ri~P!I^OY#aO!]#QO#X#QO#Y#QO#Z#QO~P!I^OP#ZOY#aOi#OOr!xOs!xOu!yO!]#QO!^!vO!`!wO!f#ZO#S!|O#T!}O#U!}O#V!}O#W#PO#X#QO#Y#QO#Z#QO#]#RO']QO^#Ri}#Ri#_#Ri#a#Ri#b#Ri&}#Ri'i#Ri'q#Riz#Ri!_#Ri'_#Ri!P#Ri$x#Ri!X#Ri~O'p#Ri~P!LUO'p!zO~P!LUOP#ZOY#aOi#OOr!xOs!xOu!yO!]#QO!^!vO!`!wO!f#ZO#S!|O#T!}O#U!}O#V!}O#W#PO#X#QO#Y#QO#Z#QO#]#RO#_#TO']QO'p!zO^#Ri}#Ri#a#Ri#b#Ri&}#Ri'i#Riz#Ri!_#Ri'_#Ri!P#Ri$x#Ri!X#Ri~O'q#Ri~P!NpO'q!{O~P!NpOP#ZOY#aOi#OOr!xOs!xOu!yO!]#QO!^!vO!`!wO!f#ZO#S!|O#T!}O#U!}O#V!}O#W#PO#X#QO#Y#QO#Z#QO#]#RO#_#TO#a#VO']QO'p!zO'q!{O~O^#Ri}#Ri#b#Ri&}#Ri'i#Riz#Ri!_#Ri'_#Ri!P#Ri$x#Ri!X#Ri~P##[OPZXYZXiZXrZXsZXuZX!]ZX!^ZX!`ZX!fZX!uZX#PcX#SZX#TZX#UZX#VZX#WZX#XZX#YZX#ZZX#]ZX#_ZX#aZX#bZX#gZX']ZX'iZX'pZX'qZX}ZX!OZX~O#eZX~P#%oOP#ZOY8|Oi8qOr!xOs!xOu!yO!]8sO!^!vO!`!wO!f#ZO#S8oO#T8pO#U8pO#V8pO#W8rO#X8sO#Y8sO#Z8sO#]8tO#_8vO#a8xO#b8yO']QO'i#XO'p!zO'q!{O~O#e,YO~P#'yOP'bXY'bXi'bXr'bXs'bXu'bX!]'bX!^'bX!`'bX!f'bX#S'bX#T'bX#U'bX#V'bX#W'bX#X'bX#Z'bX#]'bX#_'bX#a'bX#b'bX']'bX'i'bX'p'bX'q'bX}'bX~O!u8}O#g8}O#Y'bX#e'bX!O'bX~P#)tO^&ia}&ia&}&ia!_&ia'_&iaz&ia!P&ia$x&ia!X&ia~P!(tOP#RiY#Ri^#Rii#Ris#Ri}#Ri!]#Ri!^#Ri!`#Ri!f#Ri#S#Ri#T#Ri#U#Ri#V#Ri#W#Ri#X#Ri#Y#Ri#Z#Ri#]#Ri#_#Ri#a#Ri#b#Ri&}#Ri']#Riz#Ri!_#Ri'_#Ri!P#Ri$x#Ri!X#Ri~P!#QO^#fi}#fi&}#fiz#fi!_#fi'_#fi!P#fi$x#fi!X#fi~P!(tO#r,[O~O#r,]O~O!X'eO!u,^O!P#vX#o#vX#r#vX#y#vX~O|,_O~O!P'hO#o,aO#r'gO#y,bO~O}8zO!O'aX~P#'yO!O,cO~O#y,eO~O&z'wO&{'vO&|,hO~O],kOj,kOz,lO~O}cX!XcX!_cX!_$]X'icX~P! wO!_,rO~P!#QO},sO!X!tO'i&hO!_'vX~O!_,xO~Oz$]X}$]X!X$dX~P! wO},zOz'wX~P!#QO!X,|O~Oz-OO~O|(XO'S$]O!_'vP~Oi-SO!X!tO!`$UO'X$`O'i&hO~O!X)XO~O!O-YO~P!%gO!T-ZO!U-ZO'T$_O'`(aO~Ou-]O'`(aO~O!r-^O~O'S$wO}&nX'W&nX~O}(qO'W'Ya~Or-cOs-cOu-dO'ioa'poa'qoa}oa!uoa~O'Woa#eoa~P#4xOr'{Ou'|O'i$Ua'p$Ua'q$Ua}$Ua!u$Ua~O'W$Ua#e$Ua~P#5nOr'{Ou'|O'i$Wa'p$Wa'q$Wa}$Wa!u$Wa~O'W$Wa#e$Wa~P#6aO]-eO~O#P-fO~O'W$fa}$fa#e$fa!u$fa~P!#QO#P-iO~OR-rO!P&]O!k-qO$x-pO~O'W-sO~O]#nOi#oOj#nOk#nOn#|Op9OOu#uO!P#vO!Z:QO!`#sO#O9UO#l$QO$V9QO$X9SO$[$RO']#pO~Og-uO'S-tO~P#8WO!X)XO!P'Va^'Va&}'Va~O#P-{O~OYZX}cX!OcX~O}-|O!O(OX~O!O.OO~OY.PO~O!P$hO'S$]O[&vX}&vX~O})eO['}a~O!_.SO~P!(tO].UO~OY.VO~O[.WO~OR-rO!P&]O!k-qO$x-pO'X$`O~O})qO^'za&}'za~O!u.^O~OR.aO!P#vO~O'`&|O!O'{P~OR.kO!P.gO!k.jO$x.iO'X$`O~OY.uO}.sO!O'|X~O!O.vO~O[.xO^$XO&}$XO~O].yO~O#Y.{O%j.|O~P0nO!u#bO#Y.{O%j.|O~O^.}O~P)uO^/PO~O%s/TOP%qiQ%qiW%qi]%qi^%qia%qib%qig%qii%qij%qik%qin%qip%qiu%qiw%qix%qiy%qi!P%qi!Z%qi!`%qi!c%qi!d%qi!e%qi!f%qi!g%qi!j%qi#[%qi#l%qi#p%qi$w%qi$y%qi${%qi$|%qi%P%qi%R%qi%U%qi%V%qi%X%qi%f%qi%l%qi%n%qi%p%qi%r%qi%u%qi%{%qi&P%qi&R%qi&T%qi&V%qi&X%qi&x%qi'S%qi']%qi'u%qi!O%qi_%qi%x%qi~O_/ZO!O/XO%x/YO~P`O!PSO!`/^O~O}#_O'_$Ta~Oz&_i}&_i~P!(tO}!ZOz'di~O}&YOz'mi~Oz/bO~O}!Ra!O!Ra~P#'yO]%{Oj%{O|/hO'`(aO}&`X!O&`X~P?xO}+RO!O'ea~O]&TOj&TO|)pO'`&|O}&eX!O&eX~O}+UO!O'oa~Oz'ni}'ni~P!(tO^$XO!X!tO!`$UO!f/sO!u/qO&}$XO'X$`O'i&hO~O!O/vO~P!=uO!T/wO!U/wO'T$_O'`(aO~O!S/yO!T/wO!U/wO!r/zO'T$_O'`(aO~O!o/{O!p/{O~P#FWO!P&]O~O!P&]O~P!#QO}'ki!_'ki^'ki&}'ki~P!(tO!u0UO}'ki!_'ki^'ki&}'ki~O}&mO!_'ji~Ou$qO!P$rO#O0WO'S$]O~O#PoaPoaYoa^oaioa!]oa!^oa!`oa!foa#Soa#Toa#Uoa#Voa#Woa#Xoa#Yoa#Zoa#]oa#_oa#aoa#boa&}oa']oa!_oazoa!Poa'_oa$xoa!Xoa~P#4xO#P$UaP$UaY$Ua^$Uai$Uas$Ua!]$Ua!^$Ua!`$Ua!f$Ua#S$Ua#T$Ua#U$Ua#V$Ua#W$Ua#X$Ua#Y$Ua#Z$Ua#]$Ua#_$Ua#a$Ua#b$Ua&}$Ua']$Ua!_$Uaz$Ua!P$Ua'_$Ua$x$Ua!X$Ua~P#5nO#P$WaP$WaY$Wa^$Wai$Was$Wa!]$Wa!^$Wa!`$Wa!f$Wa#S$Wa#T$Wa#U$Wa#V$Wa#W$Wa#X$Wa#Y$Wa#Z$Wa#]$Wa#_$Wa#a$Wa#b$Wa&}$Wa']$Wa!_$Waz$Wa!P$Wa'_$Wa$x$Wa!X$Wa~P#6aO#P$faP$faY$fa^$fai$fas$fa}$fa!]$fa!^$fa!`$fa!f$fa#S$fa#T$fa#U$fa#V$fa#W$fa#X$fa#Y$fa#Z$fa#]$fa#_$fa#a$fa#b$fa&}$fa']$fa!_$faz$fa!P$fa!u$fa'_$fa$x$fa!X$fa~P!#QO^!wq}!wq&}!wqz!wq!_!wq'_!wq!P!wq$x!wq!X!wq~P!(tO}&aX'W&aX~PIxO},PO'W'ga~O|0`O}&bX!_&bX~P)uO},SO!_'ha~O},SO!_'ha~P!(tO#e!ba!O!ba~PBzO#e!Ya}!Ya!O!Ya~P#'yO!P0sO#p]O#w0tO~O!O0xO~O'_0yO~P!#QO^$Qq}$Qq&}$Qqz$Qq!_$Qq'_$Qq!P$Qq$x$Qq!X$Qq~P!(tOz0zO~O],kOj,kO~Or'{Ou'|O'q(QO'i$pi'p$pi}$pi!u$pi~O'W$pi#e$pi~P$&YOr'{Ou'|O'i$ri'p$ri'q$ri}$ri!u$ri~O'W$ri#e$ri~P$&{O#e0{O~P!#QO|0}O'S$]O}&jX!_&jX~O},sO!_'va~O},sO!X!tO!_'va~O},sO!X!tO'i&hO!_'va~O'W$_i}$_i#e$_i!u$_i~P!#QO|1UO'S([Oz&lX}&lX~P!#oO},zOz'wa~O},zOz'wa~P!#QO!X!tO~O!X!tO#Y1`O~Oi1dO!X!tO'i&hO~O}'Zi'W'Zi~P!#QO!u1gO}'Zi'W'Zi~P!#QO!_1jO~O^$Rq}$Rq&}$Rqz$Rq!_$Rq'_$Rq!P$Rq$x$Rq!X$Rq~P!(tO}1nO!P'xX~P!#QO!P&]O$x1qO~O!P&]O$x1qO~P!#QO!P$]X$mZX^$]X&}$]X~P! wO$m1uOrfXufX!PfX'ifX'pfX'qfX^fX&}fX~O$m1uO~O'S)aO}&uX!O&uX~O}-|O!O(Oa~O[2OO~O]2RO~OR2TO!P&]O!k2SO$x1qO~O^$XO&}$XO~P!#QO!P#vO~P!#QO}2YO!u2[O!O'{X~O!O2]O~Ou(eO!S2fO!T2_O!U2_O!n2eO!o2dO!p2dO!r2cO'T$_O'`(aO~O!O2bO~P$/ROR2mO!P.gO!k2lO$x2kO~OR2mO!P.gO!k2lO$x2kO'X$`O~O'S(sO}&tX!O&tX~O}.sO!O'|a~O'`2vO~O]2xO~O[2zO~O!_2}O~P)uO^3PO~O^3PO~P)uO#Y3RO%j3SO~PEdO_/ZO!O3WO%x/YO~P`O!X3YO~O%}3ZOP%zqQ%zqW%zq]%zq^%zqa%zqb%zqg%zqi%zqj%zqk%zqn%zqp%zqu%zqw%zqx%zqy%zq!P%zq!Z%zq!`%zq!c%zq!d%zq!e%zq!f%zq!g%zq!j%zq#[%zq#l%zq#p%zq$w%zq$y%zq${%zq$|%zq%P%zq%R%zq%U%zq%V%zq%X%zq%f%zq%l%zq%n%zq%p%zq%r%zq%u%zq%{%zq&P%zq&R%zq&T%zq&V%zq&X%zq&x%zq'S%zq']%zq'u%zq!O%zq%s%zq_%zq%x%zq~O}!|i!O!|i~P#'yO!u3]O}!|i!O!|i~O}!Ri!O!Ri~P#'yO^$XO!u3dO&}$XO~O^$XO!X!tO!u3dO&}$XO~O^$XO!X!tO!`$UO!f3hO!u3dO&}$XO'X$`O'i&hO~O!T3iO!U3iO'T$_O'`(aO~O!S3lO!T3iO!U3iO!r3mO'T$_O'`(aO~O^$XO!X!tO!f3hO!u3dO&}$XO'i&hO~O}'kq!_'kq^'kq&}'kq~P!(tO}&mO!_'jq~O#P$piP$piY$pi^$pii$pis$pi!]$pi!^$pi!`$pi!f$pi#S$pi#T$pi#U$pi#V$pi#W$pi#X$pi#Y$pi#Z$pi#]$pi#_$pi#a$pi#b$pi&}$pi']$pi!_$piz$pi!P$pi'_$pi$x$pi!X$pi~P$&YO#P$riP$riY$ri^$rii$ris$ri!]$ri!^$ri!`$ri!f$ri#S$ri#T$ri#U$ri#V$ri#W$ri#X$ri#Y$ri#Z$ri#]$ri#_$ri#a$ri#b$ri&}$ri']$ri!_$riz$ri!P$ri'_$ri$x$ri!X$ri~P$&{O#P$_iP$_iY$_i^$_ii$_is$_i}$_i!]$_i!^$_i!`$_i!f$_i#S$_i#T$_i#U$_i#V$_i#W$_i#X$_i#Y$_i#Z$_i#]$_i#_$_i#a$_i#b$_i&}$_i']$_i!_$_iz$_i!P$_i!u$_i'_$_i$x$_i!X$_i~P!#QO}&aa'W&aa~P!#QO}&ba!_&ba~P!(tO},SO!_'hi~O#e!wi}!wi!O!wi~P#'yOP#ZOr!xOs!xOu!yO!^!vO!`!wO!f#ZO']QOY#Rii#Ri!]#Ri#T#Ri#U#Ri#V#Ri#W#Ri#X#Ri#Y#Ri#Z#Ri#]#Ri#_#Ri#a#Ri#b#Ri#e#Ri'i#Ri'p#Ri'q#Ri}#Ri!O#Ri~O#S#Ri~P$@xO#S8oO~P$@xOP#ZOr!xOs!xOu!yO!^!vO!`!wO!f#ZO#S8oO#T8pO#U8pO#V8pO']QOY#Ri!]#Ri#W#Ri#X#Ri#Y#Ri#Z#Ri#]#Ri#_#Ri#a#Ri#b#Ri#e#Ri'i#Ri'p#Ri'q#Ri}#Ri!O#Ri~Oi#Ri~P$CQOi8qO~P$CQOP#ZOi8qOr!xOs!xOu!yO!^!vO!`!wO!f#ZO#S8oO#T8pO#U8pO#V8pO#W8rO']QO#]#Ri#_#Ri#a#Ri#b#Ri#e#Ri'i#Ri'p#Ri'q#Ri}#Ri!O#Ri~OY#Ri!]#Ri#X#Ri#Y#Ri#Z#Ri~P$EYOY8|O!]8sO#X8sO#Y8sO#Z8sO~P$EYOP#ZOY8|Oi8qOr!xOs!xOu!yO!]8sO!^!vO!`!wO!f#ZO#S8oO#T8pO#U8pO#V8pO#W8rO#X8sO#Y8sO#Z8sO#]8tO']QO#_#Ri#a#Ri#b#Ri#e#Ri'i#Ri'q#Ri}#Ri!O#Ri~O'p#Ri~P$GnO'p!zO~P$GnOP#ZOY8|Oi8qOr!xOs!xOu!yO!]8sO!^!vO!`!wO!f#ZO#S8oO#T8pO#U8pO#V8pO#W8rO#X8sO#Y8sO#Z8sO#]8tO#_8vO']QO'p!zO#a#Ri#b#Ri#e#Ri'i#Ri}#Ri!O#Ri~O'q#Ri~P$IvO'q!{O~P$IvOP#ZOY8|Oi8qOr!xOs!xOu!yO!]8sO!^!vO!`!wO!f#ZO#S8oO#T8pO#U8pO#V8pO#W8rO#X8sO#Y8sO#Z8sO#]8tO#_8vO#a8xO']QO'p!zO'q!{O~O#b#Ri#e#Ri'i#Ri}#Ri!O#Ri~P$LOO^#cy}#cy&}#cyz#cy!_#cy'_#cy!P#cy$x#cy!X#cy~P!(tOP#RiY#Rii#Ris#Ri!]#Ri!^#Ri!`#Ri!f#Ri#S#Ri#T#Ri#U#Ri#V#Ri#W#Ri#X#Ri#Y#Ri#Z#Ri#]#Ri#_#Ri#a#Ri#b#Ri#e#Ri']#Ri}#Ri!O#Ri~P!#QO!^!vOP'[XY'[Xi'[Xr'[Xs'[Xu'[X!]'[X!`'[X!f'[X#S'[X#T'[X#U'[X#V'[X#W'[X#X'[X#Y'[X#Z'[X#]'[X#_'[X#a'[X#b'[X#e'[X']'[X'i'[X'p'[X'q'[X}'[X!O'[X~O#e#fi}#fi!O#fi~P#'yO!O3}O~O}&ia!O&ia~P#'yO!X!tO'i&hO}&ja!_&ja~O},sO!_'vi~O},sO!X!tO!_'vi~Oz&la}&la~P!#QO!X4UO~O},zOz'wi~P!#QO},zOz'wi~Oz4[O~O!X!tO#Y4bO~Oi4cO!X!tO'i&hO~Oz4eO~O'W$aq}$aq#e$aq!u$aq~P!#QO^$Ry}$Ry&}$Ryz$Ry!_$Ry'_$Ry!P$Ry$x$Ry!X$Ry~P!(tO}1nO!P'xa~O!P&]O$x4jO~O!P&]O$x4jO~P!#QO^!wy}!wy&}!wyz!wy!_!wy'_!wy!P!wy$x!wy!X!wy~P!(tOY4mO~O}-|O!O(Oi~O]4oO~O[4pO~O'`&|O}&qX!O&qX~O}2YO!O'{a~O!O4}O~P$/RO!S5QO!T5PO!U5PO!r/zO'T$_O'`(aO~O!o5RO!p5RO~P%*]O!T5PO!U5PO'T$_O'`(aO~O!P.gO~O!P.gO$x5TO~O!P.gO$x5TO~P!#QOR5YO!P.gO!k5XO$x5TO~OY5_O}&ta!O&ta~O}.sO!O'|i~O]5bO~O!_5cO~O!_5dO~O!_5eO~O!_5eO~P)uO^5gO~O!X5jO~O!_5lO~O}'ni!O'ni~P#'yO^$XO&}$XO~P!(tO^$XO!u5qO&}$XO~O^$XO!X!tO!u5qO&}$XO~O^$XO!X!tO!f5vO!u5qO&}$XO'i&hO~O!`$UO'X$`O~P%.`O!T5wO!U5wO'T$_O'`(aO~O}'ky!_'ky^'ky&}'ky~P!(tO#P$aqP$aqY$aq^$aqi$aqs$aq}$aq!]$aq!^$aq!`$aq!f$aq#S$aq#T$aq#U$aq#V$aq#W$aq#X$aq#Y$aq#Z$aq#]$aq#_$aq#a$aq#b$aq&}$aq']$aq!_$aqz$aq!P$aq!u$aq'_$aq$x$aq!X$aq~P!#QO}&bi!_&bi~P!(tO#e!wq}!wq!O!wq~P#'yOr-cOs-cOu-dOPoaYoaioa!]oa!^oa!`oa!foa#Soa#Toa#Uoa#Voa#Woa#Xoa#Yoa#Zoa#]oa#_oa#aoa#boa#eoa']oa'ioa'poa'qoa}oa!Ooa~Or'{Ou'|OP$UaY$Uai$Uas$Ua!]$Ua!^$Ua!`$Ua!f$Ua#S$Ua#T$Ua#U$Ua#V$Ua#W$Ua#X$Ua#Y$Ua#Z$Ua#]$Ua#_$Ua#a$Ua#b$Ua#e$Ua']$Ua'i$Ua'p$Ua'q$Ua}$Ua!O$Ua~Or'{Ou'|OP$WaY$Wai$Was$Wa!]$Wa!^$Wa!`$Wa!f$Wa#S$Wa#T$Wa#U$Wa#V$Wa#W$Wa#X$Wa#Y$Wa#Z$Wa#]$Wa#_$Wa#a$Wa#b$Wa#e$Wa']$Wa'i$Wa'p$Wa'q$Wa}$Wa!O$Wa~OP$faY$fai$fas$fa!]$fa!^$fa!`$fa!f$fa#S$fa#T$fa#U$fa#V$fa#W$fa#X$fa#Y$fa#Z$fa#]$fa#_$fa#a$fa#b$fa#e$fa']$fa}$fa!O$fa~P!#QO#e$Qq}$Qq!O$Qq~P#'yO#e$Rq}$Rq!O$Rq~P#'yO!O6RO~O'W$ty}$ty#e$ty!u$ty~P!#QO!X!tO}&ji!_&ji~O!X!tO'i&hO}&ji!_&ji~O},sO!_'vq~Oz&li}&li~P!#QO},zOz'wq~Oz6YO~P!#QOz6YO~O}'Zy'W'Zy~P!#QO}&oa!P&oa~P!#QO!P$lq^$lq&}$lq~P!#QO}-|O!O(Oq~O]6cO~O!P&]O$x6dO~O!P&]O$x6dO~P!#QO!u6eO}&qa!O&qa~O}2YO!O'{i~P#'yO!T6kO!U6kO'T$_O'`(aO~O!S6mO!T6kO!U6kO!r3mO'T$_O'`(aO~O!P.gO$x6pO~O!P.gO$x6pO~P!#QO'`6vO~O}.sO!O'|q~O!_6yO~O!_6yO~P)uO!_6{O~O!_6|O~O}!|y!O!|y~P#'yO^$XO!u7RO&}$XO~O^$XO!X!tO!u7RO&}$XO~O^$XO!X!tO!f7VO!u7RO&}$XO'i&hO~O#P$tyP$tyY$ty^$tyi$tys$ty}$ty!]$ty!^$ty!`$ty!f$ty#S$ty#T$ty#U$ty#V$ty#W$ty#X$ty#Y$ty#Z$ty#]$ty#_$ty#a$ty#b$ty&}$ty']$ty!_$tyz$ty!P$ty!u$ty'_$ty$x$ty!X$ty~P!#QO#e#cy}#cy!O#cy~P#'yOP$_iY$_ii$_is$_i!]$_i!^$_i!`$_i!f$_i#S$_i#T$_i#U$_i#V$_i#W$_i#X$_i#Y$_i#Z$_i#]$_i#_$_i#a$_i#b$_i#e$_i']$_i}$_i!O$_i~P!#QOr'{Ou'|O'q(QOP$piY$pii$pis$pi!]$pi!^$pi!`$pi!f$pi#S$pi#T$pi#U$pi#V$pi#W$pi#X$pi#Y$pi#Z$pi#]$pi#_$pi#a$pi#b$pi#e$pi']$pi'i$pi'p$pi}$pi!O$pi~Or'{Ou'|OP$riY$rii$ris$ri!]$ri!^$ri!`$ri!f$ri#S$ri#T$ri#U$ri#V$ri#W$ri#X$ri#Y$ri#Z$ri#]$ri#_$ri#a$ri#b$ri#e$ri']$ri'i$ri'p$ri'q$ri}$ri!O$ri~O#e$Ry}$Ry!O$Ry~P#'yO#e!wy}!wy!O!wy~P#'yO!X!tO}&jq!_&jq~O},sO!_'vy~Oz&lq}&lq~P!#QOz7]O~P!#QO}2YO!O'{q~O!T7hO!U7hO'T$_O'`(aO~O!P.gO$x7kO~O!P.gO$x7kO~P!#QO!_7nO~O%}7oOP%z!ZQ%z!ZW%z!Z]%z!Z^%z!Za%z!Zb%z!Zg%z!Zi%z!Zj%z!Zk%z!Zn%z!Zp%z!Zu%z!Zw%z!Zx%z!Zy%z!Z!P%z!Z!Z%z!Z!`%z!Z!c%z!Z!d%z!Z!e%z!Z!f%z!Z!g%z!Z!j%z!Z#[%z!Z#l%z!Z#p%z!Z$w%z!Z$y%z!Z${%z!Z$|%z!Z%P%z!Z%R%z!Z%U%z!Z%V%z!Z%X%z!Z%f%z!Z%l%z!Z%n%z!Z%p%z!Z%r%z!Z%u%z!Z%{%z!Z&P%z!Z&R%z!Z&T%z!Z&V%z!Z&X%z!Z&x%z!Z'S%z!Z']%z!Z'u%z!Z!O%z!Z%s%z!Z_%z!Z%x%z!Z~O^$XO!u7sO&}$XO~O^$XO!X!tO!u7sO&}$XO~OP$aqY$aqi$aqs$aq!]$aq!^$aq!`$aq!f$aq#S$aq#T$aq#U$aq#V$aq#W$aq#X$aq#Y$aq#Z$aq#]$aq#_$aq#a$aq#b$aq#e$aq']$aq}$aq!O$aq~P!#QO}&qq!O&qq~P#'yO^$XO!u8XO&}$XO~OP$tyY$tyi$tys$ty!]$ty!^$ty!`$ty!f$ty#S$ty#T$ty#U$ty#V$ty#W$ty#X$ty#Y$ty#Z$ty#]$ty#_$ty#a$ty#b$ty#e$ty']$ty}$ty!O$ty~P!#QO'_'aX~P.^O'_ZXzZX!_ZX%jZX!PZX$xZX!XZX~P$wO!XcX!_ZX!_cX'icX~P;OOP8iOQ8iO]bOa:OOb!gOgbOi8iOjbOkbOn8iOp8iOuROwbOxbOybO!PSO!Z8kO!`UO!c8iO!d8iO!e8iO!f8iO!g8iO!j!fO#l!iO#p]O'S'[O']QO'u9|O~O}8zO!O$Ta~O]#nOg#{Oi#oOj#nOk#nOn#|Op9POu#uO!P#vO!Z:RO!`#sO#O9VO#l$QO$V9RO$X9TO$[$RO'S&tO']#pO~O#['cO~P&(sO!OZX!OcX~P;OO#P8nO~O!X!tO#P8nO~O!u8}O~O!u9WO}'nX!O'nX~O!u8}O}'lX!O'lX~O#P9XO~O'W9ZO~P!#QO#P9`O~O#P9aO~O!X!tO#P9bO~O!X!tO#P9XO~O#e9cO~P#'yO#P9dO~O#P9eO~O#P9fO~O#P9gO~O#e9hO~P!#QO#e9iO~P!#QO#p~!^!n!p!}#O'u$V$X$[$m$w$x$y%P%R%U%V%X%Z~TS#p'u#Ty'P'Q#r'P'S'`~",
  goto: "#=a(SPPPPPPP(TP(eP*QPPPP-aPP-v2z4m5QP5QPPP5Q5QP5QP6nPP6sP7[PPPP;kPPPP;k>ZPPP>a@dP;kPBwPPPPDo;kPPPPPFh;kPPIgJdPPPJhPJpKqP;k;kNx!#q!(a!(a!+nPPP!+u;kPPPPPPPPPP!.iP!/zPP;k!1XP;kP;k;k;k;kP;k!3lPP!6cP!9U!9^!9b!9bP!6`P!9f!9fP!<XP!<];k;k!<c!?T5QP5QP5Q5QP!@W5Q5Q!A{5Q5Q5Q!C}5Q5Q!Dk!Fe!Fe!Fi!Fe!FqP!FeP5Q!Gm5Q!Hw5Q5Q-aPPP!JUPP!Jn!JnP!JnP!KT!JnPP!KZP!KQP!KQ!KmJl!KQ!L[!Lb!Le(T!Lh(TP!Lo!Lo!LoP(TP(TP(TP(TPP(TP!Lu!LxP!Lx(TPPP(TP(TP(TP(TP(TP(T(T!L|!MW!M^!Md!Mr!Mx!NO!NY!N`!Nj!Np# O# U# [# j#!P##c##q##w##}#$T#$Z#$e#$k#$q#${#%V#%]PPPPPPPPP#%cPP#&V#*TPP#+h#+o#+wP#0TPP#0X#2l#8f#8j#8m#8p#8{#9OP#9R#9V#9t#:i#:m#;PPP#;T#;Z#;_P#;b#;f#;i#<X#<o#<t#<w#<z#=Q#=T#=X#=]mgOSi{!k$W%_%b%c%e*f*k/T/WQ$elQ$lnQ%VwS&P!`+RQ&d!gS(d#v(iQ)_$fQ)k$nQ*V%PQ+X&WS+_&]+aQ+o&eQ-Z(kQ.r*WU/w+c+d+eS2_.g2aS3i/y/{U5P2d2e2fQ5w3lS6k5Q5RR7h6m$lZORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$W$j%W%Z%_%a%b%c%e%i%t%|&X&_&i&v&z'z(|)T*b*f*k+j+q,S,Y-d-i-q-{.j.{.|.}/P/T/W/Y/q0U0`2S2l3P3R3S3d5X5g5q7R7s8X!j'^#Y#h&Q'p*z*},_/h0s2[3]6e8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:PQ(t#}Q)d$hQ*X%SQ*`%[Q+y9OQ-v)XQ.z*^Q1{-|Q2t.sR3v9PpdOSiw{!k$W%U%_%b%c%e*f*k/T/WR*Z%W&WVOSTijm{!Q!U!Z!h!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$W$j%W%Z%[%_%a%b%c%e%i%t%|&X&_&i&v&z'p'z(|)T*b*f*k*z*}+j+q,S,Y,_-d-i-q-{.j.{.|.}/P/T/W/Y/h/q0U0`0s2S2[2l3P3R3S3]3d5X5g5q6e7R7s8X8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:O:PW!aRU!^&QQ$^kQ$dlS$in$nv$spq!o!r$U$q&Y&m&p)o)p)q*d*{+[+t+v/^0WQ${uQ&a!fQ&c!gS(W#s(bS)^$e$fQ)b$hQ)n$pQ*Q$}Q*U%PS+n&d&eQ,w(XQ-z)_Q.Q)eQ.T)iQ.m*RS.q*V*WQ0S+oQ0|,sQ1z-|Q1}.PQ2Q.VQ2s.rQ4R0}R6a4m!W$bl!g$d$e$f&O&c&d&e(c)^)_+O+^+n+o-T-z/m/t/x0S1c3g3k5u7UQ)V$^Q)v$xQ)y$yQ*T%PQ.X)nQ.l*QU.p*U*V*WQ2n.mS2r.q.rQ4z2^Q5^2sS6i4{5OS7f6j6lQ8O7gR8^8PW#y`$`(q9|S$xr%UQ$ysQ$ztR)t$v$V#x`!t!v#a#s#u$O$P$T&`'v(P(R(S(Z(_(o(p)S)U)X)u)x+k,P,z,|-f-p-r.^.a.i.k0{1U1`1g1n1q1u2T2k2m4U4b4j5T5Y6d6p7k8|9Q9R9S9T9U9V9[9]9^9_9`9a9d9e9h9i9|:S:TV(u#}9O9PU&T!`$r+UQ&}!xQ)h$kQ,j'{Q.b)zQ1h-cR4v2Y&YbORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$W$j%W%Z%[%_%a%b%c%e%i%t%|&Q&X&_&i&v&z'p'z(|)T*b*f*k*z*}+j+q,S,Y,_-d-i-q-{.j.{.|.}/P/T/W/Y/h/q0U0`0s2S2[2l3P3R3S3]3d5X5g5q6e7R7s8X8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:P$]#^Y!]!l$[%s%w&r&y'P'Q'R'S'T'U'V'W'X'Y'Z']'`'d'n)g*v+P+Y+p,O,U,X,Z,i-g/c/f0T0_0c0d0e0f0g0h0i0j0k0l0m0n0o0r0w1l1x3_3b3q3t3u3z3{4x5m5p5{6P6Q7P7b7q8V8a8j9u&ZbORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$W$j%W%Z%[%_%a%b%c%e%i%t%|&Q&X&_&i&v&z'p'z(|)T*b*f*k*z*}+j+q,S,Y,_-d-i-q-{.j.{.|.}/P/T/W/Y/h/q0U0`0s2S2[2l3P3R3S3]3d5X5g5q6e7R7s8X8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:PQ&R!`R/i+RY%{!`&P&W+R+XS(c#v(iS+^&]+aS-T(d(kQ-U(eQ-[(lQ.d)|S/t+_+cS/x+d+eS/|+f2cQ1c-ZQ1e-]Q1f-^S2^.g2aS3g/w/yQ3j/zQ3k/{S4{2_2fS5O2d2eS5u3i3lQ5x3mS6j5P5QQ6l5RQ7U5wS7g6k6mR8P7hlgOSi{!k$W%_%b%c%e*f*k/T/WQ%g!OS&q!s8nQ)[$cQ*O${Q*P$|Q+l&bS+}&v9XS-h(|9bQ-x)]Q.f)}Q/[*mQ/]*nQ/e*|Q0Q+mS1m-i9fQ1v-yS1y-{9gQ3^/gQ3a/oQ3o0RQ4l1wQ5k3ZQ5n3`Q5r3fQ5y3pQ6}5lQ7Q5sQ7r7SQ8T7oR8W7t$W#]Y!]!l%s%w&r&y'P'Q'R'S'T'U'V'W'X'Y'Z']'`'d'n)g*v+P+Y+p,O,U,X,i-g/c/f0T0_0c0d0e0f0g0h0i0j0k0l0m0n0o0r0w1l1x3_3b3q3t3u3z3{4x5m5p5{6P6Q7P7b7q8V8a8j9uU(n#w&u0qT)Q$[,Z$W#[Y!]!l%s%w&r&y'P'Q'R'S'T'U'V'W'X'Y'Z']'`'d'n)g*v+P+Y+p,O,U,X,i-g/c/f0T0_0c0d0e0f0g0h0i0j0k0l0m0n0o0r0w1l1x3_3b3q3t3u3z3{4x5m5p5{6P6Q7P7b7q8V8a8j9uQ'_#]S)P$[,ZR-j)Q&YbORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$W$j%W%Z%[%_%a%b%c%e%i%t%|&Q&X&_&i&v&z'p'z(|)T*b*f*k*z*}+j+q,S,Y,_-d-i-q-{.j.{.|.}/P/T/W/Y/h/q0U0`0s2S2[2l3P3R3S3]3d5X5g5q6e7R7s8X8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:PQ%byQ%czQ%e|Q%f}R/S*iQ&^!fQ)R$^Q+i&aS-o)V)nS/}+g+hW1p-l-m-n.XS3n0O0PU4i1r1s1tU6_4h4r4sQ7_6`R7z7aT+`&]+aS+`&]+aT2`.g2aS&k!n/QQ,v(WQ-R(cS/s+^2^Q1R,wS1]-S-[U3h/x/|5OQ4Q0|S4`1d1fU5v3j3k6lQ6T4RQ6^4cR7V5xQ!uXS&j!n/QQ(}$VQ)Y$aQ)`$gQ+r&kQ,u(WQ-Q(cQ-V(fQ-w)ZQ.n*SS/r+^2^S1Q,v,wS1[-R-[Q1_-UQ1b-WQ2p.oW3e/s/x/|5OQ4P0|Q4T1RS4Y1]1fQ4a1eQ5[2qW5t3h3j3k6lS6S4Q4RQ6X4[Q6[4`Q6g4yQ6t5]S7T5v5xQ7X6TQ7Z6YQ7^6^Q7d6hQ7m6uQ7u7VQ7x7]Q7|7eQ8[7}Q8c8]Q8g8dQ9o9kQ9x9sR9y9t$nWORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$W$j%W%Z%[%_%a%b%c%e%i%t%|&X&_&i&v&z'z(|)T*b*f*k+j+q,S,Y-d-i-q-{.j.{.|.}/P/T/W/Y/q0U0`2S2l3P3R3S3d5X5g5q7R7s8XS!um!h!j9j#Y#h&Q'p*z*},_/h0s2[3]6e8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:PR9o:O$nXORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$W$j%W%Z%[%_%a%b%c%e%i%t%|&X&_&i&v&z'z(|)T*b*f*k+j+q,S,Y-d-i-q-{.j.{.|.}/P/T/W/Y/q0U0`2S2l3P3R3S3d5X5g5q7R7s8XQ$Va!W$al!g$d$e$f&O&c&d&e(c)^)_+O+^+n+o-T-z/m/t/x0S1c3g3k5u7US$gm!hQ)Z$bQ*S%PW.o*T*U*V*WU2q.p.q.rQ4y2^S5]2r2sU6h4z4{5OQ6u5^U7e6i6j6lS7}7f7gS8]8O8PQ8d8^!j9k#Y#h&Q'p*z*},_/h0s2[3]6e8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:PQ9s9}R9t:O$f[OSTij{!Q!U!Z!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$W$j%W%Z%_%a%b%c%e%i%t%|&X&_&i&v&z'z(|)T*b*f*k+j+q,S,Y-d-i-q-{.j.{.|.}/P/T/W/Y/q0U0`2S2l3P3R3S3d5X5g5q7R7s8XU!eRU!^v$spq!o!r$U$q&Y&m&p)o)p)q*d*{+[+t+v/^0WQ*a%[!h9l#Y#h'p*z*},_/h0s2[3]6e8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:PR9n&QS&U!`$rR/k+U$lZORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$W$j%W%Z%_%a%b%c%e%i%t%|&X&_&i&v&z'z(|)T*b*f*k+j+q,S,Y-d-i-q-{.j.{.|.}/P/T/W/Y/q0U0`2S2l3P3R3S3d5X5g5q7R7s8X!j'^#Y#h&Q'p*z*},_/h0s2[3]6e8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:PR*`%[!h#SY!]$[%s%w&r&y'W'X'Y'Z'`'d)g*v+Y+p,O,U,i-g0T0_0o1l1x3b3q3t5p7P7q8V8a8j!R8u']'n+P,Z/c/f0c0k0l0m0n0r0w3_3u3z3{4x5m5{6P6Q7b9u!d#UY!]$[%s%w&r&y'Y'Z'`'d)g*v+Y+p,O,U,i-g0T0_0o1l1x3b3q3t5p7P7q8V8a8j}8w']'n+P,Z/c/f0c0m0n0r0w3_3u3z3{4x5m5{6P6Q7b9u!`#YY!]$[%s%w&r&y'`'d)g*v+Y+p,O,U,i-g0T0_0o1l1x3b3q3t5p7P7q8V8a8jl(S#q&w({,q,y-_-`0]1k4O4d9p9z9{x:P']'n+P,Z/c/f0c0r0w3_3u3z3{4x5m5{6P6Q7b9u!`:S&s'b(V(]+h+|,f,}-k-n.]._0P0[1S1W1t2V2X2i3s4V4]4f4k4s5W5z6V6]6rZ:T0p3y5|7W7v&YbORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$W$j%W%Z%[%_%a%b%c%e%i%t%|&Q&X&_&i&v&z'p'z(|)T*b*f*k*z*}+j+q,S,Y,_-d-i-q-{.j.{.|.}/P/T/W/Y/h/q0U0`0s2S2[2l3P3R3S3]3d5X5g5q6e7R7s8X8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:PS#i_#jR0t,^&a^ORSTU_ij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h#j$W$j%W%Z%[%_%a%b%c%e%i%t%|&Q&X&_&i&v&z'p'z(|)T*b*f*k*z*}+j+q,S,Y,^,_-d-i-q-{.j.{.|.}/P/T/W/Y/h/q0U0`0s2S2[2l3P3R3S3]3d5X5g5q6e7R7s8X8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:PS#d]#kT'g#f'kT#e]#kT'i#f'k&a_ORSTU_ij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h#j$W$j%W%Z%[%_%a%b%c%e%i%t%|&Q&X&_&i&v&z'p'z(|)T*b*f*k*z*}+j+q,S,Y,^,_-d-i-q-{.j.{.|.}/P/T/W/Y/h/q0U0`0s2S2[2l3P3R3S3]3d5X5g5q6e7R7s8X8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:PT#i_#jQ#l_R'r#j$naORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$W$j%W%Z%[%_%a%b%c%e%i%t%|&X&_&i&v&z'z(|)T*b*f*k+j+q,S,Y-d-i-q-{.j.{.|.}/P/T/W/Y/q0U0`2S2l3P3R3S3d5X5g5q7R7s8X!k9}#Y#h&Q'p*z*},_/h0s2[3]6e8i8k8n8o8p8q8r8s8t8u8v8w8x8y8z8}9W9X9Z9b9c9f9g:P#RcOSUi{!Q!U!k!y#h$W%W%Z%[%_%a%b%c%e%i%|&_'p)T*b*f*k+j,_-d-q.j.{.|.}/P/T/W/Y0s2S2l3P3R3S5X5gt#w`!v$O$P$T(P(R(S(Z(o(p,P-f0{1g9|:S:T!|&u!t#a#s#u&`'v(_)S)U)X)u)x+k,z,|-p-r.^.a.i.k1U1`1n1q1u2T2k2m4U4b4j5T5Y6d6p7k9Q9S9U9[9^9`9d9hQ(y$Rc0q8|9R9T9V9]9_9a9e9it#t`!v$O$P$T(P(R(S(Z(o(p,P-f0{1g9|:S:TS(f#v(iQ(z$SQ-W(g!|9q!t#a#s#u&`'v(_)S)U)X)u)x+k,z,|-p-r.^.a.i.k1U1`1n1q1u2T2k2m4U4b4j5T5Y6d6p7k9Q9S9U9[9^9`9d9hb9r8|9R9T9V9]9_9a9e9iQ9v:QR9w:RleOSi{!k$W%_%b%c%e*f*k/T/WQ(^#uQ*r%lQ*s%nR1T,z$U#x`!t!v#a#s#u$O$P$T&`'v(P(R(S(Z(_(o(p)S)U)X)u)x+k,P,z,|-f-p-r.^.a.i.k0{1U1`1g1n1q1u2T2k2m4U4b4j5T5Y6d6p7k8|9Q9R9S9T9U9V9[9]9^9_9`9a9d9e9h9i9|:S:TQ)w$yQ.`)yQ2W._R4u2XT(h#v(iS(h#v(iT2`.g2aQ)Y$aQ-V(fQ-w)ZQ.n*SQ2p.oQ5[2qQ6g4yQ6t5]Q7d6hQ7m6uQ7|7eQ8[7}Q8c8]R8g8dl(P#q&w({,q,y-_-`0]1k4O4d9p9z9{!`9[&s'b(V(]+h+|,f,}-k-n.]._0P0[1S1W1t2V2X2i3s4V4]4f4k4s5W5z6V6]6rZ9]0p3y5|7W7vn(R#q&w({,o,q,y-_-`0]1k4O4d9p9z9{!b9^&s'b(V(]+h+|,f,}-k-n.]._0P0Y0[1S1W1t2V2X2i3s4V4]4f4k4s5W5z6V6]6r]9_0p3y5|5}7W7vpdOSiw{!k$W%U%_%b%c%e*f*k/T/WQ%RvR*b%[pdOSiw{!k$W%U%_%b%c%e*f*k/T/WR%RvQ){$zR.[)tqdOSiw{!k$W%U%_%b%c%e*f*k/T/WQ.h*QS2j.l.mW5S2g2h2i2nU6o5U5V5WU7i6n6q6rQ8Q7jR8_8RQ%YwR*[%UR2w.uR6w5_S$in$nR.Q)eQ%_xR*f%`R*l%fT/U*k/WQiOQ!kST$Zi!kQ'x#pR,g'xQ!WQR%q!WQ![RU%u![%v*wQ%v!]R*w%wQ+S&RR/j+SQ,Q&wR0^,QQ,T&yS0a,T0bR0b,UQ+a&]R/u+aQ&Z!cQ*x%xT+]&Z*xQ+V&UR/l+VQ&n!pQ+s&lU+w&n+s0XR0X+xQ'k#fR,`'kQ#j_R'q#jQ#`YU'a#`*u8{Q*u8jR8{'nQ,t(WW1O,t1P4S6UU1P,u,v,wS4S1Q1RR6U4T#q'}#q&s&w'b(V(](v(w({+h+z+{+|,f,o,p,q,y,}-_-`-k-n.]._0P0Y0Z0[0]0p1S1W1k1t2V2X2i3s3w3x3y4O4V4]4d4f4k4s5W5z5|5}6O6V6]6r7W7v9p9z9{Q,{(]U1V,{1X4WQ1X,}R4W1WQ(i#vR-X(iQ(r#zR-b(rQ1o-kR4g1oQ)r$tR.Z)rQ2Z.bS4w2Z6fR6f4xQ)}${R.e)}Q2a.gR4|2aQ.t*XS2u.t5`R5`2wQ-})bS1|-}4nR4n1}Q)f$iR.R)fQ/W*kR3V/WWhOSi!kQ%d{Q)O$WQ*e%_Q*g%bQ*h%cQ*j%eQ/R*fS/U*k/WR3U/TQ$YfQ%h!PQ%k!RQ%m!SQ%o!TQ)m$oQ)s$uQ*Z%YQ*p%jS.w*[*_Q/_*oQ/`*rQ/a*sS/p+^2^Q1Y-PQ1Z-QQ1a-VQ2P.UQ2U.]Q2o.nQ2y.yQ3T/SY3c/r/s/x/|5OQ4X1[Q4Z1^Q4^1bQ4q2RQ4t2VQ5Z2pQ5a2x[5o3b3e3h3j3k6lQ6W4YQ6Z4_Q6b4oQ6s5[Q6x5bW7O5p5t5v5xQ7Y6XQ7[6[Q7`6cQ7c6gQ7l6tU7p7P7T7VQ7w7ZQ7y7^Q7{7dQ8S7mS8U7q7uQ8Y7xQ8Z7|Q8`8VQ8b8[Q8e8aQ8f8cR8h8gQ$clQ&b!gU)]$d$e$fQ*|&OU+m&c&d&eQ-P(cS-y)^)_Q/g+OQ/o+^S0R+n+oQ1^-TQ1w-zQ3`/mS3f/t/xQ3p0SQ4_1cS5s3g3kQ7S5uR7t7US#r`9|R)W$`U#z`$`9|R-a(qQ#q`S&s!t)XQ&w!vQ'b#aQ(V#sQ(]#uQ(v$OQ(w$PQ({$TQ+h&`Q+z9QQ+{9SQ+|9UQ,f'vQ,o(PQ,p(RQ,q(SQ,y(ZQ,}(_Q-_(oQ-`(pd-k)S-p.i1q2k4j5T6d6p7kQ-n)UQ.])uQ._)xQ0P+kQ0Y9[Q0Z9^Q0[9`Q0],PQ0p8|Q1S,zQ1W,|Q1k-fQ1t-rQ2V.^Q2X.aQ2i.kQ3s9dQ3w9RQ3x9TQ3y9VQ4O0{Q4V1UQ4]1`Q4d1gQ4f1nQ4k1uQ4s2TQ5W2mQ5z9hQ5|9aQ5}9]Q6O9_Q6V4UQ6]4bQ6r5YQ7W9eQ7v9iQ9p9|Q9z:SR9{:TT'w#p'xlfOSi{!k$W%_%b%c%e*f*k/T/WS!mU%aQ%j!QQ%p!UQ'O!yQ'o#hS*_%W%ZQ*c%[Q*o%iQ*y%|Q+g&_Q,d'pQ-m)TQ/O*bQ0O+jQ0v,_Q1i-dQ1s-qQ2h.jQ2{.{Q2|.|Q3O.}Q3Q/PQ3X/YQ3|0sQ4r2SQ5V2lQ5f3PQ5h3RQ5i3SQ6q5XR6z5g!vYOSUi{!Q!k!y$W%W%Z%[%_%a%b%c%e%i%|&_)T*b*f*k+j-d-q.j.{.|.}/P/T/W/Y2S2l3P3R3S5X5gQ!]RQ!lTQ$[jQ%s!ZQ%w!^Q&r!sQ&y!wQ'P!|Q'Q!}Q'R#OQ'S#PQ'T#QQ'U#RQ'V#SQ'W#TQ'X#UQ'Y#VQ'Z#WQ']#YQ'`#_Q'd#bW'n#h'p,_0sQ)g$jQ*v%tS+P&Q/hQ+Y&XQ+p&iQ,O&vQ,U&zQ,X8iQ,Z8kQ,i'zQ-g(|Q/c*zQ/f*}Q0T+qQ0_,SQ0c8nQ0d8oQ0e8pQ0f8qQ0g8rQ0h8sQ0i8tQ0j8uQ0k8vQ0l8wQ0m8xQ0n8yQ0o,YQ0r8}Q0w8zQ1l-iQ1x-{Q3_9WQ3b/qQ3q0UQ3t0`Q3u9XQ3z9ZQ3{9bQ4x2[Q5m3]Q5p3dQ5{9cQ6P9fQ6Q9gQ7P5qQ7b6eQ7q7RQ8V7sQ8a8XQ8j!UR9u:PT!VQ!WR!_RR&S!`S&O!`+RS+O&P&WR/m+XR&x!vR&{!wT!qU$US!pU$UU$tpq*dS&l!o!rQ+u&mQ+x&pQ.Y)qS0V+t+vR3r0W[!bR!^$q&Y)o+[h!nUpq!o!r$U&m&p)q+t+v0WQ/Q*dQ/d*{Q3[/^T9m&Q)pT!dR$qS!cR$qS%x!^)oS+Q&Q)pQ+Z&YR/n+[T&V!`$rQ#f]R't#kT'j#f'kR0u,^T(Y#s(bR(`#uQ-l)SQ1r-pQ2g.iQ4h1qQ5U2kQ6`4jQ6n5TQ7a6dQ7j6pR8R7klgOSi{!k$W%_%b%c%e*f*k/T/WQ%XwR*Z%UV$upq*dR.c)zR*Y%SQ$mnR)l$nR)c$hT%]x%`T%^x%`T/V*k/W",
  nodeNames: "⚠ ArithOp ArithOp extends LineComment BlockComment Script ExportDeclaration export Star as VariableName from String ; default FunctionDeclaration async function VariableDefinition TypeParamList TypeDefinition ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString null super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyNameDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression await yield delete LogicOp BitOp ParenthesizedExpression ClassExpression class extends ClassBody MethodDeclaration Privacy static abstract PropertyDeclaration readonly Optional TypeAnnotation Equals FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp in instanceof const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplatExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try catch finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement",
  maxTerm: 325,
  context: trackNewline,
  nodeProps: [[_common.NodeProp.group, -26, 7, 14, 16, 54, 176, 180, 183, 184, 186, 189, 192, 203, 205, 211, 213, 215, 217, 220, 226, 230, 232, 234, 236, 238, 240, 241, "Statement", -30, 11, 13, 23, 26, 27, 38, 39, 40, 41, 43, 48, 56, 64, 70, 71, 84, 85, 94, 95, 111, 114, 116, 117, 118, 119, 121, 122, 140, 141, 143, "Expression", -22, 22, 24, 28, 29, 31, 144, 146, 148, 149, 151, 152, 153, 155, 156, 157, 159, 160, 161, 170, 172, 174, 175, "Type", -2, 75, 79, "ClassItem"], [_common.NodeProp.closedBy, 37, "]", 47, "}", 62, ")", 124, "JSXSelfCloseEndTag JSXEndTag", 138, "JSXEndTag"], [_common.NodeProp.openedBy, 42, "[", 46, "{", 61, "(", 123, "JSXStartTag", 133, "JSXStartTag JSXStartCloseTag"]],
  skippedNodes: [0, 4, 5],
  repeatNodeCount: 28,
  tokenData: "!As~R!`OX%TXY%cYZ'RZ[%c[]%T]^'R^p%Tpq%cqr'crs(kst%Ttu0huv2xvw3mwx4kxy;Ryz;cz{;s{|<s|}=W}!O<s!O!P=h!P!QAt!Q!R!.d!R![!/y![!]!5i!]!^!5{!^!_!6]!_!`!7Y!`!a!8Q!a!b!9w!b!c%T!c!}0h!}#O!;Y#O#P%T#P#Q!;j#Q#R!;z#R#S0h#S#T!<_#T#o0h#o#p!<o#p#q!<t#q#r!=[#r#s!=n#s$f%T$f$g%c$g#BY0h#BY#BZ!>O#BZ$IS0h$IS$I_!>O$I_$I|0h$I|$I}!@g$I}$JO!@g$JO$JT0h$JT$JU!>O$JU$KV0h$KV$KW!>O$KW&FU0h&FU&FV!>O&FV?HT0h?HT?HU!>O?HU~0hW%YR#|WO!^%T!_#o%T#p~%T,T%jg#|W'P+{OX%TXY%cYZ%TZ[%c[p%Tpq%cq!^%T!_#o%T#p$f%T$f$g%c$g#BY%T#BY#BZ%c#BZ$IS%T$IS$I_%c$I_$JT%T$JT$JU%c$JU$KV%T$KV$KW%c$KW&FU%T&FU&FV%c&FV?HT%T?HT?HU%c?HU~%T,T'YR#|W'Q+{O!^%T!_#o%T#p~%T$T'jS#|W!f#{O!^%T!_!`'v!`#o%T#p~%T$O'}S#]#v#|WO!^%T!_!`(Z!`#o%T#p~%T$O(bR#]#v#|WO!^%T!_#o%T#p~%T'u(rZ#|W]!ROY(kYZ)eZr(krs*rs!^(k!^!_+U!_#O(k#O#P-b#P#o(k#o#p+U#p~(k&r)jV#|WOr)ers*Ps!^)e!^!_*a!_#o)e#o#p*a#p~)e&r*WR#w&j#|WO!^%T!_#o%T#p~%T&j*dROr*ars*ms~*a&j*rO#w&j'u*{R#w&j#|W]!RO!^%T!_#o%T#p~%T'm+ZV]!ROY+UYZ*aZr+Urs+ps#O+U#O#P+w#P~+U'm+wO#w&j]!R'm+zROr+Urs,Ts~+U'm,[U#w&j]!ROY,nZr,nrs-Vs#O,n#O#P-[#P~,n!R,sU]!ROY,nZr,nrs-Vs#O,n#O#P-[#P~,n!R-[O]!R!R-_PO~,n'u-gV#|WOr(krs-|s!^(k!^!_+U!_#o(k#o#p+U#p~(k'u.VZ#w&j#|W]!ROY.xYZ%TZr.xrs/rs!^.x!^!_,n!_#O.x#O#P0S#P#o.x#o#p,n#p~.x!Z/PZ#|W]!ROY.xYZ%TZr.xrs/rs!^.x!^!_,n!_#O.x#O#P0S#P#o.x#o#p,n#p~.x!Z/yR#|W]!RO!^%T!_#o%T#p~%T!Z0XT#|WO!^.x!^!_,n!_#o.x#o#p,n#p~.x&i0s_#|W#rS'S%k'`pOt%Ttu0hu}%T}!O1r!O!Q%T!Q![0h![!^%T!_!c%T!c!}0h!}#R%T#R#S0h#S#T%T#T#o0h#p$g%T$g~0h[1y_#|W#rSOt%Ttu1ru}%T}!O1r!O!Q%T!Q![1r![!^%T!_!c%T!c!}1r!}#R%T#R#S1r#S#T%T#T#o1r#p$g%T$g~1r$O3PS#U#v#|WO!^%T!_!`3]!`#o%T#p~%T$O3dR#|W#g#vO!^%T!_#o%T#p~%T%r3tU'q%j#|WOv%Tvw4Ww!^%T!_!`3]!`#o%T#p~%T$O4_S#|W#a#vO!^%T!_!`3]!`#o%T#p~%T'u4rZ#|W]!ROY4kYZ5eZw4kwx*rx!^4k!^!_6]!_#O4k#O#P8]#P#o4k#o#p6]#p~4k&r5jV#|WOw5ewx*Px!^5e!^!_6P!_#o5e#o#p6P#p~5e&j6SROw6Pwx*mx~6P'm6bV]!ROY6]YZ6PZw6]wx+px#O6]#O#P6w#P~6]'m6zROw6]wx7Tx~6]'m7[U#w&j]!ROY7nZw7nwx-Vx#O7n#O#P8V#P~7n!R7sU]!ROY7nZw7nwx-Vx#O7n#O#P8V#P~7n!R8YPO~7n'u8bV#|WOw4kwx8wx!^4k!^!_6]!_#o4k#o#p6]#p~4k'u9QZ#w&j#|W]!ROY9sYZ%TZw9swx/rx!^9s!^!_7n!_#O9s#O#P:m#P#o9s#o#p7n#p~9s!Z9zZ#|W]!ROY9sYZ%TZw9swx/rx!^9s!^!_7n!_#O9s#O#P:m#P#o9s#o#p7n#p~9s!Z:rT#|WO!^9s!^!_7n!_#o9s#o#p7n#p~9s%V;YR!`$}#|WO!^%T!_#o%T#p~%TZ;jR!_R#|WO!^%T!_#o%T#p~%T%R;|U'T!R#V#v#|WOz%Tz{<`{!^%T!_!`3]!`#o%T#p~%T$O<gS#S#v#|WO!^%T!_!`3]!`#o%T#p~%T$u<zSi$m#|WO!^%T!_!`3]!`#o%T#p~%T&i=_R}&a#|WO!^%T!_#o%T#p~%T&i=oVr%n#|WO!O%T!O!P>U!P!Q%T!Q![>z![!^%T!_#o%T#p~%Ty>ZT#|WO!O%T!O!P>j!P!^%T!_#o%T#p~%Ty>qR|q#|WO!^%T!_#o%T#p~%Ty?RZ#|WjqO!Q%T!Q![>z![!^%T!_!g%T!g!h?t!h#R%T#R#S>z#S#X%T#X#Y?t#Y#o%T#p~%Ty?yZ#|WO{%T{|@l|}%T}!O@l!O!Q%T!Q![AW![!^%T!_#R%T#R#SAW#S#o%T#p~%Ty@qV#|WO!Q%T!Q![AW![!^%T!_#R%T#R#SAW#S#o%T#p~%TyA_V#|WjqO!Q%T!Q![AW![!^%T!_#R%T#R#SAW#S#o%T#p~%T,TA{`#|W#T#vOYB}YZ%TZzB}z{Ht{!PB}!P!Q!+m!Q!^B}!^!_EQ!_!`!,f!`!a!-e!a!}B}!}#OFy#O#PHY#P#oB}#o#pEQ#p~B}XCU[#|WyPOYB}YZ%TZ!PB}!P!QCz!Q!^B}!^!_EQ!_!}B}!}#OFy#O#PHY#P#oB}#o#pEQ#p~B}XDR_#|WyPO!^%T!_#Z%T#Z#[Cz#[#]%T#]#^Cz#^#a%T#a#bCz#b#g%T#g#hCz#h#i%T#i#jCz#j#m%T#m#nCz#n#o%T#p~%TPEVVyPOYEQZ!PEQ!P!QEl!Q!}EQ!}#OFT#O#PFp#P~EQPEqUyP#Z#[El#]#^El#a#bEl#g#hEl#i#jEl#m#nElPFWTOYFTZ#OFT#O#PFg#P#QEQ#Q~FTPFjQOYFTZ~FTPFsQOYEQZ~EQXGOY#|WOYFyYZ%TZ!^Fy!^!_FT!_#OFy#O#PGn#P#QB}#Q#oFy#o#pFT#p~FyXGsV#|WOYFyYZ%TZ!^Fy!^!_FT!_#oFy#o#pFT#p~FyXH_V#|WOYB}YZ%TZ!^B}!^!_EQ!_#oB}#o#pEQ#p~B},TH{^#|WyPOYHtYZIwZzHtz{LY{!PHt!P!Q!*Z!Q!^Ht!^!_Ne!_!}Ht!}#O!&U#O#P!)i#P#oHt#o#pNe#p~Ht,TI|V#|WOzIwz{Jc{!^Iw!^!_Ke!_#oIw#o#pKe#p~Iw,TJhX#|WOzIwz{Jc{!PIw!P!QKT!Q!^Iw!^!_Ke!_#oIw#o#pKe#p~Iw,TK[R#|WT+{O!^%T!_#o%T#p~%T+{KhROzKez{Kq{~Ke+{KtTOzKez{Kq{!PKe!P!QLT!Q~Ke+{LYOT+{,TLa^#|WyPOYHtYZIwZzHtz{LY{!PHt!P!QM]!Q!^Ht!^!_Ne!_!}Ht!}#O!&U#O#P!)i#P#oHt#o#pNe#p~Ht,TMf_#|WT+{yPO!^%T!_#Z%T#Z#[Cz#[#]%T#]#^Cz#^#a%T#a#bCz#b#g%T#g#hCz#h#i%T#i#jCz#j#m%T#m#nCz#n#o%T#p~%T+{NjYyPOYNeYZKeZzNez{! Y{!PNe!P!Q!%Q!Q!}Ne!}#O!!h#O#P!$n#P~Ne+{! _YyPOYNeYZKeZzNez{! Y{!PNe!P!Q! }!Q!}Ne!}#O!!h#O#P!$n#P~Ne+{!!UUT+{yP#Z#[El#]#^El#a#bEl#g#hEl#i#jEl#m#nEl+{!!kWOY!!hYZKeZz!!hz{!#T{#O!!h#O#P!$[#P#QNe#Q~!!h+{!#WYOY!!hYZKeZz!!hz{!#T{!P!!h!P!Q!#v!Q#O!!h#O#P!$[#P#QNe#Q~!!h+{!#{TT+{OYFTZ#OFT#O#PFg#P#QEQ#Q~FT+{!$_TOY!!hYZKeZz!!hz{!#T{~!!h+{!$qTOYNeYZKeZzNez{! Y{~Ne+{!%V_yPOzKez{Kq{#ZKe#Z#[!%Q#[#]Ke#]#^!%Q#^#aKe#a#b!%Q#b#gKe#g#h!%Q#h#iKe#i#j!%Q#j#mKe#m#n!%Q#n~Ke,T!&Z[#|WOY!&UYZIwZz!&Uz{!'P{!^!&U!^!_!!h!_#O!&U#O#P!(w#P#QHt#Q#o!&U#o#p!!h#p~!&U,T!'U^#|WOY!&UYZIwZz!&Uz{!'P{!P!&U!P!Q!(Q!Q!^!&U!^!_!!h!_#O!&U#O#P!(w#P#QHt#Q#o!&U#o#p!!h#p~!&U,T!(XY#|WT+{OYFyYZ%TZ!^Fy!^!_FT!_#OFy#O#PGn#P#QB}#Q#oFy#o#pFT#p~Fy,T!(|X#|WOY!&UYZIwZz!&Uz{!'P{!^!&U!^!_!!h!_#o!&U#o#p!!h#p~!&U,T!)nX#|WOYHtYZIwZzHtz{LY{!^Ht!^!_Ne!_#oHt#o#pNe#p~Ht,T!*bc#|WyPOzIwz{Jc{!^Iw!^!_Ke!_#ZIw#Z#[!*Z#[#]Iw#]#^!*Z#^#aIw#a#b!*Z#b#gIw#g#h!*Z#h#iIw#i#j!*Z#j#mIw#m#n!*Z#n#oIw#o#pKe#p~Iw,T!+tV#|WS+{OY!+mYZ%TZ!^!+m!^!_!,Z!_#o!+m#o#p!,Z#p~!+m+{!,`QS+{OY!,ZZ~!,Z$P!,o[#|W#g#vyPOYB}YZ%TZ!PB}!P!QCz!Q!^B}!^!_EQ!_!}B}!}#OFy#O#PHY#P#oB}#o#pEQ#p~B}]!-n[#oS#|WyPOYB}YZ%TZ!PB}!P!QCz!Q!^B}!^!_EQ!_!}B}!}#OFy#O#PHY#P#oB}#o#pEQ#p~B}y!.kd#|WjqO!O%T!O!P>z!P!Q%T!Q![!/y![!^%T!_!g%T!g!h?t!h#R%T#R#S!/y#S#U%T#U#V!1a#V#X%T#X#Y?t#Y#b%T#b#c!1P#c#d!2o#d#l%T#l#m!3w#m#o%T#p~%Ty!0Q_#|WjqO!O%T!O!P>z!P!Q%T!Q![!/y![!^%T!_!g%T!g!h?t!h#R%T#R#S!/y#S#X%T#X#Y?t#Y#b%T#b#c!1P#c#o%T#p~%Ty!1WR#|WjqO!^%T!_#o%T#p~%Ty!1fW#|WO!Q%T!Q!R!2O!R!S!2O!S!^%T!_#R%T#R#S!2O#S#o%T#p~%Ty!2VW#|WjqO!Q%T!Q!R!2O!R!S!2O!S!^%T!_#R%T#R#S!2O#S#o%T#p~%Ty!2tV#|WO!Q%T!Q!Y!3Z!Y!^%T!_#R%T#R#S!3Z#S#o%T#p~%Ty!3bV#|WjqO!Q%T!Q!Y!3Z!Y!^%T!_#R%T#R#S!3Z#S#o%T#p~%Ty!3|Z#|WO!Q%T!Q![!4o![!^%T!_!c%T!c!i!4o!i#R%T#R#S!4o#S#T%T#T#Z!4o#Z#o%T#p~%Ty!4vZ#|WjqO!Q%T!Q![!4o![!^%T!_!c%T!c!i!4o!i#R%T#R#S!4o#S#T%T#T#Z!4o#Z#o%T#p~%T%w!5rR!XV#|W#e%hO!^%T!_#o%T#p~%T!P!6SR^w#|WO!^%T!_#o%T#p~%T+c!6hR'Xd!]%Y#p&s'uP!P!Q!6q!^!_!6v!_!`!7TW!6vO$OW#v!6{P#W#v!_!`!7O#v!7TO#g#v#v!7YO#X#v%w!7aT!u%o#|WO!^%T!_!`'v!`!a!7p!a#o%T#p~%T$P!7wR#P#w#|WO!^%T!_#o%T#p~%T%w!8]T'W!s#X#v#yS#|WO!^%T!_!`!8l!`!a!8|!a#o%T#p~%T$O!8sR#X#v#|WO!^%T!_#o%T#p~%T$O!9TT#W#v#|WO!^%T!_!`3]!`!a!9d!a#o%T#p~%T$O!9kS#W#v#|WO!^%T!_!`3]!`#o%T#p~%T%w!:OV'i%o#|WO!O%T!O!P!:e!P!^%T!_!a%T!a!b!:u!b#o%T#p~%T$`!:lRs$W#|WO!^%T!_#o%T#p~%T$O!:|S#|W#b#vO!^%T!_!`3]!`#o%T#p~%T&e!;aRu&]#|WO!^%T!_#o%T#p~%TZ!;qRzR#|WO!^%T!_#o%T#p~%T$O!<RS#_#v#|WO!^%T!_!`3]!`#o%T#p~%T$P!<fR#|W']#wO!^%T!_#o%T#p~%T~!<tO!P~%r!<{T'p%j#|WO!^%T!_!`3]!`#o%T#p#q!:u#q~%T$u!=eR!O$k#|W'_QO!^%T!_#o%T#p~%TX!=uR!gP#|WO!^%T!_#o%T#p~%T,T!>]r#|W'P+{#rS'S%k'`pOX%TXY%cYZ%TZ[%c[p%Tpq%cqt%Ttu0hu}%T}!O1r!O!Q%T!Q![0h![!^%T!_!c%T!c!}0h!}#R%T#R#S0h#S#T%T#T#o0h#p$f%T$f$g%c$g#BY0h#BY#BZ!>O#BZ$IS0h$IS$I_!>O$I_$JT0h$JT$JU!>O$JU$KV0h$KV$KW!>O$KW&FU0h&FU&FV!>O&FV?HT0h?HT?HU!>O?HU~0h,T!@t_#|W'Q+{#rS'S%k'`pOt%Ttu0hu}%T}!O1r!O!Q%T!Q![0h![!^%T!_!c%T!c!}0h!}#R%T#R#S0h#S#T%T#T#o0h#p$g%T$g~0h",
  tokenizers: [noSemicolon, incdecToken, template, 0, 1, 2, 3, 4, 5, 6, 7, 8, insertSemicolon],
  topRules: {
    "Script": [0, 6]
  },
  dialects: {
    jsx: 11129,
    ts: 11131
  },
  dynamicPrecedences: {
    "141": 1,
    "168": 1
  },
  specialized: [{
    term: 280,
    get: (value, stack) => tsExtends(value, stack) << 1 | 1
  }, {
    term: 280,
    get: value => spec_identifier[value] || -1
  }, {
    term: 292,
    get: value => spec_word[value] || -1
  }, {
    term: 59,
    get: value => spec_LessThan[value] || -1
  }],
  tokenPrec: 11151
});

exports.parser = parser;
},{"@lezer/lr":"node_modules/@lezer/lr/dist/index.js","@lezer/common":"node_modules/@lezer/common/dist/index.js"}],"node_modules/@codemirror/lang-javascript/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.esLint = esLint;
exports.javascript = javascript;
exports.typescriptLanguage = exports.tsxLanguage = exports.snippets = exports.jsxLanguage = exports.javascriptLanguage = void 0;

var _javascript = require("@lezer/javascript");

var _language = require("@codemirror/language");

var _highlight = require("@codemirror/highlight");

var _autocomplete = require("@codemirror/autocomplete");

/**
A collection of JavaScript-related
[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).
*/
const snippets = [/*@__PURE__*/(0, _autocomplete.snippetCompletion)("function ${name}(${params}) {\n\t${}\n}", {
  label: "function",
  detail: "definition",
  type: "keyword"
}), /*@__PURE__*/(0, _autocomplete.snippetCompletion)("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}", {
  label: "for",
  detail: "loop",
  type: "keyword"
}), /*@__PURE__*/(0, _autocomplete.snippetCompletion)("for (let ${name} of ${collection}) {\n\t${}\n}", {
  label: "for",
  detail: "of loop",
  type: "keyword"
}), /*@__PURE__*/(0, _autocomplete.snippetCompletion)("try {\n\t${}\n} catch (${error}) {\n\t${}\n}", {
  label: "try",
  detail: "block",
  type: "keyword"
}), /*@__PURE__*/(0, _autocomplete.snippetCompletion)("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}", {
  label: "class",
  detail: "definition",
  type: "keyword"
}), /*@__PURE__*/(0, _autocomplete.snippetCompletion)("import {${names}} from \"${module}\"\n${}", {
  label: "import",
  detail: "named",
  type: "keyword"
}), /*@__PURE__*/(0, _autocomplete.snippetCompletion)("import ${name} from \"${module}\"\n${}", {
  label: "import",
  detail: "default",
  type: "keyword"
})];
/**
A language provider based on the [Lezer JavaScript
parser](https://github.com/lezer-parser/javascript), extended with
highlighting and indentation information.
*/

exports.snippets = snippets;

const javascriptLanguage = /*@__PURE__*/_language.LRLanguage.define({
  parser: /*@__PURE__*/_javascript.parser.configure({
    props: [/*@__PURE__*/_language.indentNodeProp.add({
      IfStatement: /*@__PURE__*/(0, _language.continuedIndent)({
        except: /^\s*({|else\b)/
      }),
      TryStatement: /*@__PURE__*/(0, _language.continuedIndent)({
        except: /^\s*({|catch\b|finally\b)/
      }),
      LabeledStatement: _language.flatIndent,
      SwitchBody: context => {
        let after = context.textAfter,
            closed = /^\s*\}/.test(after),
            isCase = /^\s*(case|default)\b/.test(after);
        return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
      },
      Block: /*@__PURE__*/(0, _language.delimitedIndent)({
        closing: "}"
      }),
      ArrowFunction: cx => cx.baseIndent + cx.unit,
      "TemplateString BlockComment": () => -1,
      "Statement Property": /*@__PURE__*/(0, _language.continuedIndent)({
        except: /^{/
      }),

      JSXElement(context) {
        let closed = /^\s*<\//.test(context.textAfter);
        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
      },

      JSXEscape(context) {
        let closed = /\s*\}/.test(context.textAfter);
        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
      },

      "JSXOpenTag JSXSelfClosingTag"(context) {
        return context.column(context.node.from) + context.unit;
      }

    }), /*@__PURE__*/_language.foldNodeProp.add({
      "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": _language.foldInside,

      BlockComment(tree) {
        return {
          from: tree.from + 2,
          to: tree.to - 2
        };
      }

    }), /*@__PURE__*/(0, _highlight.styleTags)({
      "get set async static": _highlight.tags.modifier,
      "for while do if else switch try catch finally return throw break continue default case": _highlight.tags.controlKeyword,
      "in of await yield void typeof delete instanceof": _highlight.tags.operatorKeyword,
      "export import let var const function class extends": _highlight.tags.definitionKeyword,
      "with debugger from as new": _highlight.tags.keyword,
      TemplateString: /*@__PURE__*/_highlight.tags.special(_highlight.tags.string),
      Super: _highlight.tags.atom,
      BooleanLiteral: _highlight.tags.bool,
      this: _highlight.tags.self,
      null: _highlight.tags.null,
      Star: _highlight.tags.modifier,
      VariableName: _highlight.tags.variableName,
      "CallExpression/VariableName": /*@__PURE__*/_highlight.tags.function(_highlight.tags.variableName),
      VariableDefinition: /*@__PURE__*/_highlight.tags.definition(_highlight.tags.variableName),
      Label: _highlight.tags.labelName,
      PropertyName: _highlight.tags.propertyName,
      "CallExpression/MemberExpression/PropertyName": /*@__PURE__*/_highlight.tags.function(_highlight.tags.propertyName),
      "FunctionDeclaration/VariableDefinition": /*@__PURE__*/_highlight.tags.function( /*@__PURE__*/_highlight.tags.definition(_highlight.tags.variableName)),
      "ClassDeclaration/VariableDefinition": /*@__PURE__*/_highlight.tags.definition(_highlight.tags.className),
      PropertyNameDefinition: /*@__PURE__*/_highlight.tags.definition(_highlight.tags.propertyName),
      UpdateOp: _highlight.tags.updateOperator,
      LineComment: _highlight.tags.lineComment,
      BlockComment: _highlight.tags.blockComment,
      Number: _highlight.tags.number,
      String: _highlight.tags.string,
      ArithOp: _highlight.tags.arithmeticOperator,
      LogicOp: _highlight.tags.logicOperator,
      BitOp: _highlight.tags.bitwiseOperator,
      CompareOp: _highlight.tags.compareOperator,
      RegExp: _highlight.tags.regexp,
      Equals: _highlight.tags.definitionOperator,
      "Arrow : Spread": _highlight.tags.punctuation,
      "( )": _highlight.tags.paren,
      "[ ]": _highlight.tags.squareBracket,
      "{ }": _highlight.tags.brace,
      ".": _highlight.tags.derefOperator,
      ", ;": _highlight.tags.separator,
      TypeName: _highlight.tags.typeName,
      TypeDefinition: /*@__PURE__*/_highlight.tags.definition(_highlight.tags.typeName),
      "type enum interface implements namespace module declare": _highlight.tags.definitionKeyword,
      "abstract global privacy readonly override": _highlight.tags.modifier,
      "is keyof unique infer": _highlight.tags.operatorKeyword,
      JSXAttributeValue: _highlight.tags.attributeValue,
      JSXText: _highlight.tags.content,
      "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": _highlight.tags.angleBracket,
      "JSXIdentifier JSXNameSpacedName": _highlight.tags.tagName,
      "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": _highlight.tags.attributeName
    })]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "`"]
    },
    commentTokens: {
      line: "//",
      block: {
        open: "/*",
        close: "*/"
      }
    },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
});
/**
A language provider for TypeScript.
*/


exports.javascriptLanguage = javascriptLanguage;
const typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({
  dialect: "ts"
});
/**
Language provider for JSX.
*/

exports.typescriptLanguage = typescriptLanguage;
const jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({
  dialect: "jsx"
});
/**
Language provider for JSX + TypeScript.
*/

exports.jsxLanguage = jsxLanguage;
const tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({
  dialect: "jsx ts"
});
/**
JavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)
completion.
*/

exports.tsxLanguage = tsxLanguage;

function javascript(config = {}) {
  let lang = config.jsx ? config.typescript ? tsxLanguage : jsxLanguage : config.typescript ? typescriptLanguage : javascriptLanguage;
  return new _language.LanguageSupport(lang, javascriptLanguage.data.of({
    autocomplete: (0, _autocomplete.ifNotIn)(["LineComment", "BlockComment", "String"], (0, _autocomplete.completeFromList)(snippets))
  }));
}
/**
Connects an [ESLint](https://eslint.org/) linter to CodeMirror's
[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the
[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)
class, and `config` an optional ESLint configuration. The return
value of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)
to create a JavaScript linting extension.

Note that ESLint targets node, and is tricky to run in the
browser. The [eslint4b](https://github.com/mysticatea/eslint4b)
and
[eslint4b-prebuilt](https://github.com/marijnh/eslint4b-prebuilt/)
packages may help with that.
*/


function esLint(eslint, config) {
  if (!config) {
    config = {
      parserOptions: {
        ecmaVersion: 2019,
        sourceType: "module"
      },
      env: {
        browser: true,
        node: true,
        es6: true,
        es2015: true,
        es2017: true,
        es2020: true
      },
      rules: {}
    };
    eslint.getRules().forEach((desc, name) => {
      if (desc.meta.docs.recommended) config.rules[name] = 2;
    });
  }

  return view => {
    let {
      state
    } = view,
        found = [];

    for (let {
      from,
      to
    } of javascriptLanguage.findRegions(state)) {
      let fromLine = state.doc.lineAt(from),
          offset = {
        line: fromLine.number - 1,
        col: from - fromLine.from,
        pos: from
      };

      for (let d of eslint.verify(state.sliceDoc(from, to), config)) found.push(translateDiagnostic(d, state.doc, offset));
    }

    return found;
  };
}

function mapPos(line, col, doc, offset) {
  return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);
}

function translateDiagnostic(input, doc, offset) {
  let start = mapPos(input.line, input.column, doc, offset);
  let result = {
    from: start,
    to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,
    message: input.message,
    source: input.ruleId ? "jshint:" + input.ruleId : "jshint",
    severity: input.severity == 1 ? "warning" : "error"
  };

  if (input.fix) {
    let {
      range,
      text
    } = input.fix,
        from = range[0] + offset.pos - start,
        to = range[1] + offset.pos - start;
    result.actions = [{
      name: "fix",

      apply(view, start) {
        view.dispatch({
          changes: {
            from: start + from,
            to: start + to,
            insert: text
          },
          scrollIntoView: true
        });
      }

    }];
  }

  return result;
}
},{"@lezer/javascript":"node_modules/@lezer/javascript/dist/index.es.js","@codemirror/language":"node_modules/@codemirror/language/dist/index.js","@codemirror/highlight":"node_modules/@codemirror/highlight/dist/index.js","@codemirror/autocomplete":"node_modules/@codemirror/autocomplete/dist/index.js"}],"editor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEditor = createEditor;

var _basicSetup = require("@codemirror/basic-setup");

var _view = require("@codemirror/view");

var _commands = require("@codemirror/commands");

var _langJavascript = require("@codemirror/lang-javascript");

var _spCode = require("./spCode");

function createEditor(codeChangeCallback) {
  var baseTheme = _view.EditorView.theme({
    "&": {
      fontSize: '20pt',
      color: "white",
      backgroundColor: "transparent",
      height: '80vh'
    },
    ".cm-content": {
      caretColor: "#0e9"
    },
    ".cm-scroller": {
      overflow: "scroll",
      border: "none",
      outline: "none"
    },
    "&.cm-focused .cm-cursor": {
      borderLeftColor: "#0e9"
    },
    "&.cm-focused .cm-selectionBackground, ::selection": {
      backgroundColor: "#074"
    },
    ".cm-gutters": {
      backgroundColor: "transparent",
      color: "#ddd",
      border: "none",
      outline: "none"
    }
  }, {
    dark: true
  });

  var codeUpdateListener = _view.EditorView.updateListener.of(function (v) {
    if (v.docChanged) {
      var code = v.state.doc.toString();
      codeChangeCallback(code);
    }
  });

  var doc = (0, _spCode.spCode)();
  return new _view.EditorView({
    state: _basicSetup.EditorState.create({
      doc: doc,
      extensions: [_basicSetup.basicSetup, _view.keymap.of([_commands.indentWithTab]), (0, _langJavascript.javascript)(), baseTheme, codeUpdateListener]
    })
  });
}
},{"@codemirror/basic-setup":"node_modules/@codemirror/basic-setup/dist/index.js","@codemirror/view":"node_modules/@codemirror/view/dist/index.js","@codemirror/commands":"node_modules/@codemirror/commands/dist/index.js","@codemirror/lang-javascript":"node_modules/@codemirror/lang-javascript/dist/index.js","./spCode":"spCode.js"}],"index.js":[function(require,module,exports) {
"use strict";

var _three = require("three");

var _OrbitControls = require("three/examples/jsm/controls/OrbitControls");

var _shaderParkCore = require("shader-park-core");

var _spCode = require("./spCode.js");

var _editor = require("./editor.js");

var codeContainer = document.querySelector('.code-container');
var scene = new _three.Scene();
var params = {
  time: 0
};
var camera = new _three.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 4;
var renderer = new _three.WebGLRenderer({
  antialias: true,
  transparent: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(new _three.Color(1, 1, 1), 0);
document.body.appendChild(renderer.domElement);
var geometry = new _three.SphereGeometry(1, 45, 45); // let geometry = new TorusKnotGeometry( 1, .3, 100, 40);
// geometry.computeBoundingSphere();
// geometry.center();
// Shader Park Setup

var mesh = (0, _shaderParkCore.createSculptureWithGeometry)(geometry, (0, _spCode.spCode)(), function () {
  return {
    time: params.time
  };
});
scene.add(mesh); // *** Uncomment to try using a custom geometry. Make sure to comment out likes 26-29 ***.
// let mesh = createSculptureWithGeometry(geometry, spCode, () => ( {
//   time: params.time,
// } ));
// scene.add(mesh);

var controls = new _OrbitControls.OrbitControls(camera, renderer.domElement, {
  enableDamping: true,
  dampingFactor: 0.25,
  zoomSpeed: 0.5,
  rotateSpeed: 0.5
});
camera.position.z = 2;
window.controls = controls;

var onCodeChange = function onCodeChange(code) {
  console.log(code);

  try {
    // let newMesh = createSculpture(code, () => ( {
    //   time: params.time,
    // } ));
    // scene.remove(mesh);
    // scene.add(newMesh);
    // mesh = newMesh;
    mesh.material = (0, _shaderParkCore.sculptToThreeJSMaterial)(code);
  } catch (error) {
    console.error(error);
  }
};

var editor = (0, _editor.createEditor)(onCodeChange);
window.editor = editor;
codeContainer.appendChild(editor.dom);

var onWindowResize = function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
};

window.addEventListener('resize', onWindowResize);

var render = function render() {
  requestAnimationFrame(render);
  params.time += 0.01;
  controls.update();
  renderer.render(scene, camera);
};

render();
},{"three":"node_modules/three/build/three.module.js","three/examples/jsm/controls/OrbitControls":"node_modules/three/examples/jsm/controls/OrbitControls.js","shader-park-core":"node_modules/shader-park-core/dist/shader-park-core.umd.js","./spCode.js":"spCode.js","./editor.js":"editor.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "56911" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.js"], null)
//# sourceMappingURL=/shader-park-live-coding.e31bb0bc.js.map